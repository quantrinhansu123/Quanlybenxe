import { Request, Response } from 'express'
import { supabase } from '../config/database.js'
import { z } from 'zod'

const scheduleSchema = z.object({
  scheduleCode: z.string().optional(), // Optional - will be auto-generated if not provided
  routeId: z.string().uuid('Invalid route ID'),
  operatorId: z.string().uuid('Invalid operator ID'),
  departureTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format (HH:MM)'),
  frequencyType: z.enum(['daily', 'weekly', 'specific_days']),
  daysOfWeek: z.array(z.number().int().min(1).max(7)).optional(),
  effectiveFrom: z.string().min(1, 'Effective from date is required'),
  effectiveTo: z.string().optional(),
})

export const getAllSchedules = async (req: Request, res: Response) => {
  try {
    const { routeId, operatorId, isActive } = req.query

    let query = supabase
      .from('schedules')
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .order('departure_time', { ascending: true })

    if (routeId) {
      query = query.eq('route_id', routeId as string)
    }
    if (operatorId) {
      query = query.eq('operator_id', operatorId as string)
    }
    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    const schedules = data.map((schedule: any) => ({
      id: schedule.id,
      scheduleCode: schedule.schedule_code,
      routeId: schedule.route_id,
      route: schedule.routes ? {
        id: schedule.routes.id,
        routeName: schedule.routes.route_name,
        routeCode: schedule.routes.route_code,
      } : undefined,
      operatorId: schedule.operator_id,
      operator: schedule.operators ? {
        id: schedule.operators.id,
        name: schedule.operators.name,
        code: schedule.operators.code,
      } : undefined,
      departureTime: schedule.departure_time,
      frequencyType: schedule.frequency_type,
      daysOfWeek: schedule.days_of_week || [],
      effectiveFrom: schedule.effective_from,
      effectiveTo: schedule.effective_to,
      isActive: schedule.is_active,
      createdAt: schedule.created_at,
      updatedAt: schedule.updated_at,
    }))

    return res.json(schedules)
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch schedules' })
  }
}

export const getScheduleById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await supabase
      .from('schedules')
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Schedule not found' })
    }

    return res.json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch schedule' })
  }
}

export const createSchedule = async (req: Request, res: Response) => {
  try {
    const validated = scheduleSchema.parse(req.body)

    const { data, error } = await supabase
      .from('schedules')
      .insert({
        schedule_code: validated.scheduleCode || null, // Will be auto-generated by trigger if null
        route_id: validated.routeId,
        operator_id: validated.operatorId,
        departure_time: validated.departureTime,
        frequency_type: validated.frequencyType,
        days_of_week: validated.daysOfWeek || null,
        effective_from: validated.effectiveFrom,
        effective_to: validated.effectiveTo || null,
        is_active: true,
      })
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.code === '23505') {
      return res.status(409).json({ error: 'Schedule with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create schedule' })
  }
}

export const updateSchedule = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = scheduleSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.scheduleCode) updateData.schedule_code = validated.scheduleCode
    if (validated.routeId) updateData.route_id = validated.routeId
    if (validated.operatorId) updateData.operator_id = validated.operatorId
    if (validated.departureTime) updateData.departure_time = validated.departureTime
    if (validated.frequencyType) updateData.frequency_type = validated.frequencyType
    if (validated.daysOfWeek !== undefined) updateData.days_of_week = validated.daysOfWeek || null
    if (validated.effectiveFrom) updateData.effective_from = validated.effectiveFrom
    if (validated.effectiveTo !== undefined) updateData.effective_to = validated.effectiveTo || null

    const { data, error } = await supabase
      .from('schedules')
      .update(updateData)
      .eq('id', id)
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Schedule not found' })
    }

    return res.json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update schedule' })
  }
}

export const deleteSchedule = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await supabase
      .from('schedules')
      .delete()
      .eq('id', id)

    if (error) throw error

    res.status(204).send()
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to delete schedule' })
  }
}

