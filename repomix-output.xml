This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
CLAUDE.md
client/.eslintrc.cjs
client/.firebaserc
client/firebase.json
client/index.html
client/package.json
client/postcss.config.js
client/README.md
client/SETUP.md
client/src/App.tsx
client/src/assets/ben-xe.webp
client/src/assets/logo.png
client/src/components/common/index.ts
client/src/components/common/PageLoader.tsx
client/src/components/common/SuspenseWrapper.tsx
client/src/components/dashboard/charts/index.ts
client/src/components/dashboard/charts/MonthlyBreakdownChart.tsx
client/src/components/dashboard/charts/VehiclesByRouteChart.tsx
client/src/components/dashboard/charts/VehiclesByStatusChart.tsx
client/src/components/dashboard/charts/VehicleTrendChart.tsx
client/src/components/dashboard/charts/WeeklyProgressChart.tsx
client/src/components/dashboard/DocumentWarningsTable.tsx
client/src/components/dashboard/EditDocumentDialog.tsx
client/src/components/dashboard/stats/HeatMapCalendar.tsx
client/src/components/dashboard/stats/HeroStatsCard.tsx
client/src/components/dashboard/stats/index.ts
client/src/components/dashboard/stats/LiveActivityFeed.tsx
client/src/components/dashboard/stats/LiveBeacon.tsx
client/src/components/dashboard/stats/MetricCard.tsx
client/src/components/dashboard/stats/QuickStatCard.tsx
client/src/components/dashboard/stats/TrendStatCard.tsx
client/src/components/dashboard/VehicleHistoryTable.tsx
client/src/components/DatePicker.tsx
client/src/components/DatePickerRange.tsx
client/src/components/DateTimePicker.tsx
client/src/components/dispatch/CapLenhXuatBenDialog.tsx
client/src/components/dispatch/CapPhepDialog.tsx
client/src/components/dispatch/CapPhepDialogRedesign.tsx
client/src/components/dispatch/ChoNhieuXeRaBenDialog.tsx
client/src/components/dispatch/ChoXeRaBenDialog.tsx
client/src/components/dispatch/ChoXeVaoBenDialog.tsx
client/src/components/dispatch/common/ActionButton.tsx
client/src/components/dispatch/common/column-config.ts
client/src/components/dispatch/common/FloatingDotsEmpty.tsx
client/src/components/dispatch/common/index.ts
client/src/components/dispatch/common/RadarPulse.tsx
client/src/components/dispatch/common/StatusRibbon.tsx
client/src/components/dispatch/common/VehicleCard.tsx
client/src/components/dispatch/DocumentHistoryDialog.tsx
client/src/components/dispatch/entry/FormHeader.tsx
client/src/components/dispatch/entry/index.ts
client/src/components/dispatch/entry/TransportOrderPreview.tsx
client/src/components/dispatch/entry/VehicleEntryForm.tsx
client/src/components/dispatch/icons/BusEnterIcon.tsx
client/src/components/dispatch/icons/BusPlusIcon.tsx
client/src/components/dispatch/icons/FileExclamationIcon.tsx
client/src/components/dispatch/icons/index.ts
client/src/components/dispatch/KiemTraGiayToDialog.tsx
client/src/components/dispatch/LyDoKhongDuDieuKienDialog.tsx
client/src/components/dispatch/sections/DocumentCheckCards.tsx
client/src/components/dispatch/sections/DriverSection.tsx
client/src/components/dispatch/sections/GsgtCheckSection.tsx
client/src/components/dispatch/sections/index.ts
client/src/components/dispatch/sections/MonthlyCalendarHeatmap.tsx
client/src/components/dispatch/sections/NotesSection.tsx
client/src/components/dispatch/sections/PermitActions.tsx
client/src/components/dispatch/sections/ServiceChargesSection.tsx
client/src/components/dispatch/sections/TransportOrderSection.tsx
client/src/components/dispatch/sections/VehicleImageSection.tsx
client/src/components/dispatch/sections/VehicleInfoSection.tsx
client/src/components/dispatch/sections/ZeroAmountWarningDialog.tsx
client/src/components/dispatch/ThanhToanTheoThangDialog.tsx
client/src/components/dispatch/ThemDichVuDialog.tsx
client/src/components/dispatch/ThemTaiXeDialog.tsx
client/src/components/dispatch/XeTraKhachDialog.tsx
client/src/components/driver/DriverDialog.tsx
client/src/components/driver/DriverForm.tsx
client/src/components/driver/DriverView.tsx
client/src/components/guide/ArticleBanner.tsx
client/src/components/guide/ArticleContent.tsx
client/src/components/guide/ArticleImage.tsx
client/src/components/layout/DashboardCard.tsx
client/src/components/layout/GuideLayout.tsx
client/src/components/layout/Header.tsx
client/src/components/layout/MainLayout.tsx
client/src/components/layout/PublicFooter.tsx
client/src/components/layout/PublicHeader.tsx
client/src/components/layout/PublicLayout.tsx
client/src/components/layout/ShiftSelectionDialog.tsx
client/src/components/layout/Sidebar.tsx
client/src/components/layout/StatusBadge.tsx
client/src/components/layout/UserDropdown.tsx
client/src/components/operator/common/DeleteConfirmDialog.tsx
client/src/components/operator/common/index.ts
client/src/components/operator/common/OperatorGridCard.tsx
client/src/components/operator/common/OperatorStatsCards.tsx
client/src/components/operator/common/OperatorTableRow.tsx
client/src/components/operator/common/QuickFilter.tsx
client/src/components/operator/common/SkeletonRow.tsx
client/src/components/operator/detail/EmptyStates.tsx
client/src/components/operator/detail/index.ts
client/src/components/operator/detail/SummaryCards.tsx
client/src/components/operator/detail/VehicleCard.tsx
client/src/components/operator/OperatorDetailDialog.tsx
client/src/components/operator/OperatorDialog.tsx
client/src/components/operator/OperatorForm.tsx
client/src/components/operator/OperatorView.tsx
client/src/components/payment/index.ts
client/src/components/payment/OrderCard.tsx
client/src/components/payment/PaymentSidebar.tsx
client/src/components/payment/PaymentStatsCard.tsx
client/src/components/payment/ServicesCard.tsx
client/src/components/payment/VehicleInfoCard.tsx
client/src/components/payment/ZeroAmountWarningDialog.tsx
client/src/components/QRScanner.tsx
client/src/components/route/RouteDialog.tsx
client/src/components/route/RouteForm.tsx
client/src/components/route/RouteView.tsx
client/src/components/service/FormulaDialog.tsx
client/src/components/service/ServiceDialog.tsx
client/src/components/shared/EmptyState.tsx
client/src/components/shared/index.ts
client/src/components/shared/LoadingSpinner.tsx
client/src/components/shared/styled-components.tsx
client/src/components/ui/autocomplete.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/components/ui/checkbox.tsx
client/src/components/ui/dialog.tsx
client/src/components/ui/input.tsx
client/src/components/ui/label.tsx
client/src/components/ui/month-picker.tsx
client/src/components/ui/popover.tsx
client/src/components/ui/radio-group.tsx
client/src/components/ui/select.tsx
client/src/components/ui/sticky-table.tsx
client/src/components/ui/table.tsx
client/src/components/ui/tabs.tsx
client/src/components/ui/textarea.tsx
client/src/constants/gradients.ts
client/src/constants/limits.ts
client/src/constants/status-config.ts
client/src/constants/vietnam-locations.ts
client/src/features/auth/api/authApi.ts
client/src/features/auth/components/index.ts
client/src/features/auth/components/ProtectedRoute.tsx
client/src/features/auth/hooks/index.ts
client/src/features/auth/hooks/useAuth.ts
client/src/features/auth/index.ts
client/src/features/auth/store/authStore.ts
client/src/features/auth/types/index.ts
client/src/features/chat/api/chatApi.ts
client/src/features/chat/components/ChatInput.tsx
client/src/features/chat/components/ChatMessage.tsx
client/src/features/chat/components/ChatWidget.tsx
client/src/features/chat/components/index.ts
client/src/features/chat/index.ts
client/src/features/chat/store/chatStore.ts
client/src/features/chat/types/index.ts
client/src/features/dispatch/api/dispatchApi.ts
client/src/features/dispatch/components/icons/BusEnterIcon.tsx
client/src/features/dispatch/components/icons/BusPlusIcon.tsx
client/src/features/dispatch/components/icons/FileExclamationIcon.tsx
client/src/features/dispatch/components/icons/index.ts
client/src/features/dispatch/components/index.ts
client/src/features/dispatch/hooks/index.ts
client/src/features/dispatch/hooks/useDispatch.ts
client/src/features/dispatch/index.ts
client/src/features/dispatch/store/dispatchStore.ts
client/src/features/dispatch/types/index.ts
client/src/features/fleet/drivers/api/driverApi.ts
client/src/features/fleet/drivers/api/index.ts
client/src/features/fleet/drivers/index.ts
client/src/features/fleet/drivers/types/index.ts
client/src/features/fleet/index.ts
client/src/features/fleet/operators/api/index.ts
client/src/features/fleet/operators/api/operatorApi.ts
client/src/features/fleet/operators/index.ts
client/src/features/fleet/operators/types/index.ts
client/src/features/fleet/vehicle-badges/api/index.ts
client/src/features/fleet/vehicle-badges/api/vehicleBadgeApi.ts
client/src/features/fleet/vehicle-badges/index.ts
client/src/features/fleet/vehicle-badges/types/index.ts
client/src/features/fleet/vehicles/api/index.ts
client/src/features/fleet/vehicles/api/vehicleApi.ts
client/src/features/fleet/vehicles/api/vehicleTypeApi.ts
client/src/features/fleet/vehicles/components/index.ts
client/src/features/fleet/vehicles/components/VehicleForm.tsx
client/src/features/fleet/vehicles/components/VehicleView.tsx
client/src/features/fleet/vehicles/index.ts
client/src/features/fleet/vehicles/types/index.ts
client/src/hooks/index.ts
client/src/hooks/useAnimatedCounter.ts
client/src/hooks/useCapPhepDialog.ts
client/src/hooks/useChoXeVaoBenForm.ts
client/src/hooks/useDebounce.ts
client/src/hooks/useDieuDo.ts
client/src/hooks/useOperatorDetail.ts
client/src/hooks/useOperatorManagement.ts
client/src/index.css
client/src/lib/api.ts
client/src/lib/cache.ts
client/src/lib/firebase.ts
client/src/lib/icon-theme.ts
client/src/lib/query-cache.ts
client/src/lib/README-THEMES.md
client/src/lib/theme-variants.ts
client/src/lib/toast.ts
client/src/lib/utils.ts
client/src/lib/vietnam-time.ts
client/src/main.tsx
client/src/pages/BangKeDoanhThu.tsx
client/src/pages/BangKeDoanhThu02.tsx
client/src/pages/BangKeHoaDon.tsx
client/src/pages/BaoCao.tsx
client/src/pages/BaoCaoCapPhepRaBen.tsx
client/src/pages/BaoCaoChamCongDangTai.tsx
client/src/pages/BaoCaoDoanhThuBenBanVe.tsx
client/src/pages/BaoCaoLichSuGiayTo.tsx
client/src/pages/BaoCaoNhatTrinhXe.tsx
client/src/pages/BaoCaoTheoDoiLenhTraKhach.tsx
client/src/pages/BaoCaoTheoDoiLenhXuatBen.tsx
client/src/pages/BaoCaoTinhHinhHoatDongMau1.tsx
client/src/pages/BaoCaoTinhHinhHoatDongMau3.tsx
client/src/pages/BaoCaoTongHop.tsx
client/src/pages/BaoCaoTongHopTuyen.tsx
client/src/pages/BaoCaoXeDiThay.tsx
client/src/pages/BaoCaoXeKhongDuDieuKien.tsx
client/src/pages/BaoCaoXeRaVaoBen.tsx
client/src/pages/BaoCaoXeTangCuong.tsx
client/src/pages/BaoCaoXeTraKhach.tsx
client/src/pages/DanhSachCaTruc.tsx
client/src/pages/Dashboard.tsx
client/src/pages/DieuDo.tsx
client/src/pages/guide/HuongDanBanVeUyThac.tsx
client/src/pages/HomePage.tsx
client/src/pages/LapBaoCao.tsx
client/src/pages/LienHe.tsx
client/src/pages/Login.tsx
client/src/pages/pricing/BangGiaChuKySo.tsx
client/src/pages/pricing/BangGiaHoaDonDienTu.tsx
client/src/pages/pricing/BangGiaLenhVanChuyen.tsx
client/src/pages/pricing/BangGiaVeDienTu.tsx
client/src/pages/Profile.tsx
client/src/pages/QuanLyBenDen.tsx
client/src/pages/QuanLyBieuThuc.tsx
client/src/pages/QuanLyDichVu.tsx
client/src/pages/QuanLyDonViVanTai.tsx
client/src/pages/QuanLyLaiXe.tsx
client/src/pages/QuanLyPhuHieuXe.tsx
client/src/pages/QuanLyTuyen.tsx
client/src/pages/QuanLyXe.tsx
client/src/pages/Register.tsx
client/src/pages/TaoMoiDonHang.tsx
client/src/pages/ThanhToan.tsx
client/src/pages/XeKhongDuDieuKien.tsx
client/src/pages/XeTraKhach.tsx
client/src/pages/XeXuatBen.tsx
client/src/services/auth.service.ts
client/src/services/dashboard.service.ts
client/src/services/dispatch.service.ts
client/src/services/driver.service.ts
client/src/services/invoice.service.ts
client/src/services/location.service.ts
client/src/services/operator.service.ts
client/src/services/province.service.ts
client/src/services/quanly-data.service.ts
client/src/services/report.service.ts
client/src/services/route.service.ts
client/src/services/schedule.service.ts
client/src/services/service-charge.service.ts
client/src/services/service-formula.service.ts
client/src/services/service.service.ts
client/src/services/shift.service.ts
client/src/services/vehicle-badge.service.ts
client/src/services/vehicle-type.service.ts
client/src/services/vehicle.service.ts
client/src/services/violation.service.ts
client/src/store/auth.store.ts
client/src/store/dispatch.store.ts
client/src/store/ui.store.ts
client/src/types/auth.types.ts
client/src/types/common.types.ts
client/src/types/dispatch.types.ts
client/src/types/fleet.types.ts
client/src/types/index.ts
client/src/utils/dispatch-helpers.ts
client/src/utils/timezone.ts
client/src/vite-env.d.ts
client/tailwind.config.js
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
DEPLOYMENT_CONFIG.md
package.json
project-memory.md
README.md
render.yaml
scripts/analyze-operator-data.ts
scripts/capture-pages.js
scripts/firebase-workarounds/firestore-query-helper.js
scripts/firebase-workarounds/rtdb-helper.js
scripts/screenshot-dialog.js
scripts/verify-firebase-security.sh
server/.firebaserc
server/database.rules.json
server/firebase-rules.json
server/firebase.json
server/firestore.indexes.json
server/firestore.rules
server/jest.config.js
server/package.json
server/README.md
server/scripts/analyze-operator-data.cjs
server/src/__tests__/fixtures/dispatch.fixtures.ts
server/src/__tests__/fixtures/fleet.fixtures.ts
server/src/__tests__/utils/test-helpers.ts
server/src/config/cloudinary.ts
server/src/config/database.ts
server/src/config/dual-write.ts
server/src/config/firestore.ts
server/src/controllers/auth.controller.ts
server/src/controllers/dashboard.controller.ts
server/src/controllers/dispatch.controller.ts
server/src/controllers/driver.controller.ts
server/src/controllers/invoice.controller.ts
server/src/controllers/location.controller.ts
server/src/controllers/operator.controller.ts
server/src/controllers/province.controller.ts
server/src/controllers/quanly-data.controller.ts
server/src/controllers/report.controller.ts
server/src/controllers/route.controller.ts
server/src/controllers/schedule.controller.ts
server/src/controllers/service-charge.controller.ts
server/src/controllers/service-formula.controller.ts
server/src/controllers/service.controller.ts
server/src/controllers/shift.controller.ts
server/src/controllers/upload.controller.ts
server/src/controllers/vehicle-badge.controller.ts
server/src/controllers/vehicle-type.controller.ts
server/src/controllers/vehicle.controller.ts
server/src/controllers/violation.controller.ts
server/src/db/seed-firebase-rest.ts
server/src/functions.ts
server/src/index.ts
server/src/lib/cache.ts
server/src/lib/firebase-rest.ts
server/src/middleware/auth.ts
server/src/middleware/errorHandler.ts
server/src/middleware/upload.ts
server/src/modules/chat/__tests__/ai.service.test.ts
server/src/modules/chat/__tests__/chat-cache.service.test.ts
server/src/modules/chat/__tests__/chat-functions.test.ts
server/src/modules/chat/__tests__/chat.controller.test.ts
server/src/modules/chat/__tests__/mocks/chat-mock-data.ts
server/src/modules/chat/chat.controller.ts
server/src/modules/chat/chat.routes.ts
server/src/modules/chat/services/ai.service.ts
server/src/modules/chat/services/chat-cache.service.ts
server/src/modules/chat/services/chat-functions.ts
server/src/modules/chat/services/data-query.service.ts
server/src/modules/chat/services/intent-classifier.service.ts
server/src/modules/chat/services/response-formatter.service.ts
server/src/modules/chat/types/chat.types.ts
server/src/modules/dispatch/__tests__/dispatch-validation.test.ts
server/src/modules/dispatch/controllers/dispatch.controller.ts
server/src/modules/dispatch/dispatch-mappers.ts
server/src/modules/dispatch/dispatch-repository.ts
server/src/modules/dispatch/dispatch-types.ts
server/src/modules/dispatch/dispatch-validation.ts
server/src/modules/dispatch/dispatch.routes.ts
server/src/modules/dispatch/index.ts
server/src/modules/fleet/__tests__/fleet-validation.test.ts
server/src/modules/fleet/controllers/driver.controller.ts
server/src/modules/fleet/controllers/vehicle.controller.ts
server/src/modules/fleet/driver.routes.ts
server/src/modules/fleet/fleet-mappers.ts
server/src/modules/fleet/fleet-types.ts
server/src/modules/fleet/fleet-validation.ts
server/src/modules/fleet/index.ts
server/src/modules/fleet/repositories/driver.repository.ts
server/src/modules/fleet/repositories/vehicle-type.repository.ts
server/src/modules/fleet/repositories/vehicle.repository.ts
server/src/modules/fleet/services/driver.service.ts
server/src/modules/fleet/services/vehicle-cache.service.ts
server/src/modules/fleet/services/vehicle.service.ts
server/src/modules/fleet/vehicle.routes.ts
server/src/modules/index.ts
server/src/modules/operator/controllers/operator.controller.ts
server/src/modules/operator/index.ts
server/src/modules/operator/operator.routes.ts
server/src/modules/operator/repositories/operator.repository.ts
server/src/modules/operator/services/operator.service.ts
server/src/routes/auth.routes.ts
server/src/routes/dashboard.routes.ts
server/src/routes/dispatch.routes.ts
server/src/routes/driver.routes.ts
server/src/routes/invoice.routes.ts
server/src/routes/location.routes.ts
server/src/routes/operator.routes.ts
server/src/routes/province.routes.ts
server/src/routes/quanly-data.routes.ts
server/src/routes/report.routes.ts
server/src/routes/route.routes.ts
server/src/routes/schedule.routes.ts
server/src/routes/service-charge.routes.ts
server/src/routes/service-formula.routes.ts
server/src/routes/service.routes.ts
server/src/routes/shift.routes.ts
server/src/routes/upload.routes.ts
server/src/routes/vehicle-badge.routes.ts
server/src/routes/vehicle-type.routes.ts
server/src/routes/vehicle.routes.ts
server/src/routes/violation.routes.ts
server/src/scripts/check-and-fix-vehicle-data.ts
server/src/scripts/cleanup-seed-data.ts
server/src/scripts/create-admin.ts
server/src/scripts/find-vehicle.ts
server/src/scripts/HUONG_DAN_IMPORT_XE_TU_SHEETS.md
server/src/scripts/import-vehicle-badges-from-sheets.gs
server/src/scripts/import-vehicle-badges-json.ts
server/src/scripts/import-vehicles-from-sheets.gs
server/src/scripts/migrate-denormalize-dispatch.ts
server/src/scripts/migrate-from-old-firebase.ts
server/src/scripts/migrate-old-rtdb-to-firestore.ts
server/src/scripts/migrate-rtdb-to-firestore.ts
server/src/scripts/migrate-vehicle-badges.ts
server/src/scripts/restore-operators.ts
server/src/scripts/restore-vehicle.ts
server/src/scripts/rollback-firestore-to-rtdb.ts
server/src/scripts/seed-service-formulas.ts
server/src/scripts/seed-vehicle-badges.ts
server/src/scripts/sync-badges-from-sheets.cjs
server/src/scripts/sync-operators-from-sheets.cjs
server/src/scripts/sync-routes-from-sheets.cjs
server/src/scripts/sync-vehicles-from-sheets.cjs
server/src/services/badge-sync.service.ts
server/src/services/cached-data.service.ts
server/src/services/dashboard.service.ts
server/src/services/operator-sync.service.ts
server/src/services/route-sync.service.ts
server/src/services/vehicle-sync.service.ts
server/src/shared/database/base-repository.ts
server/src/shared/database/index.ts
server/src/shared/errors/app-error.ts
server/src/shared/errors/error-handler.ts
server/src/shared/errors/index.ts
server/src/shared/index.ts
server/src/shared/mappers/case-converter.ts
server/src/shared/mappers/entity-mappers.ts
server/src/shared/mappers/index.ts
server/src/shared/response/api-response.ts
server/src/shared/response/index.ts
server/src/shared/services/base-service.ts
server/src/shared/services/index.ts
server/src/shared/validation/dispatch-status.ts
server/src/shared/validation/index.ts
server/src/types/common.ts
server/src/types/global.d.ts
server/src/types/index.ts
server/src/utils/denormalization-sync.ts
server/src/utils/denormalization.ts
server/src/utils/timezone.ts
server/src/utils/validation.ts
server/tsconfig.build.json
server/tsconfig.json
server/uploads/.gitkeep
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="project-memory.md">
# Project Memory - QuanLyBenXe

**Updated:** 2025-12-29 11:27
**Session:** Project context restoration

---

## Project Identity

| Attribute | Value |
|-----------|-------|
| **Name** | QuanLyBenXe (Bus Station Management System) |
| **Type** | Full-stack web application |
| **Stack** | React 18 + Express.js + Firebase (RTDB + Firestore) |
| **Package Manager** | npm (workspaces: client, server) |
| **LOC** | ~50,000 (client: 25K, server: 15K) |

---

## Current State

### Progress Summary
- **Phase:** 5/6 (Integration Testing - Pending)
- **Branch:** master (clean, up-to-date with origin)
- **Uncommitted:** None

### Recent Commits (Last 5)
1. `fa6d038` feat: Implement initial HomePage with hero, counters, features, pricing
2. `fff85f4` feat: Core app features - dashboard, auth, chat functionality
3. `70d1548` feat: add operator API service with CRUD operations
4. `fa8e5ef` feat: Core bus station operations - driver, fleet, dispatch, payment, chat
5. `b841ed2` feat: Initial app with API, UI, data sync for dispatch/fleet/operator

### Completed Phases
- Phase 1: Component Decomposition (7 large components refactored)
- Phase 2: Backend Refactoring (controllers reduced 50-80%)
- Phase 3: Performance Optimization (React.memo, custom hooks)
- Phase 4: Code Quality & Documentation (TypeScript strict, zero `any`)

### Pending Phases
- Phase 5: Integration Testing (0% - starting 2026-01-01)
- Phase 6: Production Deployment (planned 2026-01-16)

---

## Architecture Quick Ref

### Frontend Structure
```
client/src/
├── features/      # Domain modules (auth, dispatch, fleet)
├── pages/         # 27 lazy-loaded pages
├── components/    # 50+ shared UI (shadcn/ui)
├── services/      # 17 API service files
├── store/         # 3 Zustand stores
├── hooks/         # 10+ custom hooks
└── types/         # TypeScript definitions
```

### Backend Structure
```
server/src/
├── modules/       # Feature modules (dispatch, fleet, operator, chat)
├── controllers/   # 23 HTTP handlers
├── services/      # 9+ business logic services
├── middleware/    # Auth, error handling
├── shared/        # Base repo, errors, response
└── config/        # Firebase setup
```

### Key Patterns
- Controller → Service → Repository → Firebase
- Zustand for state, React Query patterns for async
- Firebase dual-write (RTDB + Firestore sync)
- JWT authentication

---

## Active Plans

### Current: Codebase Improvement (Completed)
- Location: `plans/20251221-codebase-improvement/plan.md`
- Status: All 4 phases completed
- Key results: Component sizes reduced 50-80%, TypeScript strict mode

### Next: Integration Testing (Pending)
- Location: `docs/project-roadmap.md` (Phase 5)
- Start: 2026-01-01
- Focus: E2E tests, API integration, performance benchmarks

---

## Session Continuity

### Key Decisions Made
- Denormalized data strategy for dispatch records (speed vs storage)
- Firebase dual-write pattern verified and stable
- Badge vehicles support implemented for legacy vehicles

### Open Questions
- None documented

### Handover Notes
- All Phase 4 deliverables completed
- Documentation fully updated in ./docs/
- Ready for Phase 5 integration testing

---

## Tech Stack Quick Reference

### Frontend
- React 18 + TypeScript + Vite
- Tailwind CSS + shadcn/ui
- Zustand state + React Hook Form
- Recharts + SheetJS (Excel)

### Backend
- Express.js + TypeScript
- Firebase RTDB (primary) + Firestore (complex queries)
- JWT auth + Zod validation
- Cloudinary (images)

### Code Quality Targets
- TypeScript: 95%+ coverage (achieved)
- `any` types: 0 (achieved)
- Controller size: <300 LOC (achieved)
- Test coverage: 60% (target: 80%)

---

## Recommended Skills for Next Session

| Task Type | Skill to Activate |
|-----------|-------------------|
| Testing | `debugging`, `code-review` |
| Frontend work | `frontend-development`, `ui-styling` |
| Backend work | `backend-development`, `databases` |
| Firebase | Firebase MCP tools |

---

**Memory Version:** 1.0
**Created By:** Project context restoration command
</file>

<file path=".repomixignore">
docs/*
plans/*
assets/*
dist/*
coverage/*
build/*
ios/*
android/*
tests/*
__tests__/*
__pycache__/*
node_modules/*

.opencode/*
.claude/*
.serena/*
.pnpm-store/*
.github/*
.dart_tool/*
.idea/*
.husky/*
.venv/*
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Role & Responsibilities

Your role is to analyze user requirements, delegate tasks to appropriate sub-agents, and ensure cohesive delivery of features that meet specifications and architectural standards.

## Workflows

- Primary workflow: `./.claude/workflows/primary-workflow.md`
- Development rules: `./.claude/workflows/development-rules.md`
- Orchestration protocols: `./.claude/workflows/orchestration-protocol.md`
- Documentation management: `./.claude/workflows/documentation-management.md`
- And other workflows: `./.claude/workflows/*`

**IMPORTANT:** Analyze the skills catalog and activate the skills that are needed for the task during the process.
**IMPORTANT:** You must follow strictly the development rules in `./.claude/workflows/development-rules.md` file.
**IMPORTANT:** Before you plan or proceed any implementation, always read the `./README.md` file first to get context.
**IMPORTANT:** Sacrifice grammar for the sake of concision when writing reports.
**IMPORTANT:** In reports, list any unresolved questions at the end, if any.
**IMPORTANT**: Date format is configured in `.ck.json` and injected by session hooks via `$CK_PLAN_DATE_FORMAT` env var. Use this format for plan/report naming.

## Documentation Management

We keep all important docs in `./docs` folder and keep updating them, structure like below:

```
./docs
├── project-overview-pdr.md
├── code-standards.md
├── codebase-summary.md
├── design-guidelines.md
├── deployment-guide.md
├── system-architecture.md
└── project-roadmap.md
```

**IMPORTANT:** *MUST READ* and *MUST COMPLY* all *INSTRUCTIONS* in project `./CLAUDE.md`, especially *WORKFLOWS* section is *CRITICALLY IMPORTANT*, this rule is *MANDATORY. NON-NEGOTIABLE. NO EXCEPTIONS. MUST REMEMBER AT ALL TIMES!!!*
</file>

<file path="client/.eslintrc.cjs">
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    '@typescript-eslint/no-explicit-any': 'warn',
  },
}
</file>

<file path="client/.firebaserc">
{"projects":{"default":"benxe-management-20251218"}}
</file>

<file path="client/firebase.json">
{"hosting":{"public":"dist","ignore":["firebase.json","**/.*","**/node_modules/**"],"rewrites":[{"source":"**","destination":"/index.html"}]}}
</file>

<file path="client/package.json">
{
  "name": "ben-xe-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.2",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-radio-group": "^1.3.8",
    "axios": "^1.6.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "date-fns": "^4.1.0",
    "html5-qrcode": "^2.3.8",
    "lucide-react": "^0.556.0",
    "react": "^18.2.0",
    "react-day-picker": "^9.12.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.49.2",
    "react-router-dom": "^6.20.1",
    "react-toastify": "^11.0.5",
    "recharts": "^2.10.3",
    "tailwind-merge": "^2.1.0",
    "xlsx": "^0.18.5",
    "zod": "^3.22.4",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}
</file>

<file path="client/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="client/README.md">
# Hệ Thống Quản Lý Bến Xe - Frontend

Frontend application cho hệ thống quản lý bến xe được xây dựng với React, TypeScript, và TailwindCSS.

## Công nghệ sử dụng

- **React 18+** với Vite
- **TypeScript** (strict mode)
- **TailwindCSS 3+** cho styling
- **shadcn/ui** components
- **Lucide React** cho icons
- **Zustand** cho state management
- **React Router v6** cho routing
- **React Hook Form + Zod** cho form validation
- **date-fns** cho xử lý ngày tháng
- **Recharts** cho biểu đồ
- **Axios** cho HTTP requests

## Cài đặt

1. Cài đặt dependencies:

```bash
npm install
```

2. Tạo file `.env` từ `.env.example`:

```bash
cp .env.example .env
```

3. Cấu hình API URL trong file `.env`:

```
VITE_API_URL=http://localhost:3000/api
```

## Chạy ứng dụng

### Development

```bash
npm run dev
```

Ứng dụng sẽ chạy tại `http://localhost:5173`

### Build

```bash
npm run build
```

### Preview production build

```bash
npm run preview
```

## Cấu trúc thư mục

```
src/
├── components/
│   ├── ui/              # shadcn/ui components
│   ├── layout/          # Layout components (Sidebar, Header, MainLayout)
│   ├── dispatch/        # Dispatch module components
│   ├── vehicles/        # Vehicle management components
│   ├── drivers/         # Driver management components
│   └── reports/         # Report components
├── pages/
│   ├── Login.tsx
│   ├── Dashboard.tsx
│   ├── Dispatch.tsx
│   ├── Vehicles.tsx
│   ├── Drivers.tsx
│   └── Reports.tsx
├── hooks/               # Custom hooks
├── lib/                 # Utilities (api, utils)
├── services/            # API services
├── types/               # TypeScript types
├── store/               # Zustand stores
└── App.tsx
```

## Tính năng chính

### 1. Đăng nhập
- Form đăng nhập với validation
- Remember me functionality
- Error handling

### 2. Dashboard
- Thống kê tổng quan (xe trong bến, xe xuất bến, doanh thu)
- Biểu đồ lượt xe theo giờ
- Cảnh báo giấy tờ sắp hết hạn
- Hoạt động gần đây

### 3. Điều độ xe
- Quản lý quy trình xe ra vào bến
- Tabs theo trạng thái (Trong bến, Đã cấp nốt, Đã thanh toán, Đã xuất bến)
- Các thao tác: Cho vào bến, Cấp phép, Thanh toán, Xuất bến
- Search và filter

### 4. Quản lý xe
- CRUD xe
- Quản lý giấy tờ (đăng kiểm, phù hiệu, bảo hiểm)
- Lịch sử hoạt động

### 5. Quản lý lái xe
- CRUD lái xe
- Quản lý bằng lái và hợp đồng
- Lịch sử điều độ

### 6. Báo cáo & Thống kê
- Bảng kê hóa đơn
- Nhật trình xe
- Xe ra vào bến
- Xe không đủ điều kiện
- Doanh thu
- Export Excel

## Design System

### Màu sắc
- **Primary**: Blue (#3B82F6)
- **Success**: Green (#10B981)
- **Warning**: Yellow/Amber (#F59E0B)
- **Danger**: Red (#EF4444)
- **Background**: White/Light Gray (#F9FAFB)

### Typography
- Font: Inter hoặc System fonts
- Clear hierarchy với font sizes và weights

### Spacing
- Consistent padding/margin (4, 8, 12, 16, 24, 32px)

### Border Radius
- Moderate (4-8px)

## API Integration

Tất cả API calls được định nghĩa trong `src/services/`:
- `auth.service.ts` - Authentication
- `vehicle.service.ts` - Vehicle management
- `driver.service.ts` - Driver management
- `dispatch.service.ts` - Dispatch operations
- `report.service.ts` - Reports

API client được cấu hình trong `src/lib/api.ts` với:
- Base URL từ environment variable
- Request interceptor để thêm auth token
- Response interceptor để xử lý errors

## State Management

Sử dụng Zustand cho state management:
- `auth.store.ts` - Authentication state
- `dispatch.store.ts` - Dispatch state

## Validation

Sử dụng Zod schemas cho validation:
- Form validation với React Hook Form
- Type-safe với TypeScript

## Responsive Design

- Mobile First approach
- Breakpoints: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)
- Sidebar collapsible trên mobile
- Tables responsive với horizontal scroll

## Linting

```bash
npm run lint
```

## Notes

- Tất cả components sử dụng TypeScript strict mode
- Icons từ Lucide React (không dùng emoji)
- Không sử dụng gradients, chỉ solid colors
- Loading states và error handling đầy đủ
- Accessibility support (ARIA labels, keyboard navigation)
</file>

<file path="client/SETUP.md">
# Hướng dẫn Setup

## Bước 1: Cài đặt Dependencies

```bash
cd client
npm install
```

## Bước 2: Cấu hình Environment

Tạo file `.env` trong thư mục `client`:

```env
VITE_API_URL=http://localhost:3000/api
```

Thay đổi URL này theo địa chỉ API backend của bạn.

## Bước 3: Chạy Development Server

```bash
npm run dev
```

Ứng dụng sẽ chạy tại `http://localhost:5173`

## Cấu trúc đã được tạo

### ✅ Pages
- **Login** - Trang đăng nhập với validation
- **Dashboard** - Tổng quan với stats cards và charts
- **Dispatch** - Điều độ xe (tính năng chính)
- **Vehicles** - Quản lý xe (CRUD)
- **Drivers** - Quản lý lái xe (CRUD)
- **Reports** - Báo cáo và thống kê

### ✅ Components
- **UI Components** (shadcn/ui style):
  - Button, Input, Card, Label, Dialog, Table, Badge, Tabs, Checkbox, Select
- **Layout Components**:
  - Sidebar (responsive, collapsible)
  - Header (với user menu)
  - MainLayout
- **Reusable Components**:
  - DashboardCard
  - StatusBadge

### ✅ Services
- `auth.service.ts` - Authentication
- `vehicle.service.ts` - Vehicle management
- `driver.service.ts` - Driver management
- `dispatch.service.ts` - Dispatch operations
- `report.service.ts` - Reports

### ✅ State Management (Zustand)
- `auth.store.ts` - Authentication state
- `dispatch.store.ts` - Dispatch state

### ✅ Types
- Đầy đủ TypeScript types trong `src/types/index.ts`

### ✅ Configuration
- Vite config với path aliases (@/)
- TypeScript strict mode
- TailwindCSS với design system
- ESLint configuration

## Lưu ý

1. **API Integration**: Hiện tại các service đã được setup nhưng cần kết nối với backend API thực tế. Các API calls sẽ tự động thêm auth token từ localStorage.

2. **Mock Data**: Một số trang (Dashboard, Dispatch) đang sử dụng mock data. Cần thay thế bằng API calls thực tế.

3. **Date Formatting**: Đang sử dụng `date-fns` cho format ngày tháng. Có thể thêm locale Vietnamese nếu cần.

4. **Error Handling**: Đã có error handling cơ bản. Có thể mở rộng thêm error boundaries và toast notifications.

5. **Loading States**: Đã có loading states cơ bản. Có thể thêm skeleton loaders cho UX tốt hơn.

## Next Steps

1. Kết nối với backend API
2. Thêm error boundaries
3. Thêm toast notifications (có thể dùng react-hot-toast hoặc sonner)
4. Thêm pagination cho tables
5. Thêm advanced filters
6. Thêm export Excel functionality (đã có structure)
7. Thêm image upload cho giấy tờ
8. Thêm real-time updates (WebSocket nếu cần)

## Tech Stack Summary

- React 18+ với Vite
- TypeScript (strict mode)
- TailwindCSS 3+
- shadcn/ui components
- Lucide React icons
- Zustand (state management)
- React Router v6
- React Hook Form + Zod
- date-fns
- Recharts
- Axios

## Design System

- **Colors**: Blue primary (#3B82F6), Green success, Yellow warning, Red danger
- **No Gradients**: Chỉ sử dụng solid colors
- **Icons**: Chỉ Lucide React, không emoji
- **Responsive**: Mobile-first approach
- **Accessibility**: ARIA labels, keyboard navigation
</file>

<file path="client/src/components/common/index.ts">
export { PageLoader } from './PageLoader'
export { SuspenseWrapper } from './SuspenseWrapper'
</file>

<file path="client/src/components/common/PageLoader.tsx">
export function PageLoader() {
  return (
    <div className="flex h-full min-h-[400px] w-full items-center justify-center">
      <div className="text-center">
        <div className="mb-4 h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent mx-auto" />
        <p className="text-gray-600">Đang tải...</p>
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/common/SuspenseWrapper.tsx">
import { Suspense, type ReactNode } from 'react'
import { PageLoader } from './PageLoader'

interface SuspenseWrapperProps {
  children: ReactNode
  fallback?: ReactNode
}

export function SuspenseWrapper({ children, fallback }: SuspenseWrapperProps) {
  return (
    <Suspense fallback={fallback ?? <PageLoader />}>
      {children}
    </Suspense>
  )
}
</file>

<file path="client/src/components/dashboard/charts/index.ts">
export { VehicleTrendChart } from "./VehicleTrendChart";
export { WeeklyProgressChart } from "./WeeklyProgressChart";
export { VehiclesByStatusChart } from "./VehiclesByStatusChart";
export { VehiclesByRouteChart } from "./VehiclesByRouteChart";
export { MonthlyBreakdownChart } from "./MonthlyBreakdownChart";
</file>

<file path="client/src/components/dashboard/charts/MonthlyBreakdownChart.tsx">
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";
import type { MonthlyStat } from "@/services/dashboard.service";

interface MonthlyBreakdownChartProps {
  data: MonthlyStat[];
  isLoading?: boolean;
}

const CustomTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-stone-800 text-white px-3 py-2 rounded-lg shadow-lg text-sm">
        <p className="font-medium mb-1">Tháng {label}</p>
        {payload.map((entry: any, index: number) => (
          <p key={index} style={{ color: entry.color }}>
            {entry.name}: {entry.value} xe
          </p>
        ))}
      </div>
    );
  }
  return null;
};

export function MonthlyBreakdownChart({ data, isLoading }: MonthlyBreakdownChartProps) {
  // Transform data for chart
  const chartData = data.map((item) => ({
    name: item.monthName,
    departed: item.departed,
    waiting: item.waiting,
    other: item.other,
  }));

  if (isLoading) {
    return (
      <div className="h-[240px] flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-stone-300 border-t-emerald-500 rounded-full animate-spin" />
      </div>
    );
  }

  // Show empty state if no data
  if (chartData.length === 0) {
    return (
      <div className="h-[240px] flex items-center justify-center text-stone-400">
        Chưa có dữ liệu
      </div>
    );
  }

  return (
    <div className="h-[240px]">
      <ResponsiveContainer width="100%" height="100%">
        <BarChart
          data={chartData}
          margin={{ top: 10, right: 10, left: -20, bottom: 0 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" vertical={false} />
          <XAxis
            dataKey="name"
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 10, fill: "#9ca3af" }}
            dy={10}
          />
          <YAxis
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 10, fill: "#9ca3af" }}
            dx={-10}
          />
          <Tooltip content={<CustomTooltip />} />
          <Bar
            dataKey="departed"
            name="Xuất bến"
            stackId="a"
            fill="#22c55e"
            radius={[0, 0, 0, 0]}
          />
          <Bar
            dataKey="waiting"
            name="Chờ"
            stackId="a"
            fill="#f59e0b"
            radius={[0, 0, 0, 0]}
          />
          <Bar
            dataKey="other"
            name="Khác"
            stackId="a"
            fill="#d1d5db"
            radius={[4, 4, 0, 0]}
          />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/charts/VehiclesByRouteChart.tsx">
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip,
} from "recharts";
import type { RouteBreakdown } from "@/services/dashboard.service";

interface VehiclesByRouteChartProps {
  data: RouteBreakdown[];
  isLoading?: boolean;
}

const COLORS = [
  "#f97316", // orange-500
  "#a855f7", // purple-500
  "#22c55e", // green-500
  "#3b82f6", // blue-500
  "#ef4444", // red-500
  "#eab308", // yellow-500
];

const CustomTooltip = ({ active, payload }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-stone-800 text-white px-3 py-2 rounded-lg shadow-lg text-sm">
        <p className="font-medium">{payload[0].name}</p>
        <p>{payload[0].value} xe ({payload[0].payload.percentage}%)</p>
      </div>
    );
  }
  return null;
};

export function VehiclesByRouteChart({ data, isLoading }: VehiclesByRouteChartProps) {
  // Transform data for chart
  const chartData = data.map((item, index) => ({
    name: item.routeName,
    value: item.count,
    percentage: item.percentage,
    color: COLORS[index % COLORS.length],
  }));

  const totalVehicles = chartData.reduce((sum, item) => sum + item.value, 0);

  if (isLoading) {
    return (
      <div className="h-[240px] flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-stone-300 border-t-purple-500 rounded-full animate-spin" />
      </div>
    );
  }

  // Show empty state if no data
  if (chartData.length === 0) {
    return (
      <div className="h-[240px] flex items-center justify-center text-stone-400">
        Chưa có dữ liệu
      </div>
    );
  }

  return (
    <div className="h-[240px] relative">
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={chartData}
            cx="50%"
            cy="50%"
            innerRadius={60}
            outerRadius={80}
            paddingAngle={2}
            dataKey="value"
          >
            {chartData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.color} />
            ))}
          </Pie>
          <Tooltip content={<CustomTooltip />} />
        </PieChart>
      </ResponsiveContainer>

      {/* Center total */}
      <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
        <div className="text-center">
          <span className="text-2xl font-bold text-stone-900">{totalVehicles}</span>
          <p className="text-xs text-stone-500">Tổng xe</p>
        </div>
      </div>

      {/* Legend */}
      <div className="flex flex-wrap items-center justify-center gap-x-3 gap-y-1 mt-2">
        {chartData.slice(0, 4).map((item, index) => (
          <div key={index} className="flex items-center gap-1">
            <span
              className="w-2 h-2 rounded-full"
              style={{ backgroundColor: item.color }}
            />
            <span className="text-xs text-stone-600 truncate max-w-[80px]">
              {item.name.length > 12 ? item.name.substring(0, 12) + "..." : item.name}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/charts/VehiclesByStatusChart.tsx">
import { useMemo } from "react";
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip,
} from "recharts";

interface VehiclesByStatusChartProps {
  inStation: number;
  departed: number;
  total: number;
  isLoading?: boolean;
}

const COLORS = {
  departed: "#1f2937", // stone-800
  inStation: "#9ca3af", // stone-400
  other: "#e5e7eb", // stone-200
};

const CustomTooltip = ({ active, payload }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-stone-800 text-white px-3 py-2 rounded-lg shadow-lg text-sm">
        <p className="font-medium">{payload[0].name}</p>
        <p>{payload[0].value} xe ({payload[0].payload.percentage}%)</p>
      </div>
    );
  }
  return null;
};

export function VehiclesByStatusChart({
  inStation,
  departed,
  total,
  isLoading,
}: VehiclesByStatusChartProps) {
  const chartData = useMemo(() => {
    const actualTotal = total || inStation + departed || 1;
    const other = Math.max(0, actualTotal - inStation - departed);

    return [
      {
        name: "Đã xuất bến",
        value: departed || 0,
        percentage: actualTotal > 0 ? Math.round((departed / actualTotal) * 100) : 0,
        color: COLORS.departed,
      },
      {
        name: "Trong bến",
        value: inStation || 0,
        percentage: actualTotal > 0 ? Math.round((inStation / actualTotal) * 100) : 0,
        color: COLORS.inStation,
      },
      {
        name: "Khác",
        value: other,
        percentage: actualTotal > 0 ? Math.round((other / actualTotal) * 100) : 0,
        color: COLORS.other,
      },
    ].filter((d) => d.value > 0);
  }, [inStation, departed, total]);

  // Calculate percentage for center display
  const departedPercentage = useMemo(() => {
    const actualTotal = total || inStation + departed || 1;
    return actualTotal > 0 ? Math.round((departed / actualTotal) * 100) : 0;
  }, [departed, inStation, total]);

  if (isLoading) {
    return (
      <div className="h-[240px] flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-stone-300 border-t-stone-800 rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div className="h-[240px] relative">
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={chartData}
            cx="50%"
            cy="50%"
            innerRadius={60}
            outerRadius={80}
            paddingAngle={2}
            dataKey="value"
          >
            {chartData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.color} />
            ))}
          </Pie>
          <Tooltip content={<CustomTooltip />} />
        </PieChart>
      </ResponsiveContainer>

      {/* Center percentage */}
      <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
        <span className="text-3xl font-bold text-stone-900">{departedPercentage}%</span>
      </div>

      {/* Legend */}
      <div className="flex items-center justify-center gap-4 mt-2">
        <div className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-full bg-stone-800" />
          <span className="text-xs text-stone-600">Xuất bến</span>
        </div>
        <div className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-full bg-stone-400" />
          <span className="text-xs text-stone-600">Trong bến</span>
        </div>
        <div className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-full bg-stone-200" />
          <span className="text-xs text-stone-600">Chờ</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/charts/VehicleTrendChart.tsx">
import { useMemo } from "react";
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";
import type { ChartDataPoint } from "@/services/dashboard.service";

interface VehicleTrendChartProps {
  data: ChartDataPoint[];
  isLoading?: boolean;
}

const CustomTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-stone-800 text-white px-3 py-2 rounded-lg shadow-lg text-sm">
        <p className="font-medium">{label}</p>
        <p className="text-orange-300">{payload[0].value} xe</p>
      </div>
    );
  }
  return null;
};

export function VehicleTrendChart({ data, isLoading }: VehicleTrendChartProps) {
  // Transform hourly data for chart display
  const chartData = useMemo(() => {
    if (data.length === 0) return [];
    return data.map((item) => ({
      name: item.hour,
      value: item.count,
    }));
  }, [data]);

  if (isLoading) {
    return (
      <div className="h-[280px] flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-stone-300 border-t-orange-500 rounded-full animate-spin" />
      </div>
    );
  }

  // Show empty state if no data
  if (chartData.length === 0) {
    return (
      <div className="h-[280px] flex items-center justify-center text-stone-400">
        Chưa có dữ liệu
      </div>
    );
  }

  return (
    <div className="h-[280px]">
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart
          data={chartData}
          margin={{ top: 10, right: 10, left: -20, bottom: 0 }}
        >
          <defs>
            <linearGradient id="colorValue" x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%" stopColor="#f97316" stopOpacity={0.3} />
              <stop offset="95%" stopColor="#f97316" stopOpacity={0} />
            </linearGradient>
          </defs>
          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" vertical={false} />
          <XAxis
            dataKey="name"
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 12, fill: "#9ca3af" }}
            dy={10}
          />
          <YAxis
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 12, fill: "#9ca3af" }}
            dx={-10}
          />
          <Tooltip content={<CustomTooltip />} />
          <Area
            type="monotone"
            dataKey="value"
            stroke="#f97316"
            strokeWidth={2}
            fill="url(#colorValue)"
            dot={{ r: 4, fill: "#f97316", strokeWidth: 0 }}
            activeDot={{ r: 6, fill: "#f97316", strokeWidth: 2, stroke: "#fff" }}
          />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/charts/WeeklyProgressChart.tsx">
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";
import type { WeeklyStat } from "@/services/dashboard.service";

interface WeeklyProgressChartProps {
  data: WeeklyStat[];
  isLoading?: boolean;
}

const CustomTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-stone-800 text-white px-3 py-2 rounded-lg shadow-lg text-sm">
        <p className="font-medium mb-1">{label}</p>
        {payload.map((entry: any, index: number) => (
          <p key={index} style={{ color: entry.color }}>
            {entry.name}: {entry.value} xe
          </p>
        ))}
      </div>
    );
  }
  return null;
};

export function WeeklyProgressChart({ data, isLoading }: WeeklyProgressChartProps) {
  // Transform data for chart
  const chartData = data.map((item) => ({
    name: item.dayName,
    departed: item.departed,
    inStation: item.inStation,
    total: item.total,
  }));

  if (isLoading) {
    return (
      <div className="h-[280px] flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-stone-300 border-t-emerald-500 rounded-full animate-spin" />
      </div>
    );
  }

  // Show empty state if no data
  if (chartData.length === 0) {
    return (
      <div className="h-[280px] flex items-center justify-center text-stone-400">
        Chưa có dữ liệu
      </div>
    );
  }

  return (
    <div className="h-[280px]">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart
          data={chartData}
          margin={{ top: 10, right: 10, left: -20, bottom: 0 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" vertical={false} />
          <XAxis
            dataKey="name"
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 11, fill: "#9ca3af" }}
            dy={10}
          />
          <YAxis
            axisLine={false}
            tickLine={false}
            tick={{ fontSize: 11, fill: "#9ca3af" }}
            dx={-10}
          />
          <Tooltip content={<CustomTooltip />} />
          <Line
            type="monotone"
            dataKey="departed"
            name="Xuất bến"
            stroke="#22c55e"
            strokeWidth={2}
            dot={{ r: 3, fill: "#22c55e", strokeWidth: 0 }}
            activeDot={{ r: 5, fill: "#22c55e" }}
          />
          <Line
            type="monotone"
            dataKey="inStation"
            name="Trong bến"
            stroke="#f97316"
            strokeWidth={2}
            dot={{ r: 3, fill: "#f97316", strokeWidth: 0 }}
            activeDot={{ r: 5, fill: "#f97316" }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/EditDocumentDialog.tsx">
import { useState, useEffect } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { format } from "date-fns"
import { toast } from "react-toastify"
import { Calendar, Save, X } from "lucide-react"
import { iconStyles } from "@/lib/icon-theme"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { DatePicker } from "@/components/DatePicker"
import type { Warning } from "@/services/dashboard.service"

const documentSchema = z.object({
  documentNumber: z.string().min(1, "Số giấy tờ là bắt buộc"),
  issueDate: z.string().min(1, "Ngày cấp là bắt buộc"),
  expiryDate: z.string().min(1, "Ngày hết hạn là bắt buộc"),
  issuingAuthority: z.string().optional(),
  notes: z.string().optional(),
})

type DocumentFormData = z.infer<typeof documentSchema>

interface EditDocumentDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  warning: Warning | null
  onSave: (data: DocumentFormData & { warningId: string }) => Promise<void>
}

export function EditDocumentDialog({
  open,
  onOpenChange,
  warning,
  onSave,
}: EditDocumentDialogProps) {
  const [isLoading, setIsLoading] = useState(false)

  const {
    register,
    handleSubmit,
    reset,
    setValue,
    watch,
    formState: { errors },
  } = useForm<DocumentFormData>({
    resolver: zodResolver(documentSchema),
  })

  const watchedIssueDate = watch("issueDate")
  const watchedExpiryDate = watch("expiryDate")

  useEffect(() => {
    if (warning && open) {
      // Load existing document data (this would come from an API call)
      reset({
        documentNumber: "", // Would be loaded from API
        issueDate: format(new Date(), "yyyy-MM-dd"),
        expiryDate: format(new Date(warning.expiryDate), "yyyy-MM-dd"),
        issuingAuthority: "",
        notes: "",
      })
    }
  }, [warning, open, reset])

  const onSubmit = async (data: DocumentFormData) => {
    if (!warning) return

    setIsLoading(true)
    try {
      await onSave({
        ...data,
        warningId: `${warning.type}-${warning.plateNumber || warning.name}`,
      })
      toast.success("Cập nhật giấy tờ thành công")
      onOpenChange(false)
    } catch (error: any) {
      console.error("Failed to update document:", error)
      toast.error("Không thể cập nhật giấy tờ. Vui lòng thử lại.")
    } finally {
      setIsLoading(false)
    }
  }

  if (!warning) return null

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Calendar className={iconStyles.infoIcon} />
            Cập nhật giấy tờ - {warning.document}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {/* Warning Info */}
          <div className="bg-blue-50 p-4 rounded-lg">
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div>
                <span className="font-medium text-gray-600">Loại:</span>
                <span className="ml-2">{warning.type === "vehicle" ? "Xe" : "Lái xe"}</span>
              </div>
              <div>
                <span className="font-medium text-gray-600">Thông tin:</span>
                <span className="ml-2">{warning.plateNumber || warning.name}</span>
              </div>
              <div>
                <span className="font-medium text-gray-600">Giấy tờ:</span>
                <span className="ml-2">{warning.document}</span>
              </div>
              <div>
                <span className="font-medium text-gray-600">Hết hạn cũ:</span>
                <span className="ml-2 text-red-600 font-medium">
                  {format(new Date(warning.expiryDate), "dd/MM/yyyy")}
                </span>
              </div>
            </div>
          </div>

          {/* Form Fields */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="documentNumber">
                Số giấy tờ <span className="text-red-500">*</span>
              </Label>
              <Input
                id="documentNumber"
                placeholder="Nhập số giấy tờ"
                {...register("documentNumber")}
                className={errors.documentNumber ? "border-red-500" : ""}
              />
              {errors.documentNumber && (
                <p className="text-sm text-red-500">{errors.documentNumber.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="issuingAuthority">Cơ quan cấp</Label>
              <Input
                id="issuingAuthority"
                placeholder="Nhập cơ quan cấp"
                {...register("issuingAuthority")}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="issueDate">
                Ngày cấp <span className="text-red-500">*</span>
              </Label>
              <DatePicker
                date={watchedIssueDate ? new Date(watchedIssueDate) : null}
                onDateChange={(date: Date | undefined) => {
                  if (date) {
                    setValue("issueDate", format(date, "yyyy-MM-dd"))
                  }
                }}
                placeholder="Chọn ngày cấp"
              />
              {errors.issueDate && (
                <p className="text-sm text-red-500">{errors.issueDate.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="expiryDate">
                Ngày hết hạn <span className="text-red-500">*</span>
              </Label>
              <DatePicker
                date={watchedExpiryDate ? new Date(watchedExpiryDate) : null}
                onDateChange={(date: Date | undefined) => {
                  if (date) {
                    setValue("expiryDate", format(date, "yyyy-MM-dd"))
                  }
                }}
                placeholder="Chọn ngày hết hạn"
              />
              {errors.expiryDate && (
                <p className="text-sm text-red-500">{errors.expiryDate.message}</p>
              )}
            </div>

            <div className="md:col-span-2 space-y-2">
              <Label htmlFor="notes">Ghi chú</Label>
              <textarea
                id="notes"
                {...register("notes")}
                rows={3}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                placeholder="Nhập ghi chú (tùy chọn)"
              />
            </div>
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              <X className={iconStyles.deleteButton} />
              Hủy
            </Button>
            <Button type="submit" disabled={isLoading}>
              <Save className={iconStyles.successIcon} />
              {isLoading ? "Đang lưu..." : "Lưu thay đổi"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/dashboard/stats/LiveBeacon.tsx">
import { cn } from "@/lib/utils";

interface LiveBeaconProps {
  size?: "small" | "default" | "large";
}

export function LiveBeacon({ size = "default" }: LiveBeaconProps) {
  const sizes = {
    small: "h-2 w-2",
    default: "h-3 w-3",
    large: "h-4 w-4",
  };

  return (
    <span className="relative flex">
      <span
        className={cn(
          "animate-ping absolute inline-flex rounded-full bg-emerald-400 opacity-75",
          sizes[size]
        )}
      />
      <span
        className={cn(
          "relative inline-flex rounded-full bg-emerald-500",
          sizes[size]
        )}
      />
    </span>
  );
}
</file>

<file path="client/src/components/dashboard/stats/TrendStatCard.tsx">
import { memo } from "react";
import { TrendingUp, TrendingDown, AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
import { useAnimatedCounter } from "@/hooks/useAnimatedCounter";

export interface TrendStatCardProps {
  /** Category label displayed as colored pill */
  category: string;
  /** Color theme for category pill */
  categoryColor: "orange" | "green" | "blue" | "rose" | "purple" | "amber";
  /** Main value to display */
  value: number | string;
  /** Subtitle description */
  subtitle: string;
  /** Trend indicator */
  trend?: {
    direction: "up" | "down" | "attention";
    value: string;
    description: string;
  };
  /** Loading state */
  isLoading?: boolean;
  /** Format value as currency VND */
  isCurrency?: boolean;
}

const categoryColors = {
  orange: "bg-orange-100 text-orange-600",
  green: "bg-emerald-100 text-emerald-600",
  blue: "bg-blue-100 text-blue-600",
  rose: "bg-rose-100 text-rose-600",
  purple: "bg-purple-100 text-purple-600",
  amber: "bg-amber-100 text-amber-600",
};

const trendColors = {
  up: "text-emerald-600",
  down: "text-rose-600",
  attention: "text-amber-600",
};

const TrendIcon = ({ direction }: { direction: "up" | "down" | "attention" }) => {
  switch (direction) {
    case "up":
      return <TrendingUp className="w-3.5 h-3.5" />;
    case "down":
      return <TrendingDown className="w-3.5 h-3.5" />;
    case "attention":
      return <AlertCircle className="w-3.5 h-3.5" />;
  }
};

export const TrendStatCard = memo(function TrendStatCard({
  category,
  categoryColor,
  value,
  subtitle,
  trend,
  isLoading,
  isCurrency,
}: TrendStatCardProps) {
  const numericValue = typeof value === "number" ? value : 0;
  const animatedValue = useAnimatedCounter(isLoading ? 0 : numericValue, 1200);

  const formatValue = (val: number) => {
    if (isCurrency) {
      return new Intl.NumberFormat("vi-VN").format(val);
    }
    return val.toLocaleString("vi-VN");
  };

  return (
    <div className="bg-white border border-stone-200 rounded-xl p-5 hover:shadow-md transition-shadow">
      {/* Category Pill */}
      <div className="mb-3">
        <span
          className={cn(
            "inline-flex px-2.5 py-1 rounded-md text-[11px] font-semibold uppercase tracking-wide",
            categoryColors[categoryColor]
          )}
        >
          {category}
        </span>
      </div>

      {/* Value */}
      <div className="mb-1">
        {isLoading ? (
          <div className="h-8 w-20 bg-stone-200 rounded animate-pulse" />
        ) : (
          <p className="text-[28px] font-bold text-stone-900 leading-tight">
            {typeof value === "string" ? value : formatValue(animatedValue)}
          </p>
        )}
      </div>

      {/* Subtitle */}
      <p className="text-[13px] text-stone-500 mb-4">{subtitle}</p>

      {/* Trend Indicator */}
      {trend && (
        <div
          className={cn(
            "flex items-center gap-1.5 text-[13px] font-medium",
            trendColors[trend.direction]
          )}
        >
          <TrendIcon direction={trend.direction} />
          <span>{trend.value}</span>
          <span className="text-stone-400 font-normal">{trend.description}</span>
        </div>
      )}
    </div>
  );
});
</file>

<file path="client/src/components/dashboard/VehicleHistoryTable.tsx">
import { useState, useEffect } from "react"
import { format } from "date-fns"
import { History, User, Calendar, ChevronLeft, ChevronRight, Search } from "lucide-react"
import { iconStyles } from "@/lib/icon-theme"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Badge } from "@/components/ui/badge"
import { Select } from "@/components/ui/select"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"

interface VehicleHistoryEntry {
  id: string
  vehiclePlateNumber: string
  changeType: 'document_update' | 'vehicle_info' | 'status_change'
  fieldChanged: string
  oldValue: string
  newValue: string
  changedBy: string
  changedAt: string
  notes?: string
}

interface VehicleHistoryTableProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

const ITEMS_PER_PAGE = 10

const mockHistoryData: VehicleHistoryEntry[] = [
  {
    id: "1",
    vehiclePlateNumber: "30A-12345",
    changeType: "document_update",
    fieldChanged: "Đăng kiểm",
    oldValue: "15/12/2024",
    newValue: "15/06/2025",
    changedBy: "Nguyễn Văn A",
    changedAt: "2024-12-15T10:30:00Z",
    notes: "Gia hạn đăng kiểm"
  },
  {
    id: "2", 
    vehiclePlateNumber: "29B-67890",
    changeType: "vehicle_info",
    fieldChanged: "Số ghế",
    oldValue: "45",
    newValue: "47",
    changedBy: "Trần Thị B",
    changedAt: "2024-12-14T14:20:00Z",
    notes: "Cập nhật sau sửa chữa"
  },
  {
    id: "3",
    vehiclePlateNumber: "30A-12345", 
    changeType: "status_change",
    fieldChanged: "Trạng thái",
    oldValue: "Hoạt động",
    newValue: "Bảo trì",
    changedBy: "Lê Văn C",
    changedAt: "2024-12-13T09:15:00Z",
    notes: "Xe vào bảo trì định kỳ"
  },
  {
    id: "4",
    vehiclePlateNumber: "51C-11111",
    changeType: "document_update", 
    fieldChanged: "Bảo hiểm",
    oldValue: "20/11/2024",
    newValue: "20/11/2025",
    changedBy: "Phạm Thị D",
    changedAt: "2024-12-12T16:45:00Z",
    notes: "Gia hạn bảo hiểm"
  },
  {
    id: "5",
    vehiclePlateNumber: "29B-67890",
    changeType: "vehicle_info",
    fieldChanged: "Màu xe", 
    oldValue: "Xanh",
    newValue: "Trắng",
    changedBy: "Hoàng Văn E",
    changedAt: "2024-12-11T11:30:00Z",
    notes: "Sơn lại xe"
  }
]

export function VehicleHistoryTable({ open, onOpenChange }: VehicleHistoryTableProps) {
  const [historyData, setHistoryData] = useState<VehicleHistoryEntry[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [currentPage, setCurrentPage] = useState(1)
  const [searchQuery, setSearchQuery] = useState("")
  const [filterType, setFilterType] = useState("")

  useEffect(() => {
    if (open) {
      loadHistoryData()
    }
  }, [open])

  const loadHistoryData = async () => {
    setIsLoading(true)
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000))
      setHistoryData(mockHistoryData)
    } catch (error) {
      console.error("Failed to load history data:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const filteredData = historyData.filter(entry => {
    const matchesSearch = !searchQuery || 
      entry.vehiclePlateNumber.toLowerCase().includes(searchQuery.toLowerCase()) ||
      entry.fieldChanged.toLowerCase().includes(searchQuery.toLowerCase()) ||
      entry.changedBy.toLowerCase().includes(searchQuery.toLowerCase())
    
    const matchesFilter = !filterType || entry.changeType === filterType

    return matchesSearch && matchesFilter
  })

  const totalPages = Math.ceil(filteredData.length / ITEMS_PER_PAGE)
  const startIndex = (currentPage - 1) * ITEMS_PER_PAGE
  const endIndex = startIndex + ITEMS_PER_PAGE
  const currentData = filteredData.slice(startIndex, endIndex)

  const getChangeTypeLabel = (type: string) => {
    const labels = {
      document_update: "Cập nhật giấy tờ",
      vehicle_info: "Thông tin xe", 
      status_change: "Thay đổi trạng thái"
    }
    return labels[type as keyof typeof labels] || type
  }

  const getChangeTypeBadge = (type: string) => {
    const variants = {
      document_update: "default",
      vehicle_info: "secondary",
      status_change: "outline"
    }
    return (
      <Badge variant={variants[type as keyof typeof variants] as any}>
        {getChangeTypeLabel(type)}
      </Badge>
    )
  }

  if (!open) return null

  return (
    <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4">
      <Card className="w-full max-w-6xl max-h-[90vh] overflow-hidden">
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              <History className={iconStyles.historyButton} />
              Lịch sử chỉnh sửa thông số xe
            </CardTitle>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onOpenChange(false)}
              className="h-8 w-8 p-0"
            >
              ×
            </Button>
          </div>
          
          {/* Filters */}
          <div className="flex items-center gap-4 mt-4">
            <div className="flex-1 relative">
              <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 ${iconStyles.navigationIcon}`} />
              <Input
                placeholder="Tìm kiếm biển số, trường thay đổi, người thực hiện..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>
            <Select
              value={filterType}
              onChange={(e) => setFilterType(e.target.value)}
              className="w-48"
            >
              <option value="">Tất cả loại thay đổi</option>
              <option value="document_update">Cập nhật giấy tờ</option>
              <option value="vehicle_info">Thông tin xe</option>
              <option value="status_change">Thay đổi trạng thái</option>
            </Select>
          </div>
        </CardHeader>

        <CardContent className="p-0">
          {isLoading ? (
            <div className="text-center py-12 text-gray-500">
              <History className="h-12 w-12 mx-auto mb-4 text-gray-300 animate-pulse" />
              <p>Đang tải lịch sử...</p>
            </div>
          ) : filteredData.length === 0 ? (
            <div className="text-center py-12 text-gray-500">
              <History className="h-12 w-12 mx-auto mb-4 text-gray-300" />
              <p>Không có lịch sử thay đổi</p>
            </div>
          ) : (
            <>
              <div className="overflow-x-auto max-h-[60vh] overflow-y-auto">
                <Table>
                  <TableHeader className="sticky top-0 bg-white z-10">
                    <TableRow>
                      <TableHead>Thời gian</TableHead>
                      <TableHead>Biển số</TableHead>
                      <TableHead>Loại thay đổi</TableHead>
                      <TableHead>Trường</TableHead>
                      <TableHead>Giá trị cũ</TableHead>
                      <TableHead>Giá trị mới</TableHead>
                      <TableHead>Người thực hiện</TableHead>
                      <TableHead>Ghi chú</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {currentData.map((entry) => (
                      <TableRow key={entry.id} className="hover:bg-gray-50">
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <Calendar className={iconStyles.navigationIcon} />
                            <div>
                              <div className="font-medium">
                                {format(new Date(entry.changedAt), "dd/MM/yyyy")}
                              </div>
                              <div className="text-xs text-gray-500">
                                {format(new Date(entry.changedAt), "HH:mm")}
                              </div>
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>
                          <span className="font-medium">{entry.vehiclePlateNumber}</span>
                        </TableCell>
                        <TableCell>
                          {getChangeTypeBadge(entry.changeType)}
                        </TableCell>
                        <TableCell>
                          <span className="font-medium">{entry.fieldChanged}</span>
                        </TableCell>
                        <TableCell>
                          <span className="text-gray-600 line-through">
                            {entry.oldValue}
                          </span>
                        </TableCell>
                        <TableCell>
                          <span className="text-green-600 font-medium">
                            {entry.newValue}
                          </span>
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <User className={iconStyles.navigationIcon} />
                            <span>{entry.changedBy}</span>
                          </div>
                        </TableCell>
                        <TableCell>
                          <span className="text-sm text-gray-600">
                            {entry.notes || "-"}
                          </span>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>

              {/* Pagination */}
              {totalPages > 1 && (
                <div className="flex items-center justify-between p-4 border-t">
                  <div className="text-sm text-gray-600">
                    Hiển thị {startIndex + 1}-{Math.min(endIndex, filteredData.length)} của {filteredData.length} bản ghi
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                      disabled={currentPage === 1}
                      className="gap-1"
                    >
                      <ChevronLeft className={iconStyles.navigationIcon} />
                      Trước
                    </Button>
                    
                    <div className="flex items-center gap-1">
                      {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                        let page = i + 1
                        if (totalPages > 5) {
                          if (currentPage > 3) {
                            page = currentPage - 2 + i
                          }
                          if (currentPage > totalPages - 2) {
                            page = totalPages - 4 + i
                          }
                        }
                        return (
                          <Button
                            key={page}
                            size="sm"
                            variant={currentPage === page ? "default" : "outline"}
                            onClick={() => setCurrentPage(page)}
                            className="w-8 h-8 p-0"
                          >
                            {page}
                          </Button>
                        )
                      })}
                    </div>

                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                      disabled={currentPage === totalPages}
                      className="gap-1"
                    >
                      Sau
                      <ChevronRight className={iconStyles.navigationIcon} />
                    </Button>
                  </div>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="client/src/components/DatePicker.tsx">
import React, { useState } from "react";
import { format } from "date-fns";
import { vi } from "date-fns/locale";
import { CalendarIcon, Clock } from "lucide-react";
import { Calendar } from "@/components/ui/calendar";
import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Input } from "@/components/ui/input";

// Types
interface DatePickerProps {
  date: Date | null;
  onDateChange: (date: Date | undefined) => void;
  placeholder?: string;
  disabled?: boolean;
}

interface DateTimePickerProps {
  date: Date | null;
  onDateChange: (date: Date | undefined) => void;
  placeholder?: string;
}

// Component DatePicker (dd/MM/yyyy)
export function DatePicker({
  date,
  onDateChange,
  placeholder = "Chọn ngày",
  disabled = false,
}: DatePickerProps) {
  const [open, setOpen] = useState(false);

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className="w-full justify-between text-left font-normal"
          disabled={disabled}
        >
          {date ? format(date, "dd/MM/yyyy", { locale: vi }) : placeholder}
          <CalendarIcon className="ml-2 h-4 w-4" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar
          mode="single"
          selected={date || undefined}
          onSelect={(selectedDate) => {
            onDateChange(selectedDate);
            setOpen(false);
          }}
          captionLayout="dropdown"
          fromYear={1900}
          toYear={2100}
        />
      </PopoverContent>
    </Popover>
  );
}

// Component DateTimePicker (hh:mm dd/MM/yyyy)
export function DateTimePicker({
  date,
  onDateChange,
  placeholder = "Chọn ngày và giờ",
}: DateTimePickerProps) {
  const [timeValue, setTimeValue] = useState<string>(
    date ? format(date, "HH:mm") : "00:00"
  );

  const handleDateSelect = (selectedDate: Date | undefined) => {
    if (selectedDate) {
      const [hours, minutes] = timeValue.split(":");
      selectedDate.setHours(parseInt(hours), parseInt(minutes));
      onDateChange(selectedDate);
    }
  };

  const handleTimeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTime = e.target.value;
    setTimeValue(newTime);

    if (date) {
      const [hours, minutes] = newTime.split(":");
      const newDate = new Date(date);
      newDate.setHours(parseInt(hours), parseInt(minutes));
      onDateChange(newDate);
    }
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className="w-full justify-between font-normal"
        >
          {date
            ? format(date, "HH:mm dd/MM/yyyy", { locale: vi })
            : placeholder}
          <Clock className="mr-2 h-4 w-4 " />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <div className="p-3 space-y-3">
          <div className="border-b pb-3">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Chọn giờ
            </label>
            <Input
              type="time"
              value={timeValue}
              onChange={handleTimeChange}
              className="w-full"
            />
          </div>
          <Calendar
            mode="single"
            selected={date || undefined}
            onSelect={handleDateSelect}
            initialFocus
            captionLayout="dropdown"
            fromYear={1900}
            toYear={2100}
          />
        </div>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="client/src/components/DatePickerRange.tsx">
'use client'

import { useState } from 'react'
import {
  format,
  startOfDay,
  endOfDay,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  subDays,
  subWeeks,
  getYear,
} from 'date-fns'
import { vi } from 'date-fns/locale'
import { ChevronDownIcon, CalendarIcon } from 'lucide-react'
import { iconStyles } from '@/lib/icon-theme'
import { type DateRange } from 'react-day-picker'
import { Button } from '@/components/ui/button'
import { Calendar } from '@/components/ui/calendar'
import { Label } from '@/components/ui/label'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'

interface DatePickerRangeProps {
  range?: DateRange | undefined
  onRangeChange?: (range: DateRange | undefined) => void
  placeholder?: string
  label?: string
  disabled?: boolean
  className?: string
}

export function DatePickerRange({
  range,
  onRangeChange,
  placeholder = 'Chọn khoảng thời gian',
  label,
  disabled = false,
  className = 'w-full max-w-xs space-y-2',
}: DatePickerRangeProps) {
  const [open, setOpen] = useState(false)
  const [quickSelectOpen, setQuickSelectOpen] = useState(false)

  const handleSelect = (selectedRange: DateRange | undefined) => {
    if (onRangeChange) {
      onRangeChange(selectedRange)
    }
  }

  const formatDateRange = (dateRange: DateRange | undefined): string => {
    if (!dateRange?.from) return placeholder
    if (dateRange.from && dateRange.to) {
      return `${format(dateRange.from, 'dd/MM/yyyy', { locale: vi })} - ${format(dateRange.to, 'dd/MM/yyyy', { locale: vi })}`
    }
    return format(dateRange.from, 'dd/MM/yyyy', { locale: vi })
  }

  // Functions to calculate date ranges
  const getTodayRange = (): DateRange => {
    const today = new Date()
    return {
      from: startOfDay(today),
      to: endOfDay(today),
    }
  }

  const getYesterdayRange = (): DateRange => {
    const yesterday = subDays(new Date(), 1)
    return {
      from: startOfDay(yesterday),
      to: endOfDay(yesterday),
    }
  }

  const getThisWeekRange = (): DateRange => {
    const now = new Date()
    return {
      from: startOfWeek(now, { locale: vi }),
      to: endOfWeek(now, { locale: vi }),
    }
  }

  const getLastWeekRange = (): DateRange => {
    const now = new Date()
    const lastWeek = subWeeks(now, 1)
    return {
      from: startOfWeek(lastWeek, { locale: vi }),
      to: endOfWeek(lastWeek, { locale: vi }),
    }
  }

  const getThisMonthRange = (): DateRange => {
    const now = new Date()
    return {
      from: startOfMonth(now),
      to: endOfMonth(now),
    }
  }

  const getMonthRange = (month: number): DateRange => {
    const now = new Date()
    const currentYear = getYear(now)
    const targetDate = new Date(currentYear, month - 1, 1)
    return {
      from: startOfMonth(targetDate),
      to: endOfMonth(targetDate),
    }
  }

  const getQuarterRange = (quarter: number): DateRange => {
    const now = new Date()
    const currentYear = getYear(now)
    const startMonth = (quarter - 1) * 3
    const endMonth = startMonth + 2
    return {
      from: startOfMonth(new Date(currentYear, startMonth, 1)),
      to: endOfMonth(new Date(currentYear, endMonth, 1)),
    }
  }

  const handleQuickSelect = (dateRange: DateRange) => {
    handleSelect(dateRange)
    setQuickSelectOpen(false)
  }

  const monthNames = [
    'Tháng 1',
    'Tháng 2',
    'Tháng 3',
    'Tháng 4',
    'Tháng 5',
    'Tháng 6',
    'Tháng 7',
    'Tháng 8',
    'Tháng 9',
    'Tháng 10',
    'Tháng 11',
    'Tháng 12',
  ]

  const quarterNames = ['Quý 1', 'Quý 2', 'Quý 3', 'Quý 4']

  return (
    <div className={className}>
      {label && (
        <Label htmlFor='date-range-picker' className='px-1'>
          {label}
        </Label>
      )}
      <div className='flex gap-2 items-center w-full min-w-0'>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <Button
              variant='outline'
              id='date-range-picker'
              className='flex-1 justify-between font-normal min-w-0'
              disabled={disabled}
            >
              <span className='truncate'>{formatDateRange(range)}</span>
              <ChevronDownIcon className={`${iconStyles.navigationIcon} opacity-50 shrink-0 ml-2`} />
            </Button>
          </PopoverTrigger>
          <PopoverContent className='w-auto overflow-hidden p-0' align='start'>
            <Calendar
              mode='range'
              selected={range}
              onSelect={handleSelect}
              captionLayout='dropdown'
              fromYear={1900}
              toYear={2100}
              locale={vi}
            />
          </PopoverContent>
        </Popover>
        <Popover open={quickSelectOpen} onOpenChange={setQuickSelectOpen}>
          <PopoverTrigger asChild>
            <Button
              variant='outline'
              disabled={disabled}
              className='shrink-0 whitespace-nowrap'
            >
              <CalendarIcon className={`${iconStyles.infoIcon} mr-2 shrink-0`} />
              <span>Chọn nhanh</span>
            </Button>
          </PopoverTrigger>
          <PopoverContent className='w-56 p-0' align='start'>
            <div className='py-1 max-h-96 overflow-y-auto'>
              {/* Quick options */}
              <button
                onClick={() => handleQuickSelect(getTodayRange())}
                className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
              >
                Hôm nay
              </button>
              <button
                onClick={() => handleQuickSelect(getYesterdayRange())}
                className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
              >
                Hôm qua
              </button>
              <button
                onClick={() => handleQuickSelect(getThisWeekRange())}
                className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
              >
                Tuần này
              </button>
              <button
                onClick={() => handleQuickSelect(getLastWeekRange())}
                className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
              >
                Tuần trước
              </button>
              <button
                onClick={() => handleQuickSelect(getThisMonthRange())}
                className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
              >
                Tháng này
              </button>

              <div className='border-t my-1' />

              {/* By Month */}
              {monthNames.map((month, index) => (
                <button
                  key={index}
                  onClick={() => handleQuickSelect(getMonthRange(index + 1))}
                  className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
                >
                  {month}
                </button>
              ))}

              <div className='border-t my-1' />

              {/* By Quarter */}
              {quarterNames.map((quarter, index) => (
                <button
                  key={index}
                  onClick={() => handleQuickSelect(getQuarterRange(index + 1))}
                  className='w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors'
                >
                  {quarter}
                </button>
              ))}
            </div>
          </PopoverContent>
        </Popover>
      </div>
    </div>
  )
}

export default DatePickerRange
</file>

<file path="client/src/components/DateTimePicker.tsx">
'use client'

import { useState } from 'react'

import { ChevronDownIcon } from 'lucide-react'

import { Button } from '@/components/ui/button'
import { Calendar } from '@/components/ui/calendar'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'

const DatePickerAndTimePickerDemo = () => {
  const [open, setOpen] = useState(false)
  const [date, setDate] = useState<Date | undefined>(undefined)

  return (
    <div className='flex gap-4'>
      <div className='flex flex-col gap-3'>
        <Label htmlFor='date-picker' className='px-1'>
          Date picker
        </Label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <Button variant='outline' id='date-picker' className='justify-between font-normal'>
              {date ? date.toLocaleDateString() : 'Pick a date'}
              <ChevronDownIcon />
            </Button>
          </PopoverTrigger>
          <PopoverContent className='w-auto overflow-hidden p-0' align='start'>
            <Calendar
              mode='single'
              selected={date}
              onSelect={date => {
                setDate(date)
                setOpen(false)
              }}
            />
          </PopoverContent>
        </Popover>
      </div>
      <div className='flex flex-col gap-3'>
        <Label htmlFor='time-picker' className='px-1'>
          Time input
        </Label>
        <Input
          type='time'
          id='time-picker'
          step='1'
          defaultValue='06:30:00'
          className='bg-background appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none'
        />
      </div>
    </div>
  )
}

export default DatePickerAndTimePickerDemo
</file>

<file path="client/src/components/dispatch/CapLenhXuatBenDialog.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import {
  Search
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import { dispatchService } from "@/services/dispatch.service"
import type { DispatchRecord } from "@/types"
import { formatVietnamDateTime } from "@/lib/vietnam-time"
import { useUIStore } from "@/store/ui.store"
import type { Shift } from "@/services/shift.service"

interface CapLenhXuatBenDialogProps {
  record: DispatchRecord
  onClose: () => void
  onSuccess?: () => void
}

export function CapLenhXuatBenDialog({
  record,
  onClose,
  onSuccess
}: CapLenhXuatBenDialogProps) {
  const [passengersDeparting, setPassengersDeparting] = useState("8")
  const [isLoading, setIsLoading] = useState(false)
  const [signAndTransmit, setSignAndTransmit] = useState(true)
  const [printRepresentation, setPrintRepresentation] = useState(false)
  const { currentShift } = useUIStore()

  // Helper function to get shift ID from currentShift string
  const getShiftIdFromCurrentShift = (): string | undefined => {
    if (!currentShift || currentShift === '<Trống>') {
      return undefined
    }

    const currentShifts = useUIStore.getState().shifts
    if (currentShifts.length === 0) {
      return undefined
    }

    const match = currentShift.match(/^(.+?)\s*\(/)
    if (!match) {
      return undefined
    }

    const shiftName = match[1].trim()
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName)
    return foundShift?.id
  }

  useEffect(() => {
    // Load shifts if not already loaded
    const { shifts: currentShifts, loadShifts } = useUIStore.getState()
    if (currentShifts.length === 0) {
      loadShifts()
    }
  }, [])

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()

    if (!passengersDeparting || parseInt(passengersDeparting) <= 0) {
      toast.warning("Vui lòng nhập số khách xuất bến hợp lệ")
      return
    }

    setIsLoading(true)
    try {
      const departureOrderShiftId = getShiftIdFromCurrentShift()
      await dispatchService.issueDepartureOrder(record.id, parseInt(passengersDeparting), departureOrderShiftId)
      toast.success("Cấp lệnh xuất bến thành công!")
      if (onSuccess) {
        onSuccess()
      }
      onClose()
    } catch (error) {
      console.error("Failed to issue departure order:", error)
      toast.error("Không thể cấp lệnh xuất bến. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Số khách xuất bến với nút tăng/giảm */}
      <div>
        <Label htmlFor="passengersDeparting" className="text-sm font-medium text-gray-700 mb-2 block">
          Số khách xuất bến
        </Label>
        <div className="flex items-center gap-2">
          <Input
            id="passengersDeparting"
            type="number"
            value={passengersDeparting}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setPassengersDeparting(e.target.value)}
            required
            className="flex-1 text-center"
            min="0"
          />
        </div>
      </div>

      {/* Layout 2 cột: Preview bên trái, Thông tin bên phải */}
      <div className="grid grid-cols-2 gap-4 min-h-[300px]">
        {/* Bên trái: Preview/Document */}
        <div className="border border-gray-200 rounded-lg p-4 flex flex-col items-center justify-center bg-gray-50">
          <div className="text-center text-gray-500">
            <Search className="h-12 w-12 mx-auto mb-2 text-gray-400" />
            <p className="text-sm">Không có bản thể hiện</p>
          </div>
        </div>

        {/* Bên phải: Thông tin */}
        <div className="border border-gray-200 rounded-lg p-4 bg-white">
          <h3 className="font-semibold text-gray-900 mb-3">Thông tin xe</h3>
          <div className="space-y-2 text-sm">
            <div>
              <span className="text-gray-600">Biển số xe:</span>
              <span className="ml-2 font-medium">{record.vehiclePlateNumber}</span>
            </div>
            {record.routeName && (
              <div>
                <span className="text-gray-600">Tuyến:</span>
                <span className="ml-2 font-medium">{record.routeName}</span>
              </div>
            )}
            {record.driverName && (
              <div>
                <span className="text-gray-600">Tài xế:</span>
                <span className="ml-2 font-medium">{record.driverName}</span>
              </div>
            )}
            {record.seatCount && (
              <div>
                <span className="text-gray-600">Số ghế đã cấp:</span>
                <span className="ml-2 font-medium">{record.seatCount}</span>
              </div>
            )}
            {record.plannedDepartureTime && (
              <div>
                <span className="text-gray-600">Giờ xuất bến kế hoạch:</span>
                <span className="ml-2 font-medium">
                  {formatVietnamDateTime(record.plannedDepartureTime)}
                </span>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Link xem QR code */}
      <div>
        <button
          type="button"
          onClick={() => {
            // TODO: Implement QR code list view
            toast.info("Chức năng xem chi tiết danh sách mã QR đang được phát triển")
          }}
          className="text-red-600 hover:text-red-700 text-sm underline"
        >
          Xem chi tiết danh sách mã QR
        </button>
      </div>

      {/* Checkboxes */}
      <div className="space-y-3 pt-4 border-t">
        <div className="flex items-center space-x-2">
          <Checkbox
            id="signAndTransmit"
            checked={signAndTransmit}
            onChange={(e) => setSignAndTransmit(e.target.checked)}
          />
          <Label htmlFor="signAndTransmit" className="cursor-pointer text-sm">
            Ký lệnh và truyền tải
          </Label>
        </div>
        <div className="flex items-center space-x-2">
          <Checkbox
            id="printRepresentation"
            checked={printRepresentation}
            onChange={(e) => setPrintRepresentation(e.target.checked)}
          />
          <Label htmlFor="printRepresentation" className="cursor-pointer text-sm">
            In bản thể hiện
          </Label>
        </div>
      </div>

      {/* Buttons */}
      <div className="flex justify-end gap-3 pt-4 border-t">
        <Button
          type="button"
          variant="outline"
          onClick={onClose}
          disabled={isLoading}
          className="text-blue-600 border-blue-600 hover:bg-blue-50"
        >
          HỦY
        </Button>
        <Button
          type="submit"
          disabled={isLoading}
          className="bg-blue-600 hover:bg-blue-700"
        >
          {isLoading ? "Đang xử lý..." : "XÁC NHẬN"}
        </Button>
      </div>
    </form>
  )
}
</file>

<file path="client/src/components/dispatch/ChoNhieuXeRaBenDialog.tsx">
import { useState, useMemo, useEffect } from "react";
import { toast } from "react-toastify";
import { Search } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { DateTimePicker } from "@/components/DatePicker";
import { dispatchService } from "@/services/dispatch.service";
import type { DispatchRecord } from "@/types";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { useUIStore } from "@/store/ui.store";
import type { Shift } from "@/services/shift.service";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface ChoNhieuXeRaBenDialogProps {
  records: DispatchRecord[];
  onClose: () => void;
  onSuccess?: () => void;
  open?: boolean;
}

export function ChoNhieuXeRaBenDialog({
  records,
  onClose,
  onSuccess,
  open = true,
}: ChoNhieuXeRaBenDialogProps) {
  const [exitTime, setExitTime] = useState<Date | undefined>(new Date());
  const [passengerCount, setPassengerCount] = useState(0);
  const [selectedRecords, setSelectedRecords] = useState<Set<string>>(new Set());
  const [isLoading, setIsLoading] = useState(false);
  const { currentShift } = useUIStore();

  // Helper function to get shift ID from currentShift string
  const getShiftIdFromCurrentShift = (): string | undefined => {
    if (!currentShift || currentShift === '<Trống>') {
      return undefined;
    }

    const currentShifts = useUIStore.getState().shifts;
    if (currentShifts.length === 0) {
      return undefined;
    }

    const match = currentShift.match(/^(.+?)\s*\(/);
    if (!match) {
      return undefined;
    }

    const shiftName = match[1].trim();
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName);
    return foundShift?.id;
  };

  useEffect(() => {
    // Load shifts if not already loaded
    const { shifts: currentShifts, loadShifts } = useUIStore.getState();
    if (currentShifts.length === 0) {
      loadShifts();
    }
  }, []);
  
  // Filter states for each column
  const [filters, setFilters] = useState({
    plateNumber: "",
    plateNumberOnEntry: "",
    entryTime: "",
    route: "",
    orderCode: "",
    plannedExitTime: "",
    driver: "",
  });

  // Filter records based on search criteria
  const filteredRecords = useMemo(() => {
    return records.filter((record) => {
      const plateNumber = record.vehiclePlateNumber?.toLowerCase() || "";
      const plateNumberOnEntry = record.vehiclePlateNumber?.toLowerCase() || "";
      const entryTimeStr = record.entryTime ? formatVietnamDateTime(record.entryTime) : "";
      const route = record.routeName?.toLowerCase() || "";
      const orderCode = record.transportOrderCode?.toLowerCase() || "";
      const plannedExitTime = record.plannedDepartureTime ? formatVietnamDateTime(record.plannedDepartureTime) : "";
      const driver = record.driverName?.toLowerCase() || "";

      return (
        plateNumber.includes(filters.plateNumber.toLowerCase()) &&
        plateNumberOnEntry.includes(filters.plateNumberOnEntry.toLowerCase()) &&
        entryTimeStr.toLowerCase().includes(filters.entryTime.toLowerCase()) &&
        route.includes(filters.route.toLowerCase()) &&
        orderCode.includes(filters.orderCode.toLowerCase()) &&
        plannedExitTime.toLowerCase().includes(filters.plannedExitTime.toLowerCase()) &&
        driver.includes(filters.driver.toLowerCase())
      );
    });
  }, [records, filters]);

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedRecords(new Set(filteredRecords.map((r) => r.id)));
    } else {
      setSelectedRecords(new Set());
    }
  };

  const handleSelectRecord = (recordId: string, checked: boolean) => {
    const newSelected = new Set(selectedRecords);
    if (checked) {
      newSelected.add(recordId);
    } else {
      newSelected.delete(recordId);
    }
    setSelectedRecords(newSelected);
  };

  const handleSubmit = async () => {
    if (!exitTime) {
      toast.error("Vui lòng chọn thời gian ra bến");
      return;
    }

    if (selectedRecords.size === 0) {
      toast.error("Vui lòng chọn ít nhất một xe");
      return;
    }

    setIsLoading(true);
    try {
      const exitShiftId = getShiftIdFromCurrentShift();
      const promises = Array.from(selectedRecords).map((recordId) =>
        dispatchService.recordExit(
          recordId,
          exitTime.toISOString(),
          passengerCount,
          exitShiftId
        )
      );

      await Promise.all(promises);
      toast.success(`Cho ${selectedRecords.size} xe ra bến thành công!`);
      if (onSuccess) onSuccess();
      onClose();
    } catch (error) {
      console.error("Failed to record exit:", error);
      toast.error("Không thể cho xe ra bến. Vui lòng thử lại sau.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!open) return null;

  const allSelected = filteredRecords.length > 0 && selectedRecords.size === filteredRecords.length;
  const someSelected = selectedRecords.size > 0 && selectedRecords.size < filteredRecords.length;

  return (
    <div className="space-y-6">
      {/* Input Fields */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <Label htmlFor="exitTime" className="text-sm font-medium text-gray-700 mb-1 block">
            Thời gian ra bến (*)
          </Label>
          <DateTimePicker
            date={exitTime || null}
            onDateChange={setExitTime}
          />
        </div>

        <div>
          <Label htmlFor="passengerCount" className="text-sm font-medium text-gray-700 mb-1 block">
            Số khách xuất bến
          </Label>
          <div className="flex items-center gap-2">      
            <Input
              id="passengerCount"
              type="number"
              value={passengerCount}
              onChange={(e) => setPassengerCount(parseInt(e.target.value) || 0)}
              className="flex-1 text-center"
              min="0"
            />
          </div>
        </div>
      </div>

      {/* Table */}
      <div className="border rounded-lg overflow-hidden">
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow className="bg-gray-100">
                <TableHead className="w-12">
                  <input
                    type="checkbox"
                    checked={allSelected}
                    ref={(input) => {
                      if (input) {
                        input.indeterminate = someSelected;
                      }
                    }}
                    onChange={(e) => handleSelectAll(e.target.checked)}
                    className="w-4 h-4"
                  />
                </TableHead>
                <TableHead className="min-w-[120px]">Biến số xe</TableHead>
                <TableHead className="min-w-[120px]">Biến số khi vào</TableHead>
                <TableHead className="min-w-[150px]">Thời gian vào bến</TableHead>
                <TableHead className="min-w-[150px]">Tuyến vận chuyển</TableHead>
                <TableHead className="min-w-[120px]">Mã lệnh</TableHead>
                <TableHead className="min-w-[150px]">Giờ xuất bến kế hoạch</TableHead>
                <TableHead className="min-w-[120px]">Lái xe</TableHead>
              </TableRow>
              {/* Filter Row */}
              <TableRow className="bg-gray-50">
                <TableHead></TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.plateNumber}
                      onChange={(e) => setFilters({ ...filters, plateNumber: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.plateNumberOnEntry}
                      onChange={(e) => setFilters({ ...filters, plateNumberOnEntry: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.entryTime}
                      onChange={(e) => setFilters({ ...filters, entryTime: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.route}
                      onChange={(e) => setFilters({ ...filters, route: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.orderCode}
                      onChange={(e) => setFilters({ ...filters, orderCode: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.plannedExitTime}
                      onChange={(e) => setFilters({ ...filters, plannedExitTime: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
                <TableHead>
                  <div className="relative">
                    <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      value={filters.driver}
                      onChange={(e) => setFilters({ ...filters, driver: e.target.value })}
                      className="pl-8 h-8 text-sm"
                    />
                  </div>
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredRecords.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={8} className="text-center text-gray-500 py-8">
                    Không có dữ liệu!
                  </TableCell>
                </TableRow>
              ) : (
                filteredRecords.map((record) => (
                  <TableRow key={record.id}>
                    <TableCell>
                      <input
                        type="checkbox"
                        checked={selectedRecords.has(record.id)}
                        onChange={(e) => handleSelectRecord(record.id, e.target.checked)}
                        className="w-4 h-4"
                      />
                    </TableCell>
                    <TableCell>{record.vehiclePlateNumber || "-"}</TableCell>
                    <TableCell>{record.vehiclePlateNumber || "-"}</TableCell>
                    <TableCell>
                      {record.entryTime ? formatVietnamDateTime(record.entryTime) : "-"}
                    </TableCell>
                    <TableCell>{record.routeName || "-"}</TableCell>
                    <TableCell>{record.transportOrderCode || "-"}</TableCell>
                    <TableCell>
                      {record.plannedDepartureTime ? formatVietnamDateTime(record.plannedDepartureTime) : "-"}
                    </TableCell>
                    <TableCell>{record.driverName || "-"}</TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      </div>

      {/* Footer Buttons */}
      <div className="flex justify-between items-center pt-4 border-t">
        <Button
          type="button"
          variant="ghost"
          onClick={onClose}
          className="text-red-600 hover:bg-red-50 hover:text-red-700"
        >
          HỦY
        </Button>
        <Button
          type="button"
          onClick={handleSubmit}
          disabled={isLoading || selectedRecords.size === 0}
          className="bg-blue-600 hover:bg-blue-700 text-white"
        >
          {isLoading
            ? "Đang xử lý..."
            : `XÁC NHẬN CHO ${selectedRecords.size > 0 ? selectedRecords.size : ""} XE ĐÃ CHỌN RA BẾN`}
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/ChoXeRaBenDialog.tsx">
import { useState, useEffect } from "react";
import { toast } from "react-toastify";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { DateTimePicker } from "@/components/DatePicker";
import { dispatchService } from "@/services/dispatch.service";
import type { DispatchRecord } from "@/types";
import { useUIStore } from "@/store/ui.store";
import type { Shift } from "@/services/shift.service";

interface ChoXeRaBenDialogProps {
  record: DispatchRecord;
  onClose: () => void;
  onSuccess?: () => void;
}

export function ChoXeRaBenDialog({
  record,
  onClose,
  onSuccess,
}: ChoXeRaBenDialogProps) {
  const [exitTime, setExitTime] = useState<Date | undefined>(new Date());
  const [passengerCount, setPassengerCount] = useState(
    record.passengersDeparting?.toString() || "0"
  );
  const [isLoading, setIsLoading] = useState(false);
  const { currentShift } = useUIStore();

  // Helper function to get shift ID from currentShift string
  const getShiftIdFromCurrentShift = (): string | undefined => {
    if (!currentShift || currentShift === '<Trống>') {
      return undefined;
    }

    const currentShifts = useUIStore.getState().shifts;
    if (currentShifts.length === 0) {
      return undefined;
    }

    const match = currentShift.match(/^(.+?)\s*\(/);
    if (!match) {
      return undefined;
    }

    const shiftName = match[1].trim();
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName);
    return foundShift?.id;
  };

  useEffect(() => {
    // Load shifts if not already loaded
    const { shifts: currentShifts, loadShifts } = useUIStore.getState();
    if (currentShifts.length === 0) {
      loadShifts();
    }
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!exitTime) {
      toast.error("Vui lòng chọn thời gian ra bến");
      return;
    }

    setIsLoading(true);
    try {
      const exitShiftId = getShiftIdFromCurrentShift();
      await dispatchService.recordExit(
        record.id,
        exitTime.toISOString(),
        parseInt(passengerCount),
        exitShiftId
      );
      toast.success("Cho xe ra bến thành công!");
      if (onSuccess) onSuccess();
      onClose();
    } catch (error) {
      console.error("Failed to record exit:", error);
      toast.error("Không thể cho xe ra bến. Vui lòng thử lại sau.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="space-y-4">
        <div>
          <Label className="text-sm font-medium text-gray-700 mb-1 block">
            Biển kiểm soát
          </Label>
          <Input
            value={record.vehiclePlateNumber}
            readOnly
            className="bg-gray-50 text-gray-500"
          />
        </div>

        <div>
          <Label
            htmlFor="exitTime"
            className="text-sm font-medium text-gray-700 mb-1 block"
          >
            Thời gian ra bến (*)
          </Label>
          <div className="relative">
            <DateTimePicker
              date={exitTime || null}
              onDateChange={setExitTime}
            />
          </div>
        </div>

        <div>
          <Label
            htmlFor="passengerCount"
            className="text-sm font-medium text-gray-700 mb-1 block"
          >
            Số khách xuất bến
          </Label>
          <Input
            id="passengerCount"
            type="number"
            value={passengerCount}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setPassengerCount(e.target.value)
            }
            required
            className="flex-1"
            min="0"
          />
        </div>
      </div>

      <div className="flex justify-end gap-3 pt-4 border-t">
        <Button
          type="button"
          variant="ghost"
          onClick={onClose}
          className="text-blue-600 hover:bg-blue-50 hover:text-blue-700"
        >
          HỦY
        </Button>
        <Button
          type="submit"
          disabled={isLoading}
          className="bg-blue-600 hover:bg-blue-700"
        >
          {isLoading ? "Đang xử lý..." : "XÁC NHẬN"}
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="client/src/components/dispatch/common/ActionButton.tsx">
import { cn } from "@/lib/utils";

interface ActionButtonProps {
  icon: React.ElementType;
  onClick: (e: React.MouseEvent) => void;
  title: string;
  variant?: 'default' | 'success' | 'warning' | 'danger' | 'info';
}

const variants = {
  default: 'bg-slate-100 hover:bg-slate-200 text-slate-600 hover:text-slate-800',
  success: 'bg-emerald-100 hover:bg-emerald-200 text-emerald-600 hover:text-emerald-700 hover:shadow-emerald-200',
  warning: 'bg-amber-100 hover:bg-amber-200 text-amber-600 hover:text-amber-700 hover:shadow-amber-200',
  danger: 'bg-rose-100 hover:bg-rose-200 text-rose-600 hover:text-rose-700 hover:shadow-rose-200',
  info: 'bg-sky-100 hover:bg-sky-200 text-sky-600 hover:text-sky-700 hover:shadow-sky-200',
};

export function ActionButton({ icon: Icon, onClick, title, variant = 'default' }: ActionButtonProps) {
  return (
    <button
      onClick={onClick}
      className={cn(
        "p-2.5 rounded-xl transition-all duration-200 hover:shadow-lg hover:scale-105 active:scale-95",
        variants[variant]
      )}
      title={title}
    >
      <Icon className="h-4 w-4" />
    </button>
  );
}
</file>

<file path="client/src/components/dispatch/common/column-config.ts">
import { FileCheck, Radio, Banknote, ArrowRight } from "lucide-react";

export type DisplayStatus = "in-station" | "permit-issued" | "paid" | "departed";

export const columnConfig: Record<DisplayStatus, {
  title: string;
  shortTitle: string;
  gradient: string;
  glassGradient: string;
  accentColor: string;
  iconBg: string;
  iconColor: string;
  icon: React.ElementType;
  borderColor: string;
  headerGradient: string;
  glowColor: string;
  dotColor: string;
}> = {
  "in-station": {
    title: "Xe trong bến",
    shortTitle: "Trong bến",
    gradient: "from-sky-500/10 via-cyan-500/5 to-transparent",
    glassGradient: "from-sky-500 via-cyan-500 to-blue-600",
    accentColor: "text-sky-700",
    iconBg: "bg-gradient-to-br from-sky-500 to-cyan-600",
    iconColor: "text-white",
    icon: Radio,
    borderColor: "border-sky-200/50",
    headerGradient: "from-sky-600 via-sky-500 to-cyan-500",
    glowColor: "shadow-sky-500/20",
    dotColor: "bg-sky-500"
  },
  "permit-issued": {
    title: "Đã cấp nốt",
    shortTitle: "Cấp nốt",
    gradient: "from-amber-500/10 via-orange-500/5 to-transparent",
    glassGradient: "from-amber-500 via-orange-500 to-yellow-600",
    accentColor: "text-amber-700",
    iconBg: "bg-gradient-to-br from-amber-500 to-orange-600",
    iconColor: "text-white",
    icon: FileCheck,
    borderColor: "border-amber-200/50",
    headerGradient: "from-amber-600 via-amber-500 to-orange-500",
    glowColor: "shadow-amber-500/20",
    dotColor: "bg-amber-500"
  },
  "paid": {
    title: "Đã thanh toán",
    shortTitle: "Thanh toán",
    gradient: "from-emerald-500/10 via-teal-500/5 to-transparent",
    glassGradient: "from-emerald-500 via-teal-500 to-green-600",
    accentColor: "text-emerald-700",
    iconBg: "bg-gradient-to-br from-emerald-500 to-teal-600",
    iconColor: "text-white",
    icon: Banknote,
    borderColor: "border-emerald-200/50",
    headerGradient: "from-emerald-600 via-emerald-500 to-teal-500",
    glowColor: "shadow-emerald-500/20",
    dotColor: "bg-emerald-500"
  },
  "departed": {
    title: "Sẵn sàng xuất",
    shortTitle: "Xuất bến",
    gradient: "from-violet-500/10 via-purple-500/5 to-transparent",
    glassGradient: "from-violet-500 via-purple-500 to-indigo-600",
    accentColor: "text-violet-700",
    iconBg: "bg-gradient-to-br from-violet-500 to-purple-600",
    iconColor: "text-white",
    icon: ArrowRight,
    borderColor: "border-violet-200/50",
    headerGradient: "from-violet-600 via-violet-500 to-purple-500",
    glowColor: "shadow-violet-500/20",
    dotColor: "bg-violet-500"
  }
};
</file>

<file path="client/src/components/dispatch/common/FloatingDotsEmpty.tsx">
import { Bus } from "lucide-react";

interface FloatingDotsEmptyProps {
  message: string;
}

export function FloatingDotsEmpty({ message }: FloatingDotsEmptyProps) {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <div className="relative w-24 h-24">
        {/* Center icon */}
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="w-16 h-16 rounded-2xl bg-slate-100 flex items-center justify-center">
            <Bus className="w-8 h-8 text-slate-300" />
          </div>
        </div>
        {/* Floating dots */}
        <div className="absolute top-0 left-1/2 -translate-x-1/2 w-3 h-3 rounded-full bg-blue-300 animate-bounce" style={{ animationDelay: '0s', animationDuration: '1.5s' }} />
        <div className="absolute bottom-2 left-2 w-2 h-2 rounded-full bg-emerald-300 animate-bounce" style={{ animationDelay: '0.2s', animationDuration: '1.5s' }} />
        <div className="absolute bottom-2 right-2 w-2 h-2 rounded-full bg-amber-300 animate-bounce" style={{ animationDelay: '0.4s', animationDuration: '1.5s' }} />
        <div className="absolute top-1/2 -left-1 w-2 h-2 rounded-full bg-violet-300 animate-bounce" style={{ animationDelay: '0.6s', animationDuration: '1.5s' }} />
        <div className="absolute top-1/2 -right-1 w-2 h-2 rounded-full bg-rose-300 animate-bounce" style={{ animationDelay: '0.8s', animationDuration: '1.5s' }} />
      </div>
      <p className="text-slate-400 font-medium mt-4">{message}</p>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/common/index.ts">
export { columnConfig, type DisplayStatus } from "./column-config";
export { RadarPulse } from "./RadarPulse";
export { StatusRibbon } from "./StatusRibbon";
export { ActionButton } from "./ActionButton";
export { FloatingDotsEmpty } from "./FloatingDotsEmpty";
export { VehicleCard } from "./VehicleCard";
</file>

<file path="client/src/components/dispatch/common/RadarPulse.tsx">
import { cn } from "@/lib/utils";

interface RadarPulseProps {
  count: number;
  color: string;
}

export function RadarPulse({ count, color }: RadarPulseProps) {
  const colors: Record<string, string> = {
    sky: "bg-sky-500",
    amber: "bg-amber-500",
    emerald: "bg-emerald-500",
    violet: "bg-violet-500",
  };

  return (
    <div className="flex items-center gap-2.5 px-3 py-1.5 rounded-full bg-white/90 backdrop-blur-sm shadow-lg border border-white/50">
      <div className="relative">
        <span className={cn(
          "absolute inline-flex h-3 w-3 rounded-full opacity-75 animate-ping",
          colors[color]
        )} />
        <span className={cn(
          "relative inline-flex h-3 w-3 rounded-full",
          colors[color]
        )} />
      </div>
      <span className="text-sm font-black text-slate-800 tabular-nums">{count}</span>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/common/StatusRibbon.tsx">
import { CheckCircle2, XCircle, Users, AlertTriangle } from "lucide-react";
import { cn } from "@/lib/utils";

type StatusType = 'eligible' | 'ineligible' | 'returned' | 'irregular';

interface StatusRibbonProps {
  type: StatusType;
}

const configs = {
  eligible: {
    bg: 'bg-gradient-to-r from-emerald-500 to-teal-500',
    text: 'ĐỦ ĐK',
    icon: CheckCircle2
  },
  ineligible: {
    bg: 'bg-gradient-to-r from-rose-500 to-red-500',
    text: 'THIẾU',
    icon: XCircle
  },
  returned: {
    bg: 'bg-gradient-to-r from-sky-500 to-blue-500',
    text: 'TRẢ KHÁCH',
    icon: Users
  },
  irregular: {
    bg: 'bg-gradient-to-r from-amber-500 to-orange-500',
    text: 'VÃNG LAI',
    icon: AlertTriangle
  },
};

export function StatusRibbon({ type }: StatusRibbonProps) {
  const config = configs[type];
  const Icon = config.icon;

  return (
    <div className={cn(
      "absolute -top-1 -right-1 flex items-center gap-1 px-2 py-0.5 rounded-full text-white text-[10px] font-bold uppercase tracking-wider shadow-lg",
      config.bg
    )}>
      <Icon className="w-3 h-3" />
      <span>{config.text}</span>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/DocumentHistoryDialog.tsx">
import { useState, useEffect } from "react"
import { format } from "date-fns"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { vehicleService } from "@/services/vehicle.service"
import { History, Clock, User, FileText } from "lucide-react"
import { formatVietnamDateTime } from "@/lib/vietnam-time"

interface DocumentHistoryDialogProps {
  vehicleId: string
  open: boolean
  onClose: () => void
}

interface AuditLog {
  id: string
  userId: string
  userName: string
  action: string
  recordId: string
  oldValues: any
  newValues: any
  createdAt: string
}

const getDocumentTypeLabel = (docType: string): string => {
  const labels: Record<string, string> = {
    registration: 'Đăng ký xe',
    inspection: 'Đăng kiểm',
    insurance: 'Bảo hiểm',
    operation_permit: 'Phù hiệu',
    emblem: 'Biển hiệu',
  }
  return labels[docType] || docType
}

const getActionLabel = (action: string): string => {
  const labels: Record<string, string> = {
    CREATE_DOCUMENT: 'Tạo mới giấy tờ',
    UPDATE_DOCUMENT: 'Cập nhật giấy tờ',
    UPDATE_DOCUMENT_EXPIRY: 'Cập nhật hạn giấy tờ',
  }
  return labels[action] || action
}

export function DocumentHistoryDialog({
  vehicleId,
  open,
  onClose,
}: DocumentHistoryDialogProps) {
  const [logs, setLogs] = useState<AuditLog[]>([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (open && vehicleId) {
      loadAuditLogs()
    }
  }, [open, vehicleId])

  const loadAuditLogs = async () => {
    setIsLoading(true)
    try {
      const data = await vehicleService.getDocumentAuditLogs(vehicleId)
      setLogs(data)
    } catch (error) {
      console.error("Failed to load audit logs:", error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-7xl w-[95vw] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <History className="h-5 w-5" />
            Lịch sử thay đổi giấy tờ xe
          </DialogTitle>
        </DialogHeader>

        <div className="border border-gray-200 rounded-lg overflow-hidden">
          {isLoading ? (
            <div className="text-center py-8 text-gray-500">
              Đang tải...
            </div>
          ) : logs.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              Chưa có lịch sử thay đổi
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-gray-50 border-b">
                  <tr>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Thời gian
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Loại giấy tờ
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Hành động
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Người thực hiện
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Số giấy tờ
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Ngày cấp
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Hết hạn
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Biển số
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {logs.map((log) => {
                    const values = log.newValues || log.oldValues || {};
                    const isUpdate = log.oldValues && log.newValues;
                    
                    return (
                      <tr key={log.id} className="hover:bg-gray-50">
                        <td className="px-4 py-3 text-sm text-gray-900">
                          <div className="flex items-center gap-1">
                            <Clock className="h-3 w-3 text-gray-400" />
                            {formatVietnamDateTime(log.createdAt, "dd/MM/yyyy HH:mm")}
                          </div>
                        </td>
                        <td className="px-4 py-3 text-sm">
                          <div className="flex items-center gap-2">
                            <FileText className="h-4 w-4 text-blue-600" />
                            <span className="font-medium">
                              {values.document_type
                                ? getDocumentTypeLabel(values.document_type)
                                : 'Giấy tờ'}
                            </span>
                          </div>
                        </td>
                        <td className="px-4 py-3 text-sm">
                          <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${
                            log.action === 'CREATE_DOCUMENT' 
                              ? 'bg-green-100 text-green-800'
                              : 'bg-blue-100 text-blue-800'
                          }`}>
                            {getActionLabel(log.action)}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-sm">
                          <div className="flex items-center gap-1">
                            <User className="h-3 w-3 text-gray-400" />
                            <span className="font-medium">{log.userName}</span>
                          </div>
                        </td>
                        <td className="px-4 py-3 text-sm">
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.document_number && (
                                <div className="text-gray-500 line-through">
                                  {log.oldValues.document_number}
                                </div>
                              )}
                              {log.newValues?.document_number && (
                                <div className="text-green-700 font-medium">
                                  {log.newValues.document_number}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span className="font-medium">
                              {values.document_number || '-'}
                            </span>
                          )}
                        </td>
                        <td className="px-4 py-3 text-sm">
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.issue_date && (
                                <div className="text-gray-500 line-through">
                                  {format(new Date(log.oldValues.issue_date), "dd/MM/yyyy")}
                                </div>
                              )}
                              {log.newValues?.issue_date && (
                                <div className="text-green-700 font-medium">
                                  {format(new Date(log.newValues.issue_date), "dd/MM/yyyy")}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span className="font-medium">
                              {values.issue_date 
                                ? format(new Date(values.issue_date), "dd/MM/yyyy")
                                : '-'}
                            </span>
                          )}
                        </td>
                        <td className="px-4 py-3 text-sm">
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.expiry_date && (
                                <div className="text-gray-500 line-through">
                                  {format(new Date(log.oldValues.expiry_date), "dd/MM/yyyy")}
                                </div>
                              )}
                              {log.newValues?.expiry_date && (
                                <div className="text-green-700 font-medium">
                                  {format(new Date(log.newValues.expiry_date), "dd/MM/yyyy")}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span className="font-medium">
                              {values.expiry_date 
                                ? format(new Date(values.expiry_date), "dd/MM/yyyy")
                                : '-'}
                            </span>
                          )}
                        </td>
                        <td className="px-4 py-3 text-sm">
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.vehicle_plate && (
                                <div className="text-gray-500 line-through">
                                  {log.oldValues.vehicle_plate}
                                </div>
                              )}
                              {log.newValues?.vehicle_plate && (
                                <div className="text-green-700 font-medium">
                                  {log.newValues.vehicle_plate}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span className="font-medium">
                              {values.vehicle_plate || '-'}
                            </span>
                          )}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/dispatch/entry/FormHeader.tsx">
import { memo } from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";

interface FormHeaderProps {
  isEditMode: boolean;
  isLoading: boolean;
  performPermitAfterEntry: boolean;
  onPerformPermitChange: (checked: boolean) => void;
  onClose: () => void;
}

export const FormHeader = memo(function FormHeader({
  isEditMode,
  isLoading,
  performPermitAfterEntry,
  onPerformPermitChange,
  onClose,
}: FormHeaderProps) {
  return (
    <div className="flex items-center justify-between pb-5 border-b">
      <div className="flex items-center gap-8">
        <h1 className="text-2xl font-bold text-gray-900">
          {isEditMode ? "Sửa thông tin điều độ" : "Cho xe vào bến"}
        </h1>
        {!isEditMode && (
          <div className="flex items-center space-x-2">
            <Checkbox
              id="performPermitAfterEntry"
              checked={performPermitAfterEntry}
              onChange={(e) => onPerformPermitChange(e.target.checked)}
            />
            <Label htmlFor="performPermitAfterEntry" className="cursor-pointer text-sm font-medium">
              Thực hiện Cấp phép lên nốt sau khi Cho xe vào bến
            </Label>
          </div>
        )}
      </div>
      <div className="flex items-center gap-3">
        <Button
          type="button"
          variant="outline"
          onClick={onClose}
          disabled={isLoading}
          className="text-blue-600 border-blue-600 hover:bg-blue-50 px-6"
        >
          HỦY
        </Button>
        <Button
          type="submit"
          disabled={isLoading}
          className="bg-blue-600 hover:bg-blue-700 px-6"
        >
          {isLoading ? "Đang xử lý..." : "XÁC NHẬN"}
        </Button>
      </div>
    </div>
  );
});
</file>

<file path="client/src/components/dispatch/entry/index.ts">
export { FormHeader } from "./FormHeader";
export { VehicleEntryForm } from "./VehicleEntryForm";
export { TransportOrderPreview } from "./TransportOrderPreview";
</file>

<file path="client/src/components/dispatch/entry/TransportOrderPreview.tsx">
import { Search } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";

interface TransportOrderPreviewProps {
  signAndTransmit: boolean;
  printDisplay: boolean;
  transportOrderDisplay: string | null;
  onSignAndTransmitChange: (checked: boolean) => void;
  onPrintDisplayChange: (checked: boolean) => void;
}

export function TransportOrderPreview({
  signAndTransmit,
  printDisplay,
  transportOrderDisplay,
  onSignAndTransmitChange,
  onPrintDisplayChange,
}: TransportOrderPreviewProps) {
  return (
    <div className="space-y-5">
      <div className="flex items-center gap-6 pb-3 border-b">
        <div className="flex items-center space-x-2">
          <Checkbox
            id="signAndTransmit"
            checked={signAndTransmit}
            onChange={(e) => onSignAndTransmitChange(e.target.checked)}
          />
          <Label htmlFor="signAndTransmit" className="cursor-pointer text-sm font-medium">
            Ký lệnh và truyền tải
          </Label>
        </div>
        <div className="flex items-center space-x-2">
          <Checkbox
            id="printDisplay"
            checked={printDisplay}
            onChange={(e) => onPrintDisplayChange(e.target.checked)}
          />
          <Label htmlFor="printDisplay" className="cursor-pointer text-sm font-medium">
            In bản thể hiện
          </Label>
        </div>
      </div>

      <div className="border border-gray-200 rounded-lg bg-gray-50 min-h-[500px] flex items-center justify-center relative">
        {transportOrderDisplay ? (
          <div className="p-6 text-sm text-gray-700 w-full h-full">
            {transportOrderDisplay}
          </div>
        ) : (
          <div className="text-center text-gray-500">
            <p className="text-base">Không có bản thể hiện</p>
          </div>
        )}
        <div className="absolute bottom-6 left-1/2 -translate-x-1/2">
          <Search className="h-6 w-6 text-gray-400" />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/entry/VehicleEntryForm.tsx">
import { RefreshCw } from "lucide-react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Select } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Autocomplete } from "@/components/ui/autocomplete";
import { DateTimePicker } from "@/components/DatePicker";
import type { Route, Schedule } from "@/types";

interface VehicleEntryFormProps {
  vehicleOptions: Array<{ id: string; plateNumber: string }>;
  vehicleId: string;
  entryDateTime: Date | undefined;
  confirmPassengerDrop: boolean;
  routeId: string;
  scheduleId: string;
  passengersArrived: string;
  transportOrderCode: string;
  routes: Route[];
  schedules: Schedule[];
  onVehicleSelect: (id: string) => void;
  onEntryDateTimeChange: (date: Date | undefined) => void;
  onConfirmPassengerDropChange: (checked: boolean) => void;
  onRouteChange: (routeId: string) => void;
  onScheduleChange: (scheduleId: string) => void;
  onPassengersArrivedChange: (value: string) => void;
  onTransportOrderCodeChange: (value: string) => void;
  onRefreshTransportOrder: () => void;
}

export function VehicleEntryForm({
  vehicleOptions,
  vehicleId,
  entryDateTime,
  confirmPassengerDrop,
  routeId,
  scheduleId,
  passengersArrived,
  transportOrderCode,
  routes,
  schedules,
  onVehicleSelect,
  onEntryDateTimeChange,
  onConfirmPassengerDropChange,
  onRouteChange,
  onScheduleChange,
  onPassengersArrivedChange,
  onTransportOrderCodeChange,
  onRefreshTransportOrder,
}: VehicleEntryFormProps) {
  return (
    <div className="space-y-8">
      {/* Thông tin xe vào bến */}
      <div className="space-y-5">
        <h3 className="text-lg font-semibold text-gray-900 pb-2 border-b">
          Thông tin xe vào bến
        </h3>

        <div>
          <Label htmlFor="vehicle" className="text-sm font-medium mb-2 block">
            Biển kiểm soát <span className="text-red-500">(*)</span>
          </Label>
          <Autocomplete
            value={vehicleId}
            onChange={onVehicleSelect}
            options={vehicleOptions.map((v) => ({
              value: v.id,
              label: v.plateNumber,
            }))}
            placeholder="Nhập biển kiểm soát để tìm kiếm..."
            className="w-full"
          />
        </div>

        <div>
          <Label htmlFor="entryTime" className="text-sm font-medium mb-2 block">
            Thời gian vào <span className="text-red-500">(*)</span>
          </Label>
          <div className="relative mt-1">
            <DateTimePicker
              date={entryDateTime || null}
              onDateChange={onEntryDateTimeChange}
            />
          </div>
        </div>
      </div>

      {/* Thông tin xe trả khách */}
      <div className="space-y-5 pt-6 border-t">
        <h3 className="text-lg font-semibold text-gray-900 pb-2 border-b">
          Thông tin xe trả khách
        </h3>

        <div className="flex items-center space-x-2">
          <Checkbox
            id="confirmPassengerDrop"
            checked={confirmPassengerDrop}
            onChange={(e) => onConfirmPassengerDropChange(e.target.checked)}
          />
          <Label htmlFor="confirmPassengerDrop" className="cursor-pointer">
            Xác nhận trả khách
          </Label>
        </div>

        {confirmPassengerDrop && (
          <>
            <div>
              <Label htmlFor="route" className="text-sm font-medium mb-2 block">
                Tuyến vận chuyển <span className="text-red-500">(*)</span>
              </Label>
              <Select
                id="route"
                value={routeId}
                onChange={(e) => onRouteChange(e.target.value)}
                className="mt-1 h-11"
                required
              >
                <option value="">Chọn tuyến vận chuyển</option>
                {routes.map((r) => (
                  <option key={r.id} value={r.id}>
                    {r.routeName} ({r.routeCode})
                  </option>
                ))}
              </Select>
            </div>

            <div>
              <Label htmlFor="schedule" className="text-sm font-medium mb-2 block">
                Biểu đồ giờ
              </Label>
              <Select
                id="schedule"
                value={scheduleId}
                onChange={(e) => onScheduleChange(e.target.value)}
                className="mt-1 h-11"
              >
                <option value="">Chọn biểu đồ giờ</option>
                {schedules.map((s) => (
                  <option key={s.id} value={s.id}>
                    {s.scheduleCode} - {s.departureTime}
                  </option>
                ))}
              </Select>
            </div>

            <div>
              <Label htmlFor="passengersArrived" className="text-sm font-medium mb-2 block">
                Số khách đến bến <span className="text-red-500">(*)</span>
              </Label>
              <div className="flex gap-2 mt-1">
                <Input
                  id="passengersArrived"
                  type="number"
                  value={passengersArrived}
                  onChange={(e) => onPassengersArrivedChange(e.target.value)}
                  className="flex-1 h-11"
                  min="0"
                  required
                />
              </div>
            </div>

            <div>
              <Label htmlFor="transportOrderCode" className="text-sm font-medium mb-2 block">
                Lệnh vận chuyển <span className="text-red-500">(*)</span>
              </Label>
              <div className="relative mt-1">
                <Input
                  id="transportOrderCode"
                  value={transportOrderCode}
                  onChange={(e) => onTransportOrderCodeChange(e.target.value)}
                  className="pr-10 h-11"
                  placeholder="Nhập mã lệnh vận chuyển"
                  required
                />
                <button
                  type="button"
                  onClick={onRefreshTransportOrder}
                  className="absolute right-3 top-1/2 -translate-y-1/2 p-1.5 hover:bg-gray-100 rounded transition-colors"
                  title="Làm mới"
                >
                  <RefreshCw className="h-4 w-4 text-gray-400" />
                </button>
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/icons/BusEnterIcon.tsx">
import { Bus, ArrowRight } from "lucide-react";

interface IconProps {
  className?: string;
}

/**
 * Bus Enter Icon - Used for "Cho xe ra bến" (Vehicle exit)
 * Composite icon: Bus with ArrowRight badge
 */
export function BusEnterIcon({ className = "" }: IconProps) {
  return (
    <div className={`relative inline-flex h-5 w-5 ${className}`}>
      <Bus className="h-5 w-5" />
      <div className="absolute -bottom-0.5 -right-0.5 bg-white rounded-full p-0.5">
        <ArrowRight className="h-2.5 w-2.5" strokeWidth={2.5} />
      </div>
    </div>
  );
}

export default BusEnterIcon;
</file>

<file path="client/src/components/dispatch/icons/BusPlusIcon.tsx">
import { CarFront, Plus } from "lucide-react";

interface IconProps {
  className?: string;
}

/**
 * Bus Plus Icon - Used for "Xe tăng cường" (Augmented vehicle)
 * Composite icon: CarFront with Plus badge
 */
export function BusPlusIcon({ className = "" }: IconProps) {
  return (
    <div className={`relative inline-flex h-5 w-5 ${className}`}>
      <CarFront className="h-5 w-5" />
      <div className="absolute -bottom-0.5 -right-0.5 bg-white rounded-full p-0.5">
        <Plus className="h-2.5 w-2.5" strokeWidth={3} />
      </div>
    </div>
  );
}

export default BusPlusIcon;
</file>

<file path="client/src/components/dispatch/icons/FileExclamationIcon.tsx">
interface IconProps {
  className?: string;
}

/**
 * File Exclamation Icon - Used for "Xe chưa cấp nốt" (Vehicle without permit)
 * Custom SVG icon: File with exclamation mark
 */
export function FileExclamationIcon({ className = "" }: IconProps) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <path d="M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z" />
      <path d="M12 9v4" />
      <path d="M12 17h.01" />
    </svg>
  );
}

export default FileExclamationIcon;
</file>

<file path="client/src/components/dispatch/icons/index.ts">
/**
 * Dispatch Icon Components
 * Custom icons for dispatch workflow visualization
 */

export { BusPlusIcon } from './BusPlusIcon';
export { FileExclamationIcon } from './FileExclamationIcon';
export { BusEnterIcon } from './BusEnterIcon';
</file>

<file path="client/src/components/dispatch/LyDoKhongDuDieuKienDialog.tsx">
import { useState } from "react"
import { toast } from "react-toastify"
import { Search, ChevronDown, ChevronUp } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

interface RejectionReason {
  id: string
  description: string
  category: string
  categoryName: string
}

interface LyDoKhongDuDieuKienDialogProps {
  open: boolean
  onClose: () => void
  onConfirm: (selectedReasons: string[], options: {
    createOrder: boolean
    signAndTransmit: boolean
    printDisplay: boolean
  }) => void
}

const rejectionReasons: RejectionReason[] = [
  {
    id: "driver_license_insufficient",
    description: "Không có hoặc có nhưng không đủ số lượng giấy phép lái xe so với số lái xe ghi trên lệnh vận chuyển",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  },
  {
    id: "driver_license_expired",
    description: "Giấy phép lái xe đã hết hạn hoặc sử dụng giấy phép lái xe giả",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  },
  {
    id: "driver_license_class_mismatch",
    description: "Hạng giấy phép lái xe không phù hợp với các loại xe được phép điều khiển",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  },
  {
    id: "driver_info_mismatch",
    description: "Thông tin của lái xe không đúng với thông tin được ghi trên lệnh vận chuyển",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  },
  {
    id: "driver_alcohol",
    description: "Lái xe sử dụng rượu bia",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  },
  {
    id: "driver_drugs",
    description: "Lái xe sử dụng chất ma tuý",
    category: "driver",
    categoryName: "Các điều kiện không được phép xuất bến liên quan đến lái xe"
  }
]

export function LyDoKhongDuDieuKienDialog({
  open,
  onClose,
  onConfirm
}: LyDoKhongDuDieuKienDialogProps) {
  const [searchQuery, setSearchQuery] = useState("")
  const [selectedReasons, setSelectedReasons] = useState<string[]>([])
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set(["driver"]))
  const [createOrder, setCreateOrder] = useState(true)
  const [signAndTransmit, setSignAndTransmit] = useState(true)
  const [printDisplay, setPrintDisplay] = useState(false)
  const [currentPage, setCurrentPage] = useState(1)
  const itemsPerPage = 10

  const filteredReasons = rejectionReasons.filter(reason =>
    reason.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
    reason.categoryName.toLowerCase().includes(searchQuery.toLowerCase())
  )

  const groupedReasons = filteredReasons.reduce((acc, reason) => {
    if (!acc[reason.category]) {
      acc[reason.category] = {
        categoryName: reason.categoryName,
        reasons: []
      }
    }
    acc[reason.category].reasons.push(reason)
    return acc
  }, {} as Record<string, { categoryName: string; reasons: RejectionReason[] }>)

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev)
      if (newSet.has(category)) {
        newSet.delete(category)
      } else {
        newSet.add(category)
      }
      return newSet
    })
  }

  const toggleReason = (reasonId: string) => {
    setSelectedReasons(prev => {
      if (prev.includes(reasonId)) {
        return prev.filter(id => id !== reasonId)
      } else {
        return [...prev, reasonId]
      }
    })
  }

  const handleConfirm = () => {
    if (selectedReasons.length === 0) {
      toast.warning("Vui lòng chọn ít nhất một lý do")
      return
    }
    onConfirm(selectedReasons, {
      createOrder,
      signAndTransmit,
      printDisplay
    })
  }

  const allReasonsList = Object.values(groupedReasons).flatMap(group => group.reasons)
  const totalPages = Math.ceil(allReasonsList.length / itemsPerPage)

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>Chọn lý do xe không đủ điều kiện xuất bến</DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-hidden flex flex-col space-y-4">
          {/* Search */}
          <div className="relative">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
            <Input
              placeholder="Tìm kiếm..."
              className="pl-10"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>

          {/* Reasons List */}
          <div className="flex-1 overflow-y-auto border border-gray-200 rounded-lg">
            {searchQuery ? (
              // Show flat list when searching
              <div className="p-4 space-y-2">
                {filteredReasons.map((reason) => (
                  <div key={reason.id} className="flex items-start gap-2 p-2 hover:bg-gray-50 rounded">
                    <Checkbox
                      id={reason.id}
                      checked={selectedReasons.includes(reason.id)}
                      onChange={() => toggleReason(reason.id)}
                      className="mt-1"
                    />
                    <Label htmlFor={reason.id} className="flex-1 cursor-pointer text-sm">
                      {reason.description}
                    </Label>
                  </div>
                ))}
                {filteredReasons.length === 0 && (
                  <div className="text-center py-8 text-gray-500">
                    Không tìm thấy kết quả
                  </div>
                )}
              </div>
            ) : (
              // Show grouped list when not searching
              <div className="p-4 space-y-4">
                {Object.entries(groupedReasons).map(([category, group]) => (
                  <div key={category}>
                    <button
                      onClick={() => toggleCategory(category)}
                      className="w-full flex items-center justify-between p-2 hover:bg-gray-50 rounded"
                    >
                      <div className="flex items-center gap-2">
                        <span className="text-sm font-medium text-gray-700">
                          Phân loại: {group.categoryName}
                        </span>
                      </div>
                      {expandedCategories.has(category) ? (
                        <ChevronUp className="h-4 w-4 text-gray-500" />
                      ) : (
                        <ChevronDown className="h-4 w-4 text-gray-500" />
                      )}
                    </button>
                    {expandedCategories.has(category) && (
                      <div className="ml-4 space-y-2 mt-2">
                        {group.reasons.map((reason) => (
                          <div key={reason.id} className="flex items-start gap-2 p-2 hover:bg-gray-50 rounded">
                            <Checkbox
                              id={reason.id}
                              checked={selectedReasons.includes(reason.id)}
                              onChange={() => toggleReason(reason.id)}
                              className="mt-1"
                            />
                            <Label htmlFor={reason.id} className="flex-1 cursor-pointer text-sm">
                              {reason.description}
                            </Label>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Pagination (only show when searching) */}
          {searchQuery && totalPages > 1 && (
            <div className="flex items-center justify-center gap-2">
              {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
                <button
                  key={page}
                  onClick={() => setCurrentPage(page)}
                  className={`w-8 h-8 rounded-full flex items-center justify-center text-sm ${
                    currentPage === page
                      ? "bg-blue-600 text-white"
                      : "bg-gray-200 text-gray-700 hover:bg-gray-300"
                  }`}
                >
                  {page}
                </button>
              ))}
            </div>
          )}

          {/* Options */}
          <div className="flex items-center gap-6 pt-4 border-t">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="createOrder"
                checked={createOrder}
                onChange={(e) => setCreateOrder(e.target.checked)}
              />
              <Label htmlFor="createOrder" className="cursor-pointer text-sm">
                Tạo đơn hàng
              </Label>
            </div>
            <div className="flex items-center space-x-2">
              <Checkbox
                id="signAndTransmit"
                checked={signAndTransmit}
                onChange={(e) => setSignAndTransmit(e.target.checked)}
              />
              <Label htmlFor="signAndTransmit" className="cursor-pointer text-sm">
                Ký lệnh và truyền tải
              </Label>
            </div>
            <div className="flex items-center space-x-2">
              <Checkbox
                id="printDisplay"
                checked={printDisplay}
                onChange={(e) => setPrintDisplay(e.target.checked)}
              />
              <Label htmlFor="printDisplay" className="cursor-pointer text-sm">
                In bản thể hiện
              </Label>
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-between items-center pt-4 border-t">
          <Button type="button" variant="outline" onClick={onClose}>
            HỦY
          </Button>
          <Button type="button" onClick={handleConfirm}>
            XÁC NHẬN
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/dispatch/sections/GsgtCheckSection.tsx">
import { Home, Globe, AlertTriangle, MapPin } from "lucide-react";
import { GlassCard, SectionHeader } from "@/components/shared/styled-components";

export function GsgtCheckSection() {
  return (
    <GlassCard>
      <SectionHeader icon={Globe} title="Kiểm tra GSHT" />
      <div className="p-5 space-y-3">
        {[
          { icon: Home, label: "(Chưa đăng nhập)" },
          { icon: Globe, label: "(Chưa đăng nhập)" },
          { icon: AlertTriangle, label: "(Chưa đăng nhập)" },
          { icon: MapPin, label: "(Chưa đăng nhập)" },
        ].map((item, idx) => (
          <div key={idx} className="flex items-center gap-3 text-sm text-gray-500">
            <item.icon className="h-4 w-4" />
            <span>{item.label}</span>
          </div>
        ))}
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/index.ts">
export { VehicleInfoSection } from "./VehicleInfoSection";
export { DriverSection } from "./DriverSection";
export { MonthlyCalendarHeatmap } from "./MonthlyCalendarHeatmap";
export { TransportOrderSection } from "./TransportOrderSection";
export { ServiceChargesSection } from "./ServiceChargesSection";
export { DocumentCheckCards } from "./DocumentCheckCards";
export { VehicleImageSection } from "./VehicleImageSection";
export { GsgtCheckSection } from "./GsgtCheckSection";
export { NotesSection } from "./NotesSection";
export { PermitActions } from "./PermitActions";
export { ZeroAmountWarningDialog } from "./ZeroAmountWarningDialog";
</file>

<file path="client/src/components/dispatch/sections/NotesSection.tsx">
import { MessageSquare } from "lucide-react";
import { GlassCard, SectionHeader } from "@/components/shared/styled-components";

export function NotesSection() {
  return (
    <GlassCard>
      <SectionHeader icon={MessageSquare} title="Ghi chú" />
      <div className="p-5">
        <textarea
          rows={4}
          className="w-full px-4 py-3 rounded-xl bg-gray-50 border border-gray-200 text-gray-800 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/30 focus:border-blue-400 resize-none transition-all"
          placeholder="Nhập ghi chú..."
        />
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/ZeroAmountWarningDialog.tsx">
import { AlertTriangle, ArrowRight } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ZeroAmountWarningDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: () => void;
}

export function ZeroAmountWarningDialog({ open, onClose, onConfirm }: ZeroAmountWarningDialogProps) {
  if (!open) return null;

  return (
    <div className="fixed inset-0 z-[60] bg-black/30 backdrop-blur-sm flex items-center justify-center">
      <div className="bg-white border border-gray-200 rounded-2xl p-6 max-w-sm w-full mx-4 shadow-2xl">
        <div className="flex items-center gap-3 mb-4">
          <div className="p-2 rounded-xl bg-amber-100">
            <AlertTriangle className="h-5 w-5 text-amber-600" />
          </div>
          <h3 className="text-lg font-bold text-gray-800">Xác nhận</h3>
        </div>
        <p className="text-gray-600 mb-6">
          <span className="text-gray-800 font-medium">Tổng đơn hàng 0 đồng.</span>
          <br />Bạn có muốn tiếp tục?
        </p>
        <div className="flex justify-end gap-3">
          <Button
            onClick={onClose}
            className="px-4 py-2 rounded-xl bg-gray-100 border border-gray-200 text-gray-600 hover:bg-gray-200 transition-all"
          >
            Hủy
          </Button>
          <Button
            onClick={onConfirm}
            className="px-4 py-2 rounded-xl bg-blue-500 text-white hover:bg-blue-600 transition-all flex items-center gap-2"
          >
            Tiếp tục
            <ArrowRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/ThanhToanTheoThangDialog.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Calendar } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { dispatchService } from "@/services/dispatch.service"
import { LyDoKhongDuDieuKienDialog } from "./LyDoKhongDuDieuKienDialog"
import type { DispatchRecord } from "@/types"
import { format } from "date-fns"
import { useUIStore } from "@/store/ui.store"
import type { Shift } from "@/services/shift.service"

interface ThanhToanTheoThangDialogProps {
  record: DispatchRecord
  onClose: () => void
  onSuccess?: () => void
}

export function ThanhToanTheoThangDialog({
  record,
  onClose,
  onSuccess
}: ThanhToanTheoThangDialogProps) {
  const [departureOrderCode, setDepartureOrderCode] = useState(record.transportOrderCode || "")
  const [departureDate, setDepartureDate] = useState(
    record.plannedDepartureTime
      ? format(new Date(record.plannedDepartureTime), "yyyy-MM-dd")
      : format(new Date(), "yyyy-MM-dd")
  )
  const [departureTime, setDepartureTime] = useState(
    record.plannedDepartureTime
      ? format(new Date(record.plannedDepartureTime), "HH:mm")
      : ""
  )
  const [isLoading, setIsLoading] = useState(false)
  const [notEligibleDialogOpen, setNotEligibleDialogOpen] = useState(false)
  const { currentShift } = useUIStore()

  // Helper function to get shift ID from currentShift string
  const getShiftIdFromCurrentShift = (): string | undefined => {
    if (!currentShift || currentShift === '<Trống>') {
      return undefined
    }

    const currentShifts = useUIStore.getState().shifts
    if (currentShifts.length === 0) {
      return undefined
    }

    const match = currentShift.match(/^(.+?)\s*\(/)
    if (!match) {
      return undefined
    }

    const shiftName = match[1].trim()
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName)
    return foundShift?.id
  }

  useEffect(() => {
    // Load shifts if not already loaded
    const { shifts: currentShifts, loadShifts } = useUIStore.getState()
    if (currentShifts.length === 0) {
      loadShifts()
    }
  }, [])

  const handleEligible = async () => {
    if (!departureOrderCode) {
      toast.warning("Vui lòng nhập lệnh xuất bến")
      return
    }

    if (!departureDate || !departureTime) {
      toast.warning("Vui lòng nhập giờ xuất bến")
      return
    }

    setIsLoading(true)
    try {
      // Combine date and time for planned departure time
      const plannedDepartureTime = new Date(`${departureDate}T${departureTime}`).toISOString()

      const permitShiftId = getShiftIdFromCurrentShift()
      const paymentShiftId = getShiftIdFromCurrentShift()

      // Issue permit first (this will move the vehicle to permit_issued status)
      await dispatchService.issuePermit(record.id, {
        transportOrderCode: departureOrderCode,
        plannedDepartureTime,
        seatCount: record.seatCount || 0,
        permitStatus: 'approved',
        permitShiftId,
      })

      // Then process payment (for monthly payment, amount is 0 or already paid)
      await dispatchService.processPayment(record.id, {
        paymentAmount: 0, // Monthly payment vehicles already paid
        paymentMethod: 'cash',
        paymentShiftId,
      })

      toast.success("Thanh toán và cấp phép thành công!")
      if (onSuccess) {
        onSuccess()
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to process monthly payment:", error)
      if (error.response?.data?.code === '23505' || error.message?.includes('duplicate key') || error.response?.data?.message?.includes('duplicate key')) {
        toast.error(`Mã lệnh xuất bến ${departureOrderCode} đã tồn tại. Vui lòng nhập mã khác.`)
      } else {
        toast.error("Không thể xử lý thanh toán. Vui lòng thử lại sau.")
      }
    } finally {
      setIsLoading(false)
    }
  }

  const handleNotEligible = () => {
    if (!departureOrderCode) {
      toast.warning("Vui lòng nhập lệnh xuất bến")
      return
    }
    setNotEligibleDialogOpen(true)
  }

  const handleNotEligibleConfirm = async (
    selectedReasons: string[]
  ) => {
    if (!departureOrderCode || !departureDate || !departureTime) {
      toast.warning("Vui lòng điền đầy đủ các trường bắt buộc")
      setNotEligibleDialogOpen(false)
      return
    }

    setIsLoading(true)
    try {
      const reasonDescriptions: Record<string, string> = {
        driver_license_insufficient: "Không có hoặc có nhưng không đủ số lượng giấy phép lái xe so với số lái xe ghi trên lệnh vận chuyển",
        driver_license_expired: "Giấy phép lái xe đã hết hạn hoặc sử dụng giấy phép lái xe giả",
        driver_license_class_mismatch: "Hạng giấy phép lái xe không phù hợp với các loại xe được phép điều khiển",
        driver_info_mismatch: "Thông tin của lái xe không đúng với thông tin được ghi trên lệnh vận chuyển",
        driver_alcohol: "Lái xe sử dụng rượu bia",
        driver_drugs: "Lái xe sử dụng chất ma tuý"
      }

      const rejectionReason = selectedReasons
        .map(id => reasonDescriptions[id] || id)
        .join('; ')

      const plannedDepartureTime = new Date(`${departureDate}T${departureTime}`).toISOString()
      const permitShiftId = getShiftIdFromCurrentShift()
      const paymentShiftId = getShiftIdFromCurrentShift()

      // Issue permit with rejected status
      await dispatchService.issuePermit(record.id, {
        transportOrderCode: departureOrderCode,
        plannedDepartureTime,
        seatCount: record.seatCount || 0,
        permitStatus: 'rejected',
        rejectionReason: rejectionReason,
        permitShiftId,
      })

      // Process payment
      await dispatchService.processPayment(record.id, {
        paymentAmount: 0,
        paymentMethod: 'cash',
        paymentShiftId,
      })

      toast.success("Đã xử lý thanh toán theo tháng!")
      if (onSuccess) {
        onSuccess()
      }
      setNotEligibleDialogOpen(false)
      onClose()
    } catch (error: any) {
      console.error("Failed to process monthly payment:", error)
      if (error.response?.data?.code === '23505' || error.message?.includes('duplicate key') || error.response?.data?.message?.includes('duplicate key')) {
        toast.error(`Mã lệnh xuất bến ${departureOrderCode} đã tồn tại. Vui lòng nhập mã khác.`)
      } else {
        toast.error("Không thể xử lý thanh toán. Vui lòng thử lại sau.")
      }
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-end gap-2 pb-4 border-b">
        <Button
          type="button"
          variant="outline"
          onClick={onClose}
          disabled={isLoading}
        >
          HỦY
        </Button>
        <Button
          type="button"
          variant="destructive"
          onClick={handleNotEligible}
          disabled={isLoading}
        >
          KHÔNG ĐỦ ĐIỀU KIỆN
        </Button>
        <Button
          type="button"
          onClick={handleEligible}
          disabled={isLoading}
          className="bg-green-600 hover:bg-green-700"
        >
          ĐỦ ĐIỀU KIỆN
        </Button>
      </div>

      {/* Form */}
      <div className="space-y-4">
        <div className="rounded-lg bg-blue-50 p-4 border border-blue-200">
          <Label className="text-sm font-medium text-gray-600">Biển số xe</Label>
          <p className="text-lg font-semibold text-gray-900 mt-1">{record.vehiclePlateNumber}</p>
        </div>

        <div>
          <Label htmlFor="departureOrderCode">
            Lệnh xuất bến <span className="text-red-500">(*)</span>
          </Label>
          <Input
            id="departureOrderCode"
            value={departureOrderCode}
            onChange={(e) => setDepartureOrderCode(e.target.value)}
            className="mt-1"
            required
            placeholder="Nhập mã lệnh xuất bến"
          />
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <Label htmlFor="departureDate">
              Ngày xuất bến <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1">
              <Input
                id="departureDate"
                type="date"
                value={departureDate}
                onChange={(e) => setDepartureDate(e.target.value)}
                required
                className="pr-10"
              />
              <Calendar className="absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400 pointer-events-none" />
            </div>
          </div>

          <div>
            <Label htmlFor="departureTime">
              Giờ xuất bến <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1">
              <Input
                id="departureTime"
                type="time"
                value={departureTime}
                onChange={(e) => setDepartureTime(e.target.value)}
                required
                className="pr-10"
              />
              <Calendar className="absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400 pointer-events-none" />
            </div>
          </div>
        </div>

        {/* Info box */}
        <div className="rounded-lg bg-yellow-50 p-4 border border-yellow-200">
          <p className="text-sm text-yellow-800">
            <strong>Lưu ý:</strong> Xe này đã thanh toán theo tháng. Vui lòng nhập lệnh xuất bến và giờ xuất bến để hoàn tất quy trình.
          </p>
        </div>
      </div>

      {/* Not Eligible Reason Dialog */}
      <LyDoKhongDuDieuKienDialog
        open={notEligibleDialogOpen}
        onClose={() => setNotEligibleDialogOpen(false)}
        onConfirm={handleNotEligibleConfirm}
      />
    </div>
  )
}
</file>

<file path="client/src/components/dispatch/ThemDichVuDialog.tsx">
import { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { toast } from "react-toastify";
import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select } from "@/components/ui/select";
import { serviceService } from "@/services/service.service";
import { serviceChargeService } from "@/services/service-charge.service";
import type { Service } from "@/types";

// Utility functions for number formatting
const formatCurrency = (value: number): string => {
  return value.toLocaleString("vi-VN");
};

const parseCurrency = (value: string): number => {
  return parseInt(value.replace(/[^\d]/g, "")) || 0;
};

interface ThemDichVuDialogProps {
  dispatchRecordId: string;
  open: boolean;
  onClose: () => void;
  onSuccess: () => void;
}

export function ThemDichVuDialog({
  dispatchRecordId,
  open,
  onClose,
  onSuccess,
}: ThemDichVuDialogProps) {
  const [services, setServices] = useState<Service[]>([]);
  const [selectedServiceTypeId, setSelectedServiceTypeId] = useState("");
  const [quantity, setQuantity] = useState(1);
  const [unitPrice, setUnitPrice] = useState(0);
  const [unitPriceDisplay, setUnitPriceDisplay] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (open) {
      loadServices();
      setQuantity(1);
      setUnitPrice(0);
      setUnitPriceDisplay("");
      setSelectedServiceTypeId("");
    }
  }, [open]);

  const loadServices = async () => {
    try {
      const data = await serviceService.getAll(true); // Only active services
      setServices(data);
    } catch (error) {
      console.error("Failed to load services:", error);
      toast.error("Không thể tải danh sách dịch vụ");
    }
  };

  const handleServiceTypeChange = (serviceId: string) => {
    setSelectedServiceTypeId(serviceId);
    // Service doesn't have basePrice, so keep current price or set to 0
    // User can manually enter the price
    if (unitPrice === 0) {
      setUnitPrice(0);
      setUnitPriceDisplay("");
    }
  };

  const handleUnitPriceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const inputValue = e.target.value;
    const numericValue = parseCurrency(inputValue);
    setUnitPrice(numericValue);
    setUnitPriceDisplay(formatCurrency(numericValue));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedServiceTypeId) {
      toast.warning("Vui lòng chọn loại dịch vụ");
      return;
    }

    setIsLoading(true);
    try {
      await serviceChargeService.create({
        dispatchRecordId,
        serviceTypeId: selectedServiceTypeId,
        quantity,
        unitPrice,
        totalAmount: quantity * unitPrice,
      });
      toast.success("Thêm dịch vụ thành công");
      onSuccess();
      onClose();
    } catch (error) {
      console.error("Failed to add service:", error);
      toast.error("Không thể thêm dịch vụ");
    } finally {
      setIsLoading(false);
    }
  };

  if (!open) return null;

  return createPortal(
    <div className="fixed inset-0 z-[60] bg-black/50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
        <button
          onClick={onClose}
          className="absolute right-4 top-4 text-gray-400 hover:text-gray-600"
        >
          <X className="h-5 w-5" />
        </button>

        <h2 className="text-xl font-bold mb-4">Thêm dịch vụ</h2>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="serviceType">Loại dịch vụ</Label>
            <Select
              id="serviceType"
              value={selectedServiceTypeId}
              onChange={(e) => handleServiceTypeChange(e.target.value)}
              required
              className="mt-1"
            >
              <option value="">Chọn dịch vụ</option>
              {services.map((service) => (
                <option key={service.id} value={service.id}>
                  {service.name} ({service.code})
                </option>
              ))}
            </Select>
          </div>

          <div>
            <Label htmlFor="quantity">Số lượng</Label>
            <Input
              id="quantity"
              type="number"
              min="1"
              value={quantity}
              onChange={(e) => setQuantity(parseInt(e.target.value) || 0)}
              className="mt-1"
              required
            />
          </div>

          <div>
            <Label htmlFor="unitPrice">Đơn giá (VNĐ)</Label>
            <Input
              id="unitPrice"
              type="text"
              value={unitPriceDisplay}
              onChange={handleUnitPriceChange}
              placeholder="0"
              className="mt-1"
              required
            />
          </div>

          <div className="pt-2 border-t flex justify-between items-center">
            <span className="font-semibold">Thành tiền:</span>
            <span className="font-bold text-lg text-blue-600">
              {formatCurrency(quantity * unitPrice)} VNĐ
            </span>
          </div>

          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={onClose}>
              Hủy
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? "Đang xử lý..." : "Thêm"}
            </Button>
          </div>
        </form>
      </div>
    </div>,
    document.body
  );
}
</file>

<file path="client/src/components/driver/DriverDialog.tsx">
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Driver } from "@/types"
import { DriverForm } from "./DriverForm"
import { DriverView } from "./DriverView"

interface DriverDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  mode: "create" | "edit" | "view"
  driver: Driver | null
  onSuccess: () => void
}

export function DriverDialog({
  open,
  onOpenChange,
  mode,
  driver,
  onSuccess,
}: DriverDialogProps) {
  const handleClose = () => {
    onOpenChange(false)
    onSuccess()
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[95vw] max-w-[1400px] max-h-[95vh] overflow-y-auto p-6">
        <DialogHeader>
          <DialogTitle className="text-2xl">
            {mode === "create" && "Thêm lái xe mới"}
            {mode === "edit" && "Sửa thông tin lái xe"}
            {mode === "view" && "Chi tiết lái xe"}
          </DialogTitle>
        </DialogHeader>
        <div className="mt-4">
          {mode === "view" && driver ? (
            <DriverView driver={driver} />
          ) : (
            <DriverForm
              driver={driver}
              mode={mode === "view" ? "create" : mode}
              onClose={handleClose}
            />
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/driver/DriverView.tsx">
import { useState, useMemo } from "react"
import { Label } from "@/components/ui/label"
import { Driver } from "@/types"
import { format, isValid, parseISO } from "date-fns"

// Helper function to safely format dates
const formatDate = (dateString: string | undefined | null): string => {
  if (!dateString) return "N/A"
  const date = typeof dateString === 'string' ? parseISO(dateString) : new Date(dateString)
  return isValid(date) ? format(date, "dd/MM/yyyy") : "N/A"
}

// Parse address string to extract components
const parseAddress = (addressValue?: string) => {
  if (!addressValue) {
    return {
      addressDetail: "",
      ward: "",
      district: "",
      province: "",
    }
  }

  const addressParts = addressValue.split(",").map(s => s.trim()).filter(Boolean)
  
  let addressDetail = ""
  let ward = ""
  let district = ""
  let province = ""
  
  if (addressParts.length > 0) {
    // Province is always the last part
    province = addressParts[addressParts.length - 1] || ""
    
    if (addressParts.length >= 2) {
      // Try to determine if it's v1 (3 parts) or v2 (2 parts)
      // For v2: address, ward, province
      // For v1: address, ward, district, province
      if (addressParts.length >= 3) {
        // Likely v1 format
        ward = addressParts[addressParts.length - 3] || ""
        district = addressParts[addressParts.length - 2] || ""
        if (addressParts.length >= 4) {
          addressDetail = addressParts.slice(0, -3).join(", ")
        }
      } else {
        // Likely v2 format (2 parts: ward, province)
        ward = addressParts[addressParts.length - 2] || ""
        addressDetail = ""
      }
    }
  }
  
  return {
    addressDetail,
    ward,
    district,
    province,
  }
}

export function DriverView({ driver }: { driver: Driver }) {
  const [useApiV2, setUseApiV2] = useState(false)
  
  // Parse address
  const addressParts = useMemo(() => {
    return parseAddress(driver.address)
  }, [driver.address])

  return (
    <div className="space-y-6">
      {/* Header with title */}
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-semibold">Thông tin lái xe</h3>
      </div>

      {/* Main 2 column layout */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Left Column */}
        <div className="space-y-6">
          {/* Sub-columns for ID and License info */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {/* Column 1a - ID Info */}
            <div className="space-y-4">
              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Số CMND/CCCD</Label>
                <p className="text-base font-medium text-gray-900">{driver.idNumber}</p>
              </div>

              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Họ tên</Label>
                <p className="text-base font-medium text-gray-900">{driver.fullName}</p>
              </div>

              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Số điện thoại</Label>
                <p className="text-base font-medium text-gray-900">{driver.phone || "N/A"}</p>
              </div>
            </div>

            {/* Column 1b - License Info */}
            <div className="space-y-4">
              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Số GPLX</Label>
                <p className="text-base font-medium text-gray-900">{driver.licenseNumber}</p>
              </div>

              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Hạng GPLX</Label>
                <p className="text-base font-medium text-gray-900">{driver.licenseClass}</p>
              </div>

              <div className="space-y-2">
                <Label className="text-sm font-medium text-gray-600">Hạn hiệu lực GPLX</Label>
                <p className="text-base font-medium text-gray-900">
                  {formatDate(driver.licenseExpiryDate)}
                </p>
              </div>
            </div>
          </div>

          {/* Địa chỉ */}
          <div className="space-y-3 sm:space-y-4">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 border-b pb-2">
              <h3 className="text-base sm:text-lg font-semibold text-gray-800">
                Thông tin địa chỉ
              </h3>
              {/* Checkbox chọn API version (chỉ để hiển thị, không ảnh hưởng dữ liệu) */}
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="useApiV2"
                  checked={useApiV2}
                  onChange={(e) => setUseApiV2(e.target.checked)}
                  className="h-4 w-4"
                  disabled
                />
                <Label htmlFor="useApiV2" className="cursor-default text-xs sm:text-sm text-gray-500">
                  Sử dụng dữ liệu sau sáp nhập.
                </Label>
              </div>
            </div>

            {useApiV2 ? (
              // V2: 2 cột (Tỉnh và Phường/Xã)
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                <div>
                  <Label className="text-sm font-medium text-gray-600">
                    Tỉnh/Thành phố
                  </Label>
                  <p className="text-base font-medium text-gray-900 mt-1">
                    {addressParts.province || "N/A"}
                  </p>
                </div>

                <div>
                  <Label className="text-sm font-medium text-gray-600">
                    Phường/Xã
                  </Label>
                  <p className="text-base font-medium text-gray-900 mt-1">
                    {addressParts.ward || "N/A"}
                  </p>
                </div>
              </div>
            ) : (
              // V1: 3 cột (Tỉnh, Quận/Huyện, Phường/Xã)
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                <div>
                  <Label className="text-sm font-medium text-gray-600">
                    Tỉnh/Thành phố
                  </Label>
                  <p className="text-base font-medium text-gray-900 mt-1">
                    {addressParts.province || "N/A"}
                  </p>
                </div>

                <div>
                  <Label className="text-sm font-medium text-gray-600">
                    Quận/Huyện/Thị xã
                  </Label>
                  <p className="text-base font-medium text-gray-900 mt-1">
                    {addressParts.district || "N/A"}
                  </p>
                </div>

                <div>
                  <Label className="text-sm font-medium text-gray-600">Phường/Xã</Label>
                  <p className="text-base font-medium text-gray-900 mt-1">
                    {addressParts.ward || "N/A"}
                  </p>
                </div>
              </div>
            )}

            {/* Địa chỉ cụ thể */}
            <div>
              <Label className="text-sm font-medium text-gray-600">Địa chỉ cụ thể</Label>
              <p className="text-base font-medium text-gray-900 mt-1">
                {addressParts.addressDetail || "N/A"}
              </p>
            </div>
          </div>
        </div>

        {/* Right Column */}
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {/* Column 2a - Operator info */}
          <div className="space-y-2">
            <Label className="text-sm font-medium text-gray-600">Doanh nghiệp vận tải</Label>
            <div className="border rounded-md p-4 bg-gray-50 min-h-[200px] max-h-[400px] overflow-y-auto">
              {(() => {
                // Use operators array if available, otherwise fallback to single operator
                const operatorsList = driver.operators && driver.operators.length > 0
                  ? driver.operators
                  : driver.operator
                    ? [{ ...driver.operator, isPrimary: true }]
                    : []

                if (operatorsList.length === 0) {
                  return <p className="text-sm text-gray-500">N/A</p>
                }

                return (
                  <div className="space-y-3">
                    {operatorsList.map((operator, index) => (
                      <div 
                        key={operator.id || index}
                        className="p-3 bg-white rounded border border-gray-200"
                      >
                        <div className="flex items-start justify-between gap-2">
                          <div className="flex-1">
                            <p className="text-base font-medium text-gray-900">
                              {operator.name}
                            </p>
                            {operator.code && (
                              <p className="text-sm text-gray-600 mt-1">
                                Mã: {operator.code}
                              </p>
                            )}
                          </div>
                        </div>
                      </div>
                    ))}
                    <div className="pt-2 border-t text-xs text-gray-500">
                      Tổng: {operatorsList.length} doanh nghiệp
                    </div>
                  </div>
                )
              })()}
            </div>
          </div>

          {/* Column 2b - Image Display */}
          <div className="space-y-2">
            <Label className="text-sm font-medium text-gray-600">Ảnh lái xe</Label>
            {driver.imageUrl ? (
              <div className="border rounded-md p-2 bg-gray-50">
                <img 
                  src={driver.imageUrl} 
                  alt="Driver" 
                  className="w-full aspect-[3/4] object-cover rounded"
                />
              </div>
            ) : (
              <div className="border-2 border-dashed rounded-md p-4 text-center aspect-[3/4] flex flex-col items-center justify-center bg-gray-50">
                <p className="text-sm text-gray-500">Không có ảnh</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/guide/ArticleBanner.tsx">
interface ArticleBannerProps {
  title?: string
  children: React.ReactNode
  variant?: "info" | "warning" | "success" | "default"
  className?: string
}

export function ArticleBanner({ 
  title, 
  children, 
  variant = "default",
  className = "" 
}: ArticleBannerProps) {
  const variantStyles = {
    info: "bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-200",
    warning: "bg-gradient-to-r from-amber-50 to-orange-50 border-amber-200",
    success: "bg-gradient-to-r from-green-50 to-emerald-50 border-green-200",
    default: "bg-gradient-to-r from-gray-50 to-slate-50 border-gray-200",
  }

  return (
    <div className={`rounded-lg p-6 mt-8 border ${variantStyles[variant]} ${className}`}>
      {title && (
        <h3 className="text-xl font-bold text-gray-900 mb-2">
          {title}
        </h3>
      )}
      <div className="text-gray-700">
        {children}
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/guide/ArticleContent.tsx">
interface ArticleContentProps {
  children: React.ReactNode
  className?: string
}

export function ArticleContent({ children, className = "" }: ArticleContentProps) {
  return (
    <div className={`prose prose-lg max-w-none ${className}`}>
      {children}
    </div>
  )
}
</file>

<file path="client/src/components/guide/ArticleImage.tsx">
interface ArticleImageProps {
  src?: string
  alt: string
  caption?: string
  className?: string
}

export function ArticleImage({ src, alt, caption, className = "" }: ArticleImageProps) {
  if (!src) {
    return (
      <div className={`bg-gray-100 border-2 border-dashed border-gray-300 rounded-lg p-12 flex flex-col items-center justify-center ${className}`}>
        <svg
          className="h-16 w-16 text-gray-400 mb-4"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          />
        </svg>
        <p className="text-gray-500 text-sm">{alt || "Hình ảnh minh họa"}</p>
      </div>
    )
  }

  return (
    <figure className={`my-6 ${className}`}>
      <img
        src={src}
        alt={alt}
        className="w-full rounded-lg shadow-md"
      />
      {caption && (
        <figcaption className="mt-2 text-sm text-gray-600 text-center italic">
          {caption}
        </figcaption>
      )}
    </figure>
  )
}
</file>

<file path="client/src/components/layout/DashboardCard.tsx">
import { LucideIcon } from "lucide-react"
import { Card, CardContent } from "@/components/ui/card"
import { cn } from "@/lib/utils"

interface DashboardCardProps {
  title: string
  value: string | number
  icon: LucideIcon
  trend?: {
    value: number
    isPositive: boolean
  }
  description?: string
  className?: string
}

export function DashboardCard({
  title,
  value,
  icon: Icon,
  trend,
  description,
  className,
}: DashboardCardProps) {
  return (
    <Card className={cn("border border-gray-200", className)}>
      <CardContent className="p-6">
        <div className="flex items-center justify-between">
          <div className="flex-1">
            <p className="text-sm font-medium text-gray-600">{title}</p>
            <p className="text-2xl font-bold text-gray-900 mt-2">{value}</p>
            {trend && (
              <p
                className={cn(
                  "text-xs mt-1",
                  trend.isPositive ? "text-success" : "text-destructive"
                )}
              >
                {trend.isPositive ? "+" : ""}
                {trend.value}% so với tháng trước
              </p>
            )}
            {description && (
              <p className="text-xs text-gray-500 mt-1">{description}</p>
            )}
          </div>
          <div className="ml-4">
            <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-blue-50">
              <Icon className="h-6 w-6 text-primary" />
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="client/src/components/layout/GuideLayout.tsx">
import { useState, useEffect } from "react"
import { useLocation } from "react-router-dom"
import { Search, Phone } from "lucide-react"
import { Input } from "@/components/ui/input"
import { PublicHeader } from "./PublicHeader"
import { PublicFooter } from "./PublicFooter"

interface GuideStep {
  label: string
  path: string
  scrollId?: string
}

interface GuideLayoutProps {
  title: string
  steps: GuideStep[]
  children: React.ReactNode
}

export function GuideLayout({ title, steps, children }: GuideLayoutProps) {
  const location = useLocation()
  const [searchQuery, setSearchQuery] = useState("")

  // Calculate offset for scroll (header + banner height)
  const getScrollOffset = () => {
    const header = document.querySelector("header") as HTMLElement | null
    const banner = document.querySelector(".guide-banner") as HTMLElement | null
    const headerHeight = header ? header.offsetHeight : 64 // Default header height
    const bannerHeight = banner ? banner.offsetHeight : 96 // Default banner height
    return headerHeight + bannerHeight + 20 // Add 20px extra padding
  }

  // Handle scroll to section when hash changes
  useEffect(() => {
    const hash = location.hash.replace("#", "")
    if (hash) {
      const element = document.getElementById(hash)
      if (element) {
        setTimeout(() => {
          const offset = getScrollOffset()
          const elementPosition = element.getBoundingClientRect().top + window.pageYOffset
          const offsetPosition = elementPosition - offset

          window.scrollTo({
            top: offsetPosition,
            behavior: "smooth"
          })
        }, 100)
      }
    }
  }, [location.hash])

  const handleStepClick = (e: React.MouseEvent<HTMLAnchorElement>, step: GuideStep) => {
    e.preventDefault()
    const scrollId = step.scrollId || step.path.split("/").pop() || ""
    if (scrollId) {
      const element = document.getElementById(scrollId)
      if (element) {
        const offset = getScrollOffset()
        const elementPosition = element.getBoundingClientRect().top + window.pageYOffset
        const offsetPosition = elementPosition - offset

        window.scrollTo({
          top: offsetPosition,
          behavior: "smooth"
        })
        
        // Update URL hash without scrolling
        window.history.pushState(null, "", `${location.pathname}#${scrollId}`)
      }
    }
  }

  return (
    <div className="min-h-screen bg-white flex flex-col">
      <PublicHeader />
      
      {/* Banner with Search and Hotline */}
      <div className="guide-banner bg-gradient-to-r from-amber-700 via-orange-600 to-amber-600 py-6">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row items-center justify-between gap-4">
            <div className="flex-1 max-w-md w-full">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-400" />
                <Input
                  type="search"
                  placeholder="Tìm kiếm..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-10 bg-white border-0 shadow-md"
                />
              </div>
            </div>
            <div className="flex items-center gap-2 text-white">
              <Phone className="h-5 w-5" />
              <span className="text-lg font-semibold">Tổng Đài Hỗ Trợ 1900.4751</span>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1">
        <div className="container mx-auto px-4 py-6">
          <div className="flex flex-col lg:flex-row gap-6">
            {/* Sidebar */}
            <aside className="lg:w-80 flex-shrink-0">
              <div className="bg-gray-50 rounded-lg p-4 sticky top-4">
                <h2 className="text-lg font-bold text-gray-900 mb-4">{title}</h2>
                <nav className="space-y-2">
                  {steps.map((step, index) => {
                    const scrollId = step.scrollId || step.path.split("/").pop() || ""
                    const isActive = location.hash === `#${scrollId}` || (index === 0 && !location.hash)
                    return (
                      <a
                        key={step.path}
                        href={`${location.pathname}#${scrollId}`}
                        onClick={(e) => handleStepClick(e, step)}
                        className={`block px-3 py-2 rounded-md text-sm transition-colors cursor-pointer ${
                          isActive
                            ? "bg-primary text-white font-medium"
                            : "text-gray-700 hover:bg-gray-100"
                        }`}
                      >
                        {step.label}
                      </a>
                    )
                  })}
                </nav>
              </div>
            </aside>

            {/* Main Content Area */}
            <main className="flex-1 min-w-0">
              <div className="bg-white rounded-lg shadow-sm">
                {children}
              </div>
            </main>
          </div>
        </div>
      </div>

      <PublicFooter />
    </div>
  )
}
</file>

<file path="client/src/components/layout/Header.tsx">
import { useState } from "react"
import { Menu, Bell, Home, Edit } from "lucide-react"
import { Button } from "@/components/ui/button"
import { UserDropdown } from "./UserDropdown"
import { useUIStore } from "@/store/ui.store"
import { ShiftSelectionDialog } from "./ShiftSelectionDialog"

interface HeaderProps {
  onMenuClick: () => void
}

export function Header({ onMenuClick }: HeaderProps) {
  const { title, currentShift } = useUIStore()
  const [shiftDialogOpen, setShiftDialogOpen] = useState(false)

  return (
    <header className="sticky top-0 z-40 w-full border-b border-gray-200 bg-white">
      <div className="flex h-16 items-center justify-between px-4 lg:px-6">
        <div className="flex items-center gap-4">
          <Button
            variant="ghost"
            size="icon"
            className="lg:hidden"
            onClick={onMenuClick}
            aria-label="Toggle menu"
          >
            <Menu className="h-6 w-6" />
          </Button>
          <div className="hidden lg:flex items-center gap-4">
            <h1 className="text-lg font-semibold text-gray-900">{title}</h1>
            <div className="flex items-center gap-2 text-sm text-gray-600 bg-gray-50 px-3 py-1.5 rounded-md border border-gray-200">
              <span>Ca trực: <span className="font-medium text-gray-900">{currentShift}</span></span>
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-5 w-5 hover:bg-gray-200 rounded-full ml-1"
                onClick={() => setShiftDialogOpen(true)}
              >
                <Edit className="h-3 w-3" />
              </Button>
            </div>
          </div>
        </div>

        <div className="flex items-center gap-2">
          <Button variant="ghost" size="icon" aria-label="Notifications">
            <Bell className="h-5 w-5" />
            <span className="absolute top-2 right-2 h-2 w-2 rounded-full bg-red-500" />
          </Button>

          <UserDropdown
            variant="desktop"
            homeLink="/"
            homeLabel="Trang chủ"
            homeIcon={<Home className="h-4 w-4" />}
          />
        </div>
      </div>
      <ShiftSelectionDialog open={shiftDialogOpen} onOpenChange={setShiftDialogOpen} />
    </header>
  )
}
</file>

<file path="client/src/components/layout/MainLayout.tsx">
import { useState } from "react"
import { Sidebar } from "./Sidebar"
import { Header } from "./Header"

interface MainLayoutProps {
  children: React.ReactNode
  disablePadding?: boolean
}

export function MainLayout({ children, disablePadding = false }: MainLayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false)

  return (
    <div className="h-screen flex flex-col bg-gray-50 overflow-hidden">
      <Sidebar isOpen={sidebarOpen} onClose={() => setSidebarOpen(false)} />
      <div className="lg:pl-64 flex flex-col h-full">
        <Header onMenuClick={() => setSidebarOpen(true)} />
        <main className={`flex-1 overflow-auto ${disablePadding ? "" : "p-4 lg:p-6"}`}>{children}</main>
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/layout/PublicLayout.tsx">
import { PublicHeader } from "./PublicHeader"
import { PublicFooter } from "./PublicFooter"

interface PublicLayoutProps {
  children: React.ReactNode
}

export function PublicLayout({ children }: PublicLayoutProps) {
  return (
    <div className="min-h-screen bg-white flex flex-col">
      <PublicHeader />
      <main className="flex-1">{children}</main>
      <PublicFooter />
    </div>
  )
}
</file>

<file path="client/src/components/layout/ShiftSelectionDialog.tsx">
import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { useUIStore } from "@/store/ui.store"
import { shiftService, type Shift } from "@/services/shift.service"

interface ShiftSelectionDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function ShiftSelectionDialog({ open, onOpenChange }: ShiftSelectionDialogProps) {
  const { currentShift, setCurrentShift } = useUIStore()
  const [selectedShift, setSelectedShift] = useState(currentShift)
  const [shifts, setShifts] = useState<Shift[]>([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (open) {
      loadShifts()
      setSelectedShift(currentShift)
    }
  }, [open, currentShift])

  const loadShifts = async () => {
    setIsLoading(true)
    try {
      const data = await shiftService.getAll()
      setShifts(data)
    } catch (error) {
      console.error("Failed to load shifts:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const formatShiftName = (shift: Shift) => {
    return `${shift.name} (${shift.startTime} - ${shift.endTime})`
  }

  const handleSave = () => {
    setCurrentShift(selectedShift)
    onOpenChange(false)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Chọn ca trực</DialogTitle>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          {isLoading ? (
            <div className="text-center py-4">Đang tải...</div>
          ) : (
            <RadioGroup value={selectedShift} onValueChange={setSelectedShift}>
              {shifts.map((shift) => {
                const displayName = formatShiftName(shift)
                return (
                  <div key={shift.id} className="flex items-center space-x-2">
                    <RadioGroupItem value={displayName} id={shift.id} />
                    <Label htmlFor={shift.id}>{displayName}</Label>
                  </div>
                )
              })}
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="<Trống>" id="empty" />
                <Label htmlFor="empty">Không chọn (Trống)</Label>
              </div>
            </RadioGroup>
          )}
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Hủy
          </Button>
          <Button onClick={handleSave}>Lưu thay đổi</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/layout/StatusBadge.tsx">
import { Badge } from "@/components/ui/badge"
import type { DispatchStatus } from "@/types"

// Display status type for UI (different from backend status)
type DisplayStatus = "in-station" | "permit-issued" | "paid" | "departed"

interface StatusBadgeProps {
  status: DispatchStatus | DisplayStatus | "active" | "inactive" | "maintenance" | "suspended"
  label?: string
}

const statusConfig: Record<
  string,
  { label: string; variant: "success" | "warning" | "danger" | "default" | "secondary" }
> = {
  "in-station": { label: "Trong bến", variant: "secondary" },
  "permit-issued": { label: "Đã cấp nốt", variant: "warning" },
  paid: { label: "Đã thanh toán", variant: "success" },
  departed: { label: "Đã xuất bến", variant: "default" },
  invalid: { label: "Không đủ điều kiện", variant: "danger" },
  active: { label: "Hoạt động", variant: "success" },
  inactive: { label: "Không hoạt động", variant: "default" },
  maintenance: { label: "Bảo trì", variant: "warning" },
  suspended: { label: "Tạm ngưng", variant: "danger" },
}

export function StatusBadge({ status, label }: StatusBadgeProps) {
  const config = statusConfig[status] || { label: status, variant: "default" }
  return (
    <Badge variant={config.variant}>
      {label || config.label}
    </Badge>
  )
}
</file>

<file path="client/src/components/layout/UserDropdown.tsx">
import { useState } from "react"
import { Link, useNavigate } from "react-router-dom"
import { ChevronDown, User, LogOut, LayoutDashboard, UserCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
import { useAuthStore } from "@/store/auth.store"

interface UserDropdownProps {
  variant?: "desktop" | "mobile"
  onMenuClose?: () => void
  homeLink?: string
  homeLabel?: string
  homeIcon?: React.ReactNode
}

export function UserDropdown({
  variant = "desktop",
  onMenuClose,
  homeLink = "/dashboard",
  homeLabel = "Trang quản lý",
  homeIcon = <LayoutDashboard className="h-4 w-4" />,
}: UserDropdownProps) {
  const [userMenuOpen, setUserMenuOpen] = useState(false)
  const navigate = useNavigate()
  const { user, logout } = useAuthStore()

  const handleLogout = () => {
    logout()
    setUserMenuOpen(false)
    onMenuClose?.()
    navigate("/")
  }

  const handleMenuClose = () => {
    setUserMenuOpen(false)
    onMenuClose?.()
  }

  if (variant === "mobile") {
    return (
      <>
        <div className="px-4 py-2 border-b border-gray-200 mb-2">
          <p className="text-sm font-medium text-gray-900">
            {user?.fullName || user?.username}
          </p>
          <p className="text-xs text-gray-500">{user?.role}</p>
        </div>
        <Link
          to="/profile"
          onClick={handleMenuClose}
          className="w-full"
        >
          <Button variant="outline" className="w-full" size="sm">
            <UserCircle className="h-4 w-4 mr-2" />
            Thông tin cá nhân
          </Button>
        </Link>
        <Link
          to={homeLink}
          onClick={handleMenuClose}
          className="w-full"
        >
          <Button variant="outline" className="w-full" size="sm">
            {homeIcon && <span className="mr-2">{homeIcon}</span>}
            {homeLabel}
          </Button>
        </Link>
        <Button
          variant="outline"
          className="w-full text-red-600 hover:text-red-700"
          size="sm"
          onClick={handleLogout}
        >
          <LogOut className="h-4 w-4 mr-2" />
          Đăng xuất
        </Button>
      </>
    )
  }

  return (
    <div className="relative">
      <Button
        variant="outline"
        size="sm"
        className="flex items-center gap-2"
        onClick={() => setUserMenuOpen(!userMenuOpen)}
      >
        <User className="h-4 w-4" />
        <span>{user?.fullName || user?.username || "Người dùng"}</span>
        <ChevronDown className="h-4 w-4" />
      </Button>
      {userMenuOpen && (
        <div
          className="absolute right-0 top-full mt-2 w-56 bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50"
          onMouseLeave={() => setUserMenuOpen(false)}
        >
          <div className="px-4 py-2 border-b border-gray-200">
            <p className="text-sm font-medium text-gray-900">
              {user?.fullName || user?.username}
            </p>
            <p className="text-xs text-gray-500">{user?.role}</p>
          </div>
          <Link
            to="/profile"
            className="flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
            onClick={handleMenuClose}
          >
            <UserCircle className="h-4 w-4" />
            Thông tin cá nhân
          </Link>
          <Link
            to={homeLink}
            className="flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
            onClick={handleMenuClose}
          >
            {homeIcon}
            {homeLabel}
          </Link>
          <button
            onClick={handleLogout}
            className="w-full flex items-center gap-2 px-4 py-2 text-sm text-red-600 hover:bg-red-50 transition-colors"
          >
            <LogOut className="h-4 w-4" />
            Đăng xuất
          </button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/components/operator/common/DeleteConfirmDialog.tsx">
import { AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface DeleteConfirmDialogProps {
  open: boolean;
  operatorName?: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export function DeleteConfirmDialog({
  open,
  operatorName,
  onConfirm,
  onCancel,
}: DeleteConfirmDialogProps) {
  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 animate-in zoom-in-95 duration-200">
        <div className="flex items-center gap-4 mb-4">
          <div className="p-3 rounded-2xl bg-rose-100">
            <AlertCircle className="h-6 w-6 text-rose-600" />
          </div>
          <div>
            <h3 className="text-lg font-bold text-slate-800">
              Xác nhận xóa đơn vị
            </h3>
            <p className="text-sm text-slate-500">
              Thao tác này không thể hoàn tác
            </p>
          </div>
        </div>
        <p className="text-slate-600 mb-6">
          Bạn có chắc chắn muốn xóa đơn vị{" "}
          <strong className="text-slate-800">{operatorName}</strong>?
        </p>
        <div className="flex justify-end gap-3">
          <Button
            onClick={onCancel}
            className="px-5 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 transition-all"
          >
            Hủy
          </Button>
          <Button
            onClick={onConfirm}
            className="px-5 py-2.5 rounded-xl bg-gradient-to-r from-rose-500 to-red-500 text-white hover:from-rose-600 hover:to-red-600 shadow-lg shadow-rose-500/25 transition-all"
          >
            Xóa đơn vị
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/operator/common/index.ts">
export { SkeletonRow } from "./SkeletonRow";
export { QuickFilter } from "./QuickFilter";
export { OperatorStatsCards } from "./OperatorStatsCards";
export { OperatorTableRow } from "./OperatorTableRow";
export { OperatorGridCard } from "./OperatorGridCard";
export { DeleteConfirmDialog } from "./DeleteConfirmDialog";
</file>

<file path="client/src/components/operator/common/OperatorStatsCards.tsx">
import { Building2, CheckCircle, AlertCircle, Ticket, TrendingUp } from "lucide-react";

interface OperatorStats {
  total: number;
  active: number;
  inactive: number;
  delegated: number;
}

interface OperatorStatsCardsProps {
  stats: OperatorStats;
}

export function OperatorStatsCards({ stats }: OperatorStatsCardsProps) {
  return (
    <div className="grid grid-cols-12 gap-4">
      {/* Primary Stat - Hero Card */}
      <div className="col-span-12 lg:col-span-5 bg-gradient-to-br from-orange-500 via-orange-600 to-amber-600 rounded-3xl p-8 text-white relative overflow-hidden">
        <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full -translate-y-1/2 translate-x-1/2" />
        <div className="absolute bottom-0 left-0 w-32 h-32 bg-white/5 rounded-full translate-y-1/2 -translate-x-1/2" />
        <div className="relative">
          <div className="flex items-center gap-2 text-orange-100 mb-2">
            <Building2 className="h-5 w-5" />
            <span className="text-sm font-medium uppercase tracking-wider">
              Tổng số đơn vị
            </span>
          </div>
          <p className="text-6xl font-bold tracking-tight">
            {stats.total.toLocaleString()}
          </p>
          <div className="flex items-center gap-2 mt-4 text-orange-100">
            <TrendingUp className="w-4 h-4" />
            <span className="text-sm">Đang quản lý trong hệ thống</span>
          </div>
        </div>
      </div>

      {/* Secondary Stats */}
      <div className="col-span-12 lg:col-span-7 grid grid-cols-3 gap-4">
        {/* Active */}
        <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
          <div className="flex items-center justify-between mb-4">
            <div className="p-3 rounded-xl bg-emerald-100 group-hover:bg-emerald-500 transition-colors">
              <CheckCircle className="w-4 h-4 text-emerald-600 group-hover:text-white transition-colors" />
            </div>
            <span className="text-xs font-medium text-emerald-600 bg-emerald-50 px-2 py-1 rounded-full">
              {stats.total > 0
                ? Math.round((stats.active / stats.total) * 100)
                : 0}
              %
            </span>
          </div>
          <p className="text-3xl font-bold text-slate-800">
            {stats.active.toLocaleString()}
          </p>
          <p className="text-sm text-slate-500 mt-1">Đang hoạt động</p>
          <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
            <div
              className="h-full bg-gradient-to-r from-emerald-400 to-emerald-500 rounded-full transition-all duration-500"
              style={{
                width: `${
                  stats.total > 0 ? (stats.active / stats.total) * 100 : 0
                }%`,
              }}
            />
          </div>
        </div>

        {/* Inactive */}
        <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
          <div className="flex items-center justify-between mb-4">
            <div className="p-3 rounded-xl bg-rose-100 group-hover:bg-rose-500 transition-colors">
              <AlertCircle className="w-4 h-4 text-rose-600 group-hover:text-white transition-colors" />
            </div>
            <span className="text-xs font-medium text-rose-600 bg-rose-50 px-2 py-1 rounded-full">
              {stats.total > 0
                ? Math.round((stats.inactive / stats.total) * 100)
                : 0}
              %
            </span>
          </div>
          <p className="text-3xl font-bold text-slate-800">
            {stats.inactive.toLocaleString()}
          </p>
          <p className="text-sm text-slate-500 mt-1">Ngừng hoạt động</p>
          <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
            <div
              className="h-full bg-gradient-to-r from-rose-400 to-rose-500 rounded-full transition-all duration-500"
              style={{
                width: `${
                  stats.total > 0 ? (stats.inactive / stats.total) * 100 : 0
                }%`,
              }}
            />
          </div>
        </div>

        {/* Ticket Delegated */}
        <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
          <div className="flex items-center justify-between mb-4">
            <div className="p-3 rounded-xl bg-violet-100 group-hover:bg-violet-500 transition-colors">
              <Ticket className="w-4 h-4 text-violet-600 group-hover:text-white transition-colors" />
            </div>
          </div>
          <p className="text-3xl font-bold text-slate-800">
            {stats.delegated.toLocaleString()}
          </p>
          <p className="text-sm text-slate-500 mt-1">Ủy thác vé</p>
          <div className="mt-3 flex items-center gap-1">
            {Array.from({ length: Math.min(5, stats.delegated) }).map(
              (_, i) => (
                <div
                  key={i}
                  className="w-6 h-6 rounded-full bg-gradient-to-br from-violet-400 to-purple-500 border-2 border-white -ml-2 first:ml-0"
                />
              )
            )}
            {stats.delegated > 5 && (
              <span className="text-xs text-slate-500 ml-1">
                +{stats.delegated - 5}
              </span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/operator/common/QuickFilter.tsx">
interface QuickFilterProps {
  label: string;
  count?: number;
  active?: boolean;
  onClick: () => void;
}

export function QuickFilter({ label, count, active, onClick }: QuickFilterProps) {
  return (
    <button
      onClick={onClick}
      className={`px-4 py-2 rounded-xl text-sm font-medium transition-all ${
        active
          ? "bg-orange-500 text-white shadow-md shadow-orange-500/25"
          : "bg-slate-100 text-slate-600 hover:bg-slate-200"
      }`}
    >
      {label}
      {count !== undefined && (
        <span
          className={`ml-2 px-2 py-0.5 rounded-full text-xs ${
            active ? "bg-white/20 text-white" : "bg-slate-200 text-slate-500"
          }`}
        >
          {count.toLocaleString()}
        </span>
      )}
    </button>
  );
}
</file>

<file path="client/src/components/operator/common/SkeletonRow.tsx">
export function SkeletonRow() {
  return (
    <tr className="animate-pulse">
      <td className="px-6 py-4">
        <div className="h-8 w-20 bg-slate-200 rounded-lg" />
      </td>
      <td className="px-6 py-4">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-xl bg-slate-200" />
          <div className="h-4 w-48 bg-slate-200 rounded" />
        </div>
      </td>
      <td className="px-6 py-4">
        <div className="h-4 w-28 bg-slate-200 rounded" />
      </td>
      <td className="px-6 py-4">
        <div className="h-4 w-32 bg-slate-200 rounded" />
      </td>
      <td className="px-6 py-4 text-center">
        <div className="h-6 w-12 bg-slate-200 rounded-full mx-auto" />
      </td>
      <td className="px-6 py-4 text-center">
        <div className="h-6 w-20 bg-slate-200 rounded-full mx-auto" />
      </td>
      <td className="px-6 py-4">
        <div className="h-8 w-24 bg-slate-200 rounded mx-auto" />
      </td>
    </tr>
  );
}
</file>

<file path="client/src/components/operator/detail/EmptyStates.tsx">
import { Truck, Sparkles } from "lucide-react";

export function EmptyVehicles() {
  return (
    <div className="flex flex-col items-center justify-center py-16 text-center">
      <div className="relative mb-6">
        <div className="w-24 h-24 rounded-full bg-gradient-to-br from-gray-100 to-gray-200 flex items-center justify-center">
          <Truck className="w-10 h-10 text-gray-400" />
        </div>
        <div className="absolute -bottom-1 -right-1 w-8 h-8 rounded-full bg-gradient-to-br from-blue-500 to-cyan-500 flex items-center justify-center shadow-lg">
          <Sparkles className="w-4 h-4 text-white" />
        </div>
      </div>
      <h3 className="text-lg font-semibold text-gray-900 mb-2">
        Chưa có xe nào
      </h3>
      <p className="text-sm text-gray-500 max-w-sm">
        Đơn vị vận tải này chưa có xe được đăng ký trong hệ thống
      </p>
    </div>
  );
}

export function VehiclesSkeleton() {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      {[...Array(8)].map((_, i) => (
        <div
          key={i}
          className="bg-white rounded-2xl border border-gray-100 p-5 animate-pulse"
        >
          <div className="flex items-center gap-3 mb-4">
            <div className="w-10 h-10 rounded-xl bg-gray-200" />
            <div className="flex-1">
              <div className="h-5 bg-gray-200 rounded w-24 mb-1" />
              <div className="h-3 bg-gray-100 rounded w-16" />
            </div>
          </div>
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="h-14 bg-gray-100 rounded-xl" />
            <div className="h-14 bg-gray-100 rounded-xl" />
          </div>
          <div className="h-4 bg-gray-100 rounded w-20" />
        </div>
      ))}
    </div>
  );
}
</file>

<file path="client/src/components/operator/detail/index.ts">
export { VehicleCard } from "./VehicleCard";
export { EmptyVehicles, VehiclesSkeleton } from "./EmptyStates";
export { SummaryCards } from "./SummaryCards";
</file>

<file path="client/src/components/operator/detail/SummaryCards.tsx">
import { memo } from "react";
import { Car, TrendingUp, DollarSign, FileText } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";

interface SummaryCardsProps {
  vehicleCount: number;
  totalDebt: number;
  totalPaid: number;
  invoiceCount: number;
  formatCurrency: (amount: number) => string;
}

export const SummaryCards = memo(function SummaryCards({
  vehicleCount,
  totalDebt,
  totalPaid,
  invoiceCount,
  formatCurrency,
}: SummaryCardsProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-100 rounded-lg">
              <Car className="h-5 w-5 text-blue-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Tổng số xe</p>
              <p className="text-2xl font-bold text-gray-900">{vehicleCount}</p>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-4">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-red-100 rounded-lg">
              <TrendingUp className="h-5 w-5 text-red-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Tổng công nợ</p>
              <p className="text-2xl font-bold text-red-600">
                {formatCurrency(totalDebt)}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-4">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-green-100 rounded-lg">
              <DollarSign className="h-5 w-5 text-green-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Đã thanh toán</p>
              <p className="text-2xl font-bold text-green-600">
                {formatCurrency(totalPaid)}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-4">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-purple-100 rounded-lg">
              <FileText className="h-5 w-5 text-purple-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Tổng hóa đơn</p>
              <p className="text-2xl font-bold text-gray-900">{invoiceCount}</p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
});
</file>

<file path="client/src/components/operator/detail/VehicleCard.tsx">
import { memo } from "react";
import { Truck, Users, Fuel, MapPin } from "lucide-react";
import type { Vehicle } from "@/types";

interface VehicleCardProps {
  vehicle: Vehicle;
  index: number;
}

export const VehicleCard = memo(function VehicleCard({ vehicle, index }: VehicleCardProps) {
  const isActive = vehicle.isActive;
  const hasSeats = vehicle.seatCapacity && vehicle.seatCapacity > 0;
  const hasBeds = vehicle.bedCapacity && vehicle.bedCapacity > 0;

  return (
    <div
      className="group relative bg-white rounded-2xl border border-gray-100 overflow-hidden transition-all duration-300 hover:shadow-xl hover:shadow-blue-500/10 hover:-translate-y-1"
      style={{
        animationDelay: `${index * 0.05}s`,
        animation: "slideUp 0.4s ease-out backwards",
      }}
    >
      {/* Status ribbon */}
      <div className="absolute top-3 right-3 z-10">
        <span
          className={`
          inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-semibold
          ${
            isActive
              ? "bg-gradient-to-r from-emerald-500 to-teal-500 text-white shadow-lg shadow-emerald-500/30"
              : "bg-gradient-to-r from-gray-400 to-gray-500 text-white"
          }
        `}
        >
          <span
            className={`w-1.5 h-1.5 rounded-full ${
              isActive ? "bg-white animate-pulse" : "bg-gray-300"
            }`}
          />
          {isActive ? "Hoạt động" : "Ngừng"}
        </span>
      </div>

      {/* Card content */}
      <div className="p-5">
        {/* Plate number - Hero element */}
        <div className="flex items-center gap-3 mb-4">
          <div className="p-2.5 rounded-xl bg-gradient-to-br from-blue-500 to-cyan-500 text-white shadow-lg shadow-blue-500/30">
            <Truck className="w-5 h-5" />
          </div>
          <div>
            <h3 className="text-lg font-bold text-gray-900 tracking-tight group-hover:text-blue-600 transition-colors">
              {vehicle.plateNumber}
            </h3>
            <p className="text-xs text-gray-500 font-medium">
              {vehicle.vehicleType?.name || "Loại khác"}
            </p>
          </div>
        </div>

        {/* Stats grid */}
        <div className="grid grid-cols-2 gap-3 mb-4">
          <div className="flex items-center gap-2 p-2.5 rounded-xl bg-gradient-to-br from-blue-50 to-cyan-50 border border-blue-100">
            <Users className="w-4 h-4 text-blue-600" />
            <div>
              <p className="text-xs text-gray-500">Số ghế</p>
              <p className="text-sm font-bold text-gray-900">
                {hasSeats ? vehicle.seatCapacity : "—"}
              </p>
            </div>
          </div>

          <div className="flex items-center gap-2 p-2.5 rounded-xl bg-gradient-to-br from-violet-50 to-purple-50 border border-violet-100">
            <Fuel className="w-4 h-4 text-violet-600" />
            <div>
              <p className="text-xs text-gray-500">Giường</p>
              <p className="text-sm font-bold text-gray-900">
                {hasBeds ? vehicle.bedCapacity : "—"}
              </p>
            </div>
          </div>
        </div>

        {/* Location */}
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <MapPin className="w-4 h-4 text-gray-400" />
          <span>{vehicle.province || "Chưa xác định"}</span>
        </div>
      </div>

      {/* Hover gradient border effect */}
      <div
        className="absolute inset-0 rounded-2xl opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"
        style={{
          background:
            "linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%)",
        }}
      />
    </div>
  );
});
</file>

<file path="client/src/components/operator/OperatorDialog.tsx">
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Operator } from "@/types"
import { OperatorForm } from "./OperatorForm"
import { OperatorView } from "./OperatorView"

interface OperatorDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  mode: "create" | "edit" | "view"
  operator: Operator | null
  onSuccess: () => void
}

export function OperatorDialog({
  open,
  onOpenChange,
  mode,
  operator,
  onSuccess,
}: OperatorDialogProps) {
  const handleClose = () => {
    onOpenChange(false)
    onSuccess()
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent 
        className="w-[95vw] max-w-[1400px] max-h-[95vh] overflow-y-auto p-6"
      >
        <DialogHeader>
          <DialogTitle className="text-2xl">
            {mode === "create" && "Thêm đơn vị vận tải mới"}
            {mode === "edit" && "Sửa thông tin đơn vị vận tải"}
            {mode === "view" && "Chi tiết đơn vị vận tải"}
          </DialogTitle>
        </DialogHeader>
        <div className="mt-4">
          {mode === "view" && operator ? (
            <OperatorView operator={operator} />
          ) : (
            <OperatorForm
              operator={operator}
              mode={mode === "view" ? "create" : mode}
              onClose={handleClose}
            />
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/operator/OperatorView.tsx">
import { Operator } from "@/types"
import { Check, X } from "lucide-react"

interface OperatorViewProps {
  operator: Operator
}

export function OperatorView({ operator }: OperatorViewProps) {
  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Basic Info */}
        <div className="space-y-4">
          <h3 className="text-lg font-medium border-b pb-2">Thông tin chung</h3>
          
          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Tên đơn vị:</span>
            <span className="col-span-2">{operator.name}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Mã đơn vị:</span>
            <span className="col-span-2">{operator.code}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Mã số thuế:</span>
            <span className="col-span-2">{operator.taxCode || "N/A"}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Ủy thác bán vé:</span>
            <span className="col-span-2 flex items-center">
              {operator.isTicketDelegated ? (
                <span className="flex items-center text-green-600"><Check className="h-4 w-4 mr-1" /> Có</span>
              ) : (
                <span className="flex items-center text-gray-500"><X className="h-4 w-4 mr-1" /> Không</span>
              )}
            </span>
          </div>
          
          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Trạng thái:</span>
            <span className="col-span-2">
              {operator.isActive ? (
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  Hoạt động
                </span>
              ) : (
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                  Ngừng hoạt động
                </span>
              )}
            </span>
          </div>
        </div>

        {/* Contact Info */}
        <div className="space-y-4">
          <h3 className="text-lg font-medium border-b pb-2">Liên hệ & Địa chỉ</h3>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Số điện thoại:</span>
            <span className="col-span-2">{operator.phone || "N/A"}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Email:</span>
            <span className="col-span-2">{operator.email || "N/A"}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Địa chỉ:</span>
            <span className="col-span-2">
              {[operator.address, operator.district, operator.province].filter(Boolean).join(", ") || "N/A"}
            </span>
          </div>
        </div>

        {/* Representative Info */}
        <div className="space-y-4">
          <h3 className="text-lg font-medium border-b pb-2">Người đại diện</h3>
          
          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Họ tên:</span>
            <span className="col-span-2">{operator.representativeName || "N/A"}</span>
          </div>

          <div className="grid grid-cols-3 gap-2">
            <span className="font-medium text-gray-500">Chức vụ:</span>
            <span className="col-span-2">{operator.representativePosition || "N/A"}</span>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/payment/index.ts">
export { PaymentStatsCard } from "./PaymentStatsCard";
export { OrderCard } from "./OrderCard";
export { VehicleInfoCard } from "./VehicleInfoCard";
export { ServicesCard } from "./ServicesCard";
export { PaymentSidebar } from "./PaymentSidebar";
export { ZeroAmountWarningDialog } from "./ZeroAmountWarningDialog";
</file>

<file path="client/src/components/payment/OrderCard.tsx">
import { Bus, Building2, MapPin, Calendar, Clock, User, CircleDollarSign, CheckCircle2, ArrowRight } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import type { DispatchRecord } from "@/types";

const statusConfig = {
  paid: {
    label: "Đã thanh toán",
    bg: "bg-emerald-100",
    text: "text-emerald-700",
    icon: CheckCircle2,
    gradient: "from-emerald-500 to-teal-500"
  },
  departed: {
    label: "Đã xuất bến",
    bg: "bg-violet-100",
    text: "text-violet-700",
    icon: ArrowRight,
    gradient: "from-violet-500 to-purple-500"
  },
  pending: {
    label: "Chờ thanh toán",
    bg: "bg-amber-100",
    text: "text-amber-700",
    icon: Clock,
    gradient: "from-amber-500 to-orange-500"
  }
};

interface OrderCardProps {
  item: DispatchRecord;
  isSelected: boolean;
  onSelect: () => void;
  onNavigate: () => void;
}

export function OrderCard({ item, isSelected, onSelect, onNavigate }: OrderCardProps) {
  const isPaid = item.currentStatus === 'paid' || item.currentStatus === 'departed';
  const status = isPaid
    ? (item.currentStatus === 'paid' ? statusConfig.paid : statusConfig.departed)
    : statusConfig.pending;
  const StatusIcon = status.icon;

  return (
    <div
      className={cn(
        "group relative bg-white rounded-xl border-2 transition-all duration-200",
        "hover:shadow-lg hover:border-blue-200 hover:-translate-y-0.5",
        isSelected ? "border-blue-400 ring-2 ring-blue-100" : "border-gray-100"
      )}
    >
      {/* Selection checkbox */}
      {!isPaid && (
        <div className="absolute top-4 left-4 z-10">
          <Checkbox
            checked={isSelected}
            onChange={onSelect}
            className="h-5 w-5"
          />
        </div>
      )}

      {/* Status indicator */}
      <div className={cn(
        "absolute top-0 right-0 px-3 py-1.5 rounded-bl-xl rounded-tr-xl",
        status.bg
      )}>
        <div className="flex items-center gap-1.5">
          <StatusIcon className={cn("w-3.5 h-3.5", status.text)} />
          <span className={cn("text-xs font-semibold", status.text)}>
            {status.label}
          </span>
        </div>
      </div>

      <div
        className="p-5 cursor-pointer"
        onClick={onNavigate}
      >
        {/* Header */}
        <div className="flex items-start gap-4 mb-4">
          <div className={cn(
            "flex-shrink-0 w-12 h-12 rounded-xl flex items-center justify-center",
            "bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-md"
          )}>
            <Bus className="w-6 h-6" />
          </div>
          <div className="flex-1 min-w-0 pt-1">
            <p className="font-bold text-gray-900 text-lg">
              {item.vehiclePlateNumber}
            </p>
            <p className="text-sm text-gray-500 truncate">
              {item.transportOrderCode || `#${item.id.slice(-8)}`}
            </p>
          </div>
        </div>

        {/* Details */}
        <div className="space-y-2.5">
          <div className="flex items-center gap-2 text-sm">
            <Building2 className="w-4 h-4 text-gray-400 flex-shrink-0" />
            <span className="text-gray-600 truncate">
              {item.vehicle?.operator?.name || 'Chưa có đơn vị'}
            </span>
          </div>
          <div className="flex items-center gap-2 text-sm">
            <MapPin className="w-4 h-4 text-gray-400 flex-shrink-0" />
            <span className="text-gray-600 truncate">
              {item.routeName || 'Chưa có tuyến'}
            </span>
          </div>
          <div className="flex items-center gap-2 text-sm">
            <Calendar className="w-4 h-4 text-gray-400 flex-shrink-0" />
            <span className="text-gray-600">
              {format(new Date(item.entryTime), "dd/MM/yyyy")}
            </span>
            <span className="text-gray-300">|</span>
            <Clock className="w-4 h-4 text-gray-400 flex-shrink-0" />
            <span className="text-gray-600">
              {item.plannedDepartureTime
                ? format(new Date(item.plannedDepartureTime), "HH:mm")
                : '--:--'}
            </span>
          </div>
        </div>

        {/* Footer */}
        <div className="mt-4 pt-4 border-t border-gray-100 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <User className="w-4 h-4 text-gray-400" />
            <span className="text-sm text-gray-500">{item.entryBy || 'N/A'}</span>
          </div>
          <div className="flex items-center gap-1.5">
            <CircleDollarSign className="w-5 h-5 text-emerald-500" />
            <span className="text-lg font-bold text-emerald-600">
              {(item.paymentAmount || 0).toLocaleString('vi-VN')}đ
            </span>
          </div>
        </div>
      </div>

      {/* Hover action hint */}
      <div className={cn(
        "absolute inset-x-0 bottom-0 h-1 rounded-b-xl transition-all duration-200",
        "bg-gradient-to-r opacity-0 group-hover:opacity-100",
        isPaid ? status.gradient : "from-blue-500 to-indigo-500"
      )} />
    </div>
  );
}
</file>

<file path="client/src/components/payment/PaymentSidebar.tsx">
import { Banknote, User, Building2, Printer, CheckCircle2, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Select } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent } from "@/components/ui/card";
import { toast } from "react-toastify";
import type { DispatchRecord } from "@/types";

interface PaymentSidebarProps {
  record: DispatchRecord;
  total: number;
  subtotal: number;
  discount: number;
  tax: number;
  symbol: string;
  setSymbol: (value: string) => void;
  note: string;
  setNote: (value: string) => void;
  printOneCopy: boolean;
  setPrintOneCopy: (value: boolean) => void;
  printTwoCopies: boolean;
  setPrintTwoCopies: (value: boolean) => void;
  isProcessing: boolean;
  onPayment: () => void;
}

export function PaymentSidebar({
  record,
  total,
  subtotal,
  discount,
  tax,
  symbol,
  setSymbol,
  note,
  setNote,
  printOneCopy,
  setPrintOneCopy,
  printTwoCopies,
  setPrintTwoCopies,
  isProcessing,
  onPayment,
}: PaymentSidebarProps) {
  return (
    <Card className="border-0 shadow-lg sticky top-6">
      <div className="bg-gradient-to-r from-emerald-500 to-teal-500 p-6 text-white rounded-t-xl">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 bg-white/20 backdrop-blur rounded-xl flex items-center justify-center">
            <Banknote className="w-6 h-6" />
          </div>
          <div>
            <p className="text-white/80 text-sm">Thực thu</p>
            <p className="text-3xl font-bold">{total.toLocaleString('vi-VN')}đ</p>
          </div>
        </div>
      </div>
      <CardContent className="p-6 space-y-6">
        {/* Symbol */}
        <div>
          <Label className="text-sm text-gray-500">Ký hiệu</Label>
          <Select value={symbol} onChange={(e) => setSymbol(e.target.value)} className="mt-1">
            <option value="QLBX">QLBX</option>
            <option value="KHAC">KHAC</option>
          </Select>
        </div>

        {/* Note */}
        <div>
          <Label className="text-sm text-gray-500">Ghi chú</Label>
          <textarea
            value={note}
            onChange={(e) => setNote(e.target.value)}
            className="mt-1 w-full min-h-[80px] px-3 py-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="Nhập ghi chú..."
          />
        </div>

        {/* Customer Info */}
        <div className="space-y-3 pt-4 border-t">
          <p className="text-sm font-semibold text-gray-700">Thông tin khách hàng</p>
          <div className="space-y-2 text-sm">
            <div className="flex items-center gap-2">
              <User className="w-4 h-4 text-gray-400" />
              <span className="text-gray-500">Người mua:</span>
              <span className="font-medium">{record.driverName || '-'}</span>
            </div>
            <div className="flex items-center gap-2">
              <Building2 className="w-4 h-4 text-gray-400" />
              <span className="text-gray-500">Đơn vị:</span>
              <span className="font-medium truncate">{record.vehicle?.operator?.name || '-'}</span>
            </div>
          </div>
        </div>

        {/* Payment Summary */}
        <div className="space-y-2 pt-4 border-t">
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Tổng tiền:</span>
            <span className="font-medium">{subtotal.toLocaleString('vi-VN')}đ</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Chiết khấu:</span>
            <span className="font-medium">{discount.toLocaleString('vi-VN')}đ</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Thuế GTGT:</span>
            <span className="font-medium">{tax.toLocaleString('vi-VN')}đ</span>
          </div>
        </div>

        {/* Print Options */}
        <div className="space-y-2 pt-4 border-t">
          <p className="text-sm font-semibold text-gray-700">Tùy chọn in</p>
          <div className="flex gap-4">
            <label className="flex items-center gap-2 cursor-pointer">
              <Checkbox
                checked={printOneCopy}
                onChange={(e) => {
                  setPrintOneCopy(e.target.checked);
                  if (e.target.checked) setPrintTwoCopies(false);
                }}
              />
              <span className="text-sm">In 1 liên</span>
            </label>
            <label className="flex items-center gap-2 cursor-pointer">
              <Checkbox
                checked={printTwoCopies}
                onChange={(e) => {
                  setPrintTwoCopies(e.target.checked);
                  if (e.target.checked) setPrintOneCopy(false);
                }}
              />
              <span className="text-sm">In 2 liên</span>
            </label>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="space-y-3 pt-4">
          <Button
            variant="outline"
            className="w-full gap-2"
            onClick={() => toast.info("Chức năng đang phát triển")}
          >
            <Printer className="w-4 h-4" />
            Xem trước bản in
          </Button>
          <Button
            className="w-full gap-2 bg-gradient-to-r from-emerald-500 to-teal-500 hover:from-emerald-600 hover:to-teal-600 h-12 text-lg"
            onClick={onPayment}
            disabled={isProcessing}
          >
            {isProcessing ? (
              <>
                <RefreshCw className="w-5 h-5 animate-spin" />
                Đang xử lý...
              </>
            ) : (
              <>
                <CheckCircle2 className="w-5 h-5" />
                Thanh toán
              </>
            )}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/payment/PaymentStatsCard.tsx">
import { TrendingUp } from "lucide-react";
import { cn } from "@/lib/utils";

interface PaymentStatsCardProps {
  title: string;
  value: string | number;
  subtitle?: string;
  icon: React.ElementType;
  gradient: string;
  trend?: { value: number; label: string };
}

export function PaymentStatsCard({
  title,
  value,
  subtitle,
  icon: Icon,
  gradient,
  trend
}: PaymentStatsCardProps) {
  return (
    <div className={cn(
      "relative overflow-hidden rounded-2xl p-5",
      "bg-gradient-to-br", gradient,
      "text-white shadow-lg"
    )}>
      <div className="absolute top-0 right-0 w-32 h-32 -mr-8 -mt-8 opacity-20">
        <Icon className="w-full h-full" />
      </div>
      <div className="relative">
        <p className="text-sm font-medium text-white/80">{title}</p>
        <p className="text-3xl font-bold mt-1">{value}</p>
        {subtitle && <p className="text-sm text-white/70 mt-1">{subtitle}</p>}
        {trend && (
          <div className="flex items-center gap-1 mt-2 text-sm">
            <TrendingUp className="w-4 h-4" />
            <span>{trend.value}% {trend.label}</span>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/payment/ServicesCard.tsx">
import { useState, useRef, useEffect } from "react";
import { ChevronDown, ChevronUp, Plus, FileText, Receipt, CreditCard, Trash2, Check, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { format } from "date-fns";
import type { ServiceCharge, ServiceType, DispatchRecord, ServiceChargeInput } from "@/types";
import { serviceChargeService } from "@/services/service-charge.service";
import { toast } from "react-toastify";

interface ServicesCardProps {
  record: DispatchRecord;
  serviceCharges: ServiceCharge[];
  serviceTypes: ServiceType[];
  onChargesUpdate: (charges: ServiceCharge[]) => void;
}

export function ServicesCard({ record, serviceCharges, serviceTypes, onChargesUpdate }: ServicesCardProps) {
  const orderId = record.transportOrderCode || `ORDER-${record.id.slice(0, 8)}`;
  const [expandedOrders, setExpandedOrders] = useState<Set<string>>(new Set([orderId]));
  const [isAddingService, setIsAddingService] = useState(false);
  const [showServiceDropdown, setShowServiceDropdown] = useState(false);
  const [newService, setNewService] = useState({
    serviceTypeId: "",
    serviceName: "",
    quantity: 1,
    unitPrice: 0,
  });
  const serviceDropdownRef = useRef<HTMLDivElement>(null);

  const isExpanded = expandedOrders.has(orderId);
  const subtotal = serviceCharges.reduce((sum, charge) => sum + charge.totalAmount, 0);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (serviceDropdownRef.current && !serviceDropdownRef.current.contains(event.target as Node)) {
        setShowServiceDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const toggleOrder = () => {
    setExpandedOrders(prev => {
      const newSet = new Set(prev);
      if (newSet.has(orderId)) newSet.delete(orderId);
      else newSet.add(orderId);
      return newSet;
    });
  };

  const handleAddServiceClick = () => {
    setIsAddingService(true);
    setExpandedOrders(prev => new Set(prev).add(orderId));
  };

  const handleServiceTypeChange = (serviceTypeId: string) => {
    const selectedType = serviceTypes.find(st => st.id === serviceTypeId);
    setNewService({
      ...newService,
      serviceTypeId,
      serviceName: selectedType?.name || "",
      unitPrice: selectedType?.basePrice || 0,
    });
  };

  const handleSaveService = async () => {
    if (!newService.serviceTypeId || !newService.unitPrice) {
      toast.warning("Vui lòng điền đầy đủ thông tin dịch vụ");
      return;
    }
    if (newService.quantity <= 0) {
      toast.warning("Số lượng phải lớn hơn 0");
      return;
    }

    try {
      const totalAmount = newService.quantity * newService.unitPrice;
      const input: ServiceChargeInput = {
        dispatchRecordId: record.id,
        serviceTypeId: newService.serviceTypeId,
        quantity: newService.quantity,
        unitPrice: newService.unitPrice,
        totalAmount,
      };

      await serviceChargeService.create(input);
      const chargesData = await serviceChargeService.getAll(record.id);
      onChargesUpdate(chargesData);
      setNewService({ serviceTypeId: "", serviceName: "", quantity: 1, unitPrice: 0 });
      setIsAddingService(false);
      toast.success("Thêm dịch vụ thành công!");
    } catch (error) {
      console.error("Failed to add service:", error);
      toast.error("Không thể thêm dịch vụ");
    }
  };

  const handleCancelService = () => {
    setIsAddingService(false);
    setNewService({ serviceTypeId: "", serviceName: "", quantity: 1, unitPrice: 0 });
  };

  const handleDeleteService = async (chargeId: string) => {
    if (!window.confirm("Bạn có chắc chắn muốn xóa dịch vụ này?")) return;

    try {
      await serviceChargeService.delete(chargeId);
      const chargesData = await serviceChargeService.getAll(record.id);
      onChargesUpdate(chargesData);
      toast.success("Xóa dịch vụ thành công!");
    } catch (error) {
      console.error("Failed to delete service:", error);
      toast.error("Không thể xóa dịch vụ");
    }
  };

  return (
    <Card className="border-0 shadow-sm">
      <CardHeader className="flex flex-row items-center justify-between pb-4">
        <CardTitle className="flex items-center gap-2">
          <FileText className="w-5 h-5 text-blue-600" />
          Danh sách dịch vụ
        </CardTitle>
        <Button onClick={handleAddServiceClick} size="sm" className="gap-2 bg-gradient-to-r from-blue-500 to-indigo-600">
          <Plus className="w-4 h-4" />
          Thêm dịch vụ
        </Button>
      </CardHeader>
      <CardContent className="p-0">
        {/* Order Header */}
        <button
          onClick={toggleOrder}
          className="w-full flex items-center justify-between p-4 bg-gray-50 hover:bg-gray-100 transition-colors border-y"
        >
          <div className="flex items-center gap-3">
            <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center">
              <Receipt className="w-4 h-4 text-blue-600" />
            </div>
            <div className="text-left">
              <p className="font-semibold text-gray-900">Mã đơn: {orderId}</p>
              <p className="text-sm text-gray-500">{format(new Date(record.entryTime), "dd/MM/yyyy")}</p>
            </div>
          </div>
          {isExpanded ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </button>

        {/* Services List */}
        {isExpanded && (
          <div className="divide-y">
            {/* Add Service Row */}
            {isAddingService && (
              <div className="p-4 bg-blue-50">
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                  <div className="md:col-span-2 relative" ref={serviceDropdownRef}>
                    <Label className="text-xs text-gray-500 mb-1 block">Dịch vụ</Label>
                    <Input
                      value={newService.serviceName}
                      onChange={(e) => {
                        setNewService({ ...newService, serviceName: e.target.value });
                        setShowServiceDropdown(true);
                      }}
                      onFocus={() => setShowServiceDropdown(true)}
                      placeholder="Nhập tên dịch vụ..."
                    />
                    {showServiceDropdown && (
                      <div className="absolute z-50 w-full mt-1 bg-white border rounded-lg shadow-lg max-h-60 overflow-auto">
                        {serviceTypes.filter(t =>
                          t.name.toLowerCase().includes(newService.serviceName.toLowerCase())
                        ).map((type) => (
                          <div
                            key={type.id}
                            onClick={() => {
                              handleServiceTypeChange(type.id);
                              setShowServiceDropdown(false);
                            }}
                            className="px-4 py-2.5 cursor-pointer hover:bg-blue-50 text-sm"
                          >
                            {type.name}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div>
                    <Label className="text-xs text-gray-500 mb-1 block">Đơn giá</Label>
                    <Input
                      type="number"
                      value={newService.unitPrice}
                      onChange={(e) => setNewService({ ...newService, unitPrice: parseFloat(e.target.value) || 0 })}
                    />
                  </div>
                  <div>
                    <Label className="text-xs text-gray-500 mb-1 block">Số lượng</Label>
                    <Input
                      type="number"
                      min="1"
                      value={newService.quantity}
                      onChange={(e) => setNewService({ ...newService, quantity: parseInt(e.target.value) || 1 })}
                    />
                  </div>
                </div>
                <div className="flex items-center justify-between mt-4">
                  <p className="text-sm">
                    Thành tiền: <span className="font-bold text-blue-600">
                      {(newService.quantity * newService.unitPrice).toLocaleString('vi-VN')}đ
                    </span>
                  </p>
                  <div className="flex gap-2">
                    <Button size="sm" variant="outline" onClick={handleCancelService}>
                      <X className="w-4 h-4 mr-1" /> Hủy
                    </Button>
                    <Button size="sm" onClick={handleSaveService}>
                      <Check className="w-4 h-4 mr-1" /> Lưu
                    </Button>
                  </div>
                </div>
              </div>
            )}

            {serviceCharges.length === 0 ? (
              <div className="py-12 text-center">
                <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-3">
                  <FileText className="w-8 h-8 text-gray-400" />
                </div>
                <p className="text-gray-500">Chưa có dịch vụ nào</p>
                <p className="text-sm text-gray-400 mt-1">Nhấn "Thêm dịch vụ" để bắt đầu</p>
              </div>
            ) : (
              serviceCharges.map((charge) => (
                <div key={charge.id} className="p-4 flex items-center justify-between hover:bg-gray-50">
                  <div className="flex items-center gap-4">
                    <div className="w-10 h-10 bg-emerald-100 rounded-lg flex items-center justify-center">
                      <CreditCard className="w-5 h-5 text-emerald-600" />
                    </div>
                    <div>
                      <p className="font-medium text-gray-900">{charge.serviceType?.name || "Dịch vụ"}</p>
                      <p className="text-sm text-gray-500">
                        {charge.quantity} x {charge.unitPrice.toLocaleString('vi-VN')}đ
                      </p>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <p className="font-bold text-gray-900">{charge.totalAmount.toLocaleString('vi-VN')}đ</p>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteService(charge.id)}
                      className="text-red-500 hover:text-red-600 hover:bg-red-50"
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              ))
            )}

            {/* Total */}
            {serviceCharges.length > 0 && (
              <div className="p-4 bg-gray-50 flex items-center justify-between">
                <p className="font-semibold text-gray-700">Tổng cộng</p>
                <p className="text-xl font-bold text-emerald-600">{subtotal.toLocaleString('vi-VN')}đ</p>
              </div>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/payment/ZeroAmountWarningDialog.tsx">
import { AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";

interface ZeroAmountWarningDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  isProcessing: boolean;
}

export function ZeroAmountWarningDialog({
  open,
  onOpenChange,
  onConfirm,
  isProcessing
}: ZeroAmountWarningDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md">
        <DialogClose onClose={() => onOpenChange(false)} />
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <AlertCircle className="w-5 h-5 text-amber-500" />
            Cảnh báo thanh toán
          </DialogTitle>
        </DialogHeader>
        <div className="py-4">
          <p className="text-gray-700">
            Tổng tiền thanh toán là <span className="font-bold text-red-600">0 đồng</span>.
          </p>
          <p className="text-gray-500 mt-2">
            Bạn có chắc chắn muốn tiếp tục?
          </p>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Hủy
          </Button>
          <Button
            onClick={onConfirm}
            disabled={isProcessing}
            className="bg-gradient-to-r from-emerald-500 to-teal-500"
          >
            {isProcessing ? "Đang xử lý..." : "Xác nhận"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/QRScanner.tsx">
import { useState, useEffect, useRef } from "react"
import { QrCode } from "lucide-react"
import { Html5Qrcode } from "html5-qrcode"
import { Button } from "@/components/ui/button"

interface QRScannerProps {
  onScanSuccess: (text: string) => void
}

export function QRScanner({ onScanSuccess }: QRScannerProps) {
  const [scanning, setScanning] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const qrCodeRef = useRef<Html5Qrcode | null>(null)
  const scannerId = "qr-reader"

  const stopScanning = async () => {
    if (qrCodeRef.current) {
      try {
        await qrCodeRef.current.stop()
        qrCodeRef.current.clear()
      } catch (err) {
        console.error("Error stopping QR scanner:", err)
      }
      qrCodeRef.current = null
    }
  }

  useEffect(() => {
    if (scanning) {
      const startScanning = async () => {
        try {
          const html5QrCode = new Html5Qrcode(scannerId)
          qrCodeRef.current = html5QrCode

          await html5QrCode.start(
            { facingMode: "environment" },
            {
              fps: 10,
              qrbox: { width: 250, height: 250 },
            },
            (decodedText) => {
              onScanSuccess(decodedText)
              stopScanning()
            },
            (_errorMessage) => {
              // Ignore scanning errors
            }
          )
          setError(null)
        } catch (err: any) {
          console.error("Error starting QR scanner:", err)
          setError("Không thể khởi động camera. Vui lòng kiểm tra quyền truy cập camera.")
          setScanning(false)
        }
      }
      startScanning()
    } else {
      stopScanning()
    }

    return () => {
      stopScanning()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scanning])

  return (
    <div className="space-y-4">
      {!scanning ? (
        <div className="space-y-4">
          <div className="flex flex-col items-center justify-center p-8 border-2 border-dashed border-gray-300 rounded-lg">
            <QrCode className="h-16 w-16 text-gray-400 mb-4" />
            <p className="text-gray-600 mb-4">Nhấn nút bên dưới để bắt đầu quét QR code</p>
            <Button onClick={() => setScanning(true)}>Bắt đầu quét</Button>
          </div>
        </div>
      ) : (
        <div className="space-y-4">
          <div id={scannerId} className="w-full rounded-lg overflow-hidden"></div>
          <Button variant="outline" onClick={() => setScanning(false)} className="w-full">
            Dừng quét
          </Button>
        </div>
      )}
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-sm text-red-600">{error}</p>
        </div>
      )}
      <div className="text-sm text-gray-500">
        <p>• Đảm bảo camera có quyền truy cập</p>
        <p>• Đặt QR code trong khung quét</p>
        <p>• Đảm bảo đủ ánh sáng</p>
      </div>
    </div>
  )
}
</file>

<file path="client/src/components/route/RouteDialog.tsx">
import { useState, useEffect } from "react"
import { createPortal } from "react-dom"
import { Button } from "@/components/ui/button"
import { Route } from "@/types"
import { RouteForm } from "./RouteForm"
import { RouteView } from "./RouteView"

interface RouteDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  mode: "create" | "edit" | "view"
  route: Route | null
  locations: any[]
  onSuccess: () => void
}

export function RouteDialog({
  open,
  onOpenChange,
  mode,
  route,
  locations,
  onSuccess,
}: RouteDialogProps) {
  const [isAnimating, setIsAnimating] = useState(false)

  useEffect(() => {
    if (open) {
      setIsAnimating(true)
      document.body.style.overflow = "hidden"
    } else {
      document.body.style.overflow = "unset"
    }
    return () => {
      document.body.style.overflow = "unset"
    }
  }, [open])

  const handleClose = () => {
    setIsAnimating(false)
    setTimeout(() => {
      onOpenChange(false)
      onSuccess()
    }, 300)
  }

  if (!open) return null

  return createPortal(
    <div
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center"
      onClick={handleClose}
    >
      <div
        className={`bg-white w-full h-full overflow-y-auto overflow-x-hidden transition-all duration-300 ${
          isAnimating ? "scale-100 opacity-100" : "scale-95 opacity-0"
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="max-w-[1920px] mx-auto p-8">
          {/* Header Section */}
          <div className="flex items-center justify-between pb-5 border-b mb-6">
            <h1 className="text-2xl font-bold text-gray-900">
              {mode === "create" && "Thêm tuyến mới"}
              {mode === "edit" && "Sửa thông tin tuyến"}
              {mode === "view" && "Chi tiết tuyến"}
            </h1>
            <div className="flex items-center gap-3">
              <Button
                type="button"
                variant="outline"
                onClick={handleClose}
                className="text-blue-600 border-blue-600 hover:bg-blue-50 px-6"
              >
                HỦY
              </Button>
              {mode !== "view" && (
                <Button
                  type="submit"
                  form="route-form"
                  className="bg-blue-600 hover:bg-blue-700 px-6"
                >
                  LƯU
                </Button>
              )}
            </div>
          </div>

          {/* Content */}
          <div>
            {mode === "view" && route ? (
              <RouteView route={route} />
            ) : (
              <RouteForm
                route={route}
                locations={locations}
                mode={mode === "view" ? "create" : mode}
                onClose={handleClose}
              />
            )}
          </div>
        </div>
      </div>
    </div>,
    document.body
  )
}
</file>

<file path="client/src/components/route/RouteForm.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Trash2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Textarea } from "@/components/ui/textarea"
import { routeService } from "@/services/route.service"
import { provinceService, type Province } from "@/services/province.service"
import type { Route, RouteInput, Location } from "@/types"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"

const routeSchema = z.object({
  originProvince: z.string().min(1, "Vui lòng chọn tỉnh đi"),
  originId: z.string().uuid("Vui lòng chọn bến đi"),
  destinationProvince: z.string().min(1, "Vui lòng chọn tỉnh đến"),
  destinationId: z.string().uuid("Vui lòng chọn bến đến"),
  routeCode: z.string().min(1, "Mã tuyến là bắt buộc"),
  distanceKm: z.number().min(0, "Cự ly phải lớn hơn hoặc bằng 0").optional(),
  plannedFrequency: z.string().min(1, "Lưu lượng quy hoạch là bắt buộc"),
  boardingPoint: z.string().optional(),
  journeyDescription: z.string().optional(),
}).refine((data) => data.originId !== data.destinationId, {
  message: "Bến đi và bến đến phải khác nhau",
  path: ["destinationId"],
})

type RouteFormData = z.infer<typeof routeSchema>

interface RouteFormProps {
  route: Route | null
  locations: Location[]
  mode: "create" | "edit"
  onClose: () => void
}

// Helper function to extract province from location address
const getProvinceFromLocation = (location: Location): string => {
  if (!location.address) return ""
  const parts = location.address.split(",").map(s => s.trim()).filter(Boolean)
  return parts.length > 0 ? parts[parts.length - 1] : ""
}

export function RouteForm({
  route,
  locations,
  mode,
  onClose,
}: RouteFormProps) {
  const [departureTimes, setDepartureTimes] = useState<Array<{ id: string; time: string }>>([])
  const [restStops, setRestStops] = useState<string[]>([])
  const [newRestStop, setNewRestStop] = useState("")
  const [selectedOriginProvince, setSelectedOriginProvince] = useState("")
  const [selectedDestinationProvince, setSelectedDestinationProvince] = useState("")
  const [provinces, setProvinces] = useState<Province[]>([])
  const [isLoadingProvinces, setIsLoadingProvinces] = useState(false)

  // Generate time options (every 30 minutes from 00:00 to 23:30)
  const timeOptions: string[] = []
  for (let hour = 0; hour < 24; hour++) {
    for (let minute = 0; minute < 60; minute += 30) {
      const timeString = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`
      timeOptions.push(timeString)
    }
  }

  // Load provinces from API
  const loadProvinces = async () => {
    setIsLoadingProvinces(true)
    try {
      const data = await provinceService.getProvincesV1()
      setProvinces(data)
    } catch (error) {
      console.error("Failed to load provinces:", error)
      toast.error("Không thể tải danh sách tỉnh thành. Vui lòng thử lại sau.")
    } finally {
      setIsLoadingProvinces(false)
    }
  }

  useEffect(() => {
    loadProvinces()
  }, [])

  // Remove duplicates and filter by province
  const uniqueLocations = Array.from(
    new Map(locations.map(loc => [loc.id, loc])).values()
  )

  const originLocations = selectedOriginProvince
    ? uniqueLocations.filter(loc => {
        const province = getProvinceFromLocation(loc)
        return province === selectedOriginProvince || loc.province === selectedOriginProvince
      })
    : uniqueLocations

  const destinationLocations = selectedDestinationProvince
    ? uniqueLocations.filter(loc => {
        const province = getProvinceFromLocation(loc)
        return province === selectedDestinationProvince || loc.province === selectedDestinationProvince
      })
    : uniqueLocations

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue,
  } = useForm<RouteFormData>({
    resolver: zodResolver(routeSchema),
    defaultValues: route
      ? {
        originProvince: route.origin ? getProvinceFromLocation(route.origin) : "",
        originId: route.originId,
        destinationProvince: route.destination ? getProvinceFromLocation(route.destination) : "",
        destinationId: route.destinationId,
        routeCode: route.routeCode,
        distanceKm: route.distanceKm || undefined,
        plannedFrequency: route.plannedFrequency || undefined,
        boardingPoint: route.boardingPoint || undefined,
        journeyDescription: route.journeyDescription || undefined,
      }
      : undefined,
  })

  const originId = watch("originId")
  const destinationId = watch("destinationId")

  useEffect(() => {
    if (route) {
      // Parse departure times from departureTimesDescription or schedules
      if (route.departureTimesDescription) {
        const times = route.departureTimesDescription.split(",").map(t => t.trim()).filter(Boolean)
        setDepartureTimes(times.map((time, index) => ({
          id: `departure-${index}-${Date.now()}`,
          time: time
        })))
      }
      // Parse rest stops
      if (route.restStops) {
        const stops = route.restStops.split(",").map(s => s.trim()).filter(Boolean)
        setRestStops(stops)
      }
      // Set provinces
      if (route.origin) {
        const province = getProvinceFromLocation(route.origin)
        setSelectedOriginProvince(province)
      }
      if (route.destination) {
        const province = getProvinceFromLocation(route.destination)
        setSelectedDestinationProvince(province)
      }
    }
  }, [route])

  // Update province when location changes
  useEffect(() => {
    const originLocation = locations.find(loc => loc.id === originId)
    if (originLocation) {
      const province = getProvinceFromLocation(originLocation)
      setSelectedOriginProvince(province)
      setValue("originProvince", province)
    }
  }, [originId, locations, setValue])

  useEffect(() => {
    const destinationLocation = locations.find(loc => loc.id === destinationId)
    if (destinationLocation) {
      const province = getProvinceFromLocation(destinationLocation)
      setSelectedDestinationProvince(province)
      setValue("destinationProvince", province)
    }
  }, [destinationId, locations, setValue])

  const addDepartureTime = () => {
    const newId = `departure-${Date.now()}-${Math.random()}`
    setDepartureTimes([...departureTimes, { id: newId, time: timeOptions[0] }])
  }

  const updateDepartureTime = (id: string, time: string) => {
    setDepartureTimes(departureTimes.map(dt =>
      dt.id === id ? { ...dt, time } : dt
    ))
  }

  const removeDepartureTime = (id: string) => {
    setDepartureTimes(departureTimes.filter(dt => dt.id !== id))
  }

  const addRestStop = () => {
    if (!newRestStop.trim()) {
      toast.warning("Vui lòng nhập tên điểm dừng nghỉ")
      return
    }
    if (restStops.includes(newRestStop.trim())) {
      toast.warning("Điểm dừng nghỉ này đã được thêm")
      return
    }
    setRestStops([...restStops, newRestStop.trim()])
    setNewRestStop("")
  }

  const removeRestStop = (index: number) => {
    setRestStops(restStops.filter((_, i) => i !== index))
  }

  const onSubmit = async (data: RouteFormData) => {
    try {
      const originLocation = locations.find(loc => loc.id === data.originId)
      const destinationLocation = locations.find(loc => loc.id === data.destinationId)
      const originName = originLocation?.name || ""
      const destinationName = destinationLocation?.name || ""
      const routeName = originName && destinationName ? `${originName} - ${destinationName}` : ""

      const routeData: RouteInput = {
        routeCode: data.routeCode,
        routeName: routeName || data.routeCode,
        originId: data.originId,
        destinationId: data.destinationId,
        distanceKm: data.distanceKm,
        plannedFrequency: data.plannedFrequency,
        boardingPoint: data.boardingPoint,
        journeyDescription: data.journeyDescription,
        departureTimesDescription: departureTimes.length > 0 ? departureTimes.map(dt => dt.time).join(", ") : undefined,
        restStops: restStops.length > 0 ? restStops.join(", ") : undefined,
      }

      if (mode === "create") {
        await routeService.create(routeData)
        toast.success("Thêm tuyến thành công")
      } else if (route) {
        await routeService.update(route.id, routeData)
        toast.success("Cập nhật tuyến thành công")
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to save route:", error)
      toast.error(
        error.response?.data?.error || "Không thể lưu tuyến. Vui lòng thử lại sau."
      )
    }
  }

  return (
    <form id="route-form" onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Thông tin chính */}
      <div>
        <h3 className="text-lg font-semibold mb-4">Thông tin chính</h3>
        <div className="grid grid-cols-2 gap-6">
          {/* Cột trái */}
          <div className="space-y-4">
            {/* Tỉnh đi */}
            <div className="space-y-2">
              <Label htmlFor="originProvince" className="text-base font-semibold">
                Tỉnh đi *
              </Label>
              <Select
                id="originProvince"
                value={selectedOriginProvince}
                onChange={(e) => {
                  setSelectedOriginProvince(e.target.value)
                  setValue("originProvince", e.target.value)
                  setValue("originId", "") // Reset bến đi khi đổi tỉnh
                }}
                className="h-11"
                disabled={isLoadingProvinces}
              >
                <option value="">
                  {isLoadingProvinces ? "Đang tải..." : "Chọn tỉnh đi"}
                </option>
                {provinces.map((province) => (
                  <option key={province.code} value={province.name}>
                    {province.name}
                  </option>
                ))}
              </Select>
              {errors.originProvince && (
                <p className="text-sm text-red-600 mt-1">{errors.originProvince.message}</p>
              )}
            </div>

            {/* Tỉnh đến */}
            <div className="space-y-2">
              <Label htmlFor="destinationProvince" className="text-base font-semibold">
                Tỉnh đến *
              </Label>
              <Select
                id="destinationProvince"
                value={selectedDestinationProvince}
                onChange={(e) => {
                  setSelectedDestinationProvince(e.target.value)
                  setValue("destinationProvince", e.target.value)
                  setValue("destinationId", "") // Reset bến đến khi đổi tỉnh
                }}
                className="h-11"
                disabled={isLoadingProvinces}
              >
                <option value="">
                  {isLoadingProvinces ? "Đang tải..." : "Chọn tỉnh đến"}
                </option>
                {provinces.map((province) => (
                  <option key={province.code} value={province.name}>
                    {province.name}
                  </option>
                ))}
              </Select>
              {errors.destinationProvince && (
                <p className="text-sm text-red-600 mt-1">{errors.destinationProvince.message}</p>
              )}
            </div>

            {/* Mã tuyến và Cự ly - cùng hàng */}
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="routeCode" className="text-base font-semibold">
                  Mã tuyến *
                </Label>
                <Input
                  id="routeCode"
                  className="h-11"
                  {...register("routeCode")}
                />
                {errors.routeCode && (
                  <p className="text-sm text-red-600 mt-1">{errors.routeCode.message}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="distanceKm" className="text-base font-semibold">
                  Cự ly *
                </Label>
                <Input
                  id="distanceKm"
                  type="number"
                  step="0.1"
                  className="h-11"
                  {...register("distanceKm", { valueAsNumber: true })}
                />
                {errors.distanceKm && (
                  <p className="text-sm text-red-600 mt-1">{errors.distanceKm.message}</p>
                )}
              </div>
            </div>
          </div>

          {/* Cột phải */}
          <div className="space-y-4">
            {/* Bến đi */}
            <div className="space-y-2">
              <Label htmlFor="originId" className="text-base font-semibold">
                Bến đi *
              </Label>
              <Select
                id="originId"
                className="h-11"
                disabled={!selectedOriginProvince}
                {...register("originId")}
              >
                <option value="">Chọn bến đi</option>
                {originLocations
                  .filter((loc, index, self) => 
                    index === self.findIndex(l => l.id === loc.id)
                  )
                  .map((loc) => (
                    <option key={loc.id} value={loc.id}>
                      {loc.name} ({loc.code})
                    </option>
                  ))}
              </Select>
              {errors.originId && (
                <p className="text-sm text-red-600 mt-1">{errors.originId.message}</p>
              )}
            </div>

            {/* Bến đến */}
            <div className="space-y-2">
              <Label htmlFor="destinationId" className="text-base font-semibold">
                Bến đến *
              </Label>
              <Select
                id="destinationId"
                className="h-11"
                disabled={!selectedDestinationProvince}
                {...register("destinationId")}
              >
                <option value="">Chọn bến đến</option>
                {destinationLocations
                  .filter((loc, index, self) => 
                    index === self.findIndex(l => l.id === loc.id) && loc.id !== originId
                  )
                  .map((loc) => (
                    <option key={loc.id} value={loc.id}>
                      {loc.name} ({loc.code})
                    </option>
                  ))}
              </Select>
              {errors.destinationId && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.destinationId.message}
                </p>
              )}
            </div>

            {/* Lưu lượng quy hoạch và Vị trí đỗ đón khách - cùng hàng */}
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="plannedFrequency" className="text-base font-semibold">
                  Lưu lượng quy hoạch *
                </Label>
                <Input
                  id="plannedFrequency"
                  type="number"
                  className="h-11"
                  defaultValue={0}
                  {...register("plannedFrequency")}
                />
                {errors.plannedFrequency && (
                  <p className="text-sm text-red-600 mt-1">{errors.plannedFrequency.message}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="boardingPoint" className="text-base font-semibold">
                  Vị trí đỗ đón khách của tuyến
                </Label>
                <Input
                  id="boardingPoint"
                  className="h-11"
                  {...register("boardingPoint")}
                />
                {errors.boardingPoint && (
                  <p className="text-sm text-red-600 mt-1">{errors.boardingPoint.message}</p>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Hành trình chạy */}
      <div className="space-y-2 border-t pt-6">
        <div className="flex items-center justify-between">
          <Label htmlFor="journeyDescription" className="text-base font-semibold">
            Hành trình chạy
          </Label>
        </div>
        <Textarea
          id="journeyDescription"
          rows={4}
          className="w-full"
          placeholder="Nhập mô tả hành trình chạy..."
          {...register("journeyDescription")}
        />
        {errors.journeyDescription && (
          <p className="text-sm text-red-600 mt-1">{errors.journeyDescription.message}</p>
        )}
      </div>

      {/* Hai card bên dưới */}
      <div className="grid grid-cols-2 gap-6">
        {/* Card trái: Giờ xuất bến */}
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <CardTitle className="text-base font-semibold">Giờ xuất bến</CardTitle>
              <Button type="button" onClick={addDepartureTime} variant="outline" size="sm">
                <Plus className="h-4 w-4 mr-1" />
                Thêm
              </Button>
            </div>
          </CardHeader>
          <CardContent className="space-y-3">
            {departureTimes.length > 0 ? (
              <div className="border rounded-lg overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-16">STT</TableHead>
                      <TableHead>Giờ xuất bến</TableHead>
                      <TableHead className="w-28">Thao tác</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {departureTimes.map((dt, index) => (
                      <TableRow key={dt.id}>
                        <TableCell className="text-center">{index + 1}</TableCell>
                        <TableCell>
                          <Select
                            value={dt.time}
                            onChange={(e) => updateDepartureTime(dt.id, e.target.value)}
                            className="h-9"
                          >
                            {timeOptions.map((time) => (
                              <option key={time} value={time}>
                                {time}
                              </option>
                            ))}
                          </Select>
                        </TableCell>
                        <TableCell>
                          <Button
                            type="button"
                            size="sm"
                            variant="ghost"
                            onClick={() => removeDepartureTime(dt.id)}
                          >
                            <Trash2 className="h-4 w-4 text-red-600" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            ) : (
              <p className="text-sm text-gray-500 text-center py-4">Không có dữ liệu</p>
            )}
            <div className="text-sm text-gray-500 text-center pt-2 border-t">
              Tổng: {departureTimes.length}
            </div>
          </CardContent>
        </Card>

        {/* Card phải: Tên điểm dừng nghỉ */}
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <CardTitle className="text-base font-semibold">Tên điểm dừng nghỉ</CardTitle>
              <Button
                type="button"
                onClick={addRestStop}
                variant="outline"
                size="sm"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
          </CardHeader>
          <CardContent className="space-y-3">
            <Input
              value={newRestStop}
              onChange={(e) => setNewRestStop(e.target.value)}
              placeholder="Nhập tên điểm dừng nghỉ"
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  e.preventDefault()
                  addRestStop()
                }
              }}
            />
            {restStops.length > 0 ? (
              <div className="border rounded-lg overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-16">STT</TableHead>
                      <TableHead>Tên điểm dừng nghỉ</TableHead>
                      <TableHead className="w-20">Thao tác</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {restStops.map((stop, index) => (
                      <TableRow key={index}>
                        <TableCell className="text-center">{index + 1}</TableCell>
                        <TableCell>{stop}</TableCell>
                        <TableCell>
                          <Button
                            type="button"
                            size="sm"
                            variant="ghost"
                            onClick={() => removeRestStop(index)}
                          >
                            <Trash2 className="h-4 w-4 text-red-600" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            ) : (
              <p className="text-sm text-gray-500 text-center py-4">Không có dữ liệu</p>
            )}
            <div className="text-sm text-gray-500 text-center pt-2 border-t">
              Tổng: {restStops.length}
            </div>
          </CardContent>
        </Card>
      </div>
    </form>
  )
}
</file>

<file path="client/src/components/route/RouteView.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Edit, Trash2, Clock, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Select } from "@/components/ui/select"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { scheduleService } from "@/services/schedule.service"
import { operatorService } from "@/services/operator.service"
import type { Route, Schedule, ScheduleInput, Operator } from "@/types"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { format } from "date-fns"

interface RouteViewProps {
  route: Route
}

export function RouteView({ route }: RouteViewProps) {
  const [activeTab, setActiveTab] = useState("info")
  const [schedules, setSchedules] = useState<Schedule[]>([])
  const [loadingSchedules, setLoadingSchedules] = useState(false)
  const [scheduleDialogOpen, setScheduleDialogOpen] = useState(false)
  const [selectedSchedule, setSelectedSchedule] = useState<Schedule | null>(null)
  const [scheduleViewMode, setScheduleViewMode] = useState<"create" | "edit">("create")
  const [operators, setOperators] = useState<Operator[]>([])

  useEffect(() => {
    if (activeTab === "schedules" && route.id) {
      loadSchedules()
      loadOperators()
    }
  }, [activeTab, route.id])

  const loadSchedules = async () => {
    setLoadingSchedules(true)
    try {
      const data = await scheduleService.getAll(route.id, undefined, undefined)
      setSchedules(data)
    } catch (error) {
      console.error("Failed to load schedules:", error)
      toast.error("Không thể tải danh sách biểu đồ giờ")
    } finally {
      setLoadingSchedules(false)
    }
  }

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true)
      setOperators(data)
    } catch (error) {
      console.error("Failed to load operators:", error)
    }
  }

  const handleCreateSchedule = () => {
    setSelectedSchedule(null)
    setScheduleViewMode("create")
    setScheduleDialogOpen(true)
  }

  const handleEditSchedule = (schedule: Schedule) => {
    setSelectedSchedule(schedule)
    setScheduleViewMode("edit")
    setScheduleDialogOpen(true)
  }

  const handleDeleteSchedule = async (id: string) => {
    if (window.confirm("Bạn có chắc chắn muốn xóa biểu đồ giờ này?")) {
      try {
        await scheduleService.delete(id)
        toast.success("Xóa biểu đồ giờ thành công")
        loadSchedules()
      } catch (error: any) {
        console.error("Failed to delete schedule:", error)
        toast.error(error.response?.data?.error || "Không thể xóa biểu đồ giờ")
      }
    }
  }

  const handleToggleScheduleStatus = async (schedule: Schedule) => {
    try {
      await scheduleService.update(schedule.id, { isActive: !schedule.isActive } as any)
      toast.success(`Đã ${schedule.isActive ? "vô hiệu hóa" : "kích hoạt"} biểu đồ giờ`)
      loadSchedules()
    } catch (error) {
      console.error("Failed to toggle schedule status:", error)
      toast.error("Không thể thay đổi trạng thái biểu đồ giờ")
    }
  }

  return (
    <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
      <TabsList className="grid w-full grid-cols-4">
        <TabsTrigger value="info">Thông tin cơ bản</TabsTrigger>
        <TabsTrigger value="stops">Điểm dừng</TabsTrigger>
        <TabsTrigger value="schedules">Biểu đồ giờ</TabsTrigger>
        <TabsTrigger value="stats">Thống kê</TabsTrigger>
      </TabsList>
      <TabsContent value="info" className="space-y-6 mt-6">
        <div className="grid grid-cols-2 gap-6">
          <div className="space-y-2">
            <Label className="text-base font-semibold">Mã tuyến</Label>
            <p className="text-lg font-medium text-gray-900">{route.routeCode}</p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Tên tuyến</Label>
            <p className="text-lg font-medium text-gray-900">{route.routeName}</p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Điểm đi</Label>
            <p className="text-lg font-medium text-gray-900">
              {route.origin?.name || "N/A"} ({route.origin?.code || "N/A"})
            </p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Điểm đến</Label>
            <p className="text-lg font-medium text-gray-900">
              {route.destination?.name || "N/A"} ({route.destination?.code || "N/A"})
            </p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Khoảng cách</Label>
            <p className="text-lg font-medium text-gray-900">
              {route.distanceKm ? `${route.distanceKm} km` : "N/A"}
            </p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Thời gian ước tính</Label>
            <p className="text-lg font-medium text-gray-900">
              {route.estimatedDurationMinutes
                ? `${route.estimatedDurationMinutes} phút`
                : "N/A"}
            </p>
          </div>
          <div className="space-y-2">
            <Label className="text-base font-semibold">Trạng thái</Label>
            <StatusBadge status={route.isActive ? "active" : "inactive"} />
          </div>
        </div>
      </TabsContent>
      <TabsContent value="stops" className="space-y-4 mt-6">
        {route.stops && route.stops.length > 0 ? (
          <div className="space-y-3">
            {route.stops.map((stop) => (
              <Card key={stop.id}>
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <div className="flex items-center justify-center w-8 h-8 rounded-full bg-blue-100 text-blue-700 font-semibold">
                        {stop.stopOrder}
                      </div>
                      <div>
                        <p className="font-medium">
                          {stop.location?.name || "Điểm dừng"}
                        </p>
                        <p className="text-sm text-gray-500">
                          {stop.location?.code || ""}
                        </p>
                      </div>
                    </div>
                    <div className="text-right text-sm text-gray-600">
                      {stop.distanceFromOriginKm && (
                        <p>Khoảng cách: {stop.distanceFromOriginKm} km</p>
                      )}
                      {stop.estimatedMinutesFromOrigin && (
                        <p>Thời gian: {stop.estimatedMinutesFromOrigin} phút</p>
                      )}
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        ) : (
          <p className="text-sm text-gray-500 text-center py-8">
            Không có điểm dừng
          </p>
        )}
      </TabsContent>
      <TabsContent value="schedules" className="space-y-4 mt-6">
        <div className="flex justify-between items-center mb-4">
          <Label className="text-base font-semibold">Danh sách biểu đồ giờ</Label>
          <Button onClick={handleCreateSchedule} size="sm">
            <Plus className="h-4 w-4 mr-1" />
            Thêm biểu đồ giờ
          </Button>
        </div>
        {loadingSchedules ? (
          <p className="text-center py-8">Đang tải...</p>
        ) : schedules.length > 0 ? (
          <div className="space-y-2">
            {schedules.map((schedule) => (
              <Card key={schedule.id}>
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-3">
                        <p className="font-medium">{schedule.scheduleCode}</p>
                        <StatusBadge
                          status={schedule.isActive ? "active" : "inactive"}
                        />
                      </div>
                      <div className="mt-2 space-y-1">
                        <p className="text-sm text-gray-600">
                          <Clock className="h-3 w-3 inline mr-1" />
                          Giờ xuất bến: {format(new Date(`2000-01-01T${schedule.departureTime}`), "HH:mm")}
                        </p>
                        <p className="text-sm text-gray-600">
                          Nhà xe: {schedule.operator?.name || "N/A"}
                        </p>
                        <p className="text-sm text-gray-600">
                          Tần suất: {
                            schedule.frequencyType === "daily" ? "Hàng ngày" :
                            schedule.frequencyType === "weekly" ? "Hàng tuần" :
                            schedule.frequencyType === "specific_days" ? `Thứ ${schedule.daysOfWeek?.join(", ")}` :
                            "N/A"
                          }
                        </p>
                        <p className="text-sm text-gray-600">
                          Hiệu lực từ: {format(new Date(schedule.effectiveFrom), "dd/MM/yyyy")}
                          {schedule.effectiveTo && ` đến ${format(new Date(schedule.effectiveTo), "dd/MM/yyyy")}`}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleEditSchedule(schedule)}
                        aria-label="Sửa"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleToggleScheduleStatus(schedule)}
                        aria-label={schedule.isActive ? "Vô hiệu hóa" : "Kích hoạt"}
                        title={schedule.isActive ? "Vô hiệu hóa" : "Kích hoạt"}
                      >
                        {schedule.isActive ? (
                          <X className="h-4 w-4 text-orange-600" />
                        ) : (
                          <Plus className="h-4 w-4 text-green-600" />
                        )}
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleDeleteSchedule(schedule.id)}
                        aria-label="Xóa"
                      >
                        <Trash2 className="h-4 w-4 text-red-600" />
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        ) : (
          <p className="text-sm text-gray-500 text-center py-8">
            Không có biểu đồ giờ. Nhấn "Thêm biểu đồ giờ" để tạo mới.
          </p>
        )}
      </TabsContent>
      <TabsContent value="stats" className="mt-6">
        <div className="grid grid-cols-2 gap-4">
          <Card>
            <CardContent className="p-4">
              <p className="text-sm text-gray-600">Số điểm dừng</p>
              <p className="text-2xl font-bold">{route.stops?.length || 0}</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <p className="text-sm text-gray-600">Số biểu đồ giờ</p>
              <p className="text-2xl font-bold">{schedules.length}</p>
            </CardContent>
          </Card>
        </div>
        <p className="text-sm text-gray-500 mt-4">
          Thống kê chi tiết sẽ được cập nhật sau
        </p>
      </TabsContent>

      {/* Schedule Dialog */}
      <Dialog open={scheduleDialogOpen} onOpenChange={setScheduleDialogOpen}>
        <DialogContent className="max-w-3xl w-full max-h-[95vh] overflow-y-auto p-6">
          <DialogClose onClose={() => setScheduleDialogOpen(false)} />
          <DialogHeader>
            <DialogTitle className="text-2xl">
              {scheduleViewMode === "create" && "Thêm biểu đồ giờ mới"}
              {scheduleViewMode === "edit" && "Sửa biểu đồ giờ"}
            </DialogTitle>
          </DialogHeader>
          <div className="mt-4">
            <ScheduleForm
              schedule={selectedSchedule}
              routeId={route.id}
              operators={operators}
              mode={scheduleViewMode}
              onClose={() => {
                setScheduleDialogOpen(false)
                loadSchedules()
              }}
            />
          </div>
        </DialogContent>
      </Dialog>
    </Tabs>
  )
}

function ScheduleForm({
  schedule,
  routeId,
  operators,
  mode,
  onClose,
}: {
  schedule: Schedule | null
  routeId: string
  operators: Operator[]
  mode: "create" | "edit"
  onClose: () => void
}) {
  const [selectedDays, setSelectedDays] = useState<number[]>([])

  const scheduleSchema = z.object({
    scheduleCode: z.string().optional(), // Optional - will be auto-generated by backend
    operatorId: z.string().uuid("Vui lòng chọn nhà xe"),
    departureTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, "Định dạng giờ không hợp lệ (HH:MM)"),
    frequencyType: z.enum(['daily', 'weekly', 'specific_days']),
    daysOfWeek: z.array(z.number().int().min(1).max(7)).optional(),
    effectiveFrom: z.string().min(1, "Ngày hiệu lực từ là bắt buộc"),
    effectiveTo: z.string().optional(),
  }).refine((data) => {
    if (data.frequencyType === 'specific_days') {
      return data.daysOfWeek && data.daysOfWeek.length > 0
    }
    return true
  }, {
    message: "Vui lòng chọn ít nhất một ngày trong tuần",
    path: ["daysOfWeek"],
  })

  type ScheduleFormData = z.infer<typeof scheduleSchema>

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm<ScheduleFormData>({
    resolver: zodResolver(scheduleSchema),
    defaultValues: schedule
      ? {
          scheduleCode: schedule.scheduleCode,
          operatorId: schedule.operatorId,
          departureTime: schedule.departureTime,
          frequencyType: schedule.frequencyType,
          daysOfWeek: schedule.daysOfWeek || [],
          effectiveFrom: schedule.effectiveFrom ? new Date(schedule.effectiveFrom).toISOString().split("T")[0] : "",
          effectiveTo: schedule.effectiveTo ? new Date(schedule.effectiveTo).toISOString().split("T")[0] : "",
        }
      : {
          frequencyType: 'daily',
          effectiveFrom: new Date().toISOString().split("T")[0],
        },
  })

  useEffect(() => {
    if (schedule) {
      setSelectedDays(schedule.daysOfWeek || [])
    }
  }, [schedule])

  const currentFrequencyType = watch("frequencyType")

  useEffect(() => {
    if (currentFrequencyType !== 'specific_days') {
      setSelectedDays([])
      setValue("daysOfWeek", [])
    }
  }, [currentFrequencyType, setValue])

  const toggleDay = (day: number) => {
    const newDays = selectedDays.includes(day)
      ? selectedDays.filter((d) => d !== day)
      : [...selectedDays, day].sort()
    setSelectedDays(newDays)
    setValue("daysOfWeek", newDays)
  }

  const dayLabels: Record<number, string> = {
    1: "Thứ 2",
    2: "Thứ 3",
    3: "Thứ 4",
    4: "Thứ 5",
    5: "Thứ 6",
    6: "Thứ 7",
    7: "Chủ nhật",
  }

  const onSubmit = async (data: ScheduleFormData) => {
    try {
      const scheduleData: ScheduleInput = {
        scheduleCode: data.scheduleCode || undefined, // Will be auto-generated if not provided
        routeId: routeId,
        operatorId: data.operatorId,
        departureTime: data.departureTime,
        frequencyType: data.frequencyType,
        daysOfWeek: data.frequencyType === 'specific_days' ? data.daysOfWeek : undefined,
        effectiveFrom: data.effectiveFrom,
        effectiveTo: data.effectiveTo || undefined,
      }

      if (mode === "create") {
        await scheduleService.create(scheduleData)
        toast.success("Thêm biểu đồ giờ thành công")
      } else if (schedule) {
        await scheduleService.update(schedule.id, scheduleData)
        toast.success("Cập nhật biểu đồ giờ thành công")
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to save schedule:", error)
      toast.error(
        error.response?.data?.error || "Không thể lưu biểu đồ giờ. Vui lòng thử lại sau."
      )
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {mode === "edit" && schedule?.scheduleCode && (
        <div className="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
          <Label className="text-sm font-semibold text-blue-900">Mã biểu đồ giờ</Label>
          <p className="text-lg font-mono text-blue-700 mt-1">{schedule.scheduleCode}</p>
          <p className="text-xs text-blue-600 mt-1">Mã được tạo tự động bởi hệ thống</p>
        </div>
      )}
      {mode === "create" && (
        <div className="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
          <p className="text-sm text-gray-600">
            <span className="font-semibold">Lưu ý:</span> Mã biểu đồ giờ sẽ được tạo tự động sau khi lưu.
            Định dạng: BDG-{'{'}Mã tuyến{'}'}-{'{'}Mã nhà xe{'}'}-{'{'}Giờ xuất bến{'}'}
          </p>
        </div>
      )}
      <div className="grid grid-cols-2 gap-6">
        <div className="space-y-2">
          <Label htmlFor="operatorId" className="text-base font-semibold">
            Nhà xe *
          </Label>
          <Select
            id="operatorId"
            className="h-11"
            {...register("operatorId")}
          >
            <option value="">Chọn nhà xe</option>
            {operators.map((op) => (
              <option key={op.id} value={op.id}>
                {op.name} ({op.code})
              </option>
            ))}
          </Select>
          {errors.operatorId && (
            <p className="text-sm text-red-600 mt-1">{errors.operatorId.message}</p>
          )}
        </div>
        <div className="space-y-2">
          <Label htmlFor="departureTime" className="text-base font-semibold">
            Giờ xuất bến (HH:MM) *
          </Label>
          <Input
            id="departureTime"
            type="time"
            lang="en-GB"
            className="h-11"
            {...register("departureTime")}
          />
          {errors.departureTime && (
            <p className="text-sm text-red-600 mt-1">{errors.departureTime.message}</p>
          )}
        </div>
        <div className="space-y-2">
          <Label htmlFor="frequencyType" className="text-base font-semibold">
            Tần suất *
          </Label>
          <Select
            id="frequencyType"
            className="h-11"
            {...register("frequencyType")}
          >
            <option value="daily">Hàng ngày</option>
            <option value="weekly">Hàng tuần</option>
            <option value="specific_days">Ngày cụ thể trong tuần</option>
          </Select>
          {errors.frequencyType && (
            <p className="text-sm text-red-600 mt-1">{errors.frequencyType.message}</p>
          )}
        </div>
        {currentFrequencyType === 'specific_days' && (
          <div className="space-y-2 col-span-2">
            <Label className="text-base font-semibold">Chọn ngày trong tuần *</Label>
            <div className="flex flex-wrap gap-2">
              {[1, 2, 3, 4, 5, 6, 7].map((day) => (
                <Button
                  key={day}
                  type="button"
                  variant={selectedDays.includes(day) ? "default" : "outline"}
                  onClick={() => toggleDay(day)}
                  className="min-w-[100px]"
                >
                  {dayLabels[day]}
                </Button>
              ))}
            </div>
            {errors.daysOfWeek && (
              <p className="text-sm text-red-600 mt-1">{errors.daysOfWeek.message}</p>
            )}
          </div>
        )}
        <div className="space-y-2">
          <Label htmlFor="effectiveFrom" className="text-base font-semibold">
            Hiệu lực từ *
          </Label>
          <Input
            id="effectiveFrom"
            type="date"
            className="h-11"
            {...register("effectiveFrom")}
          />
          {errors.effectiveFrom && (
            <p className="text-sm text-red-600 mt-1">{errors.effectiveFrom.message}</p>
          )}
        </div>
        <div className="space-y-2">
          <Label htmlFor="effectiveTo" className="text-base font-semibold">
            Hiệu lực đến
          </Label>
          <Input
            id="effectiveTo"
            type="date"
            className="h-11"
            {...register("effectiveTo")}
          />
          {errors.effectiveTo && (
            <p className="text-sm text-red-600 mt-1">{errors.effectiveTo.message}</p>
          )}
        </div>
      </div>

      <div className="flex justify-end gap-3 pt-4 border-t">
        <Button type="button" variant="outline" onClick={onClose} className="min-w-[100px]">
          Hủy
        </Button>
        <Button type="submit" className="min-w-[100px]">
          Lưu
        </Button>
      </div>
    </form>
  )
}
</file>

<file path="client/src/components/service/FormulaDialog.tsx">
import { useEffect } from "react"
import { toast } from "react-toastify"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { serviceFormulaService } from "@/services/service-formula.service"
import type { ServiceFormula, ServiceFormulaInput } from "@/types"

const formulaSchema = z.object({
  code: z.string().min(1, "Mã biểu thức là bắt buộc"),
  name: z.string().min(1, "Tên biểu thức là bắt buộc"),
  description: z.string().optional(),
  formulaType: z.enum(['quantity', 'price'], {
    errorMap: () => ({ message: "Loại biểu thức phải là 'quantity' hoặc 'price'" }),
  }),
  formulaExpression: z.string().optional(),
  isActive: z.boolean().default(true),
})

type FormulaFormData = z.infer<typeof formulaSchema>

interface FormulaDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  viewMode: "create" | "edit" | "view"
  selectedFormula: ServiceFormula | null
  onSuccess: () => void
  defaultFormulaType?: 'quantity' | 'price'
}

export function FormulaDialog({
  open,
  onOpenChange,
  viewMode,
  selectedFormula,
  onSuccess,
  defaultFormulaType,
}: FormulaDialogProps) {
  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<FormulaFormData>({
    resolver: zodResolver(formulaSchema),
    defaultValues: {
      isActive: true,
      formulaType: defaultFormulaType || 'quantity',
    },
  })

  useEffect(() => {
    if (selectedFormula && (viewMode === "edit" || viewMode === "view")) {
      reset({
        code: selectedFormula.code,
        name: selectedFormula.name,
        description: selectedFormula.description || "",
        formulaType: selectedFormula.formulaType,
        formulaExpression: selectedFormula.formulaExpression || "",
        isActive: selectedFormula.isActive,
      })
    } else {
      reset({
        code: "",
        name: "",
        description: "",
        formulaType: defaultFormulaType || 'quantity',
        formulaExpression: "",
        isActive: true,
      })
    }
  }, [selectedFormula, viewMode, reset, defaultFormulaType])

  const onSubmit = async (data: FormulaFormData) => {
    try {
      const formulaData: ServiceFormulaInput = {
        code: data.code,
        name: data.name,
        description: data.description,
        formulaType: data.formulaType,
        formulaExpression: data.formulaExpression,
        isActive: data.isActive,
      }

      if (viewMode === "create") {
        await serviceFormulaService.create(formulaData)
        toast.success("Thêm biểu thức thành công")
      } else if (viewMode === "edit" && selectedFormula) {
        await serviceFormulaService.update(selectedFormula.id, formulaData)
        toast.success("Cập nhật biểu thức thành công")
      }
      onOpenChange(false)
      onSuccess()
    } catch (error: any) {
      console.error("Failed to save formula:", error)
      toast.error(
        error.response?.data?.error ||
        error.response?.data?.message ||
          `Không thể ${viewMode === "create" ? "thêm" : "cập nhật"} biểu thức. Vui lòng thử lại.`
      )
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[95vw] sm:w-[90vw] md:w-[85vw] lg:w-[800px] max-w-4xl max-h-[95vh] sm:max-h-[90vh] overflow-y-auto p-4 sm:p-6">
        <DialogHeader>
          <DialogTitle className="text-xl sm:text-2xl">
            {viewMode === "create" && "Thêm biểu thức mới"}
            {viewMode === "edit" && "Sửa thông tin biểu thức"}
            {viewMode === "view" && "Chi tiết biểu thức"}
          </DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit(onSubmit)} className="mt-4 space-y-4 sm:space-y-6">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="code">
                Mã biểu thức <span className="text-red-500">(*)</span>
              </Label>
              <Input
                id="code"
                placeholder="Mã biểu thức"
                {...register("code")}
                disabled={viewMode === "view"}
                className={errors.code ? "border-red-500" : ""}
              />
              {errors.code && (
                <p className="text-sm text-red-500 mt-1">
                  {errors.code.message}
                </p>
              )}
            </div>

            <div>
              <Label htmlFor="formulaType">
                Loại biểu thức <span className="text-red-500">(*)</span>
              </Label>
              <Select
                id="formulaType"
                {...register("formulaType")}
                disabled={viewMode === "view" || viewMode === "edit"}
                className={errors.formulaType ? "border-red-500" : ""}
              >
                <option value="quantity">Tính số lượng</option>
                <option value="price">Tính đơn giá</option>
              </Select>
              {errors.formulaType && (
                <p className="text-sm text-red-500 mt-1">
                  {errors.formulaType.message}
                </p>
              )}
            </div>

            <div className="sm:col-span-2">
              <Label htmlFor="name">
                Tên biểu thức <span className="text-red-500">(*)</span>
              </Label>
              <Input
                id="name"
                placeholder="Tên biểu thức"
                {...register("name")}
                disabled={viewMode === "view"}
                className={errors.name ? "border-red-500" : ""}
              />
              {errors.name && (
                <p className="text-sm text-red-500 mt-1">
                  {errors.name.message}
                </p>
              )}
            </div>

            <div className="sm:col-span-2">
              <Label htmlFor="description">Ghi chú</Label>
              <textarea
                id="description"
                {...register("description")}
                disabled={viewMode === "view"}
                rows={3}
                className="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                placeholder="Nhập ghi chú..."
              />
            </div>

            <div className="sm:col-span-2">
              <Label htmlFor="formulaExpression">Biểu thức công thức</Label>
              <div className="mt-1 space-y-2">
                {/* Formula Builder */}
                {viewMode !== "view" && (
                  <div className="border border-gray-300 rounded-md p-3 bg-gray-50">
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                      {/* Available Fields */}
                      <div>
                        <label className="text-xs font-medium text-gray-600 mb-1 block">Trường dữ liệu</label>
                        <select 
                          className="w-full text-xs px-2 py-1 border border-gray-300 rounded"
                          onChange={(e) => {
                            if (e.target.value) {
                              const textarea = document.getElementById('formulaExpression') as HTMLTextAreaElement;
                              if (textarea) {
                                const start = textarea.selectionStart;
                                const end = textarea.selectionEnd;
                                const text = textarea.value;
                                const newText = text.substring(0, start) + e.target.value + text.substring(end);
                                textarea.value = newText;
                                textarea.focus();
                                textarea.setSelectionRange(start + e.target.value.length, start + e.target.value.length);
                                // Trigger change event
                                const event = new Event('input', { bubbles: true });
                                textarea.dispatchEvent(event);
                              }
                              e.target.value = '';
                            }
                          }}
                        >
                          <option value="">Chọn trường</option>
                          <option value="seatCount">seatCount (Số ghế)</option>
                          <option value="bedCount">bedCount (Số giường)</option>
                          <option value="distance">distance (Khoảng cách)</option>
                          <option value="basePrice">basePrice (Giá cơ bản)</option>
                          <option value="fuelPrice">fuelPrice (Giá xăng)</option>
                          <option value="routeType">routeType (Loại tuyến)</option>
                          <option value="vehicleType">vehicleType (Loại xe)</option>
                          <option value="dayOfWeek">dayOfWeek (Thứ trong tuần)</option>
                          <option value="isHoliday">isHoliday (Ngày lễ)</option>
                        </select>
                      </div>

                      {/* Operators */}
                      <div>
                        <label className="text-xs font-medium text-gray-600 mb-1 block">Phép tính</label>
                        <select 
                          className="w-full text-xs px-2 py-1 border border-gray-300 rounded"
                          onChange={(e) => {
                            if (e.target.value) {
                              const textarea = document.getElementById('formulaExpression') as HTMLTextAreaElement;
                              if (textarea) {
                                const start = textarea.selectionStart;
                                const end = textarea.selectionEnd;
                                const text = textarea.value;
                                const newText = text.substring(0, start) + ' ' + e.target.value + ' ' + text.substring(end);
                                textarea.value = newText;
                                textarea.focus();
                                textarea.setSelectionRange(start + e.target.value.length + 2, start + e.target.value.length + 2);
                                // Trigger change event
                                const event = new Event('input', { bubbles: true });
                                textarea.dispatchEvent(event);
                              }
                              e.target.value = '';
                            }
                          }}
                        >
                          <option value="">Chọn phép tính</option>
                          <option value="+">+ (Cộng)</option>
                          <option value="-">- (Trừ)</option>
                          <option value="*">* (Nhân)</option>
                          <option value="/"># (Chia)</option>
                          <option value="%">% (Chia lấy dư)</option>
                          <option value="**">** (Lũy thừa)</option>
                        </select>
                      </div>

                      {/* Functions */}
                      <div>
                        <label className="text-xs font-medium text-gray-600 mb-1 block">Hàm</label>
                        <select 
                          className="w-full text-xs px-2 py-1 border border-gray-300 rounded"
                          onChange={(e) => {
                            if (e.target.value) {
                              const textarea = document.getElementById('formulaExpression') as HTMLTextAreaElement;
                              if (textarea) {
                                const start = textarea.selectionStart;
                                const end = textarea.selectionEnd;
                                const text = textarea.value;
                                const newText = text.substring(0, start) + e.target.value + text.substring(end);
                                textarea.value = newText;
                                textarea.focus();
                                const newPos = start + e.target.value.length - 1; // Position cursor inside parentheses
                                textarea.setSelectionRange(newPos, newPos);
                                // Trigger change event
                                const event = new Event('input', { bubbles: true });
                                textarea.dispatchEvent(event);
                              }
                              e.target.value = '';
                            }
                          }}
                        >
                          <option value="">Chọn hàm</option>
                          <option value="Math.max()">Math.max() (Giá trị lớn nhất)</option>
                          <option value="Math.min()">Math.min() (Giá trị nhỏ nhất)</option>
                          <option value="Math.round()">Math.round() (Làm tròn)</option>
                          <option value="Math.ceil()">Math.ceil() (Làm tròn lên)</option>
                          <option value="Math.floor()">Math.floor() (Làm tròn xuống)</option>
                          <option value="Math.abs()">Math.abs() (Giá trị tuyệt đối)</option>
                          <option value="parseFloat()">parseFloat() (Chuyển số thực)</option>
                          <option value="parseInt()">parseInt() (Chuyển số nguyên)</option>
                        </select>
                      </div>

                      {/* Conditions */}
                      <div>
                        <label className="text-xs font-medium text-gray-600 mb-1 block">Điều kiện</label>
                        <select 
                          className="w-full text-xs px-2 py-1 border border-gray-300 rounded"
                          onChange={(e) => {
                            if (e.target.value) {
                              const textarea = document.getElementById('formulaExpression') as HTMLTextAreaElement;
                              if (textarea) {
                                const start = textarea.selectionStart;
                                const end = textarea.selectionEnd;
                                const text = textarea.value;
                                const newText = text.substring(0, start) + e.target.value + text.substring(end);
                                textarea.value = newText;
                                textarea.focus();
                                // Trigger change event
                                const event = new Event('input', { bubbles: true });
                                textarea.dispatchEvent(event);
                              }
                              e.target.value = '';
                            }
                          }}
                        >
                          <option value="">Chọn điều kiện</option>
                          <option value=" > ">&gt; (Lớn hơn)</option>
                          <option value=" < ">&lt; (Nhỏ hơn)</option>
                          <option value=" >= ">&gt;= (Lớn hơn hoặc bằng)</option>
                          <option value=" <= ">&lt;= (Nhỏ hơn hoặc bằng)</option>
                          <option value=" == "> == (Bằng)</option>
                          <option value=" != "> != (Khác)</option>
                          <option value=" && "> && (Và)</option>
                          <option value=" || "> || (Hoặc)</option>
                          <option value="condition ? value1 : value2">condition ? value1 : value2 (If-else)</option>
                        </select>
                      </div>
                    </div>

                    {/* Quick Insert Buttons */}
                    <div className="flex flex-wrap gap-1">
                      {['(', ')', '[', ']', '{', '}', ',', ';'].map((char) => (
                        <button
                          key={char}
                          type="button"
                          className="px-2 py-1 text-xs bg-white border border-gray-300 rounded hover:bg-gray-100"
                          onClick={() => {
                            const textarea = document.getElementById('formulaExpression') as HTMLTextAreaElement;
                            if (textarea) {
                              const start = textarea.selectionStart;
                              const end = textarea.selectionEnd;
                              const text = textarea.value;
                              const newText = text.substring(0, start) + char + text.substring(end);
                              textarea.value = newText;
                              textarea.focus();
                              textarea.setSelectionRange(start + 1, start + 1);
                              // Trigger change event
                              const event = new Event('input', { bubbles: true });
                              textarea.dispatchEvent(event);
                            }
                          }}
                        >
                          {char}
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                {/* Formula Expression Textarea */}
                <textarea
                  id="formulaExpression"
                  {...register("formulaExpression")}
                  disabled={viewMode === "view"}
                  rows={6}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none font-mono text-sm"
                  placeholder="Nhập biểu thức công thức hoặc sử dụng các dropdown bên trên để xây dựng..."
                />

                {/* Formula Examples */}
                <div className="text-xs text-gray-600 bg-blue-50 p-2 rounded">
                  <strong>Ví dụ:</strong>
                  <div className="mt-1 space-y-1">
                    <div>• Tính số lượng: <code className="bg-white px-1 rounded">seatCount &gt; 30 ? seatCount * 1.2 : seatCount</code></div>
                    <div>• Tính đơn giá: <code className="bg-white px-1 rounded">basePrice + (distance * 0.5) + (isHoliday ? 50000 : 0)</code></div>
                    <div>• Sử dụng hàm: <code className="bg-white px-1 rounded">Math.max(basePrice, 100000) * (seatCount / 45)</code></div>
                  </div>
                </div>
              </div>
            </div>

            {viewMode !== "view" && (
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="isActive"
                  {...register("isActive")}
                  className="h-4 w-4"
                />
                <Label htmlFor="isActive" className="cursor-pointer">
                  Kích hoạt
                </Label>
              </div>
            )}
          </div>

          {viewMode === "view" && selectedFormula && (
            <div>
              <Label>Trạng thái</Label>
              <div className="mt-2">
                <StatusBadge
                  status={selectedFormula.isActive ? "active" : "inactive"}
                />
              </div>
            </div>
          )}

          <div className="flex flex-col-reverse sm:flex-row justify-end gap-2 sm:gap-2 pt-4 border-t">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="w-full sm:w-auto"
            >
              {viewMode === "view" ? "Đóng" : "Hủy"}
            </Button>
            {viewMode !== "view" && (
              <Button type="submit" className="w-full sm:w-auto">
                {viewMode === "create" ? "Thêm" : "Cập nhật"}
              </Button>
            )}
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/shared/EmptyState.tsx">
import { memo } from "react";
import { LucideIcon, Inbox } from "lucide-react";
import { cn } from "@/lib/utils";

interface EmptyStateProps {
  icon?: LucideIcon;
  title: string;
  description?: string;
  action?: React.ReactNode;
  className?: string;
}

export const EmptyState = memo(function EmptyState({
  icon: Icon = Inbox,
  title,
  description,
  action,
  className,
}: EmptyStateProps) {
  return (
    <div className={cn("flex flex-col items-center justify-center py-12 text-center", className)}>
      <div className="w-16 h-16 rounded-full bg-slate-100 flex items-center justify-center mb-4">
        <Icon className="w-8 h-8 text-slate-400" />
      </div>
      <h3 className="text-lg font-semibold text-slate-900 mb-1">{title}</h3>
      {description && <p className="text-sm text-slate-500 max-w-sm mb-4">{description}</p>}
      {action && <div className="mt-2">{action}</div>}
    </div>
  );
});
</file>

<file path="client/src/components/shared/index.ts">
export { EmptyState } from "./EmptyState";
export { LoadingSpinner } from "./LoadingSpinner";
</file>

<file path="client/src/components/shared/LoadingSpinner.tsx">
import { memo } from "react";
import { Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  text?: string;
  className?: string;
  fullScreen?: boolean;
}

const sizeClasses = {
  sm: "w-4 h-4",
  md: "w-6 h-6",
  lg: "w-8 h-8",
};

export const LoadingSpinner = memo(function LoadingSpinner({
  size = "md",
  text,
  className,
  fullScreen = false,
}: LoadingSpinnerProps) {
  const content = (
    <div className={cn("flex flex-col items-center justify-center gap-2", className)}>
      <Loader2 className={cn("animate-spin text-blue-600", sizeClasses[size])} />
      {text && <p className="text-sm text-slate-500">{text}</p>}
    </div>
  );

  if (fullScreen) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-white/80 backdrop-blur-sm">
        {content}
      </div>
    );
  }

  return content;
});
</file>

<file path="client/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "bg-gray-100 text-gray-800",
        success: "bg-green-100 text-green-800",
        warning: "bg-yellow-100 text-yellow-800",
        danger: "bg-red-100 text-red-800",
        secondary: "bg-blue-100 text-blue-800",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="client/src/components/ui/button.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-white hover:bg-blue-700",
        destructive:
          "bg-destructive text-white hover:bg-red-600",
        outline:
          "border border-gray-300 bg-white hover:bg-gray-50 text-gray-700",
        secondary:
          "bg-gray-100 text-gray-900 hover:bg-gray-200",
        ghost: "hover:bg-gray-100 hover:text-gray-900",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="client/src/components/ui/calendar.tsx">
import * as React from "react"
import { ChevronLeftIcon, ChevronRightIcon } from "lucide-react"
import { DayButton, DayPicker, getDefaultClassNames } from "react-day-picker"
import { vi } from "date-fns/locale"
import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: CalendarProps) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      locale={vi}
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("vi-VN", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next
        ),
        month_caption: cn(
          "flex items-center justify-center h-[--cell-size] w-full px-[--cell-size]",
          defaultClassNames.month_caption
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-[--cell-size] gap-1.5",
          defaultClassNames.dropdowns
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root
        ),
        dropdown: cn("absolute inset-0 opacity-0", defaultClassNames.dropdown),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-[--cell-size]",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          defaultClassNames.day
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return <span />
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

Calendar.displayName = "Calendar"

export { Calendar, CalendarDayButton }
</file>

<file path="client/src/components/ui/card.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border border-gray-200 bg-white text-gray-950 shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="client/src/components/ui/checkbox.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

export interface CheckboxProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, ...props }, ref) => {
    return (
      <input
        type="checkbox"
        className={cn(
          "h-4 w-4 rounded border-gray-300 text-primary focus:ring-2 focus:ring-blue-500",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Checkbox.displayName = "Checkbox"

export { Checkbox }
</file>

<file path="client/src/components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="client/src/components/ui/label.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

export interface LabelProps
  extends React.LabelHTMLAttributes<HTMLLabelElement> {}

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => (
    <label
      ref={ref}
      className={cn(
        "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        className
      )}
      {...props}
    />
  )
)
Label.displayName = "Label"

export { Label }
</file>

<file path="client/src/components/ui/month-picker.tsx">
"use client";

import * as React from "react";

import { ChevronLeft, ChevronRight } from "lucide-react";

import { buttonVariants } from "./button";

import { cn } from "@/lib/utils";

type Month = {
  number: number;
  name: string;
};

const MONTHS: Month[][] = [
  [
    { number: 0, name: "Tháng 1" },
    { number: 1, name: "Tháng 2" },
    { number: 2, name: "Tháng 3" },
    { number: 3, name: "Tháng 4" },
  ],
  [
    { number: 4, name: "Tháng 5" },
    { number: 5, name: "Tháng 6" },
    { number: 6, name: "Tháng 7" },
    { number: 7, name: "Tháng 8" },
  ],
  [
    { number: 8, name: "Tháng 9" },
    { number: 9, name: "Tháng 10" },
    { number: 10, name: "Tháng 11" },
    { number: 11, name: "Tháng 12" },
  ],
];

type MonthCalProps = {
  selectedMonth?: Date;
  onMonthSelect?: (date: Date) => void;
  onYearForward?: () => void;
  onYearBackward?: () => void;
  callbacks?: {
    yearLabel?: (year: number) => string;
    monthLabel?: (month: Month) => string;
  };
  variant?: {
    calendar?: {
      main?: ButtonVariant;
      selected?: ButtonVariant;
    };
    chevrons?: ButtonVariant;
  };
  minDate?: Date;
  maxDate?: Date;
  disabledDates?: Date[];
};

type ButtonVariant = "default" | "outline" | "ghost" | "link" | "destructive" | "secondary" | null | undefined;

function MonthPicker({
  onMonthSelect,
  selectedMonth,
  minDate,
  maxDate,
  disabledDates,
  callbacks,
  onYearBackward,
  onYearForward,
  variant,
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement> & MonthCalProps) {
  return (
    <div className={cn("min-w-[200px] w-[280px] p-3", className)} {...props}>
      <div className="flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0">
        <div className="space-y-4 w-full">
          <MonthCal
            onMonthSelect={onMonthSelect}
            callbacks={callbacks}
            selectedMonth={selectedMonth}
            onYearBackward={onYearBackward}
            onYearForward={onYearForward}
            variant={variant}
            minDate={minDate}
            maxDate={maxDate}
            disabledDates={disabledDates}
          ></MonthCal>
        </div>
      </div>
    </div>
  );
}

function MonthCal({ selectedMonth, onMonthSelect, callbacks, variant, minDate, maxDate, disabledDates, onYearBackward, onYearForward }: MonthCalProps) {
  const [year, setYear] = React.useState<number>(selectedMonth?.getFullYear() ?? new Date().getFullYear());
  const [month, setMonth] = React.useState<number>(selectedMonth?.getMonth() ?? new Date().getMonth());
  const [menuYear, setMenuYear] = React.useState<number>(year);

  if (minDate && maxDate && minDate > maxDate) minDate = maxDate;

  const disabledDatesMapped = disabledDates?.map((d) => {
    return { year: d.getFullYear(), month: d.getMonth() };
  });

  return (
    <>
      <div className="flex justify-center pt-1 relative items-center">
        <div className="text-sm font-medium">{callbacks?.yearLabel ? callbacks?.yearLabel(menuYear) : menuYear}</div>
        <div className="space-x-1 flex items-center">
          <button
            onClick={() => {
              setMenuYear(menuYear - 1);
              if (onYearBackward) onYearBackward();
            }}
            className={cn(buttonVariants({ variant: variant?.chevrons ?? "outline" }), "inline-flex items-center justify-center h-7 w-7 p-0 absolute left-1")}
          >
            <ChevronLeft className="opacity-50 h-4 w-4" />
          </button>
          <button
            onClick={() => {
              setMenuYear(menuYear + 1);
              if (onYearForward) onYearForward();
            }}
            className={cn(buttonVariants({ variant: variant?.chevrons ?? "outline" }), "inline-flex items-center justify-center h-7 w-7 p-0 absolute right-1")}
          >
            <ChevronRight className="opacity-50 h-4 w-4" />
          </button>
        </div>
      </div>
      <table className="w-full border-collapse space-y-1">
        <tbody>
          {MONTHS.map((monthRow, a) => {
            return (
              <tr key={"row-" + a} className="flex w-full mt-2">
                {monthRow.map((m) => {
                  return (
                    <td
                      key={m.number}
                      className="h-10 w-1/4 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20"
                    >
                      <button
                        onClick={() => {
                          setMonth(m.number);
                          setYear(menuYear);
                          if (onMonthSelect) onMonthSelect(new Date(menuYear, m.number));
                        }}
                        disabled={
                          (maxDate ? menuYear > maxDate?.getFullYear() || (menuYear == maxDate?.getFullYear() && m.number > maxDate.getMonth()) : false) ||
                          (minDate ? menuYear < minDate?.getFullYear() || (menuYear == minDate?.getFullYear() && m.number < minDate.getMonth()) : false) ||
                          (disabledDatesMapped ? disabledDatesMapped?.some((d) => d.year == menuYear && d.month == m.number) : false)
                        }
                        className={cn(
                          buttonVariants({ variant: month == m.number && menuYear == year ? variant?.calendar?.selected ?? "default" : variant?.calendar?.main ?? "ghost" }),
                          "h-full w-full p-0 font-normal aria-selected:opacity-100"
                        )}
                      >
                        {callbacks?.monthLabel ? callbacks.monthLabel(m) : m.name}
                      </button>
                    </td>
                  );
                })}
              </tr>
            );
          })}
        </tbody>
      </table>
    </>
  );
}

MonthPicker.displayName = "MonthPicker";

export { MonthPicker };
</file>

<file path="client/src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-white p-4 text-gray-900 shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="client/src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="client/src/components/ui/select.tsx">
import * as React from "react"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"

export interface SelectProps
  extends React.SelectHTMLAttributes<HTMLSelectElement> {}

const Select = React.forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <div className="relative">
        <select
          className={cn(
            "flex h-10 w-full appearance-none rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-background placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </select>
        <ChevronDown className="absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 pointer-events-none text-gray-400" />
      </div>
    )
  }
)
Select.displayName = "Select"

export { Select }
</file>

<file path="client/src/components/ui/sticky-table.tsx">
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

const StickyTable = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
StickyTable.displayName = "StickyTable";

const StickyTableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead 
    ref={ref} 
    className={cn("[&_tr]:border-b", className)} 
    style={{ position: "sticky", top: 0, zIndex: 100 }}
    {...props} 
  />
));
StickyTableHeader.displayName = "StickyTableHeader";

const StickyTableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
StickyTableBody.displayName = "StickyTableBody";

const StickyTableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-gray-50/50 data-[state=selected]:bg-gray-100",
      className
    )}
    {...props}
  />
));
StickyTableRow.displayName = "StickyTableRow";

const StickyTableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement> & {
    sticky?: boolean;
    stickyLeft?: string | number;
    stickyRight?: string | number;
  }
>(({ className, sticky, stickyLeft, stickyRight, style, ...props }, ref) => {
  const stickyStyle: React.CSSProperties = style ? { ...style } : {};
  
  if (sticky) {
    if (stickyLeft !== undefined) {
      stickyStyle.position = "sticky";
      stickyStyle.left = typeof stickyLeft === "number" ? `${stickyLeft}px` : stickyLeft;
      stickyStyle.zIndex = stickyStyle.zIndex || 101;
      // Only set default background if not provided in style
      if (!stickyStyle.backgroundColor) {
        stickyStyle.backgroundColor = "#ffffff";
      }
    } else if (stickyRight !== undefined) {
      stickyStyle.position = "sticky";
      stickyStyle.right = typeof stickyRight === "number" ? `${stickyRight}px` : stickyRight;
      stickyStyle.zIndex = stickyStyle.zIndex || 101;
      // Only set default background if not provided in style
      if (!stickyStyle.backgroundColor) {
        stickyStyle.backgroundColor = "#ffffff";
      }
    }
  }

  return (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-gray-500 [&:has([role=checkbox])]:pr-0",
        sticky && stickyLeft !== undefined && "shadow-[2px_0_4px_rgba(0,0,0,0.1)]",
        sticky && stickyRight !== undefined && "shadow-[-2px_0_4px_rgba(0,0,0,0.1)]",
        className
      )}
      style={stickyStyle}
      {...props}
    />
  );
});
StickyTableHead.displayName = "StickyTableHead";

const StickyTableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement> & {
    sticky?: boolean;
    stickyLeft?: string | number;
    stickyRight?: string | number;
  }
>(({ className, sticky, stickyLeft, stickyRight, style, ...props }, ref) => {
  const stickyStyle: React.CSSProperties = style ? { ...style } : {};
  
  if (sticky) {
    if (stickyLeft !== undefined) {
      stickyStyle.position = "sticky";
      stickyStyle.left = typeof stickyLeft === "number" ? `${stickyLeft}px` : stickyLeft;
      stickyStyle.zIndex = stickyStyle.zIndex || 20;
      // Only set default background if not provided in style
      if (!stickyStyle.backgroundColor) {
        stickyStyle.backgroundColor = "#ffffff";
      }
    } else if (stickyRight !== undefined) {
      stickyStyle.position = "sticky";
      stickyStyle.right = typeof stickyRight === "number" ? `${stickyRight}px` : stickyRight;
      stickyStyle.zIndex = stickyStyle.zIndex || 20;
      // Only set default background if not provided in style
      if (!stickyStyle.backgroundColor) {
        stickyStyle.backgroundColor = "#ffffff";
      }
    }
  }

  return (
    <td
      ref={ref}
      className={cn(
        "p-4 align-middle [&:has([role=checkbox])]:pr-0",
        sticky && stickyLeft !== undefined && "shadow-[2px_0_4px_rgba(0,0,0,0.1)]",
        sticky && stickyRight !== undefined && "shadow-[-2px_0_4px_rgba(0,0,0,0.1)]",
        className
      )}
      style={stickyStyle}
      {...props}
    />
  );
});
StickyTableCell.displayName = "StickyTableCell";

export {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
};
</file>

<file path="client/src/components/ui/table.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
import { ArrowUpDown, ArrowUp, ArrowDown } from "lucide-react"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-gray-50/50 data-[state=selected]:bg-gray-100",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-gray-500 [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

interface SortableTableHeadProps extends React.ThHTMLAttributes<HTMLTableCellElement> {
  sortKey: string
  currentSortColumn: string | null
  sortDirection: "asc" | "desc"
  onSort: (column: string) => void
  children: React.ReactNode
}

const SortableTableHead = React.forwardRef<
  HTMLTableCellElement,
  SortableTableHeadProps
>(({ sortKey, currentSortColumn, sortDirection, onSort, children, className, ...props }, ref) => {
  const handleClick = () => {
    onSort(sortKey)
  }

  const isActive = currentSortColumn === sortKey

  return (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-gray-500 [&:has([role=checkbox])]:pr-0",
        className
      )}
      {...props}
    >
      <button
        onClick={handleClick}
        className={cn(
          "flex items-center gap-2 hover:text-indigo-600 transition-colors cursor-pointer w-full",
          className?.includes("text-center") ? "justify-center" : "text-left"
        )}
      >
        {children}
        {isActive ? (
          sortDirection === "asc" ? (
            <ArrowUp className="h-4 w-4 text-indigo-600" />
          ) : (
            <ArrowDown className="h-4 w-4 text-indigo-600" />
          )
        ) : (
          <ArrowUpDown className="h-4 w-4 opacity-50" />
        )}
      </button>
    </th>
  )
})
SortableTableHead.displayName = "SortableTableHead"

export {
  Table,
  TableHeader,
  TableBody,
  TableHead,
  TableRow,
  TableCell,
  SortableTableHead,
}
</file>

<file path="client/src/components/ui/tabs.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

interface TabsContextValue {
  value: string
  onValueChange: (value: string) => void
}

const TabsContext = React.createContext<TabsContextValue | undefined>(undefined)

interface TabsProps {
  value: string
  onValueChange: (value: string) => void
  children: React.ReactNode
  className?: string
}

const Tabs: React.FC<TabsProps> = ({ value, onValueChange, children, className }) => {
  return (
    <TabsContext.Provider value={{ value, onValueChange }}>
      <div className={cn("w-full", className)}>{children}</div>
    </TabsContext.Provider>
  )
}

const TabsList: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({
  className,
  ...props
}) => {
  return (
    <div
      className={cn(
        "inline-flex h-10 items-center justify-center rounded-md bg-gray-100 p-1 text-gray-500",
        className
      )}
      {...props}
    />
  )
}

interface TabsTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  value: string
}

const TabsTrigger: React.FC<TabsTriggerProps> = ({
  value,
  className,
  ...props
}) => {
  const context = React.useContext(TabsContext)
  if (!context || !context.onValueChange) {
    throw new Error("TabsTrigger must be used within Tabs with onValueChange handler")
  }

  const isActive = context.value === value

  return (
    <button
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
        isActive
          ? "bg-white text-gray-900 shadow-sm"
          : "text-gray-600 hover:text-gray-900",
        className
      )}
      onClick={() => {
        if (context.onValueChange) {
          context.onValueChange(value)
        }
      }}
      {...props}
    />
  )
}

interface TabsContentProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string
}

const TabsContent: React.FC<TabsContentProps> = ({
  value,
  className,
  ...props
}) => {
  const context = React.useContext(TabsContext)
  if (!context) {
    throw new Error("TabsContent must be used within Tabs")
  }

  if (context.value !== value) return null

  return (
    <div
      className={cn(
        "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        className
      )}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="client/src/components/ui/textarea.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-background placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="client/src/constants/gradients.ts">
/**
 * Shared gradient constants for consistent styling across components
 */

export const GRADIENTS = {
  // Primary gradients
  blue: "from-blue-500 to-indigo-600",
  emerald: "from-emerald-500 to-teal-600",
  amber: "from-amber-500 to-orange-600",
  rose: "from-rose-500 to-red-600",
  violet: "from-violet-500 to-purple-600",
  cyan: "from-cyan-500 to-blue-500",

  // Slate/Gray gradients
  slate: "from-slate-800 via-slate-900 to-slate-950",
  slateLight: "from-slate-100 to-slate-200",

  // Card background gradients
  cardBlue: "from-blue-50 to-cyan-50",
  cardEmerald: "from-emerald-50 to-teal-50",
  cardAmber: "from-amber-50 to-orange-50",
  cardRose: "from-rose-50 to-red-50",
  cardViolet: "from-violet-50 to-purple-50",

  // Hero gradients (for large sections)
  heroBlue: "from-blue-600 via-indigo-600 to-violet-600",
  heroOrange: "from-orange-500 via-amber-500 to-yellow-500",
} as const;

export const GLOW_SHADOWS = {
  blue: "shadow-blue-500/25",
  emerald: "shadow-emerald-500/25",
  amber: "shadow-amber-500/25",
  rose: "shadow-rose-500/25",
  violet: "shadow-violet-500/25",
  cyan: "shadow-cyan-500/25",
} as const;

export type GradientKey = keyof typeof GRADIENTS;
export type GlowShadowKey = keyof typeof GLOW_SHADOWS;
</file>

<file path="client/src/constants/limits.ts">
/**
 * Shared numeric limits and magic numbers
 */

// UI limits
export const AUTOCOMPLETE_LIMIT = 100;
export const BADGE_SLICE_LIMIT = 200;
export const TABLE_PAGE_SIZE = 10;
export const TABLE_PAGE_SIZE_OPTIONS = [10, 25, 50, 100];

// Time limits
export const DAYS_REMAINING_MAX = 999;
export const CACHE_TTL_MS = 30 * 60 * 1000; // 30 minutes
export const DEBOUNCE_DELAY_MS = 300;
export const ANIMATION_DURATION_MS = 300;

// Document expiry warnings
export const EXPIRY_WARNING_DAYS = 30;
export const EXPIRY_CRITICAL_DAYS = 7;

// Pagination
export const DEFAULT_PAGE = 1;
export const MAX_VISIBLE_PAGES = 5;
</file>

<file path="client/src/constants/status-config.ts">
/**
 * Shared status configuration for dispatch records
 * Used in: Dashboard, DieuDo, ThanhToan
 */

export interface StatusConfig {
  label: string;
  color: string;
  bgColor: string;
  borderColor: string;
  icon?: string;
}

export const DISPATCH_STATUS: Record<string, StatusConfig> = {
  entered: {
    label: "Đã vào bến",
    color: "text-blue-700",
    bgColor: "bg-blue-100",
    borderColor: "border-blue-200",
  },
  passengers_dropped: {
    label: "Đã trả khách",
    color: "text-cyan-700",
    bgColor: "bg-cyan-100",
    borderColor: "border-cyan-200",
  },
  permit_issued: {
    label: "Đã cấp phép",
    color: "text-violet-700",
    bgColor: "bg-violet-100",
    borderColor: "border-violet-200",
  },
  paid: {
    label: "Đã thanh toán",
    color: "text-emerald-700",
    bgColor: "bg-emerald-100",
    borderColor: "border-emerald-200",
  },
  departure_ordered: {
    label: "Đã lệnh xuất",
    color: "text-amber-700",
    bgColor: "bg-amber-100",
    borderColor: "border-amber-200",
  },
  departed: {
    label: "Đã xuất bến",
    color: "text-slate-700",
    bgColor: "bg-slate-100",
    borderColor: "border-slate-200",
  },
} as const;

export const OPERATOR_STATUS = {
  active: {
    label: "Hoạt động",
    color: "text-emerald-700",
    bgColor: "bg-emerald-100",
  },
  inactive: {
    label: "Ngừng hoạt động",
    color: "text-slate-600",
    bgColor: "bg-slate-100",
  },
} as const;

export const PAYMENT_STATUS = {
  pending: {
    label: "Chưa thanh toán",
    color: "text-amber-700",
    bgColor: "bg-amber-100",
  },
  paid: {
    label: "Đã thanh toán",
    color: "text-emerald-700",
    bgColor: "bg-emerald-100",
  },
  overdue: {
    label: "Quá hạn",
    color: "text-rose-700",
    bgColor: "bg-rose-100",
  },
} as const;

export type DispatchStatusKey = keyof typeof DISPATCH_STATUS;
export type OperatorStatusKey = keyof typeof OPERATOR_STATUS;
export type PaymentStatusKey = keyof typeof PAYMENT_STATUS;
</file>

<file path="client/src/features/auth/api/authApi.ts">
import api from '@/lib/api'
import type { LoginCredentials, RegisterCredentials, User, AuthResponse } from '../types'

export const authApi = {
  login: async (credentials: LoginCredentials): Promise<AuthResponse> => {
    const response = await api.post<AuthResponse>('/auth/login', credentials)
    if (response.data.token) {
      localStorage.setItem('auth_token', response.data.token)
    }
    return response.data
  },

  register: async (credentials: RegisterCredentials): Promise<AuthResponse> => {
    const response = await api.post<AuthResponse>('/auth/register', credentials)
    if (response.data.token) {
      localStorage.setItem('auth_token', response.data.token)
    }
    return response.data
  },

  logout: (): void => {
    localStorage.removeItem('auth_token')
  },

  getCurrentUser: async (): Promise<User> => {
    const response = await api.get<User>('/auth/me')
    return response.data
  },

  updateProfile: async (data: { fullName?: string; email?: string; phone?: string }): Promise<User> => {
    const response = await api.put<User>('/auth/profile', data)
    return response.data
  },

  isAuthenticated: (): boolean => {
    return !!localStorage.getItem('auth_token')
  },
}

// Backward compatibility
export default authApi
</file>

<file path="client/src/features/auth/components/index.ts">
export { ProtectedRoute } from './ProtectedRoute'
</file>

<file path="client/src/features/auth/components/ProtectedRoute.tsx">
import { useEffect } from 'react'
import { Navigate } from 'react-router-dom'
import { useAuthStore } from '../store/authStore'
import { useUIStore } from '@/store/ui.store'

interface ProtectedRouteProps {
  children: React.ReactNode
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading, checkAuth } = useAuthStore()
  const { initializeShiftIfNeeded } = useUIStore()

  useEffect(() => {
    checkAuth()
  }, [checkAuth])

  // Tự động set shift theo giờ hiện tại khi đăng nhập lần đầu
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      initializeShiftIfNeeded()
    }
  }, [isAuthenticated, isLoading, initializeShiftIfNeeded])

  if (isLoading) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <div className="mb-4 h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent mx-auto" />
          <p className="text-gray-600">Đang tải...</p>
        </div>
      </div>
    )
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />
  }

  return <>{children}</>
}
</file>

<file path="client/src/features/auth/hooks/index.ts">
export { useAuth } from './useAuth'
</file>

<file path="client/src/features/auth/hooks/useAuth.ts">
import { useAuthStore } from '../store/authStore'
import type { RegisterCredentials } from '../types'

/**
 * Wrapper hook for auth functionality
 * Provides cleaner API and hides store implementation
 */
export function useAuth() {
  const {
    user,
    isAuthenticated,
    isLoading,
    login,
    register,
    logout,
    checkAuth,
    updateProfile,
  } = useAuthStore()

  return {
    // State
    user,
    isAuthenticated,
    isLoading,

    // Actions
    login: async (usernameOrEmail: string, password: string, rememberMe?: boolean) => {
      await login(usernameOrEmail, password, rememberMe)
    },
    register: async (credentials: RegisterCredentials) => {
      await register(credentials)
    },
    logout: () => {
      logout()
    },
    checkAuth: async () => {
      await checkAuth()
    },
    updateProfile: async (data: { fullName?: string; email?: string; phone?: string }) => {
      await updateProfile(data)
    },
  }
}
</file>

<file path="client/src/features/auth/index.ts">
// Auth Feature Public API
// Only export what should be used by other features/modules

// Components
export { ProtectedRoute } from './components/ProtectedRoute'

// Hooks
export { useAuth } from './hooks/useAuth'

// Store (for direct access if needed)
export { useAuthStore } from './store/authStore'

// API (for advanced usage)
export { authApi } from './api/authApi'

// Types
export type {
  User,
  LoginCredentials,
  RegisterCredentials,
  AuthResponse,
  AuthState,
  AuthContextValue,
} from './types'
</file>

<file path="client/src/features/auth/store/authStore.ts">
import { create } from 'zustand'
import type { User, RegisterCredentials } from '../types'
import { authApi } from '../api/authApi'

interface AuthStoreState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  login: (usernameOrEmail: string, password: string, rememberMe?: boolean) => Promise<void>
  register: (credentials: RegisterCredentials) => Promise<void>
  logout: () => void
  checkAuth: () => Promise<void>
  updateProfile: (data: { fullName?: string; email?: string; phone?: string }) => Promise<void>
}

export const useAuthStore = create<AuthStoreState>((set) => ({
  user: null,
  isAuthenticated: false,
  isLoading: true,

  login: async (usernameOrEmail: string, password: string, rememberMe = false) => {
    try {
      const data = await authApi.login({ usernameOrEmail, password, rememberMe })
      set({ user: data.user, isAuthenticated: true, isLoading: false })
    } catch (error) {
      set({ isLoading: false })
      throw error
    }
  },

  register: async (credentials: RegisterCredentials) => {
    try {
      const data = await authApi.register(credentials)
      set({ user: data.user, isAuthenticated: true, isLoading: false })
    } catch (error) {
      set({ isLoading: false })
      throw error
    }
  },

  logout: () => {
    authApi.logout()
    set({ user: null, isAuthenticated: false })
  },

  checkAuth: async () => {
    if (authApi.isAuthenticated()) {
      try {
        const user = await authApi.getCurrentUser()
        set({ user, isAuthenticated: true, isLoading: false })
      } catch {
        set({ user: null, isAuthenticated: false, isLoading: false })
      }
    } else {
      set({ isLoading: false })
    }
  },

  updateProfile: async (data: { fullName?: string; email?: string; phone?: string }) => {
    try {
      const updatedUser = await authApi.updateProfile(data)
      set({ user: updatedUser })
    } catch (error) {
      throw error
    }
  },
}))
</file>

<file path="client/src/features/auth/types/index.ts">
// Auth Feature Types
// Re-export from shared types for consistency

export type {
  User,
  LoginCredentials,
  RegisterCredentials,
} from '@/types/auth.types'

// Feature-specific types
export interface AuthResponse {
  token: string
  user: User
}

export interface AuthState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
}

export interface AuthContextValue extends AuthState {
  login: (usernameOrEmail: string, password: string, rememberMe?: boolean) => Promise<void>
  register: (credentials: RegisterCredentials) => Promise<void>
  logout: () => void
  checkAuth: () => Promise<void>
  updateProfile: (data: { fullName?: string; email?: string; phone?: string }) => Promise<void>
}

// Import User type for AuthResponse
import type { User, RegisterCredentials } from '@/types/auth.types'
</file>

<file path="client/src/features/chat/api/chatApi.ts">
import api from '@/lib/api'
import type { SendMessageResponse } from '../types'

export const chatApi = {
  sendMessage: async (
    message: string,
    sessionId?: string
  ): Promise<SendMessageResponse> => {
    const response = await api.post<SendMessageResponse>('/chat/message', {
      message,
      sessionId
    })
    return response.data
  },

  clearHistory: async (sessionId: string): Promise<void> => {
    await api.delete(`/chat/history/${sessionId}`)
  }
}
</file>

<file path="client/src/features/chat/components/index.ts">
export { ChatWidget } from './ChatWidget'
export { ChatMessage } from './ChatMessage'
export { ChatInput } from './ChatInput'
</file>

<file path="client/src/features/chat/index.ts">
export { ChatWidget } from './components'
export { useChatStore } from './store/chatStore'
export { chatApi } from './api/chatApi'
export * from './types'
</file>

<file path="client/src/features/chat/store/chatStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { chatApi } from '../api/chatApi'
import type { ChatMessage, ChatState } from '../types'

interface ChatStore extends ChatState {
  toggleChat: () => void
  openChat: () => void
  closeChat: () => void
  sendMessage: (content: string) => Promise<void>
  clearChat: () => Promise<void>
}

export const useChatStore = create<ChatStore>()(
  persist(
    (set, get) => ({
      isOpen: false,
      messages: [],
      sessionId: null,
      isLoading: false,

      toggleChat: () => set(state => ({ isOpen: !state.isOpen })),
      openChat: () => set({ isOpen: true }),
      closeChat: () => set({ isOpen: false }),

      sendMessage: async (content: string) => {
        const { sessionId, messages } = get()

        // Add user message immediately
        const userMessage: ChatMessage = {
          id: Date.now().toString(),
          role: 'user',
          content,
          type: 'data',
          createdAt: new Date()
        }
        set({ messages: [...messages, userMessage], isLoading: true })

        try {
          const response = await chatApi.sendMessage(content, sessionId || undefined)

          // Add assistant message
          const assistantMessage: ChatMessage = {
            id: (Date.now() + 1).toString(),
            role: 'assistant',
            content: response.response,
            type: response.type,
            metadata: response.metadata,
            createdAt: new Date()
          }

          set(state => ({
            messages: [...state.messages, assistantMessage],
            sessionId: response.sessionId,
            isLoading: false
          }))
        } catch (error) {
          console.error('Chat error:', error)
          
          // Add error message
          const errorMessage: ChatMessage = {
            id: (Date.now() + 1).toString(),
            role: 'assistant',
            content: 'Xin lỗi, đã có lỗi xảy ra. Vui lòng thử lại.',
            type: 'error',
            createdAt: new Date()
          }
          set(state => ({
            messages: [...state.messages, errorMessage],
            isLoading: false
          }))
        }
      },

      clearChat: async () => {
        const { sessionId } = get()
        if (sessionId) {
          try {
            await chatApi.clearHistory(sessionId)
          } catch (error) {
            console.error('Failed to clear chat history:', error)
          }
        }
        set({ messages: [], sessionId: null })
      }
    }),
    {
      name: 'chat-storage',
      partialize: (state) => ({
        sessionId: state.sessionId,
        messages: state.messages.slice(-50) // Keep last 50 messages
      })
    }
  )
)
</file>

<file path="client/src/features/chat/types/index.ts">
export interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  type: 'data' | 'ai' | 'error'
  metadata?: {
    queryType?: string
    processingTime?: number
    resultCount?: number
    hasContext?: boolean
  }
  createdAt: Date
}

export interface ChatState {
  isOpen: boolean
  messages: ChatMessage[]
  sessionId: string | null
  isLoading: boolean
}

export interface SendMessageResponse {
  response: string
  type: 'data' | 'ai' | 'error'
  sessionId: string
  metadata?: {
    queryType?: string
    processingTime?: number
    resultCount?: number
    hasContext?: boolean
  }
}
</file>

<file path="client/src/features/dispatch/api/dispatchApi.ts">
// Dispatch Feature API Service

import api from '@/lib/api'
import type {
  DispatchRecord,
  DispatchInput,
  DispatchStatus,
  DispatchFilters,
  PassengerDropInput,
  PermitInput,
  PaymentInput,
  DepartureOrderInput,
  ExitInput,
} from '../types'

export const dispatchApi = {
  // Get all dispatch records with optional filters
  getAll: async (filters?: DispatchFilters): Promise<DispatchRecord[]> => {
    try {
      const params = new URLSearchParams()
      if (filters?.status) params.append('status', filters.status)
      if (filters?.vehicleId) params.append('vehicleId', filters.vehicleId)
      if (filters?.driverId) params.append('driverId', filters.driverId)
      if (filters?.routeId) params.append('routeId', filters.routeId)
      if (filters?.from) params.append('from', filters.from)
      if (filters?.to) params.append('to', filters.to)

      const queryString = params.toString()
      const url = queryString ? `/dispatch?${queryString}` : '/dispatch'

      const response = await api.get<DispatchRecord[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching dispatch records:', error)
      return []
    }
  },

  // Get single dispatch record by ID
  getById: async (id: string): Promise<DispatchRecord> => {
    const response = await api.get<DispatchRecord>(`/dispatch/${id}`)
    return response.data
  },

  // Create new dispatch record (vehicle entry)
  create: async (input: DispatchInput): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>('/dispatch', input)
    return response.data
  },

  // Record passenger drop-off
  recordPassengerDrop: async (
    id: string,
    input: PassengerDropInput
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/passenger-drop`, input)
    return response.data
  },

  // Issue boarding permit
  issuePermit: async (id: string, input: PermitInput): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/permit`, input)
    return response.data
  },

  // Process payment
  processPayment: async (id: string, input: PaymentInput): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/payment`, input)
    return response.data
  },

  // Issue departure order
  issueDepartureOrder: async (
    id: string,
    input: DepartureOrderInput
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/departure-order`, input)
    return response.data
  },

  // Record vehicle exit
  recordExit: async (id: string, input?: ExitInput): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/exit`, input || {})
    return response.data
  },

  // Bulk exit multiple vehicles
  bulkExit: async (ids: string[], input?: ExitInput): Promise<DispatchRecord[]> => {
    const response = await api.post<DispatchRecord[]>('/dispatch/bulk-exit', {
      ids,
      ...input,
    })
    return response.data
  },

  // Delete dispatch record
  delete: async (id: string): Promise<void> => {
    await api.delete(`/dispatch/${id}`)
  },

  // Legacy methods for backward compatibility
  updateStatus: async (
    id: string,
    status: DispatchStatus,
    data?: Partial<DispatchRecord>
  ): Promise<DispatchRecord> => {
    if (status === 'permit_issued') {
      return dispatchApi.issuePermit(id, {
        transportOrderCode: data?.transportOrderCode || '',
        plannedDepartureTime: data?.plannedDepartureTime || new Date().toISOString(),
        seatCount: data?.seatCount || 0,
      })
    }
    if (status === 'paid') {
      return dispatchApi.processPayment(id, {
        paymentAmount: data?.paymentAmount || 0,
      })
    }
    if (status === 'departed') {
      return dispatchApi.recordExit(id)
    }
    throw new Error('Legacy updateStatus is deprecated. Use specific workflow methods.')
  },

  depart: async (
    id: string,
    _exitTime: string,
    passengerCount: number
  ): Promise<DispatchRecord> => {
    await dispatchApi.issueDepartureOrder(id, { passengersDeparting: passengerCount })
    return dispatchApi.recordExit(id)
  },
}

export default dispatchApi
</file>

<file path="client/src/features/dispatch/components/icons/BusEnterIcon.tsx">
import { Bus, ArrowRight } from "lucide-react";

interface IconProps {
  className?: string;
}

/**
 * Bus Enter Icon - Used for "Cho xe ra bến" (Vehicle exit)
 * Composite icon: Bus with ArrowRight badge
 */
export function BusEnterIcon({ className = "" }: IconProps) {
  return (
    <div className={`relative inline-flex h-5 w-5 ${className}`}>
      <Bus className="h-5 w-5" />
      <div className="absolute -bottom-0.5 -right-0.5 bg-white rounded-full p-0.5">
        <ArrowRight className="h-2.5 w-2.5" strokeWidth={2.5} />
      </div>
    </div>
  );
}

export default BusEnterIcon;
</file>

<file path="client/src/features/dispatch/components/icons/BusPlusIcon.tsx">
import { CarFront, Plus } from "lucide-react";

interface IconProps {
  className?: string;
}

/**
 * Bus Plus Icon - Used for "Xe tăng cường" (Augmented vehicle)
 * Composite icon: CarFront with Plus badge
 */
export function BusPlusIcon({ className = "" }: IconProps) {
  return (
    <div className={`relative inline-flex h-5 w-5 ${className}`}>
      <CarFront className="h-5 w-5" />
      <div className="absolute -bottom-0.5 -right-0.5 bg-white rounded-full p-0.5">
        <Plus className="h-2.5 w-2.5" strokeWidth={3} />
      </div>
    </div>
  );
}

export default BusPlusIcon;
</file>

<file path="client/src/features/dispatch/components/icons/FileExclamationIcon.tsx">
interface IconProps {
  className?: string;
}

/**
 * File Exclamation Icon - Used for "Xe chưa cấp nốt" (Vehicle without permit)
 * Custom SVG icon: File with exclamation mark
 */
export function FileExclamationIcon({ className = "" }: IconProps) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <path d="M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z" />
      <path d="M12 9v4" />
      <path d="M12 17h.01" />
    </svg>
  );
}

export default FileExclamationIcon;
</file>

<file path="client/src/features/dispatch/components/icons/index.ts">
/**
 * Dispatch Icon Components
 * Custom icons for dispatch workflow visualization
 */

export { BusPlusIcon } from './BusPlusIcon';
export { FileExclamationIcon } from './FileExclamationIcon';
export { BusEnterIcon } from './BusEnterIcon';
</file>

<file path="client/src/features/dispatch/components/index.ts">
// Dispatch Feature Components
// Re-export from current locations for backward compatibility

// Icons (migrated to feature)
export { BusPlusIcon, BusEnterIcon, FileExclamationIcon } from './icons'

// Workflow Dialogs - Keep importing from original location for now
// These will be gradually migrated in future phases
export { ChoXeVaoBenDialog } from '@/components/dispatch/ChoXeVaoBenDialog'
export { XeTraKhachDialog } from '@/components/dispatch/XeTraKhachDialog'
export { CapPhepDialog } from '@/components/dispatch/CapPhepDialog'
export { CapLenhXuatBenDialog } from '@/components/dispatch/CapLenhXuatBenDialog'
export { ChoXeRaBenDialog } from '@/components/dispatch/ChoXeRaBenDialog'
export { ChoNhieuXeRaBenDialog } from '@/components/dispatch/ChoNhieuXeRaBenDialog'
export { ThanhToanTheoThangDialog } from '@/components/dispatch/ThanhToanTheoThangDialog'

// Supporting Dialogs - Keep importing from original location for now
export { KiemTraGiayToDialog } from '@/components/dispatch/KiemTraGiayToDialog'
export { LyDoKhongDuDieuKienDialog } from '@/components/dispatch/LyDoKhongDuDieuKienDialog'
export { ThemDichVuDialog } from '@/components/dispatch/ThemDichVuDialog'
export { ThemTaiXeDialog } from '@/components/dispatch/ThemTaiXeDialog'
export { DocumentHistoryDialog } from '@/components/dispatch/DocumentHistoryDialog'
</file>

<file path="client/src/features/dispatch/hooks/index.ts">
// Dispatch Feature Hooks

export { useDispatch } from './useDispatch'
</file>

<file path="client/src/features/dispatch/hooks/useDispatch.ts">
// Dispatch Feature Hook
// Combines store state with API actions

import { useCallback } from 'react'
import { useDispatchStore, getDisplayStatus } from '../store/dispatchStore'
import { dispatchApi } from '../api/dispatchApi'
import type {
  DispatchInput,
  DispatchFilters,
  PassengerDropInput,
  PermitInput,
  PaymentInput,
  DepartureOrderInput,
  ExitInput,
  DisplayStatus,
} from '../types'

export function useDispatch() {
  const {
    records,
    selectedRecord,
    activeTab,
    setRecords,
    setSelectedRecord,
    setActiveTab,
    updateRecord,
    replaceRecord,
    addRecord,
    removeRecord,
  } = useDispatchStore()

  // Fetch all records
  const fetchRecords = useCallback(async (filters?: DispatchFilters) => {
    const data = await dispatchApi.getAll(filters)
    setRecords(data)
    return data
  }, [setRecords])

  // Fetch single record
  const fetchRecord = useCallback(async (id: string) => {
    const data = await dispatchApi.getById(id)
    replaceRecord(data)
    return data
  }, [replaceRecord])

  // Create new entry
  const createEntry = useCallback(async (input: DispatchInput) => {
    const record = await dispatchApi.create(input)
    addRecord(record)
    return record
  }, [addRecord])

  // Process passenger drop
  const processPassengerDrop = useCallback(async (id: string, input: PassengerDropInput) => {
    const record = await dispatchApi.recordPassengerDrop(id, input)
    replaceRecord(record)
    return record
  }, [replaceRecord])

  // Issue permit
  const issuePermit = useCallback(async (id: string, input: PermitInput) => {
    const record = await dispatchApi.issuePermit(id, input)
    replaceRecord(record)
    return record
  }, [replaceRecord])

  // Process payment
  const processPayment = useCallback(async (id: string, input: PaymentInput) => {
    const record = await dispatchApi.processPayment(id, input)
    replaceRecord(record)
    return record
  }, [replaceRecord])

  // Issue departure order
  const issueDepartureOrder = useCallback(async (id: string, input: DepartureOrderInput) => {
    const record = await dispatchApi.issueDepartureOrder(id, input)
    replaceRecord(record)
    return record
  }, [replaceRecord])

  // Process exit
  const processExit = useCallback(async (id: string, input?: ExitInput) => {
    const record = await dispatchApi.recordExit(id, input)
    replaceRecord(record)
    return record
  }, [replaceRecord])

  // Bulk exit
  const processBulkExit = useCallback(async (ids: string[], input?: ExitInput) => {
    const records = await dispatchApi.bulkExit(ids, input)
    records.forEach(replaceRecord)
    return records
  }, [replaceRecord])

  // Delete record
  const deleteRecord = useCallback(async (id: string) => {
    await dispatchApi.delete(id)
    removeRecord(id)
  }, [removeRecord])

  // Filter records by display status
  const getRecordsByStatus = useCallback((status: DisplayStatus) => {
    return records.filter((r) => getDisplayStatus(r.currentStatus) === status)
  }, [records])

  // Get filtered records based on active tab
  const getFilteredRecords = useCallback(() => {
    if (activeTab === 'all') return records
    return records.filter((r) => getDisplayStatus(r.currentStatus) === activeTab)
  }, [records, activeTab])

  return {
    // State
    records,
    selectedRecord,
    activeTab,

    // Setters
    setSelectedRecord,
    setActiveTab,
    updateRecord,

    // API Actions
    fetchRecords,
    fetchRecord,
    createEntry,
    processPassengerDrop,
    issuePermit,
    processPayment,
    issueDepartureOrder,
    processExit,
    processBulkExit,
    deleteRecord,

    // Utilities
    getRecordsByStatus,
    getFilteredRecords,
    getDisplayStatus,
  }
}
</file>

<file path="client/src/features/dispatch/index.ts">
// Dispatch Feature Public API
// Only export what should be used by other features/modules

// Hooks
export { useDispatch } from './hooks'

// Store
export { useDispatchStore, getDisplayStatus } from './store/dispatchStore'

// API
export { dispatchApi } from './api/dispatchApi'

// Types
export type {
  DispatchStatus,
  PermitStatus,
  PaymentMethod,
  DispatchRecord,
  DispatchInput,
  DisplayStatus,
  DispatchFilters,
  PassengerDropInput,
  PermitInput,
  PaymentInput,
  DepartureOrderInput,
  ExitInput,
  DispatchWorkflowState,
} from './types'

// Components - Icons
export { BusPlusIcon, BusEnterIcon, FileExclamationIcon } from './components/icons'

// Components - Dialogs (re-exported from original locations)
export {
  ChoXeVaoBenDialog,
  XeTraKhachDialog,
  CapPhepDialog,
  CapLenhXuatBenDialog,
  ChoXeRaBenDialog,
  ChoNhieuXeRaBenDialog,
  ThanhToanTheoThangDialog,
  KiemTraGiayToDialog,
  LyDoKhongDuDieuKienDialog,
  ThemDichVuDialog,
  ThemTaiXeDialog,
  DocumentHistoryDialog,
} from './components'
</file>

<file path="client/src/features/dispatch/store/dispatchStore.ts">
// Dispatch Feature Store

import { create } from 'zustand'
import type { DispatchRecord, DisplayStatus } from '../types'

// Map backend status to display status for UI
export function getDisplayStatus(status: string): DisplayStatus {
  switch (status) {
    case 'entered':
    case 'passengers_dropped':
    case 'permit_rejected':
      return 'in-station'
    case 'permit_issued':
      return 'permit-issued'
    case 'paid':
      return 'paid'
    case 'departure_ordered':
    case 'departed':
      return 'departed'
    default:
      return 'in-station'
  }
}

interface DispatchState {
  records: DispatchRecord[]
  selectedRecord: DispatchRecord | null
  activeTab: DisplayStatus | 'all'

  // Actions
  setRecords: (records: DispatchRecord[]) => void
  setSelectedRecord: (record: DispatchRecord | null) => void
  setActiveTab: (tab: DisplayStatus | 'all') => void
  updateRecord: (id: string, updates: Partial<DispatchRecord>) => void
  replaceRecord: (record: DispatchRecord) => void
  addRecord: (record: DispatchRecord) => void
  removeRecord: (id: string) => void
}

export const useDispatchStore = create<DispatchState>((set) => ({
  records: [],
  selectedRecord: null,
  activeTab: 'all',

  setRecords: (records) => set({ records }),

  setSelectedRecord: (selectedRecord) => set({ selectedRecord }),

  setActiveTab: (activeTab) => set({ activeTab }),

  updateRecord: (id, updates) =>
    set((state) => ({
      records: state.records.map((record) =>
        record.id === id ? { ...record, ...updates } : record
      ),
      selectedRecord:
        state.selectedRecord?.id === id
          ? { ...state.selectedRecord, ...updates }
          : state.selectedRecord,
    })),

  replaceRecord: (updatedRecord) =>
    set((state) => ({
      records: state.records.map((record) =>
        record.id === updatedRecord.id ? updatedRecord : record
      ),
      selectedRecord:
        state.selectedRecord?.id === updatedRecord.id
          ? updatedRecord
          : state.selectedRecord,
    })),

  addRecord: (newRecord) =>
    set((state) => ({
      records: [newRecord, ...state.records],
    })),

  removeRecord: (id) =>
    set((state) => ({
      records: state.records.filter((record) => record.id !== id),
      selectedRecord:
        state.selectedRecord?.id === id ? null : state.selectedRecord,
    })),
}))
</file>

<file path="client/src/features/dispatch/types/index.ts">
// Dispatch Feature Types - Re-export from shared types

export type {
  DispatchStatus,
  PermitStatus,
  PaymentMethod,
  DispatchRecord,
  DispatchInput,
} from '@/types/dispatch.types'

// Display status type for UI tabs (different from backend status)
export type DisplayStatus = 'in-station' | 'permit-issued' | 'paid' | 'departed'

// Feature-specific types
export interface DispatchFilters {
  status?: string
  vehicleId?: string
  driverId?: string
  routeId?: string
  from?: string
  to?: string
}

export interface PassengerDropInput {
  passengersArrived: number
  routeId?: string
}

export interface PermitInput {
  transportOrderCode?: string
  plannedDepartureTime: string
  seatCount: number
  permitStatus?: 'approved' | 'rejected'
  rejectionReason?: string
  routeId?: string
  scheduleId?: string
  replacementVehicleId?: string
  permitShiftId?: string
}

export interface PaymentInput {
  paymentAmount: number
  paymentMethod?: 'cash' | 'bank_transfer' | 'card'
  invoiceNumber?: string
  paymentShiftId?: string
}

export interface DepartureOrderInput {
  passengersDeparting: number
  departureOrderShiftId?: string
}

export interface ExitInput {
  exitTime?: string
  passengersDeparting?: number
  exitShiftId?: string
}

export interface DispatchWorkflowState {
  currentStep: 'entry' | 'passenger-drop' | 'permit' | 'payment' | 'departure' | 'exit'
  selectedRecord: import('@/types/dispatch.types').DispatchRecord | null
  isProcessing: boolean
}
</file>

<file path="client/src/features/fleet/drivers/api/driverApi.ts">
// Driver API Service

import api from '@/lib/api'
import type { Driver, DriverInput } from '../types'

export const driverApi = {
  getAll: async (operatorId?: string, isActive?: boolean): Promise<Driver[]> => {
    try {
      const params = new URLSearchParams()
      if (operatorId) params.append('operatorId', operatorId)
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/drivers?${queryString}` : '/drivers'

      const response = await api.get<Driver[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching drivers:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Driver> => {
    const response = await api.get<Driver>(`/drivers/${id}`)
    return response.data
  },

  create: async (input: DriverInput): Promise<Driver> => {
    const response = await api.post<Driver>('/drivers', input)
    return response.data
  },

  update: async (id: string, input: Partial<DriverInput>): Promise<Driver> => {
    const response = await api.put<Driver>(`/drivers/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/drivers/${id}`)
  },
}

// Re-export for backward compatibility
export const driverService = driverApi
export default driverApi
</file>

<file path="client/src/features/fleet/drivers/api/index.ts">
// Drivers API Services

export { driverApi, driverService } from './driverApi'
</file>

<file path="client/src/features/fleet/drivers/index.ts">
// Drivers Domain Public API

// API Services
export { driverApi, driverService } from './api'

// Components (re-exported from original location)
export { DriverDialog } from '@/components/driver/DriverDialog'
export { DriverForm } from '@/components/driver/DriverForm'
export { DriverView } from '@/components/driver/DriverView'

// Types
export type {
  Driver,
  DriverInput,
  DriverFilters,
  DriverFormMode,
} from './types'
</file>

<file path="client/src/features/fleet/drivers/types/index.ts">
// Drivers Domain Types

export type {
  Driver,
  DriverInput,
} from '@/types/fleet.types'

// Feature-specific types
export interface DriverFilters {
  search?: string
  operatorId?: string
  isActive?: boolean
}

export interface DriverFormMode {
  mode: 'create' | 'edit' | 'view'
  driverId?: string
}
</file>

<file path="client/src/features/fleet/index.ts">
// Fleet Feature Public API
// Groups Vehicle, Driver, Operator, and Vehicle Badge management

// ============ Vehicles ============
export {
  vehicleApi,
  vehicleService,
  vehicleTypeApi,
  vehicleTypeService,
  VehicleForm,
  VehicleView,
} from './vehicles'

export type {
  Vehicle,
  VehicleInput,
  VehicleDocuments,
  DocumentInfo,
  VehicleType,
  VehicleTypeInput,
  VehicleFilters,
  VehicleFormMode,
} from './vehicles'

// ============ Drivers ============
export {
  driverApi,
  driverService,
  DriverDialog,
  DriverForm,
  DriverView,
} from './drivers'

export type {
  Driver,
  DriverInput,
  DriverFilters,
  DriverFormMode,
} from './drivers'

// ============ Operators ============
export {
  operatorApi,
  operatorService,
  OperatorDialog,
  OperatorForm,
  OperatorView,
  OperatorDetailDialog,
} from './operators'

export type {
  Operator,
  OperatorInput,
  OperatorFilters,
  OperatorFormMode,
} from './operators'

// ============ Vehicle Badges ============
export {
  vehicleBadgeApi,
  vehicleBadgeService,
} from './vehicle-badges'

export type {
  VehicleBadge,
  VehicleBadgeFilters,
  VehicleBadgeStats,
} from './vehicle-badges'
</file>

<file path="client/src/features/fleet/operators/api/index.ts">
// Operators API Services

export { operatorApi, operatorService } from './operatorApi'
</file>

<file path="client/src/features/fleet/operators/index.ts">
// Operators Domain Public API

// API Services
export { operatorApi, operatorService } from './api'

// Components (re-exported from original location)
export { OperatorDialog } from '@/components/operator/OperatorDialog'
export { OperatorForm } from '@/components/operator/OperatorForm'
export { OperatorView } from '@/components/operator/OperatorView'
export { OperatorDetailDialog } from '@/components/operator/OperatorDetailDialog'

// Types
export type {
  Operator,
  OperatorInput,
  OperatorFilters,
  OperatorFormMode,
} from './types'
</file>

<file path="client/src/features/fleet/operators/types/index.ts">
// Operators Domain Types

export type {
  Operator,
  OperatorInput,
} from '@/types/fleet.types'

// Feature-specific types
export interface OperatorFilters {
  search?: string
  isActive?: boolean
}

export interface OperatorFormMode {
  mode: 'create' | 'edit' | 'view'
  operatorId?: string
}
</file>

<file path="client/src/features/fleet/vehicle-badges/api/index.ts">
// Vehicle Badges API Services

export { vehicleBadgeApi, vehicleBadgeService } from './vehicleBadgeApi'
export type { VehicleBadgeStats } from './vehicleBadgeApi'
</file>

<file path="client/src/features/fleet/vehicle-badges/api/vehicleBadgeApi.ts">
// Vehicle Badge API Service

import api from '@/lib/api'
import type { VehicleBadge } from '../types'

export interface VehicleBadgeStats {
  total: number
  active: number
  expired: number
  expiringSoon: number
}

export const vehicleBadgeApi = {
  // Read-only service - data comes from external source
  getAll: async (): Promise<VehicleBadge[]> => {
    try {
      const response = await api.get<VehicleBadge[]>('/vehicle-badges')
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badges:', error)
      return []
    }
  },

  getById: async (id: string): Promise<VehicleBadge | null> => {
    try {
      const response = await api.get<VehicleBadge>(`/vehicle-badges/${id}`)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badge by id:', error)
      return null
    }
  },

  getStats: async (): Promise<VehicleBadgeStats> => {
    try {
      const response = await api.get<VehicleBadgeStats>('/vehicle-badges/stats')
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badge stats:', error)
      return {
        total: 0,
        active: 0,
        expired: 0,
        expiringSoon: 0,
      }
    }
  },
}

// Re-export for backward compatibility
export const vehicleBadgeService = vehicleBadgeApi
export default vehicleBadgeApi
</file>

<file path="client/src/features/fleet/vehicle-badges/index.ts">
// Vehicle Badges Domain Public API

// API Services
export { vehicleBadgeApi, vehicleBadgeService } from './api'
export type { VehicleBadgeStats } from './api'

// Types
export type {
  VehicleBadge,
  VehicleBadgeFilters,
} from './types'
</file>

<file path="client/src/features/fleet/vehicle-badges/types/index.ts">
// Vehicle Badges Domain Types

export type { VehicleBadge } from '@/types/fleet.types'

// Feature-specific types
export interface VehicleBadgeFilters {
  search?: string
  status?: string
  badgeType?: string
  badgeColor?: string
  page?: number
  limit?: number
}
</file>

<file path="client/src/features/fleet/vehicles/api/index.ts">
// Vehicles API Services

export { vehicleApi, vehicleService } from './vehicleApi'
export { vehicleTypeApi, vehicleTypeService } from './vehicleTypeApi'
</file>

<file path="client/src/features/fleet/vehicles/api/vehicleApi.ts">
// Vehicle API Service

import api from '@/lib/api'
import type { Vehicle, VehicleInput } from '../types'

export const vehicleApi = {
  getAll: async (operatorId?: string, isActive?: boolean): Promise<Vehicle[]> => {
    try {
      const params = new URLSearchParams()
      if (operatorId) params.append('operatorId', operatorId)
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/vehicles?${queryString}` : '/vehicles'

      const response = await api.get<Vehicle[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicles:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Vehicle> => {
    const response = await api.get<Vehicle>(`/vehicles/${id}`)
    return response.data
  },

  create: async (input: VehicleInput): Promise<Vehicle> => {
    const response = await api.post<Vehicle>('/vehicles', input)
    return response.data
  },

  update: async (id: string, input: Partial<VehicleInput>): Promise<Vehicle> => {
    const response = await api.put<Vehicle>(`/vehicles/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/vehicles/${id}`)
  },

  getDocumentAuditLogs: async (vehicleId: string): Promise<unknown[]> => {
    try {
      const response = await api.get<unknown[]>(`/vehicles/${vehicleId}/document-audit-logs`)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle document audit logs:', error)
      return []
    }
  },
}

// Re-export for backward compatibility
export const vehicleService = vehicleApi
export default vehicleApi
</file>

<file path="client/src/features/fleet/vehicles/api/vehicleTypeApi.ts">
// Vehicle Type API Service

import api from '@/lib/api'
import type { VehicleType, VehicleTypeInput } from '../types'

export const vehicleTypeApi = {
  getAll: async (): Promise<VehicleType[]> => {
    try {
      const response = await api.get<VehicleType[]>('/vehicle-types')
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle types:', error)
      return []
    }
  },

  getById: async (id: string): Promise<VehicleType> => {
    const response = await api.get<VehicleType>(`/vehicle-types/${id}`)
    return response.data
  },

  create: async (input: VehicleTypeInput): Promise<VehicleType> => {
    const response = await api.post<VehicleType>('/vehicle-types', input)
    return response.data
  },

  update: async (id: string, input: Partial<VehicleTypeInput>): Promise<VehicleType> => {
    const response = await api.put<VehicleType>(`/vehicle-types/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/vehicle-types/${id}`)
  },
}

// Re-export for backward compatibility
export const vehicleTypeService = vehicleTypeApi
export default vehicleTypeApi
</file>

<file path="client/src/features/fleet/vehicles/components/index.ts">
// Vehicle Components
export { VehicleForm } from './VehicleForm'
export { VehicleView } from './VehicleView'
</file>

<file path="client/src/features/fleet/vehicles/components/VehicleView.tsx">
import { useState, useMemo } from "react"
import { format, differenceInDays } from "date-fns"
import { Card, CardContent } from "@/components/ui/card"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Label } from "@/components/ui/label"
import {
  FileText,
  Shield,
  FileCheck,
  Calendar,
  Building2,
  AlertTriangle,
  CheckCircle2,
  XCircle,
  Clock,
  Badge,
  Award,
  Car,
  MapPin,
  Users,
  Package,
  History,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { DocumentHistoryDialog } from "@/components/dispatch/DocumentHistoryDialog"
import type { Vehicle, DocumentInfo } from "../types"

// Helper functions
const getVehicleTypeName = (vehicle: Vehicle): string => {
  return vehicle.vehicleType?.name || vehicle.vehicleTypeId || ""
}

const getOperatorName = (vehicle: Vehicle): string => {
  return vehicle.operator?.name || vehicle.operatorId || ""
}

// Helper function to calculate days until expiry
const getDaysUntilExpiry = (expiryDate: string): number | null => {
  if (!expiryDate) return null
  try {
    const expiry = new Date(expiryDate)
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    expiry.setHours(0, 0, 0, 0)
    return differenceInDays(expiry, today)
  } catch {
    return null
  }
}

// Helper function to get expiry status
const getExpiryStatus = (expiryDate: string | undefined): {
  status: "valid" | "expiring" | "expired" | "missing"
  label: string
  color: string
  icon: JSX.Element
} => {
  if (!expiryDate) {
    return {
      status: "missing",
      label: "Chưa có",
      color: "text-gray-500",
      icon: <XCircle className="h-4 w-4" />,
    }
  }

  const days = getDaysUntilExpiry(expiryDate)
  if (days === null) {
    return {
      status: "missing",
      label: "Không hợp lệ",
      color: "text-gray-500",
      icon: <XCircle className="h-4 w-4" />,
    }
  }

  if (days < 0) {
    return {
      status: "expired",
      label: "Đã hết hạn",
      color: "text-red-600",
      icon: <XCircle className="h-4 w-4" />,
    }
  }

  if (days <= 30) {
    return {
      status: "expiring",
      label: `Còn ${days} ngày`,
      color: "text-orange-600",
      icon: <AlertTriangle className="h-4 w-4" />,
    }
  }

  return {
    status: "valid",
    label: `Còn ${days} ngày`,
    color: "text-green-600",
    icon: <CheckCircle2 className="h-4 w-4" />,
  }
}

interface VehicleViewProps {
  vehicle: Vehicle
}

// Document type configuration
const DOCUMENT_TYPES = [
  {
    key: "registration" as const,
    title: "Đăng ký xe",
    icon: FileText,
    description: "Giấy đăng ký xe",
  },
  {
    key: "operation_permit" as const,
    title: "Phù hiệu",
    icon: Award,
    description: "Giấy phép hoạt động vận tải",
  },
  {
    key: "inspection" as const,
    title: "Đăng kiểm",
    icon: FileCheck,
    description: "Giấy chứng nhận kiểm định",
  },
  {
    key: "insurance" as const,
    title: "Bảo hiểm",
    icon: Shield,
    description: "Bảo hiểm xe",
  },
  {
    key: "emblem" as const,
    title: "Biển hiệu",
    icon: Badge,
    description: "Biển hiệu xe",
  },
]

export function VehicleView({ vehicle }: VehicleViewProps) {
  const [activeTab, setActiveTab] = useState("info")
  const [historyDialogOpen, setHistoryDialogOpen] = useState(false)

  // Calculate document statistics
  const documentStats = useMemo(() => {
    const docs = vehicle.documents || {}
    let validCount = 0
    let expiredCount = 0
    let expiringCount = 0
    let missingCount = 0

    DOCUMENT_TYPES.forEach(({ key }) => {
      const doc = docs[key]
      if (!doc) {
        missingCount++
        return
      }

      const status = getExpiryStatus(doc.expiryDate)
      if (status.status === "expired") expiredCount++
      else if (status.status === "expiring") expiringCount++
      else if (status.status === "valid") validCount++
      else missingCount++
    })

    return { validCount, expiredCount, expiringCount, missingCount, total: DOCUMENT_TYPES.length }
  }, [vehicle.documents])

  return (
    <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
      <TabsList className="grid w-full grid-cols-3">
        <TabsTrigger value="info">Thông tin cơ bản</TabsTrigger>
        <TabsTrigger value="documents">
          Giấy tờ
          {documentStats.expiredCount > 0 && (
            <span className="ml-2 px-2 py-0.5 text-xs bg-red-100 text-red-700 rounded-full">
              {documentStats.expiredCount}
            </span>
          )}
        </TabsTrigger>
        <TabsTrigger value="history">Lịch sử hoạt động</TabsTrigger>
      </TabsList>

      <TabsContent value="info" className="space-y-6 mt-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 rounded-lg">
                  <Car className="h-5 w-5 text-blue-600" />
                </div>
                <div>
                  <Label className="text-sm text-gray-500">Biển số</Label>
                  <p className="text-lg font-semibold text-gray-900">{vehicle.plateNumber}</p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-purple-100 rounded-lg">
                  <Package className="h-5 w-5 text-purple-600" />
                </div>
                <div>
                  <Label className="text-sm text-gray-500">Loại xe</Label>
                  <p className="text-lg font-semibold text-gray-900">
                    {getVehicleTypeName(vehicle) || "N/A"}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-green-100 rounded-lg">
                  <Users className="h-5 w-5 text-green-600" />
                </div>
                <div>
                  <Label className="text-sm text-gray-500">Số ghế</Label>
                  <p className="text-lg font-semibold text-gray-900">
                    {vehicle.seatCapacity || 0}
                    {vehicle.bedCapacity && ` / ${vehicle.bedCapacity} giường`}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-orange-100 rounded-lg">
                  <Building2 className="h-5 w-5 text-orange-600" />
                </div>
                <div>
                  <Label className="text-sm text-gray-500">Nhà xe</Label>
                  <p className="text-lg font-semibold text-gray-900">
                    {getOperatorName(vehicle) || "N/A"}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-red-100 rounded-lg">
                  <MapPin className="h-5 w-5 text-red-600" />
                </div>
                <div>
                  <Label className="text-sm text-gray-500">Tỉnh/Thành phố</Label>
                  <p className="text-lg font-semibold text-gray-900">
                    {vehicle.province || "N/A"}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          {(vehicle.chassisNumber || vehicle.engineNumber) && (
            <Card>
              <CardContent className="p-4">
                <div className="space-y-2">
                  <Label className="text-sm text-gray-500">Thông tin kỹ thuật</Label>
                  {vehicle.chassisNumber && (
                    <p className="text-sm text-gray-700">
                      <span className="font-medium">Số khung:</span> {vehicle.chassisNumber}
                    </p>
                  )}
                  {vehicle.engineNumber && (
                    <p className="text-sm text-gray-700">
                      <span className="font-medium">Số máy:</span> {vehicle.engineNumber}
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      </TabsContent>

      <TabsContent value="documents" className="space-y-6 mt-6">
        {/* Document Summary */}
        <Card className="bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-200">
          <CardContent className="p-6">
            <div className="flex items-center justify-between mb-4">
              <div className="flex-1">
                <div className="flex items-center gap-3 mb-1">
                  <h3 className="text-lg font-semibold text-gray-900">
                    Tổng quan giấy tờ
                  </h3>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => setHistoryDialogOpen(true)}
                    className="flex items-center gap-2"
                  >
                    <History className="h-4 w-4" />
                    Lịch sử thay đổi
                  </Button>
                </div>
                <p className="text-sm text-gray-600">
                  {documentStats.validCount}/{documentStats.total} giấy tờ còn hiệu lực
                </p>
              </div>
              <div className="flex items-center gap-4">
                {documentStats.validCount > 0 && (
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">
                      {documentStats.validCount}
                    </div>
                    <div className="text-xs text-gray-600">Hợp lệ</div>
                  </div>
                )}
                {documentStats.expiringCount > 0 && (
                  <div className="text-center">
                    <div className="text-2xl font-bold text-orange-600">
                      {documentStats.expiringCount}
                    </div>
                    <div className="text-xs text-gray-600">Sắp hết hạn</div>
                  </div>
                )}
                {documentStats.expiredCount > 0 && (
                  <div className="text-center">
                    <div className="text-2xl font-bold text-red-600">
                      {documentStats.expiredCount}
                    </div>
                    <div className="text-xs text-gray-600">Hết hạn</div>
                  </div>
                )}
                {documentStats.missingCount > 0 && (
                  <div className="text-center">
                    <div className="text-2xl font-bold text-gray-600">
                      {documentStats.missingCount}
                    </div>
                    <div className="text-xs text-gray-600">Thiếu</div>
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Document List */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {DOCUMENT_TYPES.map(({ key, title, icon: Icon, description }) => {
            const doc = vehicle.documents?.[key]
            return (
              <DocumentCard
                key={key}
                title={title}
                description={description}
                icon={Icon}
                doc={doc}
              />
            )
          })}
        </div>
      </TabsContent>

      <TabsContent value="history" className="mt-6">
        <Card>
          <CardContent className="p-6">
            <p className="text-sm text-gray-500 text-center py-8">
              Lịch sử hoạt động sẽ được hiển thị ở đây
            </p>
          </CardContent>
        </Card>
      </TabsContent>

      {/* Document History Dialog */}
      <DocumentHistoryDialog
        vehicleId={vehicle.id}
        open={historyDialogOpen}
        onClose={() => setHistoryDialogOpen(false)}
      />
    </Tabs>
  )
}

function DocumentCard({
  title,
  description,
  icon: Icon,
  doc,
}: {
  title: string
  description: string
  icon: React.ComponentType<{ className?: string }>
  doc?: DocumentInfo
}) {
  const expiryStatus = getExpiryStatus(doc?.expiryDate)
  const daysUntilExpiry = doc?.expiryDate ? getDaysUntilExpiry(doc.expiryDate) : null

  return (
    <Card
      className={`transition-all hover:shadow-lg ${
        expiryStatus.status === "expired"
          ? "border-red-300 bg-red-50/50"
          : expiryStatus.status === "expiring"
          ? "border-orange-300 bg-orange-50/50"
          : expiryStatus.status === "valid"
          ? "border-green-300 bg-green-50/50"
          : "border-gray-200 bg-gray-50/50"
      }`}
    >
      <CardContent className="p-5">
        <div className="space-y-4">
          {/* Header */}
          <div className="flex items-start justify-between">
            <div className="flex items-center gap-3">
              <div
                className={`p-2 rounded-lg ${
                  expiryStatus.status === "expired"
                    ? "bg-red-100"
                    : expiryStatus.status === "expiring"
                    ? "bg-orange-100"
                    : expiryStatus.status === "valid"
                    ? "bg-green-100"
                    : "bg-gray-100"
                }`}
              >
                <Icon
                  className={`h-5 w-5 ${
                    expiryStatus.status === "expired"
                      ? "text-red-600"
                      : expiryStatus.status === "expiring"
                      ? "text-orange-600"
                      : expiryStatus.status === "valid"
                      ? "text-green-600"
                      : "text-gray-600"
                  }`}
                />
              </div>
              <div>
                <p className="font-semibold text-base text-gray-900">{title}</p>
                <p className="text-xs text-gray-500">{description}</p>
              </div>
            </div>
            <div className={`flex items-center gap-1 ${expiryStatus.color}`}>
              {expiryStatus.icon}
              <span className="text-sm font-medium">{expiryStatus.label}</span>
            </div>
          </div>

          {/* Document Info */}
          {doc ? (
            <div className="space-y-2 pt-2 border-t border-gray-200">
              {doc.number && (
                <div className="flex items-center gap-2 text-sm">
                  <span className="text-gray-500 font-medium">Số:</span>
                  <span className="text-gray-900">{doc.number}</span>
                </div>
              )}

              {doc.issueDate && (
                <div className="flex items-center gap-2 text-sm">
                  <Calendar className="h-4 w-4 text-gray-400" />
                  <span className="text-gray-500 font-medium">Ngày cấp:</span>
                  <span className="text-gray-900">
                    {format(new Date(doc.issueDate), "dd/MM/yyyy")}
                  </span>
                </div>
              )}

              {doc.expiryDate && (
                <div className="flex items-center gap-2 text-sm">
                  <Clock className="h-4 w-4 text-gray-400" />
                  <span className="text-gray-500 font-medium">Hết hạn:</span>
                  <span className="text-gray-900">
                    {format(new Date(doc.expiryDate), "dd/MM/yyyy")}
                  </span>
                  {daysUntilExpiry !== null && daysUntilExpiry >= 0 && (
                    <span className={`text-xs px-2 py-0.5 rounded-full ${
                      daysUntilExpiry <= 30
                        ? "bg-orange-100 text-orange-700"
                        : "bg-green-100 text-green-700"
                    }`}>
                      {daysUntilExpiry === 0
                        ? "Hôm nay"
                        : daysUntilExpiry === 1
                        ? "Còn 1 ngày"
                        : `Còn ${daysUntilExpiry} ngày`}
                    </span>
                  )}
                </div>
              )}

              {doc.issuingAuthority && (
                <div className="flex items-center gap-2 text-sm">
                  <Building2 className="h-4 w-4 text-gray-400" />
                  <span className="text-gray-500 font-medium">Cơ quan cấp:</span>
                  <span className="text-gray-900">{doc.issuingAuthority}</span>
                </div>
              )}

              {doc.notes && (
                <div className="text-sm pt-1">
                  <span className="text-gray-500 font-medium">Ghi chú: </span>
                  <span className="text-gray-700">{doc.notes}</span>
                </div>
              )}
            </div>
          ) : (
            <div className="pt-2 border-t border-gray-200">
              <p className="text-sm text-gray-500 italic">Chưa có thông tin</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="client/src/features/fleet/vehicles/types/index.ts">
// Vehicles Domain Types

export type {
  Vehicle,
  VehicleInput,
  VehicleDocuments,
  DocumentInfo,
  VehicleType,
  VehicleTypeInput,
} from '@/types/fleet.types'

// Feature-specific types
export interface VehicleFilters {
  search?: string
  operatorId?: string
  vehicleTypeId?: string
  provinceId?: string
  isActive?: boolean
}

export interface VehicleFormMode {
  mode: 'create' | 'edit' | 'view'
  vehicleId?: string
}
</file>

<file path="client/src/hooks/index.ts">
export { useDebounce } from './useDebounce'
</file>

<file path="client/src/hooks/useAnimatedCounter.ts">
import { useState, useEffect, useRef } from "react";

export function useAnimatedCounter(end: number, duration: number = 1500) {
  const [count, setCount] = useState(0);
  const countRef = useRef(0);
  const frameRef = useRef<number>();

  useEffect(() => {
    if (frameRef.current) {
      cancelAnimationFrame(frameRef.current);
    }

    if (end === 0) {
      setCount(0);
      countRef.current = 0;
      return;
    }

    const startValue = countRef.current;
    const startTime = performance.now();

    const animate = (currentTime: number) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // easeOutExpo for smooth deceleration
      const easeOutExpo = 1 - Math.pow(2, -10 * progress);
      const currentValue = Math.floor(startValue + (end - startValue) * easeOutExpo);

      setCount(currentValue);
      countRef.current = currentValue;

      if (progress < 1) {
        frameRef.current = requestAnimationFrame(animate);
      } else {
        setCount(end);
        countRef.current = end;
      }
    };

    frameRef.current = requestAnimationFrame(animate);

    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, [end, duration]);

  return count;
}
</file>

<file path="client/src/hooks/useDebounce.ts">
import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(timer)
    }
  }, [value, delay])

  return debouncedValue
}
</file>

<file path="client/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
  }
}
</file>

<file path="client/src/lib/api.ts">
import axios, { AxiosError, AxiosInstance } from 'axios'

const api: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('auth_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Handle unauthorized - clear token
      localStorage.removeItem('auth_token')
      // Only redirect if not already on login page
      if (window.location.pathname !== '/login') {
        window.location.href = '/login'
      }
    }
    return Promise.reject(error)
  }
)

export default api
</file>

<file path="client/src/lib/cache.ts">
/**
 * Simple in-memory cache with TTL (Time To Live)
 * Used for caching static/semi-static data like operators, vehicle types, routes
 */

interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

class SimpleCache {
  private cache = new Map<string, CacheEntry<unknown>>();
  private defaultTTL = 5 * 60 * 1000; // 5 minutes

  /**
   * Get cached value by key
   * Returns null if not found or expired
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  /**
   * Set value in cache with optional TTL
   */
  set<T>(key: string, data: T, ttl = this.defaultTTL): void {
    this.cache.set(key, {
      data,
      expiresAt: Date.now() + ttl,
    });
  }

  /**
   * Invalidate single key
   */
  invalidate(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Invalidate all keys matching prefix
   * Useful for invalidating all operator-related cache when operator data changes
   */
  invalidatePrefix(prefix: string): void {
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Clear entire cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Check if key exists and is not expired
   */
  has(key: string): boolean {
    return this.get(key) !== null;
  }

  /**
   * Get or set pattern - fetches if not cached
   */
  async getOrSet<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl = this.defaultTTL
  ): Promise<T> {
    const cached = this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    const data = await fetcher();
    this.set(key, data, ttl);
    return data;
  }
}

// Singleton instance
export const cache = new SimpleCache();

// Cache key constants for consistency
export const CACHE_KEYS = {
  OPERATORS: 'operators',
  VEHICLE_TYPES: 'vehicle_types',
  ROUTES: 'routes',
  SHIFTS: 'shifts',
} as const;

// Default TTL values (in milliseconds)
export const CACHE_TTL = {
  SHORT: 1 * 60 * 1000,    // 1 minute
  MEDIUM: 5 * 60 * 1000,   // 5 minutes (default)
  LONG: 15 * 60 * 1000,    // 15 minutes
  VERY_LONG: 60 * 60 * 1000, // 1 hour
} as const;
</file>

<file path="client/src/lib/icon-theme.ts">
import { activeTheme } from './theme-variants'

// Icon theme configuration using active theme
export const iconTheme = {
  ...activeTheme,
  
  // Size classes
  sizes: {
    sm: "h-3 w-3",
    md: "h-4 w-4", 
    lg: "h-5 w-5",
    xl: "h-6 w-6",
  }
}

// Helper function to get icon classes
export const getIconClasses = (
  type: keyof typeof iconTheme,
  size: keyof typeof iconTheme.sizes = 'md'
) => {
  const colorClass = typeof iconTheme[type] === 'string' ? iconTheme[type] : iconTheme.default
  const sizeClass = iconTheme.sizes[size]
  return `${colorClass} ${sizeClass}`
}

// Predefined combinations for common use cases
export const iconStyles = {
  editButton: getIconClasses('edit'),
  viewButton: getIconClasses('view'),
  deleteButton: getIconClasses('delete'),
  historyButton: getIconClasses('history'),
  warningIcon: getIconClasses('warning'),
  dangerIcon: getIconClasses('danger'),
  successIcon: getIconClasses('success'),
  infoIcon: getIconClasses('info'),
  navigationIcon: getIconClasses('navigation'),
}
</file>

<file path="client/src/lib/query-cache.ts">
/**
 * Lightweight query cache using Zustand
 * Provides caching, deduplication, and background refresh for API calls
 */

import { create } from 'zustand'

interface CacheEntry<T> {
  data: T
  timestamp: number
  isStale: boolean
}

interface QueryState {
  cache: Map<string, CacheEntry<any>>
  pending: Map<string, Promise<any>>
  
  // Get cached data
  get: <T>(key: string) => T | undefined
  
  // Set cache entry
  set: <T>(key: string, data: T, ttl?: number) => void
  
  // Check if data is stale
  isStale: (key: string, maxAge: number) => boolean
  
  // Invalidate cache entries
  invalidate: (pattern: string) => void
  invalidateAll: () => void
  
  // Deduplicated fetch
  fetchWithCache: <T>(
    key: string,
    fetcher: () => Promise<T>,
    options?: { ttl?: number; staleTime?: number; forceRefresh?: boolean }
  ) => Promise<T>
}

// Default TTL values in milliseconds
export const CACHE_TTL = {
  SHORT: 30 * 1000,       // 30 seconds - frequently changing data
  MEDIUM: 2 * 60 * 1000,  // 2 minutes - moderately changing data
  LONG: 5 * 60 * 1000,    // 5 minutes - rarely changing data
  STATIC: 10 * 60 * 1000, // 10 minutes - static data
}

export const useQueryCache = create<QueryState>((set, get) => ({
  cache: new Map(),
  pending: new Map(),

  get: <T>(key: string): T | undefined => {
    const entry = get().cache.get(key)
    return entry?.data as T | undefined
  },

  set: <T>(key: string, data: T, ttl = CACHE_TTL.MEDIUM) => {
    set((state) => {
      const newCache = new Map(state.cache)
      newCache.set(key, {
        data,
        timestamp: Date.now(),
        isStale: false,
      })
      
      // Auto-mark as stale after TTL
      setTimeout(() => {
        set((s) => {
          const cache = new Map(s.cache)
          const entry = cache.get(key)
          if (entry) {
            cache.set(key, { ...entry, isStale: true })
          }
          return { cache }
        })
      }, ttl)
      
      return { cache: newCache }
    })
  },

  isStale: (key: string, maxAge: number): boolean => {
    const entry = get().cache.get(key)
    if (!entry) return true
    return entry.isStale || Date.now() - entry.timestamp > maxAge
  },

  invalidate: (pattern: string) => {
    set((state) => {
      const newCache = new Map(state.cache)
      const regex = new RegExp(pattern)
      for (const key of newCache.keys()) {
        if (regex.test(key)) {
          newCache.delete(key)
        }
      }
      return { cache: newCache }
    })
  },

  invalidateAll: () => {
    set({ cache: new Map() })
  },

  fetchWithCache: async <T>(
    key: string,
    fetcher: () => Promise<T>,
    options: { ttl?: number; staleTime?: number; forceRefresh?: boolean } = {}
  ): Promise<T> => {
    const { ttl = CACHE_TTL.MEDIUM, staleTime = ttl, forceRefresh = false } = options
    const state = get()

    // Return cached data if fresh and not force refresh
    if (!forceRefresh) {
      const cached = state.cache.get(key)
      if (cached && !state.isStale(key, staleTime)) {
        return cached.data as T
      }
    }

    // Deduplicate concurrent requests
    const pending = state.pending.get(key)
    if (pending) {
      return pending as Promise<T>
    }

    // Fetch fresh data
    const promise = fetcher()
      .then((data) => {
        get().set(key, data, ttl)
        return data
      })
      .catch((error) => {
        // Remove from pending on error so next call can retry
        set((s) => {
          const newPending = new Map(s.pending)
          newPending.delete(key)
          return { pending: newPending }
        })
        throw error
      })
      .finally(() => {
        set((s) => {
          const newPending = new Map(s.pending)
          newPending.delete(key)
          return { pending: newPending }
        })
      })

    set((s) => {
      const newPending = new Map(s.pending)
      newPending.set(key, promise)
      return { pending: newPending }
    })

    return promise
  },
}))

// Cache key generators
export const cacheKeys = {
  vehicles: () => 'vehicles',
  vehicleById: (id: string) => `vehicle:${id}`,
  
  drivers: () => 'drivers',
  driverById: (id: string) => `driver:${id}`,
  
  routes: () => 'routes',
  routeById: (id: string) => `route:${id}`,
  
  operators: () => 'operators',
  operatorById: (id: string) => `operator:${id}`,
  
  schedules: () => 'schedules',
  schedulesByRoute: (routeId: string) => `schedules:route:${routeId}`,
  
  dispatch: () => 'dispatch',
  dispatchById: (id: string) => `dispatch:${id}`,
  
  services: () => 'services',
  serviceCharges: (dispatchId: string) => `service-charges:${dispatchId}`,
  
  vehicleTypes: () => 'vehicle-types',
  vehicleBadges: () => 'vehicle-badges',
  shifts: () => 'shifts',
  locations: () => 'locations',
}

// Hook for cached queries
export function useCachedQuery<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: { ttl?: number; staleTime?: number; enabled?: boolean } = {}
) {
  const { ttl, staleTime, enabled = true } = options
  const { fetchWithCache, get: getCached, isStale } = useQueryCache()
  
  const cachedData = getCached<T>(key)
  const needsFetch = enabled && (cachedData === undefined || isStale(key, staleTime || ttl || CACHE_TTL.MEDIUM))
  
  // Start fetch if needed (will be deduplicated)
  if (needsFetch) {
    fetchWithCache(key, fetcher, { ttl, staleTime })
  }
  
  return {
    data: cachedData,
    isLoading: needsFetch && cachedData === undefined,
    refetch: () => fetchWithCache(key, fetcher, { ttl, staleTime, forceRefresh: true }),
  }
}
</file>

<file path="client/src/lib/README-THEMES.md">
# Icon Theme System

Hệ thống này cho phép thay đổi màu sắc của tất cả icon trong ứng dụng một cách đồng bộ.

## Cách sử dụng

### 1. Thay đổi theme toàn bộ ứng dụng

Mở file `theme-variants.ts` và thay đổi giá trị `ACTIVE_THEME`:

```typescript
// Thay đổi từ 'default' sang theme khác
export const ACTIVE_THEME: keyof typeof colorThemes = 'professional' // hoặc 'vibrant', 'minimal'
```

### 2. Các theme có sẵn

- **default**: Theme xanh dương chuyên nghiệp (mặc định)
- **professional**: Theme xám sang trọng
- **vibrant**: Theme màu sắc rực rỡ
- **minimal**: Theme tối giản đen trắng

### 3. Tạo theme mới

Thêm theme mới vào `colorThemes` trong `theme-variants.ts`:

```typescript
export const colorThemes = {
  // ... existing themes
  
  myCustomTheme: {
    edit: "text-pink-600 hover:text-pink-700",
    view: "text-cyan-600 hover:text-cyan-700", 
    delete: "text-red-600 hover:text-red-700",
    history: "text-teal-600 hover:text-teal-700",
    warning: "text-yellow-600",
    danger: "text-red-600",
    success: "text-green-600",
    info: "text-blue-600",
    navigation: "text-gray-600 hover:text-gray-700",
    default: "text-gray-500 hover:text-gray-600",
    muted: "text-gray-400",
  }
}
```

### 4. Sử dụng trong component

```typescript
import { iconStyles } from "@/lib/icon-theme"

// Sử dụng style có sẵn
<Edit className={iconStyles.editButton} />
<History className={iconStyles.historyButton} />

// Hoặc sử dụng function helper
import { getIconClasses } from "@/lib/icon-theme"
<Edit className={getIconClasses('edit', 'lg')} />
```

### 5. Các style có sẵn

- `iconStyles.editButton` - Nút chỉnh sửa
- `iconStyles.viewButton` - Nút xem
- `iconStyles.deleteButton` - Nút xóa
- `iconStyles.historyButton` - Nút lịch sử
- `iconStyles.warningIcon` - Icon cảnh báo
- `iconStyles.dangerIcon` - Icon nguy hiểm
- `iconStyles.successIcon` - Icon thành công
- `iconStyles.infoIcon` - Icon thông tin
- `iconStyles.navigationIcon` - Icon điều hướng

## Thư viện Icon

Dự án sử dụng **Lucide React** (https://lucide.dev/) cho tất cả các icon.

### Cài đặt thêm icon:
```bash
npm install lucide-react
```

### Import và sử dụng:
```typescript
import { IconName } from "lucide-react"
<IconName className={iconStyles.editButton} />
```
</file>

<file path="client/src/lib/theme-variants.ts">
// Different color themes for icons
export const colorThemes = {
  // Default blue theme
  default: {
    edit: "text-blue-600 hover:text-blue-700",
    view: "text-green-600 hover:text-green-700", 
    delete: "text-red-600 hover:text-red-700",
    history: "text-purple-600 hover:text-purple-700",
    warning: "text-yellow-600",
    danger: "text-red-600",
    success: "text-green-600",
    info: "text-blue-600",
    navigation: "text-gray-600 hover:text-gray-700",
    default: "text-gray-500 hover:text-gray-600",
    muted: "text-gray-400",
  },

  // Professional gray theme
  professional: {
    edit: "text-slate-600 hover:text-slate-700",
    view: "text-slate-600 hover:text-slate-700", 
    delete: "text-red-600 hover:text-red-700",
    history: "text-slate-600 hover:text-slate-700",
    warning: "text-amber-600",
    danger: "text-red-600",
    success: "text-emerald-600",
    info: "text-slate-600",
    navigation: "text-slate-500 hover:text-slate-600",
    default: "text-slate-400 hover:text-slate-500",
    muted: "text-slate-300",
  },

  // Vibrant theme
  vibrant: {
    edit: "text-indigo-600 hover:text-indigo-700",
    view: "text-emerald-600 hover:text-emerald-700", 
    delete: "text-rose-600 hover:text-rose-700",
    history: "text-violet-600 hover:text-violet-700",
    warning: "text-orange-600",
    danger: "text-rose-600",
    success: "text-emerald-600",
    info: "text-sky-600",
    navigation: "text-gray-600 hover:text-gray-700",
    default: "text-gray-500 hover:text-gray-600",
    muted: "text-gray-400",
  },

  // Minimal theme
  minimal: {
    edit: "text-gray-700 hover:text-gray-800",
    view: "text-gray-700 hover:text-gray-800", 
    delete: "text-gray-700 hover:text-gray-800",
    history: "text-gray-700 hover:text-gray-800",
    warning: "text-gray-700",
    danger: "text-gray-700",
    success: "text-gray-700",
    info: "text-gray-700",
    navigation: "text-gray-600 hover:text-gray-700",
    default: "text-gray-500 hover:text-gray-600",
    muted: "text-gray-400",
  }
}

// Current active theme - change this to switch themes globally
export const ACTIVE_THEME: keyof typeof colorThemes = 'default'

// Export the active theme
export const activeTheme = colorThemes[ACTIVE_THEME]
</file>

<file path="client/src/lib/toast.ts">
import { toast, ToastOptions } from "react-toastify"

const defaultOptions: ToastOptions = {
  position: "top-right",
  autoClose: 3000,
  hideProgressBar: false,
  closeOnClick: true,
  pauseOnHover: true,
  draggable: true,
}

export const toastService = {
  success: (message: string, options?: ToastOptions) => {
    toast.success(message, { ...defaultOptions, ...options })
  },

  error: (message: string, options?: ToastOptions) => {
    toast.error(message, { ...defaultOptions, ...options })
  },

  warning: (message: string, options?: ToastOptions) => {
    toast.warning(message, { ...defaultOptions, ...options })
  },

  info: (message: string, options?: ToastOptions) => {
    toast.info(message, { ...defaultOptions, ...options })
  },
}
</file>

<file path="client/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Re-export Vietnam time utilities for convenience
export {
  parseVietnamDateTime,
  formatVietnamDateTime,
  getCurrentVietnamTime,
  getCurrentVietnamTimeFormatted,
  toVietnamISO,
  isValidISODateString,
  DEFAULT_DATE_FORMAT,
  VIETNAM_TIMEZONE,
  VIETNAM_TIMEZONE_OFFSET_HOURS,
} from "./vietnam-time"
</file>

<file path="client/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="client/src/pages/BaoCao.tsx">
import { useState, useEffect, useCallback } from "react"
import { toast } from "react-toastify"
import { Download, RefreshCw } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { reportService } from "@/services/report.service"
import { format, subDays } from "date-fns"
import { useUIStore } from "@/store/ui.store"

type ReportType = "invoices" | "vehicle-logs" | "station-activity" | "invalid-vehicles" | "revenue"

// Helper function to safely format dates
const safeFormatDate = (dateString: string | undefined | null): string => {
  if (!dateString) return "-"
  try {
    const date = new Date(dateString)
    if (isNaN(date.getTime())) return "-"
    return format(date, "dd/MM/yyyy")
  } catch {
    return "-"
  }
}

export default function BaoCao() {
  const [reportType, setReportType] = useState<ReportType>("invoices")
  const [startDate, setStartDate] = useState(
    format(subDays(new Date(), 7), "yyyy-MM-dd")
  )
  const [endDate, setEndDate] = useState(format(new Date(), "yyyy-MM-dd"))
  const [isLoading, setIsLoading] = useState(false)
  const [data, setData] = useState<any[]>([])
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Báo cáo & Thống kê")
  }, [setTitle])

  const loadReport = useCallback(async () => {
    setIsLoading(true)
    try {
      const filter = { startDate, endDate }
      let result: any[] = []

      switch (reportType) {
        case "invoices":
          result = await reportService.getInvoices(filter)
          break
        case "vehicle-logs":
          result = await reportService.getVehicleLogs(filter)
          break
        case "station-activity":
          result = await reportService.getStationActivity(filter)
          break
        case "invalid-vehicles":
          result = await reportService.getInvalidVehicles(filter)
          break
        case "revenue":
          result = await reportService.getRevenue(filter)
          break
      }

      setData(result)
    } catch (error) {
      console.error("Failed to load report:", error)
      toast.error("Không thể tải báo cáo. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }, [reportType, startDate, endDate])

  // Auto load report when reportType changes
  useEffect(() => {
    loadReport()
  }, [loadReport])

  const handleExport = async () => {
    try {
      const filter = {
        startDate,
        endDate,
      }
      const blob = await reportService.exportExcel(reportType, filter)
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = `bao-cao-${reportType}-${startDate}-${endDate}.xlsx`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      window.URL.revokeObjectURL(url)
    } catch (error) {
      console.error("Failed to export:", error)
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-start justify-end">
        <Button variant="outline" onClick={handleExport}>
          <Download className="mr-2 h-4 w-4" />
          Xuất Excel
        </Button>
      </div>

      {/* Report Type Tabs */}
      <Card>
        <CardHeader>
          <CardTitle>Loại báo cáo</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={reportType} onValueChange={(value) => setReportType(value as ReportType)}>
            <TabsList className="w-full justify-start">
              <TabsTrigger value="invoices">Bảng kê hóa đơn</TabsTrigger>
              <TabsTrigger value="vehicle-logs">Nhật trình xe</TabsTrigger>
              <TabsTrigger value="station-activity">Xe ra vào bến</TabsTrigger>
              <TabsTrigger value="invalid-vehicles">Xe không đủ điều kiện</TabsTrigger>
              <TabsTrigger value="revenue">Doanh thu</TabsTrigger>
            </TabsList>
          </Tabs>
        </CardContent>
      </Card>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle>Bộ lọc</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid gap-4 md:grid-cols-3">
            <div>
              <Label htmlFor="startDate">Từ ngày</Label>
              <Input
                id="startDate"
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
              />
            </div>
            <div>
              <Label htmlFor="endDate">Đến ngày</Label>
              <Input
                id="endDate"
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
              />
            </div>
            <div className="flex items-end gap-2">
              <Button onClick={loadReport} className="w-full">
                <RefreshCw className="mr-2 h-4 w-4" />
                Tải lại
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Report Content */}
      <Card>
        <CardHeader>
          <CardTitle>
            {reportType === "invoices" && "Bảng kê hóa đơn"}
            {reportType === "vehicle-logs" && "Nhật trình xe"}
            {reportType === "station-activity" && "Xe ra vào bến"}
            {reportType === "invalid-vehicles" && "Xe không đủ điều kiện"}
            {reportType === "revenue" && "Doanh thu"}
          </CardTitle>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="text-center py-8">
              <div className="mb-4 h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent mx-auto" />
              <p className="text-gray-600">Đang tải...</p>
            </div>
          ) : data.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              Không có dữ liệu
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  {reportType === "invoices" && (
                    <>
                      <TableHead>Mã hóa đơn</TableHead>
                      <TableHead>Biển số</TableHead>
                      <TableHead>Tuyến</TableHead>
                      <TableHead>Số tiền</TableHead>
                      <TableHead>Ngày</TableHead>
                    </>
                  )}
                  {reportType === "revenue" && (
                    <>
                      <TableHead>Ngày</TableHead>
                      <TableHead>Tổng doanh thu</TableHead>
                      <TableHead>Số xe</TableHead>
                      <TableHead>Số giao dịch</TableHead>
                    </>
                  )}
                  {reportType === "invalid-vehicles" && (
                    <>
                      <TableHead>Biển số</TableHead>
                      <TableHead>Lý do</TableHead>
                      <TableHead>Ngày</TableHead>
                    </>
                  )}
                </TableRow>
              </TableHeader>
              <TableBody>
                {data.map((item, index) => (
                  <TableRow key={index}>
                    {reportType === "invoices" && (
                      <>
                        <TableCell>{item.id}</TableCell>
                        <TableCell>{item.vehiclePlateNumber}</TableCell>
                        <TableCell>{item.route}</TableCell>
                        <TableCell>
                          {new Intl.NumberFormat("vi-VN").format(item.amount)} đ
                        </TableCell>
                        <TableCell>
                          {safeFormatDate(item.issueDate)}
                        </TableCell>
                      </>
                    )}
                    {reportType === "revenue" && (
                      <>
                        <TableCell>
                          {safeFormatDate(item.date)}
                        </TableCell>
                        <TableCell>
                          {new Intl.NumberFormat("vi-VN").format(item.totalRevenue)} đ
                        </TableCell>
                        <TableCell>{item.vehicleCount}</TableCell>
                        <TableCell>{item.transactionCount}</TableCell>
                      </>
                    )}
                    {reportType === "invalid-vehicles" && (
                      <>
                        <TableCell>{item.plateNumber}</TableCell>
                        <TableCell>{item.reason}</TableCell>
                        <TableCell>
                          {safeFormatDate(item.date)}
                        </TableCell>
                      </>
                    )}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="client/src/pages/BaoCaoCapPhepRaBen.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface PermitData {
  plateNumber: string;
  operatorName: string;
  routeName: string;
  entryTime: string;
  permitTime: string;
  permitBy: string;
  exitTime: string;
}

export default function BaoCaoCapPhepRaBen() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<PermitData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  useEffect(() => {
    setTitle("Báo cáo > Cấp phép ra bến");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          // Filter by permit time if available, otherwise by entry time
          const filterDate = record.boardingPermitTime || record.entryTime;
          if (filterDate) {
            const recordDate = new Date(filterDate);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Only show records that have been issued a permit (approved)
      const permitRecords = filteredRecords.filter(
        (record) => record.boardingPermitTime && record.permitStatus === "approved"
      );

      // Map to permit data
      const result = permitRecords.map((record) => ({
        plateNumber: record.vehiclePlateNumber || "-",
        operatorName: record.vehicle?.operator?.name || "-",
        routeName: record.routeName || "-",
        entryTime: record.entryTime || "-",
        permitTime: record.boardingPermitTime || "-",
        permitBy: record.boardingPermitBy || "-",
        exitTime: record.exitTime || "-",
      }));

      setData(result);
    } catch (error) {
      console.error("Failed to load permit data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredData = useMemo(() => {
    let filtered = data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "plateNumber":
            aValue = a.plateNumber || "";
            bValue = b.plateNumber || "";
            break;
          case "operatorName":
            aValue = a.operatorName || "";
            bValue = b.operatorName || "";
            break;
          case "routeName":
            aValue = a.routeName || "";
            bValue = b.routeName || "";
            break;
          case "entryTime":
            aValue = a.entryTime !== "-" ? new Date(a.entryTime).getTime() : 0;
            bValue = b.entryTime !== "-" ? new Date(b.entryTime).getTime() : 0;
            break;
          case "permitTime":
            aValue = a.permitTime !== "-" ? new Date(a.permitTime).getTime() : 0;
            bValue = b.permitTime !== "-" ? new Date(b.permitTime).getTime() : 0;
            break;
          case "permitBy":
            aValue = a.permitBy || "";
            bValue = b.permitBy || "";
            break;
          case "exitTime":
            aValue = a.exitTime !== "-" ? new Date(a.exitTime).getTime() : 0;
            bValue = b.exitTime !== "-" ? new Date(b.exitTime).getTime() : 0;
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [data, searchQuery, sortColumn, sortDirection]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Tên đơn vị": item.operatorName,
        "Tên luồng tuyến": item.routeName,
        "Thời gian vào bến": item.entryTime !== "-" 
          ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") 
          : "-",
        "Thời gian cấp phép ra bến": item.permitTime !== "-"
          ? format(new Date(item.permitTime), "dd/MM/yyyy HH:mm")
          : "-",
        "Người cấp phép ra bến": item.permitBy,
        "Thời gian ra bến": item.exitTime !== "-"
          ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm")
          : "-",
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Cấp phép ra bến");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 20 },  // Thời gian vào bến
        { wch: 25 },  // Thời gian cấp phép ra bến
        { wch: 25 },  // Người cấp phép ra bến
        { wch: 20 },  // Thời gian ra bến
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-cap-phep-ra-ben_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-100">
                  <TableHead className="text-center font-semibold">STT</TableHead>
                  <SortableTableHead
                    sortKey="plateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Biển số
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="operatorName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên đơn vị
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên luồng tuyến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="entryTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Thời gian vào bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="permitTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Thời gian cấp phép ra bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="permitBy"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Người cấp phép ra bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="exitTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Thời gian ra bến
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={8} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={8} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <TableRow key={`${item.plateNumber}-${item.permitTime}-${index}`}>
                      <TableCell className="text-center">
                        {index + 1}
                      </TableCell>
                      <TableCell className="text-center font-semibold">
                        {item.plateNumber}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.operatorName}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.routeName}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderTime(item.entryTime)}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderTime(item.permitTime)}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.permitBy}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderTime(item.exitTime)}
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoChamCongDangTai.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, Download, Filter, Calendar, BarChart3 } from "lucide-react";
import { toast } from "react-toastify";
import { format, startOfMonth, endOfMonth, getDaysInMonth } from "date-fns";
import { vi } from "date-fns/locale";
import * as XLSX from "xlsx";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { dispatchService } from "@/services/dispatch.service";
import { routeService } from "@/services/route.service";
import { operatorService } from "@/services/operator.service";
import { useUIStore } from "@/store/ui.store";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { MonthPicker } from "@/components/ui/month-picker";
import { ChevronDownIcon } from "lucide-react";
import {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
} from "@/components/ui/sticky-table";

interface AttendanceData {
  plateNumber: string;
  operatorName: string;
  routeName: string;
  routeType: string;
  registeredTrips: number; // Số chuyến đăng ký tháng
  dailyTrips: Record<number, number>; // Số chuyến theo từng ngày
  totalActual: number; // Tổng thực hiện
}

export default function BaoCaoChamCongDangTai() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<AttendanceData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedMonth, setSelectedMonth] = useState<Date>(new Date());
  const [selectedRouteType, setSelectedRouteType] = useState<string>("");
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");
  const [selectedRouteId, setSelectedRouteId] = useState<string>("");
  const [routeTypes, setRouteTypes] = useState<string[]>([]);
  const [operators, setOperators] = useState<any[]>([]);
  const [routes, setRoutes] = useState<any[]>([]);
  const [monthPickerOpen, setMonthPickerOpen] = useState(false);

  useEffect(() => {
    setTitle("Báo cáo > Chấm công đăng tài");
    loadOperators();
    loadRoutes();
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedMonth]);

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const loadRoutes = async () => {
    try {
      const data = await routeService.getAll();
      setRoutes(data);
      
      // Extract unique route types
      const types = new Set<string>();
      data.forEach((route) => {
        if (route.routeType) {
          types.add(route.routeType);
        }
      });
      setRouteTypes(Array.from(types).sort());
    } catch (error) {
      console.error("Failed to load routes:", error);
    }
  };

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by selected month
      const monthStart = startOfMonth(selectedMonth);
      const monthEnd = endOfMonth(selectedMonth);
      
      const filteredRecords = dispatchRecords.filter((record) => {
        const recordDate = new Date(record.entryTime);
        return recordDate >= monthStart && recordDate <= monthEnd;
      });

      // Group by vehicle and route
      const grouped = new Map<string, AttendanceData>();
      
      filteredRecords.forEach((record) => {
        const key = `${record.vehicleId}-${record.routeId}`;
        const plateNumber = record.vehiclePlateNumber || "-";
        const operatorName = record.vehicle?.operator?.name || "-";
        const routeName = record.routeName || "-";
        const routeType = record.route?.routeType || "-";
        
        if (!grouped.has(key)) {
          grouped.set(key, {
            plateNumber,
            operatorName,
            routeName,
            routeType,
            registeredTrips: 0,
            dailyTrips: {},
            totalActual: 0,
          });
        }
        
        const item = grouped.get(key)!;
        
        // Count trips by day
        const recordDate = new Date(record.entryTime);
        const day = recordDate.getDate();
        
        if (!item.dailyTrips[day]) {
          item.dailyTrips[day] = 0;
        }
        item.dailyTrips[day] += 1;
        item.totalActual += 1;
        
        // For registered trips, we'll use a simple calculation
        // In a real scenario, this would come from schedules
        item.registeredTrips = Math.max(item.registeredTrips, item.totalActual);
      });
      
      // Convert to array and sort
      const result = Array.from(grouped.values()).sort((a, b) => 
        a.plateNumber.localeCompare(b.plateNumber)
      );
      
      setData(result);
    } catch (error) {
      console.error("Failed to load attendance data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        matchesSearch = 
          item.plateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query);
      }
      
      // Route type filter
      let matchesRouteType = true;
      if (selectedRouteType) {
        matchesRouteType = item.routeType === selectedRouteType;
      }
      
      // Operator filter
      let matchesOperator = true;
      if (selectedOperatorId) {
        const operator = operators.find((op) => op.id === selectedOperatorId);
        matchesOperator = item.operatorName === (operator?.name || "");
      }
      
      // Route filter
      let matchesRoute = true;
      if (selectedRouteId) {
        const route = routes.find((r) => r.id === selectedRouteId);
        matchesRoute = item.routeName === (route?.routeName || "");
      }
      
      return matchesSearch && matchesRouteType && matchesOperator && matchesRoute;
    });
  }, [data, searchQuery, selectedRouteType, selectedOperatorId, selectedRouteId, operators, routes]);

  // Get days in selected month
  const daysInMonth = useMemo(() => {
    return getDaysInMonth(selectedMonth);
  }, [selectedMonth]);

  const monthDays = useMemo(() => {
    return Array.from({ length: daysInMonth }, (_, i) => i + 1);
  }, [daysInMonth]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData: any[] = [];
      
      filteredData.forEach((item, index) => {
        const row: any = {
          "STT": index + 1,
          "Biển số": item.plateNumber,
          "Tên đơn vị": item.operatorName,
          "Tên tuyến": item.routeName,
          "Loại tuyến": item.routeType,
        };
        
        // Add daily trips
        monthDays.forEach((day) => {
          row[`Ngày ${day.toString().padStart(2, "0")}`] = item.dailyTrips[day] || 0;
        });
        
        row["Số chuyến đăng ký tháng"] = item.registeredTrips;
        row["Tổng thực hiện"] = item.totalActual;
        
        excelData.push(row);
      });

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Chấm công đăng tài");

      // Generate filename with current month
      const monthStr = format(selectedMonth, "MM-yyyy");
      const filename = `Bao-cao-cham-cong-dang-tai_${monthStr}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  // Calculate totals
  const totals = useMemo(() => {
    return filteredData.reduce(
      (acc, item) => ({
        registeredTrips: acc.registeredTrips + item.registeredTrips,
        totalActual: acc.totalActual + item.totalActual,
        dailyTotals: monthDays.reduce((dailyAcc, day) => {
          dailyAcc[day] = (dailyAcc[day] || 0) + (item.dailyTrips[day] || 0);
          return dailyAcc;
        }, {} as Record<number, number>),
      }),
      {
        registeredTrips: 0,
        totalActual: 0,
        dailyTotals: {} as Record<number, number>,
      }
    );
  }, [filteredData, monthDays]);

  const formatMonthDisplay = (date: Date) => {
    return format(date, "MM/yyyy", { locale: vi });
  };

  return (
    <div className="space-y-4">
      {/* Filters */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Bộ lọc và tìm kiếm
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <Download className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <div className="space-y-2">
              <Label htmlFor="month-picker" className="flex items-center gap-2">
                <Calendar className="h-4 w-4" />
                Tháng báo cáo <span className="text-red-500">*</span>
              </Label>
              <Popover open={monthPickerOpen} onOpenChange={setMonthPickerOpen}>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    id="month-picker"
                    className="w-full justify-between font-normal"
                  >
                    {formatMonthDisplay(selectedMonth)}
                    <ChevronDownIcon className="h-4 w-4" />
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0 z-[200]" align="start">
                  <MonthPicker
                    selectedMonth={selectedMonth}
                    onMonthSelect={(date) => {
                      setSelectedMonth(date);
                      setMonthPickerOpen(false);
                    }}
                  />
                </PopoverContent>
              </Popover>
            </div>
            
            <div className="space-y-2">
              <Label>Tìm kiếm</Label>
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-500" />
                <Input
                  placeholder="Biển số, đơn vị, tuyến..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-9"
                />
              </div>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="routeType">Loại tuyến</Label>
              <Select
                id="routeType"
                value={selectedRouteType}
                onChange={(e) => setSelectedRouteType(e.target.value)}
              >
                <option value="">Tất cả loại tuyến</option>
                {routeTypes.map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </Select>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="operator">Doanh nghiệp</Label>
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Tất cả doanh nghiệp</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="route">Tuyến vận chuyển</Label>
              <Select
                id="route"
                value={selectedRouteId}
                onChange={(e) => setSelectedRouteId(e.target.value)}
              >
                <option value="">Tất cả tuyến</option>
                {routes.map((route) => (
                  <option key={route.id} value={route.id}>
                    {route.routeName}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          {/* Active Filters */}
          {(searchQuery || selectedRouteType || selectedOperatorId || selectedRouteId) && (
            <div className="flex flex-wrap gap-2">
              <span className="text-sm text-gray-600">Bộ lọc đang áp dụng:</span>
              {searchQuery && (
                <Badge variant="secondary" className="gap-1">
                  Tìm kiếm: {searchQuery}
                  <button
                    onClick={() => setSearchQuery("")}
                    className="ml-1 hover:bg-gray-300 rounded-full p-0.5"
                  >
                    ×
                  </button>
                </Badge>
              )}
              {selectedRouteType && (
                <Badge variant="secondary" className="gap-1">
                  Loại tuyến: {selectedRouteType}
                  <button
                    onClick={() => setSelectedRouteType("")}
                    className="ml-1 hover:bg-gray-300 rounded-full p-0.5"
                  >
                    ×
                  </button>
                </Badge>
              )}
              {selectedOperatorId && (
                <Badge variant="secondary" className="gap-1">
                  Doanh nghiệp: {operators.find(op => op.id === selectedOperatorId)?.name}
                  <button
                    onClick={() => setSelectedOperatorId("")}
                    className="ml-1 hover:bg-gray-300 rounded-full p-0.5"
                  >
                    ×
                  </button>
                </Badge>
              )}
              {selectedRouteId && (
                <Badge variant="secondary" className="gap-1">
                  Tuyến: {routes.find(r => r.id === selectedRouteId)?.routeName}
                  <button
                    onClick={() => setSelectedRouteId("")}
                    className="ml-1 hover:bg-gray-300 rounded-full p-0.5"
                  >
                    ×
                  </button>
                </Badge>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={() => {
                  setSearchQuery("");
                  setSelectedRouteType("");
                  setSelectedOperatorId("");
                  setSelectedRouteId("");
                }}
                className="h-6 px-2 text-xs"
              >
                Xóa tất cả
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Data Table */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              <BarChart3 className="h-5 w-5" />
              Bảng chấm công chi tiết
            </CardTitle>
            <div className="flex items-center gap-2 text-sm text-gray-600">
              <span>Hiển thị {filteredData.length} xe</span>
              {filteredData.length !== data.length && (
                <span>/ {data.length} tổng</span>
              )}
            </div>
          </div>
        </CardHeader>
        <CardContent className="p-0">
          {/* Legend */}
          <div className="px-6 py-3 bg-gray-50 border-b">
            <div className="flex flex-wrap items-center gap-6 text-sm">
              <span className="font-medium text-gray-700">Chú thích số chuyến:</span>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-green-600 rounded"></div>
                <span className="text-green-700">≥ 3 chuyến (Cao)</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-green-100 border border-green-300 rounded"></div>
                <span className="text-green-700">2 chuyến (Trung bình)</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-blue-100 border border-blue-300 rounded"></div>
                <span className="text-blue-700">1 chuyến (Thấp)</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-gray-50 border border-gray-300 rounded"></div>
                <span className="text-gray-600">0 chuyến (Không hoạt động)</span>
              </div>
            </div>
          </div>
          
          <div className="overflow-hidden">
            <StickyTable className="min-w-full" style={{ tableLayout: "fixed" }}>
                <colgroup>
                  <col className="w-[60px]" />
                  <col className="w-[150px]" />
                  {monthDays.map((_, idx) => (
                    <col key={idx} className="w-[50px]" />
                  ))}
                  <col className="w-[150px]" />
                  <col className="w-[120px]" />
                </colgroup>
              <StickyTableHeader>
                {/* Main header row */}
                <StickyTableRow className="bg-gray-100">
                  <StickyTableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle bg-gray-100"
                    sticky
                    stickyLeft={0}
                    style={{ 
                      width: "60px", 
                      minWidth: "60px", 
                      maxWidth: "60px",
                      backgroundColor: "#f3f4f6"
                    }}
                  >
                    STT
                  </StickyTableHead>
                  <StickyTableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle bg-gray-100"
                    sticky
                    stickyLeft={60}
                    style={{ 
                      width: "150px", 
                      minWidth: "150px", 
                      maxWidth: "150px",
                      backgroundColor: "#f3f4f6"
                    }}
                  >
                    Biển kiểm soát
                  </StickyTableHead>
                  <StickyTableHead
                    colSpan={daysInMonth}
                    className="text-center font-semibold border-r border-gray-300 bg-gray-100"
                  >
                    Tháng {format(selectedMonth, "MM", { locale: vi })}
                  </StickyTableHead>
                  <StickyTableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle bg-gray-100"
                    sticky
                    stickyRight={120}
                    style={{ 
                      width: "150px", 
                      minWidth: "150px", 
                      maxWidth: "150px",
                      backgroundColor: "#f3f4f6"
                    }}
                  >
                    Số chuyến đăng ký tháng =
                  </StickyTableHead>
                  <StickyTableHead
                    rowSpan={2}
                    className="text-center font-semibold align-middle bg-gray-100"
                    sticky
                    stickyRight={0}
                    style={{ 
                      width: "120px", 
                      minWidth: "120px", 
                      maxWidth: "120px",
                      backgroundColor: "#f3f4f6"
                    }}
                  >
                    Tổng thực hiện =
                  </StickyTableHead>
                </StickyTableRow>
                {/* Sub-header row */}
                <StickyTableRow className="bg-gray-50">
                  {monthDays.map((day) => (
                    <StickyTableHead
                      key={day}
                      className="text-center font-medium border-r border-gray-200"
                      style={{ width: "50px", minWidth: "50px" }}
                    >
                      {day.toString().padStart(2, "0")}
                    </StickyTableHead>
                  ))}
                </StickyTableRow>
              </StickyTableHeader>
              <StickyTableBody>
                  {isLoading ? (
                    <StickyTableRow>
                      <StickyTableCell
                        colSpan={2 + daysInMonth + 2}
                        className="text-center text-gray-500 py-4"
                      >
                        Đang tải dữ liệu...
                      </StickyTableCell>
                    </StickyTableRow>
                  ) : filteredData.length === 0 ? (
                    <StickyTableRow>
                      <StickyTableCell
                        colSpan={2 + daysInMonth + 2}
                        className="text-center text-gray-500 py-4"
                      >
                        Không có dữ liệu
                      </StickyTableCell>
                    </StickyTableRow>
                  ) : (
                    <>
                      {filteredData.map((item, index) => {
                        const completionRate = item.registeredTrips > 0 
                          ? (item.totalActual / item.registeredTrips) * 100 
                          : 0;
                        const isLowPerformance = completionRate < 80;
                        const isHighPerformance = completionRate >= 100;
                        
                        return (
                          <StickyTableRow 
                            key={`${item.plateNumber}-${item.routeName}-${index}`}
                            className={`hover:bg-gray-50 ${
                              isLowPerformance ? 'bg-red-50' : 
                              isHighPerformance ? 'bg-green-50' : ''
                            }`}
                          >
                            <StickyTableCell 
                              className="text-center border-r border-gray-200 py-2"
                              sticky
                              stickyLeft={0}
                              style={{ 
                                width: "60px", 
                                minWidth: "60px", 
                                maxWidth: "60px"
                              }}
                            >
                              {index + 1}
                            </StickyTableCell>
                            <StickyTableCell 
                              className="border-r border-gray-200 py-2 px-3"
                              sticky
                              stickyLeft={60}
                              style={{ 
                                width: "150px", 
                                minWidth: "150px", 
                                maxWidth: "150px"
                              }}
                            >
                              <div className="space-y-1">
                                <div className="font-semibold text-center">{item.plateNumber}</div>
                                <div className="text-xs text-gray-600 text-center truncate" title={item.operatorName}>
                                  {item.operatorName}
                                </div>
                                <div className="text-xs text-blue-600 text-center truncate" title={item.routeName}>
                                  {item.routeName}
                                </div>
                              </div>
                            </StickyTableCell>
                            {monthDays.map((day) => {
                              const tripCount = item.dailyTrips[day] || 0;
                              let cellClass = "text-center border-r border-gray-200 py-2 transition-colors";
                              
                              if (tripCount === 0) {
                                cellClass += " text-gray-400 bg-gray-50";
                              } else if (tripCount >= 3) {
                                cellClass += " font-bold text-white bg-green-600 hover:bg-green-700";
                              } else if (tripCount >= 2) {
                                cellClass += " font-semibold text-green-800 bg-green-100 hover:bg-green-200";
                              } else {
                                cellClass += " font-medium text-blue-800 bg-blue-100 hover:bg-blue-200";
                              }
                              
                              return (
                                <StickyTableCell
                                  key={day}
                                  className={cellClass}
                                  style={{ width: "50px", minWidth: "50px" }}
                                  title={tripCount > 0 ? `${tripCount} chuyến ngày ${day}` : `Không có chuyến ngày ${day}`}
                                >
                                  {tripCount > 0 ? tripCount : "-"}
                                </StickyTableCell>
                              );
                            })}
                            <StickyTableCell 
                              className="text-center border-r border-gray-200 py-2 font-medium"
                              sticky
                              stickyRight={120}
                              style={{ 
                                width: "150px", 
                                minWidth: "150px", 
                                maxWidth: "150px"
                              }}
                            >
                              {item.registeredTrips.toLocaleString()}
                            </StickyTableCell>
                            <StickyTableCell 
                              className={`text-center py-2 font-medium ${
                                isLowPerformance ? 'text-red-600' :
                                isHighPerformance ? 'text-green-600' : 'text-gray-900'
                              }`}
                              sticky
                              stickyRight={0}
                              style={{ 
                                width: "120px", 
                                minWidth: "120px", 
                                maxWidth: "120px"
                              }}
                            >
                              <div className="space-y-1">
                                <div>{item.totalActual.toLocaleString()}</div>
                                <div className="text-xs">
                                  ({Math.round(completionRate)}%)
                                </div>
                              </div>
                            </StickyTableCell>
                          </StickyTableRow>
                        );
                      })}
                      {/* Total row */}
                      <StickyTableRow className="bg-gray-50 font-semibold border-b">
                        <StickyTableCell 
                          colSpan={2} 
                          className="text-center border-r border-gray-200 bg-gray-50 py-2"
                          sticky
                          stickyLeft={0}
                        >
                          Tổng cộng:
                        </StickyTableCell>
                        {monthDays.map((day) => (
                          <StickyTableCell
                            key={day}
                            className="text-center border-r border-gray-200 py-2"
                            style={{ width: "50px", minWidth: "50px" }}
                          >
                            {totals.dailyTotals[day] || 0}
                          </StickyTableCell>
                        ))}
                        <StickyTableCell 
                          className="text-center border-r border-gray-200 bg-gray-50 py-2"
                          sticky
                          stickyRight={120}
                          style={{ 
                            width: "150px", 
                            minWidth: "150px", 
                            maxWidth: "150px"
                          }}
                        >
                          {totals.registeredTrips}
                        </StickyTableCell>
                        <StickyTableCell 
                          className="text-center bg-gray-50 py-2"
                          sticky
                          stickyRight={0}
                          style={{ 
                            width: "120px", 
                            minWidth: "120px", 
                            maxWidth: "120px"
                          }}
                        >
                          {totals.totalActual}
                        </StickyTableCell>
                      </StickyTableRow>
                    </>
                  )}
              </StickyTableBody>
            </StickyTable>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoNhatTrinhXe.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface VehicleLogData {
  plateNumber: string;
  operatorName: string;
  orderCode: string;
  routeName: string;
  entryTime: string;
  entryBy: string;
  permitStatus: string;
  syncStatus: string;
}

export default function BaoCaoNhatTrinhXe() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<VehicleLogData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  useEffect(() => {
    setTitle("Báo cáo > Nhật trình xe");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          if (record.entryTime) {
            const recordDate = new Date(record.entryTime);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Map to vehicle log data
      const result = filteredRecords.map((record) => ({
        plateNumber: record.vehiclePlateNumber || "-",
        operatorName: record.vehicle?.operator?.name || "-",
        orderCode: record.transportOrderCode || "-",
        routeName: record.routeName || "-",
        entryTime: record.entryTime || "-",
        entryBy: record.entryBy || "-",
        permitStatus: getPermitStatusLabel(record.permitStatus),
        syncStatus: getSyncStatus(record),
      }));

      setData(result);
    } catch (error) {
      console.error("Failed to load vehicle log data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const getPermitStatusLabel = (permitStatus?: string): string => {
    if (!permitStatus) return "Chưa ký";
    
    switch (permitStatus) {
      case "approved":
        return "Đã ký";
      case "rejected":
        return "Từ chối";
      case "pending":
        return "Chờ ký";
      default:
        return permitStatus;
    }
  };

  const getSyncStatus = (record: any): string => {
    // Check if data has been synced based on metadata or other indicators
    // For now, we'll use a simple logic: if the record has been updated recently and has key fields filled
    if (record.metadata?.synced === true) {
      return "Đã đồng bộ";
    }
    
    // If record has transport order code and permit status, consider it synced
    if (record.transportOrderCode && record.permitStatus === "approved") {
      return "Đã đồng bộ";
    }
    
    // If record has been updated recently (within last hour), consider it syncing
    if (record.updatedAt) {
      const updatedTime = new Date(record.updatedAt).getTime();
      const now = new Date().getTime();
      const diffHours = (now - updatedTime) / (1000 * 60 * 60);
      
      if (diffHours < 1) {
        return "Đang đồng bộ";
      }
    }
    
    return "Chưa đồng bộ";
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredData = useMemo(() => {
    let filtered = data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.orderCode.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "plateNumber":
            aValue = a.plateNumber || "";
            bValue = b.plateNumber || "";
            break;
          case "operatorName":
            aValue = a.operatorName || "";
            bValue = b.operatorName || "";
            break;
          case "orderCode":
            aValue = a.orderCode || "";
            bValue = b.orderCode || "";
            break;
          case "routeName":
            aValue = a.routeName || "";
            bValue = b.routeName || "";
            break;
          case "entryTime":
            aValue = a.entryTime !== "-" ? new Date(a.entryTime).getTime() : 0;
            bValue = b.entryTime !== "-" ? new Date(b.entryTime).getTime() : 0;
            break;
          case "entryBy":
            aValue = a.entryBy || "";
            bValue = b.entryBy || "";
            break;
          case "permitStatus":
            aValue = a.permitStatus || "";
            bValue = b.permitStatus || "";
            break;
          case "syncStatus":
            aValue = a.syncStatus || "";
            bValue = b.syncStatus || "";
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [data, searchQuery, sortColumn, sortDirection]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Tên đơn vị": item.operatorName,
        "Mã lệnh xuất bến": item.orderCode,
        "Tên luồng tuyến": item.routeName,
        "Thời gian vào bến": item.entryTime !== "-"
          ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm")
          : "-",
        "Người cho xe vào bến": item.entryBy,
        "Trạng thái ký lệnh vận chuyển": item.permitStatus,
        "Trạng thái đồng bộ dữ liệu": item.syncStatus,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Nhật trình xe");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 25 },  // Tên đơn vị
        { wch: 20 },  // Mã lệnh xuất bến
        { wch: 25 },  // Tên luồng tuyến
        { wch: 20 },  // Thời gian vào bến
        { wch: 25 },  // Người cho xe vào bến
        { wch: 25 },  // Trạng thái ký lệnh vận chuyển
        { wch: 25 },  // Trạng thái đồng bộ dữ liệu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-nhat-trinh-xe_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, mã lệnh, tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-100">
                  <TableHead className="text-center font-semibold">STT</TableHead>
                  <SortableTableHead
                    sortKey="plateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Biển số
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="operatorName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên đơn vị
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="orderCode"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Mã lệnh xuất bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên luồng tuyến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="entryTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Thời gian vào bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="entryBy"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Người cho xe vào bến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="permitStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Trạng thái ký lệnh vận chuyển
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="syncStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Trạng thái đồng bộ dữ liệu
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={9} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={9} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <TableRow key={`${item.plateNumber}-${item.entryTime}-${index}`}>
                      <TableCell className="text-center">
                        {index + 1}
                      </TableCell>
                      <TableCell className="text-center font-semibold">
                        {item.plateNumber}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.operatorName}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.orderCode}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.routeName}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderTime(item.entryTime)}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.entryBy}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.permitStatus}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.syncStatus}
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoTheoDoiLenhTraKhach.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface OrderData {
  plateNumber: string;
  orderCode: string;
  departureStation: string;
  orderType: string;
  plannedDepartureTime: string;
  orderStatus: string;
}

export default function BaoCaoTheoDoiLenhTraKhach() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<OrderData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  useEffect(() => {
    setTitle("Báo cáo > Theo dõi lệnh trả khách");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          // Filter by passenger drop time or planned departure time
          const filterDate = record.passengerDropTime || record.plannedDepartureTime;
          if (filterDate) {
            const recordDate = new Date(filterDate);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Only show records that have passenger drop-off (lệnh trả khách)
      const returnOrderRecords = filteredRecords.filter(
        (record) => record.passengerDropTime
      );

      // Map to order data
      const result = returnOrderRecords.map((record) => ({
        plateNumber: record.vehiclePlateNumber || "-",
        orderCode: record.transportOrderCode || "-",
        departureStation: record.routeName || "-",
        orderType: record.route?.routeType || "-",
        plannedDepartureTime: record.plannedDepartureTime || "-",
        orderStatus: getStatusLabel(record.currentStatus, record.permitStatus),
      }));

      setData(result);
    } catch (error) {
      console.error("Failed to load order data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const getStatusLabel = (currentStatus: string, permitStatus?: string): string => {
    if (permitStatus === "approved") return "Đã duyệt";
    if (permitStatus === "rejected") return "Từ chối";
    if (permitStatus === "pending") return "Chờ duyệt";
    
    switch (currentStatus) {
      case "entered":
        return "Đã vào bến";
      case "passengers_dropped":
        return "Đã trả khách";
      case "permit_issued":
        return "Đã cấp phép";
      case "permit_rejected":
        return "Từ chối cấp phép";
      case "paid":
        return "Đã thanh toán";
      case "departure_ordered":
        return "Đã xuất lệnh";
      case "departed":
        return "Đã xuất bến";
      default:
        return currentStatus;
    }
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredData = useMemo(() => {
    let filtered = data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.orderCode.toLowerCase().includes(query) ||
          item.departureStation.toLowerCase().includes(query) ||
          item.orderType.toLowerCase().includes(query)
        );
      }
      return true;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "plateNumber":
            aValue = a.plateNumber || "";
            bValue = b.plateNumber || "";
            break;
          case "orderCode":
            aValue = a.orderCode || "";
            bValue = b.orderCode || "";
            break;
          case "departureStation":
            aValue = a.departureStation || "";
            bValue = b.departureStation || "";
            break;
          case "orderType":
            aValue = a.orderType || "";
            bValue = b.orderType || "";
            break;
          case "plannedDepartureTime":
            aValue = a.plannedDepartureTime !== "-" ? new Date(a.plannedDepartureTime).getTime() : 0;
            bValue = b.plannedDepartureTime !== "-" ? new Date(b.plannedDepartureTime).getTime() : 0;
            break;
          case "orderStatus":
            aValue = a.orderStatus || "";
            bValue = b.orderStatus || "";
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [data, searchQuery, sortColumn, sortDirection]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển kiểm soát": item.plateNumber,
        "Mã lệnh": item.orderCode,
        "Bến đi": item.departureStation,
        "Loại lệnh": item.orderType,
        "Giờ XB kế hoạch": item.plannedDepartureTime !== "-"
          ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm")
          : "-",
        "Trạng thái lệnh": item.orderStatus,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Theo dõi lệnh trả khách");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển kiểm soát
        { wch: 15 },  // Mã lệnh
        { wch: 25 },  // Bến đi
        { wch: 15 },  // Loại lệnh
        { wch: 20 },  // Giờ XB kế hoạch
        { wch: 20 },  // Trạng thái lệnh
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-theo-doi-lenh-tra-khach_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, mã lệnh, bến đi..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-100">
                  <TableHead className="text-center font-semibold">STT</TableHead>
                  <SortableTableHead
                    sortKey="plateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Biển kiểm soát
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="orderCode"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Mã lệnh
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="departureStation"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Bến đi
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="orderType"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Loại lệnh
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="plannedDepartureTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Giờ XB kế hoạch
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="orderStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Trạng thái lệnh
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <TableRow key={`${item.plateNumber}-${item.orderCode}-${index}`}>
                      <TableCell className="text-center">
                        {index + 1}
                      </TableCell>
                      <TableCell className="text-center font-semibold">
                        {item.plateNumber}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.orderCode}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.departureStation}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.orderType}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderTime(item.plannedDepartureTime)}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.orderStatus}
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoTheoDoiLenhXuatBen.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { operatorService } from "@/services/operator.service";
import type { DispatchRecord, Operator } from "@/types";
import { useUIStore } from "@/store/ui.store";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { DatePickerRange } from "@/components/DatePickerRange";

export default function BaoCaoTheoDoiLenhXuatBen() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [records, setRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  useEffect(() => {
    setTitle("Báo cáo > Theo dõi lệnh xuất bến");
    loadRecords();
    loadOperators();
  }, [setTitle]);

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      // Lấy tất cả các lệnh có mã lệnh (transportOrderCode) hoặc đã có giờ XB kế hoạch
      const filtered = data.filter(
        (item) => item.transportOrderCode || item.plannedDepartureTime
      );
      setRecords(filtered);
    } catch (error) {
      console.error("Failed to load dispatch records:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const getStatusLabel = (status?: string) => {
    const statusMap: Record<string, string> = {
      entered: "Đã vào bến",
      passengers_dropped: "Đã trả khách",
      permit_issued: "Đã cấp phép",
      permit_rejected: "Từ chối cấp phép",
      paid: "Đã thanh toán",
      departure_ordered: "Đã xuất lệnh",
      departed: "Đã xuất bến",
    };
    return statusMap[status || ""] || status || "-";
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredRecords = useMemo(() => {
    let filtered = records.filter((item) => {
      // Full text search - search in plate number, order code, and route name
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        const plateMatch = item.vehiclePlateNumber
          .toLowerCase()
          .includes(query);
        const orderCodeMatch = (item.transportOrderCode || "")
          .toLowerCase()
          .includes(query);
        const routeMatch = (item.routeName || "")
          .toLowerCase()
          .includes(query);
        matchesSearch = plateMatch || orderCodeMatch || routeMatch;
      }

      // Filter by operator
      let matchesOperator = true;
      if (selectedOperatorId) {
        matchesOperator = item.vehicle?.operatorId === selectedOperatorId;
      }

      // Filter by date range (using plannedDepartureTime)
      let matchesDate = true;
      if (dateRange?.from && dateRange?.to) {
        const filterDate = item.plannedDepartureTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          const toDate = new Date(dateRange.to);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = itemDate >= fromDate && itemDate <= toDate;
        } else {
          matchesDate = false;
        }
      } else if (dateRange?.from) {
        const filterDate = item.plannedDepartureTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = itemDate >= fromDate;
        } else {
          matchesDate = false;
        }
      }

      return matchesSearch && matchesOperator && matchesDate;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "vehiclePlateNumber":
            aValue = a.vehiclePlateNumber || "";
            bValue = b.vehiclePlateNumber || "";
            break;
          case "transportOrderCode":
            aValue = a.transportOrderCode || a.id.substring(0, 8) || "";
            bValue = b.transportOrderCode || b.id.substring(0, 8) || "";
            break;
          case "destination":
            aValue = a.route?.destination?.name || "";
            bValue = b.route?.destination?.name || "";
            break;
          case "routeType":
            aValue = a.route?.routeType || "";
            bValue = b.route?.routeType || "";
            break;
          case "plannedDepartureTime":
            aValue = a.plannedDepartureTime ? new Date(a.plannedDepartureTime).getTime() : 0;
            bValue = b.plannedDepartureTime ? new Date(b.plannedDepartureTime).getTime() : 0;
            break;
          case "passengerDropTime":
            aValue = a.passengerDropTime ? new Date(a.passengerDropTime).getTime() : 0;
            bValue = b.passengerDropTime ? new Date(b.passengerDropTime).getTime() : 0;
            break;
          case "currentStatus":
            aValue = getStatusLabel(a.currentStatus);
            bValue = getStatusLabel(b.currentStatus);
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [records, searchQuery, dateRange, selectedOperatorId, sortColumn, sortDirection]);

  const renderTime = (value?: string) =>
    value ? formatVietnamDateTime(value) : "-";

  const handleExportExcel = () => {
    if (filteredRecords.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredRecords.map((item, index) => ({
        "STT": index + 1,
        "Biển kiểm soát": item.vehiclePlateNumber || "-",
        "Mã lệnh": item.transportOrderCode || item.id.substring(0, 8) || "-",
        "Bến đến": item.route?.destination?.name || "-",
        "Loại lệnh": item.route?.routeType || "-",
        "Giờ XB kế hoạch": item.plannedDepartureTime
          ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm")
          : "-",
        "Giờ xác nhận trả khách": item.passengerDropTime
          ? format(new Date(item.passengerDropTime), "dd/MM/yyyy HH:mm")
          : "-",
        "Trạng thái lệnh": getStatusLabel(item.currentStatus),
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Theo dõi lệnh xuất bến");

      // Set column widths
      const colWidths = [
        { wch: 5 }, // STT
        { wch: 15 }, // Biển kiểm soát
        { wch: 18 }, // Mã lệnh
        { wch: 25 }, // Bến đến
        { wch: 15 }, // Loại lệnh
        { wch: 20 }, // Giờ XB kế hoạch
        { wch: 25 }, // Giờ xác nhận trả khách
        { wch: 20 }, // Trạng thái lệnh
      ];
      ws["!cols"] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Theo-doi-lenh-xuat-ben_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);

      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredRecords.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadRecords}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, mã lệnh, tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Chọn doanh nghiệp vận tải</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <SortableTableHead
                    sortKey="vehiclePlateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Biển kiểm soát
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="transportOrderCode"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Mã lệnh
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="destination"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Bến đến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeType"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Loại lệnh
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="plannedDepartureTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Giờ XB kế hoạch
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="passengerDropTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Giờ xác nhận trả khách
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="currentStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Trạng thái lệnh
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredRecords.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredRecords.map((item) => (
                      <TableRow key={item.id}>
                        <TableCell className="font-semibold">
                          {item.vehiclePlateNumber || "-"}
                        </TableCell>
                        <TableCell>
                          {item.transportOrderCode ||
                            item.id.substring(0, 8) ||
                            "-"}
                        </TableCell>
                        <TableCell>
                          {item.route?.destination?.name || "-"}
                        </TableCell>
                        <TableCell>{item.route?.routeType || "-"}</TableCell>
                        <TableCell>
                          {renderTime(item.plannedDepartureTime)}
                        </TableCell>
                        <TableCell>
                          {renderTime(item.passengerDropTime)}
                        </TableCell>
                        <TableCell>
                          {getStatusLabel(item.currentStatus)}
                        </TableCell>
                      </TableRow>
                    ))}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell>
                        {`Tổng: ${filteredRecords.length} lệnh`}
                      </TableCell>
                      <TableCell colSpan={6}></TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoTongHop.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";

interface RouteSummaryData {
  routeCode: string;
  routeName: string;
  quantity: number; // Số lượng chuyến
  revenue: number; // Doanh thu
  paymentMethods: string[]; // Hình thức thu
}

const paymentMethodLabels: Record<string, string> = {
  cash: "Tiền mặt",
  bank_transfer: "Chuyển khoản",
  card: "Thẻ",
};

export default function BaoCaoTongHop() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<RouteSummaryData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  useEffect(() => {
    setTitle("Báo cáo > Báo cáo tổng hợp");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          const recordDate = new Date(record.entryTime);
          return recordDate >= fromDate && recordDate <= toDate;
        });
      }

      // Only count records that have been paid and departed
      const paidRecords = filteredRecords.filter(
        (record) => record.paymentAmount && record.paymentAmount > 0 && record.currentStatus === "departed"
      );

      // Group by route
      const grouped = new Map<string, RouteSummaryData>();
      
      paidRecords.forEach((record) => {
        const routeId = record.routeId;
        const routeCode = record.route?.routeCode || "-";
        const routeName = record.routeName || "-";
        
        if (!grouped.has(routeId)) {
          grouped.set(routeId, {
            routeCode,
            routeName,
            quantity: 0,
            revenue: 0,
            paymentMethods: [],
          });
        }
        
        const item = grouped.get(routeId)!;
        
        // Count trips
        item.quantity += 1;
        
        // Sum revenue
        if (record.paymentAmount) {
          item.revenue += record.paymentAmount;
        }
        
        // Collect payment methods
        if (record.paymentMethod && !item.paymentMethods.includes(record.paymentMethod)) {
          item.paymentMethods.push(record.paymentMethod);
        }
      });
      
      // Convert to array and sort by route code
      const result = Array.from(grouped.values()).sort((a, b) => 
        a.routeCode.localeCompare(b.routeCode)
      );
      
      setData(result);
    } catch (error) {
      console.error("Failed to load summary data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.routeCode.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Mã tuyến": item.routeCode,
        "Tên tuyến": item.routeName,
        "Số lượng": item.quantity,
        "Doanh thu": item.revenue,
        "Hình thức thu": item.paymentMethods
          .map((method) => paymentMethodLabels[method] || method)
          .join(", ") || "-",
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Báo cáo tổng hợp");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Mã tuyến
        { wch: 30 },  // Tên tuyến
        { wch: 12 },  // Số lượng
        { wch: 15 },  // Doanh thu
        { wch: 20 },  // Hình thức thu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-tong-hop_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  // Calculate totals
  const totals = useMemo(() => {
    return filteredData.reduce(
      (acc, item) => ({
        quantity: acc.quantity + item.quantity,
        revenue: acc.revenue + item.revenue,
      }),
      {
        quantity: 0,
        revenue: 0,
      }
    );
  }, [filteredData]);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND",
    }).format(amount);
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm mã tuyến, tên tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-100">
                  <TableHead className="text-center font-semibold">STT</TableHead>
                  <TableHead className="text-center font-semibold">Mã tuyến</TableHead>
                  <TableHead className="text-center font-semibold">Tên tuyến</TableHead>
                  <TableHead className="text-center font-semibold">Số lượng</TableHead>
                  <TableHead className="text-center font-semibold">Doanh thu</TableHead>
                  <TableHead className="text-center font-semibold">Hình thức thu</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={6} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={6} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredData.map((item, index) => (
                      <TableRow key={`${item.routeCode}-${index}`}>
                        <TableCell className="text-center">
                          {index + 1}
                        </TableCell>
                        <TableCell className="text-center font-semibold">
                          {item.routeCode}
                        </TableCell>
                        <TableCell className="text-center">{item.routeName}</TableCell>
                        <TableCell className="text-center">
                          {item.quantity}
                        </TableCell>
                        <TableCell className="text-center font-semibold">
                          {formatCurrency(item.revenue)}
                        </TableCell>
                        <TableCell className="text-center">
                          {item.paymentMethods.length > 0
                            ? item.paymentMethods
                                .map((method) => paymentMethodLabels[method] || method)
                                .join(", ")
                            : "-"}
                        </TableCell>
                      </TableRow>
                    ))}
                    {/* Total row */}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell colSpan={3} className="text-center">
                        Tổng cộng:
                      </TableCell>
                      <TableCell className="text-center">
                        {totals.quantity}
                      </TableCell>
                      <TableCell className="text-center">
                        {formatCurrency(totals.revenue)}
                      </TableCell>
                      <TableCell className="text-center"></TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoTongHopTuyen.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";

interface RouteSummaryData {
  routeName: string;
  routeType: string;
  plateNumber: string;
  seatCount: number;
  plannedTrips: number;
  actualTrips: number;
  tripRatio: number;
  plannedPassengers: number;
  actualPassengers: number;
  passengerRatio: number;
}

export default function BaoCaoTongHopTuyen() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<RouteSummaryData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [selectedRouteType, setSelectedRouteType] = useState<string>("");

  useEffect(() => {
    setTitle("Báo cáo > Báo cáo tổng hợp tuyến");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          const recordDate = new Date(record.entryTime);
          return recordDate >= fromDate && recordDate <= toDate;
        });
      }

      // Group by route and vehicle
      const grouped = new Map<string, RouteSummaryData>();
      
      filteredRecords.forEach((record) => {
        const key = `${record.routeId}-${record.vehicleId}`;
        const routeName = record.routeName || "-";
        const routeType = record.route?.routeType || "-";
        const plateNumber = record.vehiclePlateNumber || "-";
        const seatCount = record.vehicle?.seatCapacity || record.seatCount || 0;
        
        if (!grouped.has(key)) {
          grouped.set(key, {
            routeName,
            routeType,
            plateNumber,
            seatCount,
            plannedTrips: 0,
            actualTrips: 0,
            tripRatio: 0,
            plannedPassengers: 0,
            actualPassengers: 0,
            passengerRatio: 0,
          });
        }
        
        const item = grouped.get(key)!;
        
        // Count actual trips (departed records)
        if (record.currentStatus === "departed") {
          item.actualTrips += 1;
          item.actualPassengers += record.passengersDeparting || 0;
        }
        
        // For planned trips, we'll use a simple calculation
        // In a real scenario, this would come from schedules
        item.plannedTrips = Math.max(item.plannedTrips, item.actualTrips);
        item.plannedPassengers = Math.max(
          item.plannedPassengers,
          item.plannedTrips * seatCount
        );
      });
      
      // Calculate ratios
      const result = Array.from(grouped.values()).map((item) => ({
        ...item,
        tripRatio: item.plannedTrips > 0 
          ? Math.round((item.actualTrips / item.plannedTrips) * 100) 
          : 0,
        passengerRatio: item.plannedPassengers > 0
          ? Math.round((item.actualPassengers / item.plannedPassengers) * 100)
          : 0,
      }));
      
      setData(result);
    } catch (error) {
      console.error("Failed to load route summary data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        matchesSearch = 
          item.routeName.toLowerCase().includes(query) ||
          item.plateNumber.toLowerCase().includes(query) ||
          item.routeType.toLowerCase().includes(query);
      }
      
      // Route type filter
      let matchesRouteType = true;
      if (selectedRouteType) {
        matchesRouteType = item.routeType === selectedRouteType;
      }
      
      return matchesSearch && matchesRouteType;
    });
  }, [data, searchQuery, selectedRouteType]);

  const routeTypes = useMemo(() => {
    const types = new Set<string>();
    data.forEach((item) => {
      if (item.routeType && item.routeType !== "-") {
        types.add(item.routeType);
      }
    });
    return Array.from(types).sort();
  }, [data]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Tên tuyến": item.routeName,
        "Loại tuyến": item.routeType,
        "Biển số": item.plateNumber,
        "Số ghế": item.seatCount,
        "Số chuyến - Kế hoạch": item.plannedTrips,
        "Số chuyến - Thực hiện": item.actualTrips,
        "Số chuyến - Tỷ lệ (%)": item.tripRatio,
        "Lượt khách - Kế hoạch": item.plannedPassengers,
        "Lượt khách - Thực hiện": item.actualPassengers,
        "Lượt khách - Tỷ lệ (%)": item.passengerRatio,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Báo cáo tổng hợp tuyến");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 25 },  // Tên tuyến
        { wch: 15 },  // Loại tuyến
        { wch: 15 },  // Biển số
        { wch: 10 },  // Số ghế
        { wch: 18 },  // Số chuyến - Kế hoạch
        { wch: 18 },  // Số chuyến - Thực hiện
        { wch: 15 },  // Số chuyến - Tỷ lệ
        { wch: 20 },  // Lượt khách - Kế hoạch
        { wch: 20 },  // Lượt khách - Thực hiện
        { wch: 18 },  // Lượt khách - Tỷ lệ
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-tong-hop-tuyen_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  // Calculate totals
  const totals = useMemo(() => {
    return filteredData.reduce(
      (acc, item) => ({
        plannedTrips: acc.plannedTrips + item.plannedTrips,
        actualTrips: acc.actualTrips + item.actualTrips,
        plannedPassengers: acc.plannedPassengers + item.plannedPassengers,
        actualPassengers: acc.actualPassengers + item.actualPassengers,
      }),
      {
        plannedTrips: 0,
        actualTrips: 0,
        plannedPassengers: 0,
        actualPassengers: 0,
      }
    );
  }, [filteredData]);

  const totalTripRatio = totals.plannedTrips > 0
    ? Math.round((totals.actualTrips / totals.plannedTrips) * 100)
    : 0;
  const totalPassengerRatio = totals.plannedPassengers > 0
    ? Math.round((totals.actualPassengers / totals.plannedPassengers) * 100)
    : 0;

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm tên tuyến, biển số..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="routeType"
                value={selectedRouteType}
                onChange={(e) => setSelectedRouteType(e.target.value)}
              >
                <option value="">Tất cả loại tuyến</option>
                {routeTypes.map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                {/* Main header row with merged cells */}
                <TableRow className="bg-gray-100">
                  <TableHead
                    rowSpan={2}
                    className="border-r border-gray-300 align-middle text-center font-semibold"
                  >
                    STT
                  </TableHead>
                  <TableHead
                    colSpan={4}
                    className="border-r border-gray-300 text-center font-semibold"
                  >
                    Xe khai thác
                  </TableHead>
                  <TableHead
                    colSpan={3}
                    className="border-r border-gray-300 text-center font-semibold"
                  >
                    Số chuyến trên tháng
                  </TableHead>
                  <TableHead
                    colSpan={3}
                    className="text-center font-semibold"
                  >
                    Lượt khách xuất bến
                  </TableHead>
                </TableRow>
                {/* Sub-header row */}
                <TableRow className="bg-gray-50">
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Tên tuyến
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Loại tuyến
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Biển số
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Số ghế
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Kế hoạch
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Thực hiện
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Tỷ lệ (%)
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Kế hoạch
                  </TableHead>
                  <TableHead className="border-r border-gray-300 text-center font-medium">
                    Thực hiện
                  </TableHead>
                  <TableHead className="text-center font-medium">
                    Tỷ lệ (%)
                  </TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredData.map((item, index) => (
                      <TableRow key={`${item.plateNumber}-${item.routeName}-${index}`}>
                        <TableCell className="text-center border-r border-gray-200">
                          {index + 1}
                        </TableCell>
                        <TableCell className="border-r border-gray-200">
                          {item.routeName}
                        </TableCell>
                        <TableCell className="border-r border-gray-200">
                          {item.routeType}
                        </TableCell>
                        <TableCell className="border-r border-gray-200 font-semibold">
                          {item.plateNumber}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.seatCount}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.plannedTrips}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.actualTrips}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.tripRatio}%
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.plannedPassengers.toLocaleString()}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.actualPassengers.toLocaleString()}
                        </TableCell>
                        <TableCell className="text-center">
                          {item.passengerRatio}%
                        </TableCell>
                      </TableRow>
                    ))}
                    {/* Total row */}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell className="text-center border-r border-gray-200">
                        Tổng
                      </TableCell>
                      <TableCell colSpan={3} className="border-r border-gray-200">
                        {filteredData.length} xe
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {filteredData.reduce((sum, item) => sum + item.seatCount, 0)}
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {totals.plannedTrips}
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {totals.actualTrips}
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {totalTripRatio}%
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {totals.plannedPassengers.toLocaleString()}
                      </TableCell>
                      <TableCell className="text-center border-r border-gray-200">
                        {totals.actualPassengers.toLocaleString()}
                      </TableCell>
                      <TableCell className="text-center">
                        {totalPassengerRatio}%
                      </TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/DanhSachCaTruc.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Search, Edit, Trash2, Clock, FileSpreadsheet } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import { format } from "date-fns"
import * as XLSX from "xlsx"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { shiftService, type Shift } from "@/services/shift.service"
import { useUIStore } from "@/store/ui.store"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"

const shiftSchema = z.object({
  name: z.string().min(1, "Tên ca trực là bắt buộc"),
  startTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, "Giờ bắt đầu không hợp lệ (HH:mm)"),
  endTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, "Giờ kết thúc không hợp lệ (HH:mm)"),
})

type ShiftFormData = z.infer<typeof shiftSchema>

export default function DanhSachCaTruc() {
  const [shifts, setShifts] = useState<Shift[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedShift, setSelectedShift] = useState<Shift | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit">("create")
  const setTitle = useUIStore((state) => state.setTitle)

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<ShiftFormData>({
    resolver: zodResolver(shiftSchema),
  })

  useEffect(() => {
    setTitle("Quản lý thông tin > Danh sách ca trực")
    loadShifts()
  }, [setTitle])

  const loadShifts = async () => {
    setIsLoading(true)
    try {
      const data = await shiftService.getAll()
      setShifts(data)
    } catch (error) {
      console.error("Failed to load shifts:", error)
      toast.error("Không thể tải danh sách ca trực. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  const filteredShifts = shifts.filter((shift) => {
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      return (
        shift.name.toLowerCase().includes(query) ||
        shift.startTime.toLowerCase().includes(query) ||
        shift.endTime.toLowerCase().includes(query)
      )
    }
    return true
  })

  const handleCreate = () => {
    setSelectedShift(null)
    setViewMode("create")
    reset({
      name: "",
      startTime: "",
      endTime: "",
    })
    setDialogOpen(true)
  }

  const handleEdit = (shift: Shift) => {
    setSelectedShift(shift)
    setViewMode("edit")
    reset({
      name: shift.name,
      startTime: shift.startTime,
      endTime: shift.endTime,
    })
    setDialogOpen(true)
  }

  const handleDelete = async (id: string) => {
    if (window.confirm("Bạn có chắc chắn muốn xóa ca trực này?")) {
      try {
        await shiftService.delete(id)
        toast.success("Xóa ca trực thành công")
        loadShifts()
      } catch (error) {
        console.error("Failed to delete shift:", error)
        toast.error("Không thể xóa ca trực. Có thể ca trực này đang được sử dụng.")
      }
    }
  }

  const onSubmit = async (data: ShiftFormData) => {
    try {
      if (viewMode === "create") {
        await shiftService.create(data)
        toast.success("Tạo ca trực thành công")
      } else if (selectedShift) {
        await shiftService.update(selectedShift.id, data)
        toast.success("Cập nhật ca trực thành công")
      }
      setDialogOpen(false)
      loadShifts()
    } catch (error) {
      console.error("Failed to save shift:", error)
      toast.error(`Không thể ${viewMode === "create" ? "tạo" : "cập nhật"} ca trực. Vui lòng thử lại sau.`)
    }
  }

  const handleExportExcel = () => {
    if (filteredShifts.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel")
      return
    }

    try {
      // Prepare data for Excel
      const excelData = filteredShifts.map((item, index) => ({
        "STT": index + 1,
        "Tên ca trực": item.name,
        "Giờ bắt đầu ca": item.startTime,
        "Giờ kết thúc ca": item.endTime,
      }))

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData)
      const wb = XLSX.utils.book_new()
      XLSX.utils.book_append_sheet(wb, ws, "Danh sách ca trực")

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 20 },  // Tên ca trực
        { wch: 18 },  // Giờ bắt đầu ca
        { wch: 18 },  // Giờ kết thúc ca
      ]
      ws['!cols'] = colWidths

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy")
      const filename = `Danh-sach-ca-truc_${currentDate}.xlsx`

      // Write file
      XLSX.writeFile(wb, filename)
      
      toast.success(`Đã xuất Excel thành công: ${filename}`)
    } catch (error) {
      console.error("Failed to export Excel:", error)
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.")
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-end gap-2">
        <Button
          variant="outline"
          onClick={handleExportExcel}
          disabled={isLoading || filteredShifts.length === 0}
        >
          <FileSpreadsheet className="mr-2 h-4 w-4" />
          Xuất Excel
        </Button>
        <Button onClick={handleCreate}>
          <Plus className="mr-2 h-4 w-4" />
          Thêm ca trực
        </Button>
      </div>

      {/* Search */}
      <Card>
        <CardContent className="pt-6">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
            <Input
              placeholder="Tìm kiếm theo tên ca trực, giờ bắt đầu, giờ kết thúc..."
              className="pl-10"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="text-center">Tên ca trực</TableHead>
              <TableHead className="text-center">Giờ bắt đầu ca</TableHead>
              <TableHead className="text-center">Giờ kết thúc ca</TableHead>
              <TableHead className="text-center">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8">
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : filteredShifts.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8 text-gray-500">
                  Không có dữ liệu
                </TableCell>
              </TableRow>
            ) : (
              filteredShifts.map((shift) => (
                <TableRow key={shift.id}>
                  <TableCell className="font-medium text-center">
                    <div className="flex items-center justify-center">
                      <Clock className="h-4 w-4 mr-2 text-gray-400" />
                      {shift.name}
                    </div>
                  </TableCell>
                  <TableCell className="text-center">{shift.startTime}</TableCell>
                  <TableCell className="text-center">{shift.endTime}</TableCell>
                  <TableCell className="text-center">
                    <div className="flex items-center justify-center gap-2">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleEdit(shift)}
                        aria-label="Sửa"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleDelete(shift.id)}
                        aria-label="Xóa"
                      >
                        <Trash2 className="h-4 w-4 text-red-600" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </Card>

      {/* Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>
              {viewMode === "create" ? "Thêm ca trực mới" : "Chỉnh sửa ca trực"}
            </DialogTitle>
          </DialogHeader>
          <form onSubmit={handleSubmit(onSubmit)}>
            <div className="grid gap-4 py-4">
              <div className="space-y-2">
                <Label htmlFor="name">
                  Tên ca trực <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="name"
                  placeholder="Ví dụ: Ca 1, Ca 2, Hành chính..."
                  {...register("name")}
                />
                {errors.name && (
                  <p className="text-sm text-red-500">{errors.name.message}</p>
                )}
              </div>
              <div className="space-y-2">
                <Label htmlFor="startTime">
                  Giờ bắt đầu ca <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="startTime"
                  type="time"
                  {...register("startTime")}
                />
                {errors.startTime && (
                  <p className="text-sm text-red-500">{errors.startTime.message}</p>
                )}
              </div>
              <div className="space-y-2">
                <Label htmlFor="endTime">
                  Giờ kết thúc ca <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="endTime"
                  type="time"
                  {...register("endTime")}
                />
                {errors.endTime && (
                  <p className="text-sm text-red-500">{errors.endTime.message}</p>
                )}
              </div>
            </div>
            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setDialogOpen(false)}
              >
                Hủy
              </Button>
              <Button type="submit">
                {viewMode === "create" ? "Tạo mới" : "Cập nhật"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="client/src/pages/guide/HuongDanBanVeUyThac.tsx">
import { GuideLayout } from "@/components/layout/GuideLayout"
import { ArticleImage } from "@/components/guide/ArticleImage"
import { ArticleBanner } from "@/components/guide/ArticleBanner"
import { ArticleContent } from "@/components/guide/ArticleContent"

const steps = [
  { label: "Bước 1: Truy Cập Trang Web", path: "/guide/bus-station/consignment", scrollId: "step1" },
  { label: "Bước 2: Mua Vé", path: "/guide/bus-station/consignment", scrollId: "step2" },
  { label: "Bước 3: Chọn điểm xuất phát và lưu điểm xuất phát", path: "/guide/bus-station/consignment", scrollId: "step3" },
  { label: "Bước 4: Thanh toán", path: "/guide/bus-station/consignment", scrollId: "step4" },
]

export default function HuongDanBanVeUyThac() {
  return (
    <GuideLayout title="HƯỚNG DẪN BÁN VÉ ỦY THÁC" steps={steps}>
      <div className="p-6 lg:p-8">
        {/* Main Title */}
        <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-6">
          HƯỚNG DẪN BÁN VÉ ỦY THÁC
        </h1>

        {/* Introduction */}
        <ArticleContent>
          <p className="text-gray-700 leading-relaxed mb-8">
            Hiểu về quy trình bán vé ủy thác của bến xe. Trong bài viết này, ABC C&T sẽ hướng dẫn bạn bán vé ủy thác một cách chi tiết nhất.
          </p>
        </ArticleContent>

        {/* Step 1 */}
        <section id="step1" className="mb-8 scroll-mt-32">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">
            Bước 1: Truy Cập Trang Web
          </h2>
          <ArticleContent>
            <p className="text-gray-700 leading-relaxed mb-4">
              Đầu tiên Anh/Chị truy cập vào trang web{" "}
              <a 
                href="https://banve.sbus.vn/" 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-primary hover:underline font-medium"
              >
                https://banve.sbus.vn/
              </a>{" "}
              tại màn hình đăng nhập anh/chị nhập tài khoản và mật khẩu do ABC đã cung cấp rồi chọn Đăng Nhập.
            </p>
          </ArticleContent>
          
          <ArticleImage alt="Hình ảnh minh họa Bước 1: Truy cập trang web" />
        </section>

        {/* Step 2 */}
        <section id="step2" className="mb-8 scroll-mt-32">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">
            Bước 2: Mua Vé
          </h2>
          <ArticleContent>
            <p className="text-gray-700 leading-relaxed mb-4">
              Sau khi đăng nhập thành công, bạn sẽ thấy giao diện chính của hệ thống. Tại đây, bạn có thể thực hiện các thao tác mua vé cho khách hàng.
            </p>
          </ArticleContent>
          
          <ArticleImage alt="Hình ảnh minh họa Bước 2: Mua vé" />
        </section>

        {/* Step 3 */}
        <section id="step3" className="mb-8 scroll-mt-32">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">
            Bước 3: Chọn điểm xuất phát và lưu điểm xuất phát
          </h2>
          <ArticleContent>
            <p className="text-gray-700 leading-relaxed mb-4">
              Trong quá trình mua vé, bạn cần chọn điểm xuất phát cho chuyến xe. Hệ thống sẽ tự động lưu lại điểm xuất phát này để sử dụng cho các lần mua vé tiếp theo, giúp bạn tiết kiệm thời gian.
            </p>
          </ArticleContent>
          
          <ArticleImage alt="Hình ảnh minh họa Bước 3: Chọn điểm xuất phát" />
        </section>

        {/* Step 4 */}
        <section id="step4" className="mb-8 scroll-mt-32">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">
            Bước 4: Thanh toán
          </h2>
          <ArticleContent>
            <p className="text-gray-700 leading-relaxed mb-4">
              Sau khi hoàn tất việc chọn vé, bạn sẽ được chuyển đến trang thanh toán. Tại đây, bạn có thể chọn phương thức thanh toán phù hợp và hoàn tất giao dịch.
            </p>
          </ArticleContent>
          
          <ArticleImage alt="Hình ảnh minh họa Bước 4: Thanh toán" />
        </section>

        {/* Additional Banner/Info Section */}
        <ArticleBanner title="Lưu ý quan trọng" variant="info">
          <ul className="list-disc list-inside space-y-2">
            <li>Đảm bảo bạn đã đăng nhập với tài khoản được cấp bởi ABC</li>
            <li>Kiểm tra thông tin vé trước khi thanh toán</li>
            <li>Liên hệ tổng đài 1900.4751 nếu gặp vấn đề</li>
          </ul>
        </ArticleBanner>
      </div>
    </GuideLayout>
  )
}
</file>

<file path="client/src/pages/LapBaoCao.tsx">
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { FileText, Download } from "lucide-react";
import { toast } from "react-toastify";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { DateTimePicker } from "@/components/DatePicker";
import { useUIStore } from "@/store/ui.store";
import { format } from "date-fns";

export default function LapBaoCao() {
  const navigate = useNavigate();
  const setTitle = useUIStore((state) => state.setTitle);
  const [fromDate, setFromDate] = useState<Date | null>(() => {
    const date = new Date();
    date.setHours(0, 0, 0, 0);
    return date;
  });
  const [toDate, setToDate] = useState<Date | null>(() => {
    const date = new Date();
    date.setHours(23, 59, 59);
    return date;
  });
  const [hideInactive, setHideInactive] = useState(true);
  const [isGenerating, setIsGenerating] = useState<string | null>(null);

  useEffect(() => {
    setTitle("Báo cáo > Lập báo cáo");
  }, [setTitle]);

  const handleGenerateReport = async (reportType: string) => {
    if (!fromDate || !toDate) {
      toast.error("Vui lòng chọn đầy đủ từ ngày và đến ngày");
      return;
    }

    if (fromDate > toDate) {
      toast.error("Từ ngày không được lớn hơn đến ngày");
      return;
    }

    setIsGenerating(reportType);
    try {
      // Navigate to report page based on type
      if (reportType === "bao-cao-tinh-hinh-hoat-dong-mau-1") {
        // For single day reports, use fromDate
        const reportDate = format(fromDate, "yyyy-MM-dd");
        navigate(`/bao-cao/tinh-hinh-hoat-dong-mau-1?date=${reportDate}`);
        return;
      }
      
      if (reportType === "bao-cao-tinh-hinh-hoat-dong-mau-3") {
        // For date range reports
        const fromDateStr = format(fromDate, "yyyy-MM-dd");
        const toDateStr = format(toDate, "yyyy-MM-dd");
        navigate(`/bao-cao/tinh-hinh-hoat-dong-mau-3?fromDate=${fromDateStr}&toDate=${toDateStr}`);
        return;
      }
      
      if (reportType === "bang-ke-doanh-thu") {
        // For single day revenue statement, use fromDate
        const reportDate = format(fromDate, "yyyy-MM-dd");
        navigate(`/bao-cao/bang-ke-doanh-thu?date=${reportDate}`);
        return;
      }
      
      if (reportType === "bang-ke-doanh-thu-02-rut-gon") {
        // For single day revenue statement (simplified version), use fromDate
        const reportDate = format(fromDate, "yyyy-MM-dd");
        navigate(`/bao-cao/bang-ke-doanh-thu-02-rut-gon?date=${reportDate}`);
        return;
      }
      
      // TODO: Implement other report types
      // For now, simulate API call for other types
      await new Promise((resolve) => setTimeout(resolve, 1500));
      
      toast.success(`Đã tạo báo cáo ${reportType} thành công`);
      
      // In a real implementation, you would:
      // 1. Call the API with fromDate, toDate, hideInactive
      // 2. Download the generated file
      // Example:
      // const response = await reportService.generateReport({
      //   type: reportType,
      //   fromDate: fromDate.toISOString(),
      //   toDate: toDate.toISOString(),
      //   hideInactive
      // });
      // const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      // const url = window.URL.createObjectURL(blob);
      // const link = document.createElement('a');
      // link.href = url;
      // link.download = `${reportType}_${format(fromDate, 'dd-MM-yyyy')}_${format(toDate, 'dd-MM-yyyy')}.xlsx`;
      // link.click();
    } catch (error) {
      console.error("Failed to generate report:", error);
      toast.error("Không thể tạo báo cáo. Vui lòng thử lại sau.");
    } finally {
      setIsGenerating(null);
    }
  };

  const reportTypes = [
    {
      id: "bao-cao-tinh-hinh-hoat-dong-mau-1",
      title: "BÁO CÁO TÌNH HÌNH HOẠT ĐỘNG (MẪU 1)",
      description: "Báo cáo tổng hợp tình hình hoạt động theo mẫu 1",
    },
    {
      id: "bao-cao-tinh-hinh-hoat-dong-mau-3",
      title: "BÁO CÁO TÌNH HÌNH HOẠT ĐỘNG (MẪU 3)",
      description: "Báo cáo tổng hợp tình hình hoạt động theo mẫu 3",
    },
    {
      id: "bang-ke-doanh-thu",
      title: "BẢNG KÊ DOANH THU",
      description: "Bảng kê chi tiết doanh thu",
    },
    {
      id: "bang-ke-doanh-thu-02-rut-gon",
      title: "BẢNG KÊ DOANH THU 02 (RÚT GỌN)",
      description: "Bảng kê doanh thu rút gọn",
    },
  ];

  return (
    <div className="space-y-6">
      {/* Title */}
      <div className="text-center">
        <h1 className="text-3xl font-bold text-gray-900">Lập báo cáo</h1>
      </div>

      {/* Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
              <div className="space-y-2">
                <Label htmlFor="from-date">
                  Từ ngày <span className="text-red-500">(*)</span>
                </Label>
                <DateTimePicker
                  date={fromDate}
                  onDateChange={(date) => setFromDate(date || null)}
                  placeholder="Chọn ngày và giờ"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="to-date">
                  Đến ngày <span className="text-red-500">(*)</span>
                </Label>
                <DateTimePicker
                  date={toDate}
                  onDateChange={(date) => setToDate(date || null)}
                  placeholder="Chọn ngày và giờ"
                />
              </div>
              <div className="flex items-center space-x-2 pb-2">
                <Checkbox
                  id="hide-inactive"
                  checked={hideInactive}
                  onChange={(e) => setHideInactive(e.target.checked)}
                />
                <Label
                  htmlFor="hide-inactive"
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
                >
                  Ẩn thông tin không hoạt động
                </Label>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Report Options */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {reportTypes.map((report) => (
          <Card
            key={report.id}
            className="hover:shadow-lg transition-shadow duration-200"
          >
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4 flex-1">
                  <div className="flex-shrink-0">
                    <div className="w-12 h-12 rounded-lg bg-blue-100 flex items-center justify-center">
                      <FileText className="h-6 w-6 text-blue-600" />
                    </div>
                  </div>
                  <div className="flex-1 min-w-0">
                    <h3 className="font-semibold text-gray-900 text-sm leading-tight mb-1">
                      {report.title}
                    </h3>
                    <p className="text-xs text-gray-500 line-clamp-2">
                      {report.description}
                    </p>
                  </div>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => handleGenerateReport(report.id)}
                  disabled={isGenerating === report.id}
                  className="ml-4 flex-shrink-0"
                >
                  {isGenerating === report.id ? (
                    <div className="h-4 w-4 border-2 border-gray-300 border-t-blue-600 rounded-full animate-spin" />
                  ) : (
                    <Download className="h-5 w-5 text-gray-600" />
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/pricing/BangGiaChuKySo.tsx">
import { Link } from "react-router-dom"
import { CheckCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"

export default function BangGiaChuKySo() {
  return (
    <div className="w-full bg-gray-50 py-6 lg:py-10">
      <div className="container mx-auto px-4">
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-2">
            BẢNG GIÁ CHỮ KÝ SỐ HSM KÝ LỆNH VÀ VÉ ĐIỆN TỬ
          </h1>
        </div>

        {/* Pricing Card */}
        <div className="max-w-5xl mx-auto">
          <Card className="border-2 border-purple-200 shadow-xl">
            {/* Package Header */}
            <div className="bg-gray-100 py-3 px-4 border-b border-gray-200">
              <h2 className="text-xl lg:text-2xl font-bold text-gray-900 text-center">
                GÓI HỢP TÁC ĐẶC BIỆT HILO - CA
              </h2>
            </div>
            
            <CardContent className="p-6">
              {/* Price */}
              <div className="text-center mb-6">
                <div className="flex items-baseline justify-center gap-2 mb-2">
                  <span className="text-5xl lg:text-6xl font-bold text-purple-600">500.000</span>
                  <span className="text-2xl text-gray-600">đ</span>
                </div>
                <p className="text-lg text-gray-600">/đơn vị sử dụng</p>
              </div>

              {/* Features */}
              <div className="border-t border-gray-200 pt-6 mb-6">
                <ul className="space-y-4">
                  <li className="flex items-start gap-3 pb-3 border-b border-gray-100">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Chứng thư số server lưu khóa trên thiết bị HSM tốc độ ký cao
                    </span>
                  </li>
                  <li className="flex items-start gap-3 pb-3 border-b border-gray-100">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Không giới hạn</span> số lượng lượt ký cho Lệnh vận chuyển điện, vé xe điện tử trên hệ thống của ABC trong 01 năm
                    </span>
                  </li>
                  <li className="flex items-start gap-3 pb-3 border-b border-gray-100">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Tích hợp sẵn</span> để ký Lệnh vận chuyển điện tử và Vé xe khách điện tử
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Miễn phí</span> sử dụng thử phần mềm Hợp đồng điện tử Hilo - Econtract
                    </span>
                  </li>
                </ul>
              </div>

              {/* Info Text */}
              <div className="text-center mb-6">
                <p className="text-gray-700 text-base">
                  Cài đặt ngay để sử dụng cùng giải pháp Lệnh và Vé điện tử.
                </p>
              </div>

              {/* CTA Button */}
              <div className="text-center">
                <Link to="/lien-he">
                  <Button 
                    size="lg" 
                    className="bg-teal-500 hover:bg-teal-600 text-white px-8 py-4 text-lg rounded-lg shadow-lg transition-all hover:shadow-xl"
                  >
                    Liên hệ đăng ký
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>

          {/* Additional Info */}
          <div className="mt-4 text-center">
            <p className="text-gray-600 text-sm">
              * Giá trên chưa bao gồm VAT. Vui lòng liên hệ để được tư vấn chi tiết về gói dịch vụ phù hợp với nhu cầu của bạn.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/pricing/BangGiaHoaDonDienTu.tsx">
import { Link } from "react-router-dom"
import { Monitor, Heart, PenTool, Gift } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"

export default function BangGiaHoaDonDienTu() {
  const features = [
    {
      icon: Monitor,
      title: "Xuất hóa đơn ngay khi điều độ",
      description: "Xuất hóa đơn ngay trong phiên điều độ, giảm thiểu sai sót.",
      color: "text-blue-600",
      bgColor: "bg-blue-50",
    },
    {
      icon: Heart,
      title: "Lưu trữ, tra cứu tiện lợi",
      description: "Dữ liệu lưu vết tại hệ thống để nhà xe, kế toán kiểm tra & tra cứu",
      color: "text-pink-600",
      bgColor: "bg-pink-50",
    },
    {
      icon: PenTool,
      title: "Cấu hình đúng pháp luật Việt Nam",
      description: "ABC đã cấu hình các chuẩn thông tin theo NĐ70/2025, mẫu vé đa dạng, gán logo nhà xe, DNVT trên mẫu vé",
      color: "text-purple-600",
      bgColor: "bg-purple-50",
    },
    {
      icon: Gift,
      title: "Tích hợp đa kênh",
      description: "Tích hợp các phần mềm bán vé, tích hợp tự động vào phần mềm kế toán như MISA, hạch toán và khai báo doanh thu tự động",
      color: "text-teal-600",
      bgColor: "bg-teal-50",
    },
  ]

  return (
    <div className="w-full bg-white py-6 lg:py-10">
      <div className="container mx-auto px-4">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-2">
            BẢNG GIÁ SẢN PHẨM HÓA ĐƠN ĐIỆN TỬ
          </h1>
        </div>

        {/* Features Grid */}
        <div className="max-w-6xl mx-auto">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            {features.map((feature, index) => {
              const IconComponent = feature.icon
              return (
                <Card key={index} className="border border-gray-200 shadow-md hover:shadow-lg transition-shadow">
                  <CardContent className="p-6">
                    <div className="flex flex-col items-center text-center">
                      <div className={`${feature.bgColor} rounded-full p-4 mb-4`}>
                        <IconComponent className={`h-8 w-8 ${feature.color}`} />
                      </div>
                      <h3 className="text-xl font-bold text-gray-900 mb-3">
                        {feature.title}
                      </h3>
                      <p className="text-gray-700 text-base leading-relaxed">
                        {feature.description}
                      </p>
                    </div>
                  </CardContent>
                </Card>
              )
            })}
          </div>

          {/* CTA Button */}
          <div className="text-center">
            <Link to="/lien-he">
              <Button 
                size="lg" 
                className="bg-teal-500 hover:bg-teal-600 text-white px-8 py-4 text-lg rounded-lg shadow-lg transition-all hover:shadow-xl"
              >
                Khám phá tất cả tính năng
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/pricing/BangGiaLenhVanChuyen.tsx">
import { Link } from "react-router-dom"
import { CheckCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader } from "@/components/ui/card"

export default function BangGiaLenhVanChuyen() {
  return (
    <div className="w-full bg-gray-50 py-6 lg:py-10">
      <div className="container mx-auto px-4">
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-2">
            BẢNG GIÁ LỆNH VẬN CHUYỂN ĐIỆN TỬ
          </h1>
        </div>

        {/* Pricing Card */}
        <div className="max-w-5xl mx-auto">
          <Card className="border-2 border-blue-200 shadow-xl">
            <CardHeader className="bg-gradient-to-r from-blue-500 to-blue-600 text-white pb-4">
              <div className="text-center">
                <h2 className="text-3xl lg:text-4xl font-bold mb-2">Trọn gói L-MAX</h2>
              </div>
            </CardHeader>
            <CardContent className="p-6">

              {/* Price */}
              <div className="text-center mb-6">
                <div className="flex items-baseline justify-center gap-2 mb-2">
                  <span className="text-5xl lg:text-6xl font-bold text-blue-600">600.000</span>
                  <span className="text-2xl font-bold text-gray-600">Đồng/xe/năm</span>
                </div>
                <p className="text-base text-gray-500 italic">Không giới hạn số lượng lệnh vận chuyển ký phát hành trong 01 năm</p>
              </div>

              {/* Features */}
              <div className="border-t border-gray-200 pt-6 mb-6">
                <ul className="space-y-3">
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Miễn phí</span> phần mền quản lý và app SLaiXe
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Miễn phí</span> hỗ trợ khởi tạo dữ liệu xe khách
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Lưu trữ tối thiểu <span className="font-bold text-lg">03 năm</span> theo quy định
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Kết nối hơn <span className="font-bold text-lg">500 bến xe</span> tiếp nhận và ký lệnh điện tử
                    </span>
                  </li>
                </ul>
              </div>

              {/* CTA Button */}
              <div className="text-center">
                <p className="text-gray-600 text-sm italic mb-4">Cài đặt ngay. Hoàn tiền nếu không hài lòng.</p>
                <Link to="/lien-he">
                  <Button
                    size="lg"
                    className="bg-green-600 hover:bg-green-700 text-white px-8 py-4 text-lg rounded-lg shadow-lg transition-all hover:shadow-xl"
                  >
                    Liên hệ tư vấn ngay
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>

          {/* Additional Info */}
          <div className="mt-4 text-center">
            <p className="text-gray-600 text-sm">
              * Giá trên chưa bao gồm VAT. Vui lòng liên hệ để được tư vấn chi tiết về gói dịch vụ phù hợp với nhu cầu của bạn.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/pricing/BangGiaVeDienTu.tsx">
import { Link } from "react-router-dom"
import { CheckCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader } from "@/components/ui/card"

export default function BangGiaVeDienTu() {
  return (
    <div className="w-full bg-gray-50 py-6 lg:py-10">
      <div className="container mx-auto px-4">
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-2">
            BẢNG GIÁ SẢN PHẨM VÉ ĐIỆN TỬ
          </h1>
        </div>

        {/* Pricing Card */}
        <div className="max-w-5xl mx-auto">
          <Card className="border-2 border-teal-200 shadow-xl">
            <CardHeader className="bg-gradient-to-r from-teal-500 to-teal-600 text-white pb-4">
              <div className="text-center">
                <h2 className="text-3xl lg:text-4xl font-bold mb-2">V-MAX</h2>
              </div>
            </CardHeader>
            <CardContent className="p-6">
              {/* Promotion Banner */}
              <div className="bg-red-500 text-white text-center py-2 px-4 rounded-lg mb-4">
                <p className="font-semibold text-sm lg:text-base">
                  Khuyến mãi đặc biệt +03 tháng sử dụng miễn phí cho các đơn vị đăng ký trước 01/08/2022
                </p>
              </div>

              {/* Price */}
              <div className="text-center mb-6">
                <div className="flex items-baseline justify-center gap-2 mb-2">
                  <span className="text-5xl lg:text-6xl font-bold text-teal-600">300.000</span>
                  <span className="text-2xl font-bold text-gray-600">Đồng/xe/năm</span>
                </div>
                <p className="text-base text-gray-500 italic">Gói không giới hạn số lượng sử dụng theo năm</p>
              </div>

              {/* Features */}
              <div className="border-t border-gray-200 pt-6 mb-6">
                <ul className="space-y-3">
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      <span className="font-bold text-lg">Miễn phí</span> phần mềm bán vé và quản lý
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Lưu trữ dữ liệu <span className="font-bold text-lg">10 năm</span> theo quy định
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Thời gian sử dụng không giới hạn
                    </span>
                  </li>
                  <li className="flex items-start gap-3">
                    <CheckCircle className="h-6 w-6 text-green-600 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700 text-base">
                      Số lượng vé sử dụng không giới hạn
                    </span>
                  </li>
                </ul>
              </div>

              {/* CTA Button */}
              <div className="text-center">
                <p className="text-gray-600 text-sm italic mb-4">Trọn bộ giải pháp cung cấp theo năm</p>
                <Link to="/lien-he">
                  <Button
                    size="lg"
                    className="bg-green-600 hover:bg-green-700 text-white px-8 py-4 text-lg rounded-lg shadow-lg transition-all hover:shadow-xl"
                  >
                    Liên hệ tư vấn ngay
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>

          {/* Additional Info */}
          <div className="mt-4 text-center">
            <p className="text-gray-600 text-sm">
              * Giá trên chưa bao gồm VAT. Vui lòng liên hệ để được tư vấn chi tiết về gói dịch vụ phù hợp với nhu cầu của bạn.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/Profile.tsx">
import { useState, useEffect } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { User, Mail, Phone, UserCircle, Save, Loader2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { useAuthStore } from "@/store/auth.store"

const profileSchema = z.object({
  fullName: z.string().min(1, "Họ tên là bắt buộc").max(100, "Họ tên không được quá 100 ký tự"),
  email: z.string().email("Email không hợp lệ").optional().or(z.literal("")),
  phone: z.string().max(20, "Số điện thoại không được quá 20 ký tự").optional().or(z.literal("")),
})

type ProfileFormData = z.infer<typeof profileSchema>

export default function Profile() {
  const { user, updateProfile } = useAuthStore()
  const [error, setError] = useState<string>("")
  const [success, setSuccess] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      fullName: user?.fullName || "",
      email: user?.email || "",
      phone: user?.phone || "",
    },
  })

  useEffect(() => {
    if (user) {
      reset({
        fullName: user.fullName || "",
        email: user.email || "",
        phone: user.phone || "",
      })
    }
  }, [user, reset])

  const onSubmit = async (data: ProfileFormData) => {
    try {
      setIsLoading(true)
      setError("")
      setSuccess("")
      
      await updateProfile({
        fullName: data.fullName,
        email: data.email || undefined,
        phone: data.phone || undefined,
      })
      
      setSuccess("Cập nhật thông tin thành công!")
    } catch (err: any) {
      setError(err?.response?.data?.error || err?.message || "Cập nhật thông tin thất bại. Vui lòng thử lại.")
    } finally {
      setIsLoading(false)
    }
  }

  const getRoleLabel = (role: string) => {
    const roleLabels: Record<string, string> = {
      admin: "Quản trị viên",
      dispatcher: "Điều độ viên",
      accountant: "Kế toán",
      reporter: "Báo cáo viên",
    }
    return roleLabels[role] || role
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 via-blue-50 to-indigo-50 py-12 lg:py-16">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8 max-w-6xl">
        {/* Header Section */}
        <div className="mb-8 lg:mb-12 text-center">
          <div className="inline-flex items-center justify-center w-20 h-20 lg:w-24 lg:h-24 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 mb-4 shadow-lg">
            <UserCircle className="h-10 w-10 lg:h-12 lg:w-12 text-white" />
          </div>
          <h1 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-2">
            Thông tin cá nhân
          </h1>
          <p className="text-base lg:text-lg text-gray-600 max-w-2xl mx-auto">
            Quản lý và cập nhật thông tin tài khoản của bạn
          </p>
        </div>

        {/* Main Content Grid */}
        <div className="grid gap-6 lg:gap-8 lg:grid-cols-3">
          {/* Thông tin tài khoản - Left Column */}
          <div className="lg:col-span-1">
            <Card className="h-full shadow-lg border-0 bg-white/80 backdrop-blur-sm">
              <CardHeader className="pb-4">
                <CardTitle className="flex items-center gap-2 text-lg lg:text-xl">
                  <div className="p-2 rounded-lg bg-blue-100">
                    <UserCircle className="h-5 w-5 text-blue-600" />
                  </div>
                  Thông tin tài khoản
                </CardTitle>
                <CardDescription className="text-sm">
                  Thông tin đăng nhập và quyền truy cập
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-5">
                <div className="p-4 rounded-lg bg-gray-50 border border-gray-200">
                  <Label className="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2 block">
                    Tên đăng nhập
                  </Label>
                  <div className="flex items-center gap-3">
                    <div className="p-2 rounded-md bg-white border border-gray-200">
                      <User className="h-4 w-4 text-gray-500" />
                    </div>
                    <p className="text-sm lg:text-base font-semibold text-gray-900">
                      {user?.username}
                    </p>
                  </div>
                </div>

                <div className="p-4 rounded-lg bg-gray-50 border border-gray-200">
                  <Label className="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2 block">
                    Vai trò
                  </Label>
                  <div className="mt-1">
                    <span className="inline-flex items-center rounded-full bg-gradient-to-r from-blue-500 to-indigo-600 px-4 py-2 text-sm font-semibold text-white shadow-md">
                      {getRoleLabel(user?.role || "")}
                    </span>
                  </div>
                </div>

                <div className="p-4 rounded-lg bg-gray-50 border border-gray-200">
                  <Label className="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2 block">
                    ID người dùng
                  </Label>
                  <p className="mt-1 text-xs lg:text-sm text-gray-600 font-mono bg-white px-3 py-2 rounded border border-gray-200 break-all">
                    {user?.id}
                  </p>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Form cập nhật thông tin - Right Column (2/3 width) */}
          <div className="lg:col-span-2">
            <Card className="shadow-lg border-0 bg-white/80 backdrop-blur-sm">
              <CardHeader className="pb-4">
                <CardTitle className="flex items-center gap-2 text-lg lg:text-xl">
                  <div className="p-2 rounded-lg bg-green-100">
                    <Save className="h-5 w-5 text-green-600" />
                  </div>
                  Cập nhật thông tin
                </CardTitle>
                <CardDescription className="text-sm">
                  Chỉnh sửa thông tin cá nhân của bạn
                </CardDescription>
              </CardHeader>
              <CardContent>
                <form onSubmit={handleSubmit(onSubmit)} className="space-y-5">
                  {error && (
                    <div className="rounded-lg bg-red-50 border border-red-200 p-4 text-sm text-red-800 flex items-center gap-2">
                      <div className="h-5 w-5 rounded-full bg-red-200 flex items-center justify-center flex-shrink-0">
                        <span className="text-red-600 text-xs">!</span>
                      </div>
                      {error}
                    </div>
                  )}
                  {success && (
                    <div className="rounded-lg bg-green-50 border border-green-200 p-4 text-sm text-green-800 flex items-center gap-2">
                      <div className="h-5 w-5 rounded-full bg-green-200 flex items-center justify-center flex-shrink-0">
                        <span className="text-green-600 text-xs">✓</span>
                      </div>
                      {success}
                    </div>
                  )}

                  <div className="space-y-2">
                    <Label htmlFor="fullName" className="text-sm font-semibold text-gray-700">
                      Họ và tên <span className="text-red-500">*</span>
                    </Label>
                    <div className="relative">
                      <UserCircle className="absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-400" />
                      <Input
                        id="fullName"
                        type="text"
                        placeholder="Nhập họ và tên"
                        className="pl-11 h-11 text-base border-gray-300 focus:border-blue-500 focus:ring-blue-500"
                        {...register("fullName")}
                      />
                    </div>
                    {errors.fullName && (
                      <p className="text-sm text-red-600 mt-1">{errors.fullName.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="email" className="text-sm font-semibold text-gray-700">
                      Email
                    </Label>
                    <div className="relative">
                      <Mail className="absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-400" />
                      <Input
                        id="email"
                        type="email"
                        placeholder="Nhập email (tùy chọn)"
                        className="pl-11 h-11 text-base border-gray-300 focus:border-blue-500 focus:ring-blue-500"
                        {...register("email")}
                      />
                    </div>
                    {errors.email && (
                      <p className="text-sm text-red-600 mt-1">{errors.email.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="phone" className="text-sm font-semibold text-gray-700">
                      Số điện thoại
                    </Label>
                    <div className="relative">
                      <Phone className="absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-400" />
                      <Input
                        id="phone"
                        type="tel"
                        placeholder="Nhập số điện thoại (tùy chọn)"
                        className="pl-11 h-11 text-base border-gray-300 focus:border-blue-500 focus:ring-blue-500"
                        {...register("phone")}
                      />
                    </div>
                    {errors.phone && (
                      <p className="text-sm text-red-600 mt-1">{errors.phone.message}</p>
                    )}
                  </div>

                  <div className="pt-2">
                    <Button
                      type="submit"
                      className="w-full h-12 text-base font-semibold bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 shadow-md hover:shadow-lg transition-all duration-200"
                      disabled={isLoading}
                    >
                      {isLoading ? (
                        <>
                          <Loader2 className="mr-2 h-5 w-5 animate-spin" />
                          Đang lưu...
                        </>
                      ) : (
                        <>
                          <Save className="mr-2 h-5 w-5" />
                          Lưu thay đổi
                        </>
                      )}
                    </Button>
                  </div>
                </form>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/QuanLyBieuThuc.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Search, Edit, Eye, Trash2, RefreshCw, ChevronDown, ChevronUp, Filter } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Checkbox } from "@/components/ui/checkbox"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { serviceFormulaService } from "@/services/service-formula.service"
import type { ServiceFormula } from "@/types"
import { useUIStore } from "@/store/ui.store"
import { FormulaDialog } from "@/components/service/FormulaDialog"

export default function QuanLyBieuThuc() {
  const [formulas, setFormulas] = useState<ServiceFormula[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [selectedFormula, setSelectedFormula] = useState<ServiceFormula | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create")
  const [expandedSections, setExpandedSections] = useState<Set<'quantity' | 'price'>>(new Set(['quantity', 'price']))
  const [searchQuery, setSearchQuery] = useState("")
  const [filterStatus, setFilterStatus] = useState("")
  const [createFormulaType, setCreateFormulaType] = useState<'quantity' | 'price'>('quantity')
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý biểu thức")
    loadFormulas()
  }, [setTitle])

  const loadFormulas = async () => {
    setIsLoading(true)
    try {
      const data = await serviceFormulaService.getAll()
      setFormulas(data)
    } catch (error) {
      console.error("Failed to load formulas:", error)
      toast.error("Không thể tải danh sách biểu thức. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  const toggleSection = (type: 'quantity' | 'price') => {
    setExpandedSections(prev => {
      const newSet = new Set(prev)
      if (newSet.has(type)) {
        newSet.delete(type)
      } else {
        newSet.add(type)
      }
      return newSet
    })
  }

  const filteredFormulas = (type: 'quantity' | 'price') => {
    return formulas.filter((formula) => {
      if (formula.formulaType !== type) return false

      // Fulltext search - search across all fields
      if (searchQuery) {
        const query = searchQuery.toLowerCase()
        const searchableText = [
          formula.code,
          formula.name,
          formula.description || '',
          formula.usedByServices || '',
        ].join(' ').toLowerCase()
        
        if (!searchableText.includes(query)) {
          return false
        }
      }

      // Status filter
      if (filterStatus) {
        const isActive = filterStatus === "active"
        if (formula.isActive !== isActive) return false
      }

      return true
    })
  }

  const handleCreate = (type: 'quantity' | 'price') => {
    setSelectedFormula(null)
    setCreateFormulaType(type)
    setViewMode("create")
    setDialogOpen(true)
  }

  const handleEdit = (formula: ServiceFormula) => {
    setSelectedFormula(formula)
    setViewMode("edit")
    setDialogOpen(true)
  }

  const handleView = (formula: ServiceFormula) => {
    setSelectedFormula(formula)
    setViewMode("view")
    setDialogOpen(true)
  }

  const handleDelete = async (id: string) => {
    if (window.confirm("Bạn có chắc chắn muốn xóa biểu thức này?")) {
      try {
        await serviceFormulaService.delete(id)
        toast.success("Xóa biểu thức thành công")
        loadFormulas()
      } catch (error: any) {
        console.error("Failed to delete formula:", error)
        toast.error(error.response?.data?.error || "Không thể xóa biểu thức. Vui lòng thử lại sau.")
      }
    }
  }

  const quantityFormulas = filteredFormulas('quantity')
  const priceFormulas = filteredFormulas('price')

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Quản lý biểu thức</h1>
          <p className="text-gray-600 mt-1">Quản lý biểu thức tính số lượng và tính đơn giá</p>
        </div>
        <div className="flex items-center gap-2">
          <Button variant="ghost" size="icon" title="Làm mới" onClick={loadFormulas}>
            <RefreshCw className="h-4 w-4" />
          </Button>
          <Button variant="ghost" size="icon" title="Lọc">
            <Filter className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <label className="text-sm font-medium">Tìm kiếm</label>
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
                  <Input
                    placeholder="Tìm kiếm theo mã, tên, ghi chú, dịch vụ..."
                    className="pl-10"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                  />
                </div>
              </div>
              <div className="space-y-2">
                <label className="text-sm font-medium">Lọc theo trạng thái</label>
                <select
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md"
                >
                  <option value="">Tất cả trạng thái</option>
                  <option value="active">Đang áp dụng</option>
                  <option value="inactive">Ngừng áp dụng</option>
                </select>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-10"></TableHead>
                <TableHead>Mã biểu thức</TableHead>
                <TableHead>Tên biểu thức</TableHead>
                <TableHead>Ghi chú</TableHead>
                <TableHead>Đang được sử dụng bởi dịch vụ</TableHead>
                <TableHead>Trạng thái</TableHead>
                <TableHead className="text-center">Thao tác</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={7} className="text-center py-8">
                    <div className="flex justify-center items-center gap-2">
                      <RefreshCw className="h-4 w-4 animate-spin" />
                      Đang tải...
                    </div>
                  </TableCell>
                </TableRow>
              ) : (
                <>
                  {/* Tính số lượng Section */}
                  <TableRow className="bg-blue-50">
                    <TableCell colSpan={7} className="p-0">
                      <div className="w-full flex items-center justify-between p-4 hover:bg-blue-100">
                        <div 
                          className="flex items-center gap-2 cursor-pointer flex-1"
                          onClick={() => toggleSection('quantity')}
                        >
                          {expandedSections.has('quantity') ? (
                            <ChevronDown className="h-4 w-4" />
                          ) : (
                            <ChevronUp className="h-4 w-4" />
                          )}
                          <span className="font-semibold text-gray-900">Tính số lượng</span>
                        </div>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => handleCreate('quantity')}
                          className="h-7"
                        >
                          <Plus className="h-3 w-3 mr-1" />
                          Thêm
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                  {expandedSections.has('quantity') && (
                    <>
                      {quantityFormulas.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={7} className="text-center py-8 text-gray-500">
                            Không có dữ liệu
                          </TableCell>
                        </TableRow>
                      ) : (
                        quantityFormulas.map((formula) => (
                          <TableRow key={formula.id} className="hover:bg-gray-50">
                            <TableCell>
                              <Checkbox />
                            </TableCell>
                            <TableCell className="font-medium">{formula.code}</TableCell>
                            <TableCell>{formula.name}</TableCell>
                            <TableCell>{formula.description || "-"}</TableCell>
                            <TableCell>
                              {formula.usedByServices || "-"}
                            </TableCell>
                            <TableCell>
                              <StatusBadge
                                status={formula.isActive ? "active" : "inactive"}
                              />
                            </TableCell>
                            <TableCell>
                              <div className="flex items-center justify-center gap-2">
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleView(formula)}
                                  aria-label="Xem"
                                >
                                  <Eye className="h-4 w-4" />
                                </Button>
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleEdit(formula)}
                                  aria-label="Sửa"
                                >
                                  <Edit className="h-4 w-4" />
                                </Button>
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleDelete(formula.id)}
                                  aria-label="Xóa"
                                >
                                  <Trash2 className="h-4 w-4 text-red-600" />
                                </Button>
                              </div>
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </>
                  )}

                  {/* Tính đơn giá Section */}
                  <TableRow className="bg-green-50">
                    <TableCell colSpan={7} className="p-0">
                      <div className="w-full flex items-center justify-between p-4 hover:bg-green-100">
                        <div 
                          className="flex items-center gap-2 cursor-pointer flex-1"
                          onClick={() => toggleSection('price')}
                        >
                          {expandedSections.has('price') ? (
                            <ChevronDown className="h-4 w-4" />
                          ) : (
                            <ChevronUp className="h-4 w-4" />
                          )}
                          <span className="font-semibold text-gray-900">Tính đơn giá</span>
                        </div>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => handleCreate('price')}
                          className="h-7"
                        >
                          <Plus className="h-3 w-3 mr-1" />
                          Thêm
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                  {expandedSections.has('price') && (
                    <>
                      {priceFormulas.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={7} className="text-center py-8 text-gray-500">
                            Không có dữ liệu
                          </TableCell>
                        </TableRow>
                      ) : (
                        priceFormulas.map((formula) => (
                          <TableRow key={formula.id} className="hover:bg-gray-50">
                            <TableCell>
                              <Checkbox />
                            </TableCell>
                            <TableCell className="font-medium">{formula.code}</TableCell>
                            <TableCell>{formula.name}</TableCell>
                            <TableCell>{formula.description || "-"}</TableCell>
                            <TableCell>
                              {formula.usedByServices || "-"}
                            </TableCell>
                            <TableCell>
                              <StatusBadge
                                status={formula.isActive ? "active" : "inactive"}
                              />
                            </TableCell>
                            <TableCell>
                              <div className="flex items-center justify-center gap-2">
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleView(formula)}
                                  aria-label="Xem"
                                >
                                  <Eye className="h-4 w-4" />
                                </Button>
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleEdit(formula)}
                                  aria-label="Sửa"
                                >
                                  <Edit className="h-4 w-4" />
                                </Button>
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => handleDelete(formula.id)}
                                  aria-label="Xóa"
                                >
                                  <Trash2 className="h-4 w-4 text-red-600" />
                                </Button>
                              </div>
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </>
                  )}
                </>
              )}
            </TableBody>
          </Table>
        </div>
      </Card>

      {/* Dialog */}
      <FormulaDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        viewMode={viewMode}
        selectedFormula={selectedFormula}
        onSuccess={loadFormulas}
        defaultFormulaType={viewMode === "create" ? createFormulaType : undefined}
      />
    </div>
  )
}
</file>

<file path="client/src/pages/TaoMoiDonHang.tsx">
import { useState, useEffect, useRef } from "react"
import { createPortal } from "react-dom"
import { useNavigate } from "react-router-dom"
import { toast } from "react-toastify"
import { 
  Plus, 
  Trash2, 
  Check, 
  X,
  RefreshCw,
  Settings,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { DateTimePicker } from "@/components/DatePicker"
import { dispatchService } from "@/services/dispatch.service"
import { serviceChargeService } from "@/services/service-charge.service"
import { vehicleService } from "@/services/vehicle.service"
import { operatorService } from "@/services/operator.service"
import { routeService } from "@/services/route.service"
import { driverService } from "@/services/driver.service"
import type { ServiceType, ServiceChargeInput, Operator, Vehicle, Route, Driver } from "@/types"
import { useUIStore } from "@/store/ui.store"

interface ServiceItem {
  id: string
  serviceTypeId: string
  serviceName: string
  unitPrice: number
  quantity: number
  discountAmount: number
  discountPercent: number
  taxPercent: number
  amountBeforeDiscount: number
  totalAmount: number
}

export default function TaoMoiDonHang() {
  const navigate = useNavigate()
  const setTitle = useUIStore((state) => state.setTitle)
  
  // Form state
  const [effectiveDate, setEffectiveDate] = useState<Date>(new Date())
  const [operatorId, setOperatorId] = useState("")
  const [vehicleId, setVehicleId] = useState("")
  const [routeId, setRouteId] = useState("")
  const [orderType, setOrderType] = useState("thanh-toan-chuyen")
  const [status, setStatus] = useState("da-xac-nhan")
  const [invoiceSymbol, setInvoiceSymbol] = useState("QLBX")
  
  // Service list state
  const [services, setServices] = useState<ServiceItem[]>([])
  const [serviceTypes, setServiceTypes] = useState<ServiceType[]>([])
  const [isAddingService, setIsAddingService] = useState(false)
  const [newService, setNewService] = useState({
    serviceTypeId: "",
    serviceName: "",
    quantity: 1,
    unitPrice: 0,
    discountAmount: 0,
    discountPercent: 0,
    taxPercent: 0,
  })
  const [showServiceDropdown, setShowServiceDropdown] = useState(false)
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0, width: 0 })
  const serviceDropdownRef = useRef<HTMLDivElement>(null)
  const serviceInputRef = useRef<HTMLInputElement>(null)
  
  // Dropdown data
  const [operators, setOperators] = useState<Operator[]>([])
  const [vehicles, setVehicles] = useState<Vehicle[]>([])
  const [routes, setRoutes] = useState<Route[]>([])
  const [drivers, setDrivers] = useState<Driver[]>([])
  const [filteredVehicles, setFilteredVehicles] = useState<Vehicle[]>([])
  
  const [isCreating, setIsCreating] = useState(false)

  useEffect(() => {
    setTitle("Quản lý đơn hàng > Tạo mới")
    loadInitialData()
  }, [setTitle])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (serviceDropdownRef.current && !serviceDropdownRef.current.contains(event.target as Node)) {
        if (serviceInputRef.current && !serviceInputRef.current.contains(event.target as Node)) {
          setShowServiceDropdown(false)
        }
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [])

  useEffect(() => {
    const updateDropdownPosition = () => {
      if (showServiceDropdown && serviceInputRef.current) {
        const rect = serviceInputRef.current.getBoundingClientRect()
        setDropdownPosition({
          top: rect.bottom + window.scrollY + 4,
          left: rect.left + window.scrollX,
          width: rect.width,
        })
      }
    }

    if (showServiceDropdown) {
      updateDropdownPosition()
      window.addEventListener('scroll', updateDropdownPosition, true)
      window.addEventListener('resize', updateDropdownPosition)
    }

    return () => {
      window.removeEventListener('scroll', updateDropdownPosition, true)
      window.removeEventListener('resize', updateDropdownPosition)
    }
  }, [showServiceDropdown])

  useEffect(() => {
    // Filter vehicles by operator
    if (operatorId) {
      const filtered = vehicles.filter(v => v.operatorId === operatorId)
      setFilteredVehicles(filtered)
      // Reset vehicle selection if current vehicle doesn't belong to selected operator
      if (vehicleId && !filtered.find(v => v.id === vehicleId)) {
        setVehicleId("")
      }
      // Load drivers for selected operator
      loadDrivers(operatorId)
    } else {
      setFilteredVehicles(vehicles)
      setDrivers([])
    }
  }, [operatorId, vehicles, vehicleId])

  const loadDrivers = async (opId: string) => {
    try {
      const driversData = await driverService.getAll(opId, true)
      setDrivers(driversData)
    } catch (error) {
      console.error("Failed to load drivers:", error)
      setDrivers([])
    }
  }

  const loadInitialData = async () => {
    try {
      const [operatorsData, vehiclesData, routesData, serviceTypesData] = await Promise.all([
        operatorService.getAll(true),
        vehicleService.getAll(undefined, true),
        routeService.getAll(undefined, undefined, true),
        serviceChargeService.getServiceTypes(true)
      ])
      setOperators(operatorsData)
      setVehicles(vehiclesData)
      setFilteredVehicles(vehiclesData)
      setRoutes(routesData)
      setServiceTypes(serviceTypesData)
    } catch (error) {
      console.error("Failed to load initial data:", error)
      toast.error("Không thể tải dữ liệu. Vui lòng thử lại sau.")
    }
  }

  const handleServiceTypeChange = (serviceTypeId: string) => {
    const selectedType = serviceTypes.find(st => st.id === serviceTypeId)
    if (selectedType) {
      setNewService({
        ...newService,
        serviceTypeId,
        serviceName: selectedType.name,
        unitPrice: selectedType.basePrice,
      })
      setShowServiceDropdown(false)
    }
  }

  const calculateServiceAmounts = (service: typeof newService) => {
    const amountBeforeDiscount = service.quantity * service.unitPrice
    const discountAmount = service.discountAmount || (amountBeforeDiscount * service.discountPercent / 100)
    const subtotal = amountBeforeDiscount - discountAmount
    const taxAmount = subtotal * service.taxPercent / 100
    const totalAmount = subtotal + taxAmount
    
    return {
      amountBeforeDiscount,
      discountAmount,
      totalAmount,
    }
  }

  const handleAddService = () => {
    if (!newService.serviceTypeId || !newService.unitPrice) {
      toast.warning("Vui lòng chọn dịch vụ và nhập đơn giá")
      return
    }

    if (newService.quantity <= 0) {
      toast.warning("Số lượng phải lớn hơn 0")
      return
    }

    const { amountBeforeDiscount, discountAmount, totalAmount } = calculateServiceAmounts(newService)
    
    const serviceItem: ServiceItem = {
      id: `temp-${Date.now()}-${Math.random()}`,
      serviceTypeId: newService.serviceTypeId,
      serviceName: newService.serviceName,
      unitPrice: newService.unitPrice,
      quantity: newService.quantity,
      discountAmount,
      discountPercent: newService.discountPercent,
      taxPercent: newService.taxPercent,
      amountBeforeDiscount,
      totalAmount,
    }

    setServices([...services, serviceItem])
    setNewService({
      serviceTypeId: "",
      serviceName: "",
      quantity: 1,
      unitPrice: 0,
      discountAmount: 0,
      discountPercent: 0,
      taxPercent: 0,
    })
    setIsAddingService(false)
  }

  const handleCancelAddService = () => {
    setIsAddingService(false)
    setNewService({
      serviceTypeId: "",
      serviceName: "",
      quantity: 1,
      unitPrice: 0,
      discountAmount: 0,
      discountPercent: 0,
      taxPercent: 0,
    })
  }

  const handleDeleteService = (id: string) => {
    setServices(services.filter(s => s.id !== id))
  }

  const calculateTotals = () => {
    const subtotal = services.reduce((sum, s) => sum + s.totalAmount, 0)
    const totalDiscount = services.reduce((sum, s) => sum + s.discountAmount, 0)
    const totalTax = services.reduce((sum, s) => {
      const subtotalItem = s.amountBeforeDiscount - s.discountAmount
      return sum + (subtotalItem * s.taxPercent / 100)
    }, 0)
    const total = subtotal
    
    return { subtotal, discount: totalDiscount, tax: totalTax, total }
  }

  const handleCreateOrder = async () => {
    // Validation
    if (!operatorId) {
      toast.warning("Vui lòng chọn đơn vị vận tải")
      return
    }

    if (!vehicleId) {
      toast.warning("Vui lòng chọn phương tiện")
      return
    }

    if (!routeId) {
      toast.warning("Vui lòng chọn tuyến vận chuyển")
      return
    }

    if (services.length === 0) {
      toast.warning("Vui lòng thêm ít nhất một dịch vụ")
      return
    }

    // Get vehicle to find driver
    const vehicle = vehicles.find(v => v.id === vehicleId)
    if (!vehicle) {
      toast.error("Không tìm thấy thông tin phương tiện")
      return
    }

    // Get driver - use first active driver if available
    if (drivers.length === 0) {
      toast.warning("Không tìm thấy lái xe cho đơn vị vận tải này. Vui lòng thêm lái xe trước.")
      return
    }

    const selectedDriverId = drivers[0].id

    setIsCreating(true)
    try {
      // Create dispatch record first
      const dispatchInput = {
        vehicleId,
        driverId: selectedDriverId,
        routeId,
        entryTime: effectiveDate.toISOString(),
        notes: `Đơn hàng ${orderType} - ${invoiceSymbol}`,
      }

      // Include metadata in notes for now (since backend doesn't support metadata in create)
      // The operatorId is already linked through vehicle, but we store it in notes for reference
      const notesWithMetadata = `Đơn hàng ${orderType} - ${invoiceSymbol} | OperatorId: ${operatorId}`
      
      const dispatchRecord = await dispatchService.create({
        ...dispatchInput,
        notes: notesWithMetadata,
      })
      
      // Create service charges for each service
      for (const service of services) {
        const serviceChargeInput: ServiceChargeInput = {
          dispatchRecordId: dispatchRecord.id,
          serviceTypeId: service.serviceTypeId,
          quantity: service.quantity,
          unitPrice: service.unitPrice,
          totalAmount: service.totalAmount,
        }
        await serviceChargeService.create(serviceChargeInput)
      }

      toast.success("Tạo đơn hàng thành công!")
      navigate(`/thanh-toan/${dispatchRecord.id}`)
      
    } catch (error) {
      console.error("Failed to create order:", error)
      toast.error("Không thể tạo đơn hàng. Vui lòng thử lại sau.")
    } finally {
      setIsCreating(false)
    }
  }

  const handleCancel = () => {
    if (window.confirm("Bạn có chắc chắn muốn hủy? Tất cả thông tin sẽ bị mất.")) {
      navigate("/thanh-toan")
    }
  }

  const { subtotal, discount, tax, total } = calculateTotals()

  return (
    <div className="h-full flex flex-col p-6 space-y-4">
      {/* Breadcrumb */}
      <div className="text-sm text-gray-600">
        Quản lý đơn hàng &gt; Tạo mới
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 overflow-hidden">
        {/* Left Column - Service Information */}
        <div className="lg:col-span-2 flex flex-col space-y-4 overflow-hidden">
          <Card className="flex-1 flex flex-col overflow-hidden">
            <CardContent className="p-4">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold text-gray-900">Thông tin dịch vụ</h2>
                <div className="flex items-center gap-2">
                  <Button
                    onClick={() => setIsAddingService(true)}
                    size="sm"
                    variant="outline"
                    className="gap-2"
                  >
                    <Plus className="h-4 w-4" />
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    className="gap-2"
                    title="Cài đặt"
                  >
                    <Settings className="h-4 w-4" />
                  </Button>
                  <Button
                    onClick={loadInitialData}
                    size="sm"
                    variant="outline"
                    className="gap-2"
                    title="Làm mới"
                  >
                    <RefreshCw className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
            <CardContent className="p-0 pt-0 flex-1 overflow-auto relative">
              <div className="border-t">
                <h3 className="p-4 font-medium text-gray-700">Danh sách dịch vụ</h3>
                <div className="relative">
                  <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="text-center w-12">STT</TableHead>
                      <TableHead className="text-center">Dịch vụ</TableHead>
                      <TableHead className="text-center">Đơn giá (đ)</TableHead>
                      <TableHead className="text-center">Số lượng</TableHead>
                      <TableHead className="text-center">Tiền trước chiết khấu (đ)</TableHead>
                      <TableHead className="text-center">Thành tiền (đ)</TableHead>
                      <TableHead className="text-center w-20">Thao tác</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {isAddingService && (
                      <TableRow className="bg-blue-50">
                        <TableCell className="text-center">-</TableCell>
                        <TableCell className="relative">
                          <div className="relative">
                            <Input
                              ref={serviceInputRef}
                              value={newService.serviceName}
                              onChange={(e) => {
                                setNewService({ ...newService, serviceName: e.target.value })
                                setShowServiceDropdown(true)
                              }}
                              onFocus={() => setShowServiceDropdown(true)}
                              placeholder="Tên dịch vụ"
                              className="h-8"
                            />
                          </div>
                        </TableCell>
                        <TableCell>
                          <Input
                            type="number"
                            min="0"
                            value={newService.unitPrice}
                            onChange={(e) => setNewService({ ...newService, unitPrice: parseFloat(e.target.value) || 0 })}
                            className="h-8"
                          />
                        </TableCell>
                        <TableCell>
                          <Input
                            type="number"
                            min="1"
                            value={newService.quantity}
                            onChange={(e) => setNewService({ ...newService, quantity: parseInt(e.target.value) || 1 })}
                            className="h-8"
                          />
                        </TableCell>
                        <TableCell className="text-center">
                          {calculateServiceAmounts(newService).amountBeforeDiscount.toLocaleString('vi-VN')}
                        </TableCell>
                        <TableCell className="text-center font-medium">
                          {calculateServiceAmounts(newService).totalAmount.toLocaleString('vi-VN')}
                        </TableCell>
                        <TableCell>
                          <div className="flex gap-1 justify-center">
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={handleAddService}
                              className="h-8 w-8 text-green-600 hover:text-green-700 hover:bg-green-50"
                            >
                              <Check className="h-4 w-4" />
                            </Button>
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={handleCancelAddService}
                              className="h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-50"
                            >
                              <X className="h-4 w-4" />
                            </Button>
                          </div>
                        </TableCell>
                      </TableRow>
                    )}
                    {services.length === 0 && !isAddingService ? (
                      <TableRow>
                        <TableCell colSpan={7} className="text-center py-8 text-gray-500">
                          Không có dữ liệu!
                        </TableCell>
                      </TableRow>
                    ) : (
                      services.map((service, index) => (
                        <TableRow key={service.id}>
                          <TableCell className="text-center">{index + 1}</TableCell>
                          <TableCell className="font-medium">{service.serviceName}</TableCell>
                          <TableCell className="text-center">{service.unitPrice.toLocaleString('vi-VN')}</TableCell>
                          <TableCell className="text-center">{service.quantity}</TableCell>
                          <TableCell className="text-center">{service.amountBeforeDiscount.toLocaleString('vi-VN')}</TableCell>
                          <TableCell className="text-center font-medium">{service.totalAmount.toLocaleString('vi-VN')}</TableCell>
                          <TableCell>
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => handleDeleteService(service.id)}
                              className="h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-50"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                    {services.length > 0 && (
                      <TableRow className="bg-gray-50 font-semibold">
                        <TableCell colSpan={4} className="text-right">
                          Tổng tiền:
                        </TableCell>
                        <TableCell className="text-center">{subtotal.toLocaleString('vi-VN')}</TableCell>
                        <TableCell className="text-center">{total.toLocaleString('vi-VN')}</TableCell>
                        <TableCell></TableCell>
                      </TableRow>
                    )}
                  </TableBody>
                </Table>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Cancel Button */}
          <Button variant="destructive" onClick={handleCancel} className="w-full">
            HỦY
          </Button>
        </div>

        {/* Right Column - General Information */}
        <div className="space-y-4 overflow-y-auto">
          <Card>
            <CardContent className="p-6 space-y-4">
              <h2 className="text-lg font-semibold text-gray-900">Thông tin chung</h2>

              {/* Effective Date */}
              <div>
                <Label htmlFor="effectiveDate">Ngày áp dụng:</Label>
                <div className="mt-1">
                  <DateTimePicker 
                    date={effectiveDate} 
                    onDateChange={(d) => d && setEffectiveDate(d)} 
                  />
                </div>
              </div>

              {/* Transport Unit */}
              <div>
                <Label htmlFor="operator">Đơn vị vận tải:</Label>
                <Select
                  id="operator"
                  value={operatorId}
                  onChange={(e) => setOperatorId(e.target.value)}
                  className="mt-1"
                >
                  <option value="">Lựa chọn...</option>
                  {operators.map((op) => (
                    <option key={op.id} value={op.id}>
                      {op.name}
                    </option>
                  ))}
                </Select>
              </div>

              {/* Vehicle */}
              <div>
                <Label htmlFor="vehicle">Phương tiện:</Label>
                <Select
                  id="vehicle"
                  value={vehicleId}
                  onChange={(e) => setVehicleId(e.target.value)}
                  className="mt-1"
                  disabled={!operatorId}
                >
                  <option value="">Lựa chọn...</option>
                  {filteredVehicles.map((vehicle) => (
                    <option key={vehicle.id} value={vehicle.id}>
                      {vehicle.plateNumber}
                    </option>
                  ))}
                </Select>
              </div>

              {/* Shipping Route */}
              <div>
                <Label htmlFor="route">Tuyến vận chuyển:</Label>
                <Select
                  id="route"
                  value={routeId}
                  onChange={(e) => setRouteId(e.target.value)}
                  className="mt-1"
                >
                  <option value="">Lựa chọn...</option>
                  {routes.map((route) => (
                    <option key={route.id} value={route.id}>
                      {route.routeName}
                    </option>
                  ))}
                </Select>
              </div>

              {/* Order Type */}
              <div>
                <Label htmlFor="orderType">Loại đơn hàng:</Label>
                <Select
                  id="orderType"
                  value={orderType}
                  onChange={(e) => setOrderType(e.target.value)}
                  className="mt-1"
                >
                  <option value="thanh-toan-chuyen">Thanh toán chuyến</option>
                  <option value="thanh-toan-dinh-ky">Thanh toán định kỳ</option>
                  <option value="thanh-toan-truy-thu">Thanh toán truy thu</option>
                  <option value="khac">Khác</option>
                  <option value="thanh-toan-khong-du-dieu-kien">Thanh toán không đủ điều kiện</option>
                  <option value="thanh-toan-chuyen-tang-cuong">Thanh toán chuyến (Tăng cường)</option>
                  <option value="thanh-toan-vang-lai">Thanh toán vãng lai</option>
                </Select>
              </div>

              {/* Status */}
              <div>
                <Label htmlFor="status">Trạng thái:</Label>
                <Select
                  id="status"
                  value={status}
                  onChange={(e) => setStatus(e.target.value)}
                  className="mt-1"
                >
                  <option value="da-xac-nhan">Đã xác nhận</option>
                  <option value="chua-xac-nhan">Chưa xác nhận</option>
                  <option value="dang-xu-ly">Đang xử lý</option>
                </Select>
              </div>

              {/* Invoice Symbol */}
              <div>
                <Label htmlFor="invoiceSymbol">Ký hiệu hóa đơn:</Label>
                <Select
                  id="invoiceSymbol"
                  value={invoiceSymbol}
                  onChange={(e) => setInvoiceSymbol(e.target.value)}
                  className="mt-1"
                >
                  <option value="QLBX">QLBX</option>
                  <option value="KHAC">KHAC</option>
                </Select>
              </div>

              {/* Payment Summary */}
              <div className="pt-4 border-t space-y-3">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Tổng tiền:</span>
                  <span className="font-medium">{subtotal.toLocaleString('vi-VN')} đồng</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Chiết khấu:</span>
                  <span className="font-medium">{discount.toLocaleString('vi-VN')} đồng</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Tiền thuế GTGT:</span>
                  <span className="font-medium">{tax.toLocaleString('vi-VN')} đồng</span>
                </div>
                <div className="flex justify-between pt-2 border-t font-bold text-lg">
                  <span>Thực thu:</span>
                  <span className="text-blue-600">{total.toLocaleString('vi-VN')} đồng</span>
                </div>
              </div>

              {/* Create Order Button */}
              <Button 
                className="w-full bg-green-600 hover:bg-green-700"
                onClick={handleCreateOrder}
                disabled={isCreating}
              >
                {isCreating ? "Đang tạo..." : "TẠO ĐƠN HÀNG"}
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Service Dropdown Portal */}
      {showServiceDropdown && serviceInputRef.current && createPortal(
        <div
          ref={serviceDropdownRef}
          className="fixed z-[9999] bg-white border border-gray-300 rounded-md shadow-xl max-h-60 overflow-auto"
          style={{
            top: `${dropdownPosition.top}px`,
            left: `${dropdownPosition.left}px`,
            width: `${dropdownPosition.width}px`,
          }}
        >
          {serviceTypes.filter(t => 
            t.name.toLowerCase().includes(newService.serviceName.toLowerCase())
          ).length > 0 ? (
            serviceTypes.filter(t => 
              t.name.toLowerCase().includes(newService.serviceName.toLowerCase())
            ).map((type) => (
              <div
                key={type.id}
                onClick={() => handleServiceTypeChange(type.id)}
                className="px-3 py-2 cursor-pointer hover:bg-blue-50 text-sm"
              >
                {type.name}
              </div>
            ))
          ) : (
            <div className="px-3 py-2 text-gray-500 text-sm">
              Không tìm thấy kết quả
            </div>
          )}
        </div>,
        document.body
      )}
    </div>
  )
}
</file>

<file path="client/src/services/invoice.service.ts">
import api from '@/lib/api'
import type { Invoice, InvoiceInput } from '@/types'

export const invoiceService = {
  getAll: async (
    operatorId?: string,
    paymentStatus?: 'pending' | 'paid' | 'overdue' | 'cancelled',
    startDate?: string,
    endDate?: string
  ): Promise<Invoice[]> => {
    const params: Record<string, string> = {}
    if (operatorId) params.operatorId = operatorId
    if (paymentStatus) params.paymentStatus = paymentStatus
    if (startDate) params.startDate = startDate
    if (endDate) params.endDate = endDate
    const response = await api.get<Invoice[]>('/invoices', { params })
    return response.data
  },

  getById: async (id: string): Promise<Invoice> => {
    const response = await api.get<Invoice>(`/invoices/${id}`)
    return response.data
  },

  create: async (data: InvoiceInput): Promise<Invoice> => {
    const response = await api.post<Invoice>('/invoices', data)
    return response.data
  },

  update: async (id: string, data: Partial<InvoiceInput>): Promise<Invoice> => {
    const response = await api.put<Invoice>(`/invoices/${id}`, data)
    return response.data
  },

  updatePayment: async (
    id: string,
    data: {
      paymentStatus: 'pending' | 'paid' | 'overdue' | 'cancelled'
      paymentDate?: string
    }
  ): Promise<Invoice> => {
    const response = await api.patch<Invoice>(`/invoices/${id}/payment`, data)
    return response.data
  },
}
</file>

<file path="client/src/services/quanly-data.service.ts">
import api from '@/lib/api'

export interface QuanLyBadge {
  id: string
  badge_number: string
  license_plate_sheet: string
  badge_type: string
  badge_color: string
  issue_date: string
  expiry_date: string
  status: string
  file_code: string
  issuing_authority_ref: string
  route_id: string
  vehicle_type: string
}

export interface QuanLyVehicle {
  id: string
  plateNumber: string
  seatCapacity: number
  operatorName: string
  vehicleType: string
  inspectionExpiryDate: string
  isActive: boolean
  source: string
}

export interface QuanLyOperator {
  id: string
  name: string
  province: string
  phone: string
  email: string
  address: string
  representativeName: string
  isActive: boolean
  source: string
}

export interface QuanLyRoute {
  id: string
  code: string
  name: string
  startPoint: string
  endPoint: string
  distance: string
}

export interface QuanLyData {
  badges?: QuanLyBadge[]
  vehicles?: QuanLyVehicle[]
  operators?: QuanLyOperator[]
  routes?: QuanLyRoute[]
  meta: {
    badgeCount: number
    vehicleCount: number
    operatorCount: number
    routeCount: number
    cachedAt: string
  }
}

// Frontend cache
let dataCache: QuanLyData | null = null
let dataCacheTime = 0
const FE_CACHE_TTL = 5 * 60 * 1000 // 5 minutes frontend cache - stable numbers

export const quanlyDataService = {
  /**
   * Get all data for Quản lý thông tin module in a single request
   * @param include - comma-separated list of data to include (badges,vehicles,operators,routes)
   * @param forceRefresh - bypass cache and fetch fresh data
   */
  async getAll(include?: string[], forceRefresh = false): Promise<QuanLyData> {
    try {
      const now = Date.now()
      
      // Return cached data if valid
      if (!forceRefresh && dataCache && (now - dataCacheTime) < FE_CACHE_TTL) {
        // Filter cached data if specific includes requested
        if (include && include.length > 0) {
          const filtered: QuanLyData = { meta: dataCache.meta }
          if (include.includes('badges')) filtered.badges = dataCache.badges
          if (include.includes('vehicles')) filtered.vehicles = dataCache.vehicles
          if (include.includes('operators')) filtered.operators = dataCache.operators
          if (include.includes('routes')) filtered.routes = dataCache.routes
          return filtered
        }
        return dataCache
      }
      
      const params: Record<string, string> = {}
      if (include && include.length > 0) {
        params.include = include.join(',')
      }
      if (forceRefresh) {
        params.refresh = 'true'
      }
      
      const response = await api.get<QuanLyData>('/quanly-data', { params })
      
      // Cache the response if it includes all data
      if (!include || include.length === 4) {
        dataCache = response.data
        dataCacheTime = now
      }
      
      return response.data
    } catch (error) {
      console.error('Error fetching quanly data:', error)
      // Return stale cache on error
      if (dataCache) return dataCache
      throw error
    }
  },
  
  /**
   * Get just badges
   */
  async getBadges(forceRefresh = false): Promise<QuanLyBadge[]> {
    const data = await this.getAll(['badges'], forceRefresh)
    return data.badges || []
  },
  
  /**
   * Get just vehicles
   */
  async getVehicles(forceRefresh = false): Promise<QuanLyVehicle[]> {
    const data = await this.getAll(['vehicles'], forceRefresh)
    return data.vehicles || []
  },
  
  /**
   * Get just operators
   */
  async getOperators(forceRefresh = false): Promise<QuanLyOperator[]> {
    const data = await this.getAll(['operators'], forceRefresh)
    return data.operators || []
  },
  
  /**
   * Get just routes
   */
  async getRoutes(forceRefresh = false): Promise<QuanLyRoute[]> {
    const data = await this.getAll(['routes'], forceRefresh)
    return data.routes || []
  },
  
  /**
   * Get lightweight stats
   */
  async getStats(): Promise<QuanLyData['meta']> {
    const response = await api.get<QuanLyData['meta']>('/quanly-data/stats')
    return response.data
  },
  
  /**
   * Clear frontend cache
   */
  clearCache() {
    dataCache = null
    dataCacheTime = 0
  },
}
</file>

<file path="client/src/services/report.service.ts">
import api from '@/lib/api'
import type { ReportFilter, InvoiceReport, RevenueReport } from '@/types'

export const reportService = {
  getInvoices: async (filter: ReportFilter): Promise<InvoiceReport[]> => {
    const response = await api.get<InvoiceReport[]>('/reports/invoices', { params: filter })
    return response.data
  },

  getVehicleLogs: async (filter: ReportFilter): Promise<any[]> => {
    const response = await api.get('/reports/vehicle-logs', { params: filter })
    return response.data
  },

  getStationActivity: async (filter: ReportFilter): Promise<any[]> => {
    const response = await api.get('/reports/station-activity', { params: filter })
    return response.data
  },

  getInvalidVehicles: async (filter: ReportFilter): Promise<any[]> => {
    const response = await api.get('/reports/invalid-vehicles', { params: filter })
    return response.data
  },

  getRevenue: async (filter: ReportFilter): Promise<RevenueReport[]> => {
    const response = await api.get<RevenueReport[]>('/reports/revenue', { params: filter })
    return response.data
  },

  exportExcel: async (type: string, filter: ReportFilter): Promise<Blob> => {
    const response = await api.get(`/reports/export/${type}`, {
      params: filter,
      responseType: 'blob',
    })
    return response.data
  },
}
</file>

<file path="client/src/services/service-charge.service.ts">
import api from '@/lib/api'
import type { ServiceCharge, ServiceChargeInput, ServiceType } from '@/types'

export const serviceChargeService = {
  getAll: async (dispatchRecordId?: string): Promise<ServiceCharge[]> => {
    const params = dispatchRecordId ? { dispatchRecordId } : {}
    const response = await api.get<ServiceCharge[]>('/service-charges', { params })
    return response.data
  },

  getById: async (id: string): Promise<ServiceCharge> => {
    const response = await api.get<ServiceCharge>(`/service-charges/${id}`)
    return response.data
  },

  create: async (data: ServiceChargeInput): Promise<ServiceCharge> => {
    const response = await api.post<ServiceCharge>('/service-charges', data)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/service-charges/${id}`)
  },

  getServiceTypes: async (isActive?: boolean): Promise<ServiceType[]> => {
    const params = isActive !== undefined ? { isActive: isActive.toString() } : {}
    const response = await api.get<ServiceType[]>('/service-charges/types', { params })
    return response.data
  },
}
</file>

<file path="client/src/services/violation.service.ts">
import api from '@/lib/api'
import type { Violation, ViolationInput, ViolationType } from '@/types'

export const violationService = {
  getAll: async (
    vehicleId?: string,
    driverId?: string,
    dispatchRecordId?: string,
    resolutionStatus?: 'pending' | 'resolved' | 'dismissed'
  ): Promise<Violation[]> => {
    const params: Record<string, string> = {}
    if (vehicleId) params.vehicleId = vehicleId
    if (driverId) params.driverId = driverId
    if (dispatchRecordId) params.dispatchRecordId = dispatchRecordId
    if (resolutionStatus) params.resolutionStatus = resolutionStatus
    const response = await api.get<Violation[]>('/violations', { params })
    return response.data
  },

  getById: async (id: string): Promise<Violation> => {
    const response = await api.get<Violation>(`/violations/${id}`)
    return response.data
  },

  create: async (data: ViolationInput): Promise<Violation> => {
    const response = await api.post<Violation>('/violations', data)
    return response.data
  },

  update: async (
    id: string,
    data: {
      resolutionStatus: 'pending' | 'resolved' | 'dismissed'
      resolutionNotes?: string
    }
  ): Promise<Violation> => {
    const response = await api.put<Violation>(`/violations/${id}`, data)
    return response.data
  },

  getViolationTypes: async (): Promise<ViolationType[]> => {
    const response = await api.get<ViolationType[]>('/violations/types')
    return response.data
  },
}
</file>

<file path="client/src/store/dispatch.store.ts">
import { create } from 'zustand'
import type { DispatchRecord } from '@/types'

// Display status type for UI tabs (different from backend status)
type DisplayStatus = "in-station" | "permit-issued" | "paid" | "departed"

interface DispatchState {
  records: DispatchRecord[]
  selectedRecord: DispatchRecord | null
  activeTab: DisplayStatus | 'all'
  setRecords: (records: DispatchRecord[]) => void
  setSelectedRecord: (record: DispatchRecord | null) => void
  setActiveTab: (tab: DisplayStatus | 'all') => void
  updateRecord: (id: string, updates: Partial<DispatchRecord>) => void
  addRecord: (record: DispatchRecord) => void
}

export const useDispatchStore = create<DispatchState>((set) => ({
  records: [],
  selectedRecord: null,
  activeTab: 'all',

  setRecords: (records) => set({ records }),
  
  setSelectedRecord: (record) => set({ selectedRecord: record }),
  
  setActiveTab: (tab) => set({ activeTab: tab }),
  
  updateRecord: (id, updates) =>
    set((state) => ({
      records: state.records.map((r) => (r.id === id ? { ...r, ...updates } : r)),
    })),
  
  addRecord: (record) =>
    set((state) => ({
      records: [record, ...state.records],
    })),
}))
</file>

<file path="client/src/store/ui.store.ts">
import { create } from 'zustand'
import { shiftService, type Shift } from '@/services/shift.service'

interface UIState {
  title: string
  setTitle: (title: string) => void
  currentShift: string
  setCurrentShift: (shift: string) => void
  shifts: Shift[]
  setShifts: (shifts: Shift[]) => void
  loadShifts: () => Promise<void>
  getShiftByCurrentTime: () => string
  initializeShiftIfNeeded: () => Promise<void>
}

// Helper function để parse time (HH:mm) thành số phút
const timeToMinutes = (time: string): number => {
  const [hours, minutes] = time.split(':').map(Number)
  return hours * 60 + minutes
}

// Helper function để format shift name (tương tự như trong ShiftSelectionDialog)
const formatShiftName = (shift: Shift): string => {
  return `${shift.name} (${shift.startTime} - ${shift.endTime})`
}

// Hàm xác định shift dựa trên giờ hiện tại
const getShiftByCurrentTime = (shifts: Shift[]): string => {
  if (shifts.length === 0) {
    // Fallback nếu chưa có shifts
    return '<Trống>'
  }

  const now = new Date()
  const currentMinutes = now.getHours() * 60 + now.getMinutes()

  for (const shift of shifts) {
    const startMinutes = timeToMinutes(shift.startTime)
    const endMinutes = timeToMinutes(shift.endTime)

    // Xử lý ca kéo dài qua nửa đêm (ví dụ: 22:00 - 06:00)
    if (startMinutes > endMinutes) {
      // Ca kéo dài qua nửa đêm
      if (currentMinutes >= startMinutes || currentMinutes < endMinutes) {
        return formatShiftName(shift)
      }
    } else {
      // Ca thông thường
      if (currentMinutes >= startMinutes && currentMinutes < endMinutes) {
        return formatShiftName(shift)
      }
    }
  }

  // Nếu không tìm thấy ca nào phù hợp, trả về ca đầu tiên hoặc '<Trống>'
  return '<Trống>'
}

export const useUIStore = create<UIState>((set, get) => ({
  title: '',
  setTitle: (title) => set({ title }),
  currentShift: '<Trống>',
  setCurrentShift: (shift) => set({ currentShift: shift }),
  shifts: [],
  setShifts: (shifts) => set({ shifts }),
  loadShifts: async () => {
    try {
      const shifts = await shiftService.getAll()
      set({ shifts })
    } catch (error) {
      console.error('Failed to load shifts:', error)
      // Giữ shifts hiện tại nếu load thất bại
    }
  },
  getShiftByCurrentTime: () => {
    const { shifts } = get()
    return getShiftByCurrentTime(shifts)
  },
  initializeShiftIfNeeded: async () => {
    const { currentShift, shifts, loadShifts } = get()
    
    // Chỉ tự động set nếu currentShift là '<Trống>'
    if (currentShift === '<Trống>') {
      // Load shifts nếu chưa có
      if (shifts.length === 0) {
        await loadShifts()
      }
      
      // Lấy shifts mới nhất từ store
      const updatedShifts = get().shifts
      const shift = getShiftByCurrentTime(updatedShifts)
      
      if (shift !== '<Trống>') {
        set({ currentShift: shift })
      }
    }
  },
}))
</file>

<file path="client/src/types/auth.types.ts">
// Authentication Types

export interface User {
  id: string
  username: string
  fullName: string
  role: 'admin' | 'dispatcher' | 'accountant' | 'reporter'
  email?: string
  phone?: string
}

export interface LoginCredentials {
  usernameOrEmail: string
  password: string
  rememberMe?: boolean
}

export interface RegisterCredentials {
  username: string
  password: string
  fullName: string
  email?: string
  phone?: string
  role?: 'admin' | 'dispatcher' | 'accountant' | 'reporter'
}
</file>

<file path="client/src/types/common.types.ts">
// Common/Shared Types
import type { DispatchStatus } from './dispatch.types'
import type { Operator } from './fleet.types'

// ==================== Shift Types ====================

export interface Shift {
  id: string
  name: string
  startTime: string
  endTime: string
  isActive: boolean
  createdAt?: string
}

// ==================== Location Types ====================

export interface Location {
  id: string
  name: string
  code: string
  stationType?: string
  province?: string
  district?: string
  phone?: string
  email?: string
  address?: string
  latitude?: number
  longitude?: number
  isActive: boolean
  createdAt?: string
}

export interface LocationInput {
  name: string
  code: string
  stationType?: string
  province?: string
  district?: string
  phone?: string
  email?: string
  address?: string
  latitude?: number
  longitude?: number
  isActive?: boolean
}

// ==================== Route Types ====================

export interface RouteStop {
  id: string
  routeId: string
  locationId: string
  location?: Location
  stopOrder: number
  distanceFromOriginKm?: number
  estimatedMinutesFromOrigin?: number
  createdAt?: string
}

export interface Route {
  id: string
  routeCode: string
  routeName: string
  routeType?: string
  originId: string
  origin?: Location
  originName?: string
  destinationId: string
  destination?: Location
  destinationName?: string
  distanceKm?: number
  estimatedDurationMinutes?: number

  plannedFrequency?: string
  boardingPoint?: string
  journeyDescription?: string
  departureTimesDescription?: string
  restStops?: string

  isActive: boolean
  stops?: RouteStop[]
  createdAt?: string
  updatedAt?: string
}

export interface RouteInput {
  routeCode: string
  routeName: string
  routeType?: string
  originId: string
  destinationId: string
  distanceKm?: number
  estimatedDurationMinutes?: number

  plannedFrequency?: string
  boardingPoint?: string
  journeyDescription?: string
  departureTimesDescription?: string
  restStops?: string

  isActive?: boolean
  stops?: Omit<RouteStop, 'id' | 'routeId' | 'createdAt'>[]
}

// ==================== Schedule Types ====================

export interface Schedule {
  id: string
  scheduleCode: string
  routeId: string
  route?: Route
  operatorId: string
  operator?: Operator
  departureTime: string
  frequencyType: 'daily' | 'weekly' | 'specific_days'
  daysOfWeek?: number[]
  effectiveFrom: string
  effectiveTo?: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export interface ScheduleInput {
  scheduleCode?: string // Optional - will be auto-generated if not provided
  routeId: string
  operatorId: string
  departureTime: string
  frequencyType: 'daily' | 'weekly' | 'specific_days'
  daysOfWeek?: number[]
  effectiveFrom: string
  effectiveTo?: string
}

// ==================== Violation Types ====================

export interface ViolationType {
  id: string
  code: string
  name: string
  description?: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  createdAt?: string
}

export interface Violation {
  id: string
  dispatchRecordId?: string
  vehicleId?: string
  driverId?: string
  violationTypeId: string
  violationType?: ViolationType
  violationDate: string
  description?: string
  resolutionStatus: 'pending' | 'resolved' | 'dismissed'
  resolutionNotes?: string
  recordedBy?: string
  createdAt?: string
  updatedAt?: string
}

export interface ViolationInput {
  dispatchRecordId?: string
  vehicleId?: string
  driverId?: string
  violationTypeId: string
  violationDate: string
  description?: string
}

// ==================== Service Types ====================

export interface ServiceType {
  id: string
  code: string
  name: string
  description?: string
  basePrice: number
  unit?: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export interface ServiceCharge {
  id: string
  dispatchRecordId: string
  serviceTypeId: string
  serviceType?: ServiceType
  quantity: number
  unitPrice: number
  totalAmount: number
  createdAt?: string
}

export interface ServiceChargeInput {
  dispatchRecordId: string
  serviceTypeId: string
  quantity?: number
  unitPrice: number
  totalAmount: number
}

// Service Management types (Quan ly dich vu)
export interface Service {
  id: string
  code: string // Ma dich vu
  name: string // Ten dich vu
  unit: string // Don vi tinh
  taxPercentage: number // Phan tram thue
  materialType: string // Loai vat tu/hang hoa
  useQuantityFormula: boolean // Su dung cong thuc tinh so luong
  usePriceFormula: boolean // Su dung cong thuc tinh don gia
  displayOrder: number // Thu tu hien thi
  isDefault: boolean // Mac dinh chon
  autoCalculateQuantity: boolean // Tu dong tinh so luong
  isActive: boolean // Trang thai
  quantityFormulaExpression?: string // ID bieu thuc tinh so luong
  priceFormulaExpression?: string // ID bieu thuc tinh don gia
  createdAt?: string
  updatedAt?: string
}

export interface ServiceInput {
  code: string
  name: string
  unit: string
  taxPercentage: number
  materialType: string
  useQuantityFormula: boolean
  usePriceFormula: boolean
  displayOrder: number
  isDefault: boolean
  autoCalculateQuantity: boolean
  isActive?: boolean
}

// Service Formula types (Quan ly bieu thuc)
export interface ServiceFormula {
  id: string
  code: string // Ma bieu thuc
  name: string // Ten bieu thuc
  description?: string // Ghi chu
  formulaType: 'quantity' | 'price' // Loai bieu thuc: tinh so luong hoac tinh don gia
  formulaExpression?: string // Bieu thuc cong thuc
  isActive: boolean // Trang thai
  usageCount?: number // So luong dich vu dang su dung (tu view)
  usedByServices?: string // Danh sach dich vu dang su dung (tu view)
  createdAt?: string
  updatedAt?: string
}

export interface ServiceFormulaInput {
  code: string
  name: string
  description?: string
  formulaType: 'quantity' | 'price'
  formulaExpression?: string
  isActive?: boolean
}

// ==================== Invoice Types ====================

export interface Invoice {
  id: string
  invoiceNumber: string
  dispatchRecordId?: string
  operatorId: string
  operator?: Operator
  issueDate: string
  dueDate?: string
  subtotal: number
  taxAmount: number
  totalAmount: number
  paymentStatus: 'pending' | 'paid' | 'overdue' | 'cancelled'
  paymentDate?: string
  notes?: string
  createdAt?: string
  updatedAt?: string
}

export interface InvoiceInput {
  invoiceNumber: string
  dispatchRecordId?: string
  operatorId: string
  issueDate: string
  dueDate?: string
  subtotal: number
  taxAmount?: number
  totalAmount: number
  notes?: string
}

// ==================== Report Types ====================

export interface ReportFilter {
  startDate: string
  endDate: string
  vehicleId?: string
  driverId?: string
  operatorId?: string
  routeId?: string
  status?: DispatchStatus
}

export interface RevenueReport {
  date: string
  totalRevenue: number
  vehicleCount: number
  transactionCount: number
}

export interface InvoiceReport {
  id: string
  invoiceNumber: string
  dispatchId: string
  operatorName: string
  amount: number
  issueDate: string
  status: string
}
</file>

<file path="client/src/utils/dispatch-helpers.ts">
/**
 * Helper functions for dispatch record filtering
 */

/**
 * Check if a date string is from today (Vietnam timezone)
 */
export function isToday(dateString: string | undefined): boolean {
  if (!dateString) return false;
  
  const date = new Date(dateString);
  const today = new Date();
  
  // Compare year, month, day
  return (
    date.getFullYear() === today.getFullYear() &&
    date.getMonth() === today.getMonth() &&
    date.getDate() === today.getDate()
  );
}

/**
 * Filter dispatch records to only include today's entries
 * This allows multiple trips per vehicle in a single day
 */
export function filterTodayRecords<T extends { entryTime: string }>(records: T[]): T[] {
  return records.filter(record => isToday(record.entryTime));
}

/**
 * Get start and end of today for date range filtering
 */
export function getTodayRange(): { start: Date; end: Date } {
  const start = new Date();
  start.setHours(0, 0, 0, 0);
  
  const end = new Date(start);
  end.setDate(end.getDate() + 1);
  
  return { start, end };
}
</file>

<file path="client/src/utils/timezone.ts">
/**
 * Vietnam Timezone Utilities
 * 
 * The backend stores Vietnam time with UTC "Z" suffix (mislabeled as UTC).
 * These utilities handle display correctly by treating stored time as Vietnam time.
 */

/**
 * Format a stored ISO timestamp (Vietnam time stored as UTC) for display
 * @param isoString - ISO string from database (e.g., "2024-12-25T23:54:00.000Z")
 * @param formatStr - Format pattern: "HH:mm", "dd/MM/yyyy", "dd/MM/yyyy HH:mm", "HH:mm dd/MM/yyyy", "HH:mm dd/MM", "yyyy-MM-dd"
 * @returns Formatted string in Vietnam time
 */
export function formatVietnamTime(isoString: string | null | undefined, formatStr: string = "HH:mm"): string {
  if (!isoString) return "-";
  
  try {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) return "-";
    
    // Use UTC methods since stored time is Vietnam time (just mislabeled as UTC)
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    
    // Handle common format patterns
    switch (formatStr) {
      case "HH:mm":
        return `${hours}:${minutes}`;
      case "dd/MM/yyyy":
        return `${day}/${month}/${year}`;
      case "dd/MM/yyyy HH:mm":
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      case "HH:mm dd/MM/yyyy":
        return `${hours}:${minutes} ${day}/${month}/${year}`;
      case "HH:mm dd/MM":
        return `${hours}:${minutes} ${day}/${month}`;
      case "yyyy-MM-dd":
        return `${year}-${month}-${day}`;
      default:
        // Fallback: replace format tokens
        return formatStr
          .replace("yyyy", String(year))
          .replace("MM", month)
          .replace("dd", day)
          .replace("HH", hours)
          .replace("mm", minutes);
    }
  } catch {
    return "-";
  }
}
</file>

<file path="client/src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL?: string
  readonly VITE_PHUHIEU_FIREBASE?: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="DEPLOYMENT_CONFIG.md">
# Hướng dẫn cấu hình kết nối Frontend và Backend

## Tổng quan
- **Frontend**: Deploy trên Vercel tại `https://quan-li-ben-xe.vercel.app/`
- **Backend**: Deploy trên Render tại `https://ben-xe-backend.onrender.com`

## Bước 1: Cấu hình CORS trên Backend (Render)

Trên Render Dashboard, bạn cần thêm biến môi trường `CORS_ORIGIN`:

1. Vào Render Dashboard
2. Chọn service backend của bạn
3. Vào tab **Environment**
4. Thêm biến môi trường mới:
   - **Key**: `CORS_ORIGIN`
   - **Value**: `https://quan-li-ben-xe.vercel.app`
   - Hoặc nhiều origin (ngăn cách bởi dấu phẩy): `https://quan-li-ben-xe.vercel.app,http://localhost:5173`
5. Lưu và redeploy service

**Lưu ý**: 
- Backend đã được cập nhật để tự động xử lý dấu `/` ở cuối URL, nên bạn có thể thêm hoặc không thêm dấu `/` đều được
- Có thể cấu hình nhiều origin bằng cách ngăn cách bởi dấu phẩy (hữu ích cho dev và production)

## Bước 2: Cấu hình API URL trên Frontend (Vercel)

Trên Vercel Dashboard, bạn cần thêm biến môi trường `VITE_API_URL`:

1. Vào Vercel Dashboard
2. Chọn project frontend của bạn
3. Vào **Settings** > **Environment Variables**
4. Thêm biến môi trường mới:
   - **Key**: `VITE_API_URL`
   - **Value**: `https://ben-xe-backend.onrender.com/api`
5. Chọn môi trường: **Production**, **Preview**, và **Development** (nếu cần)
6. Lưu và redeploy

## Bước 3: Kiểm tra kết nối

Sau khi cấu hình xong:

1. **Kiểm tra Backend Health Check**:
   ```
   https://ben-xe-backend.onrender.com/health
   ```
   Nên trả về: `{"status":"ok","timestamp":"..."}`

2. **Kiểm tra Frontend**:
   - Mở `https://quan-li-ben-xe.vercel.app/`
   - Thử đăng nhập hoặc gọi API
   - Mở Developer Tools (F12) > Network tab để xem các request

## Cấu hình cho Development (Local)

### Backend `.env`:
```env
CORS_ORIGIN=http://localhost:5173
PORT=3000
# ... các biến khác
```

### Frontend `.env`:
```env
VITE_API_URL=http://localhost:3000/api
```

## Troubleshooting

### Lỗi CORS
- ✅ **Đã sửa**: Backend đã được cập nhật để tự động xử lý dấu `/` ở cuối URL
- Kiểm tra `CORS_ORIGIN` trên Render có đúng URL frontend không
- Kiểm tra backend đã được redeploy sau khi thay đổi biến môi trường
- Nếu vẫn lỗi, thử xóa và thêm lại biến môi trường `CORS_ORIGIN` trên Render
- Kiểm tra trong Render logs xem CORS có được cấu hình đúng không

### Lỗi kết nối API
- Kiểm tra `VITE_API_URL` trên Vercel có đúng URL backend không
- Đảm bảo có `/api` ở cuối URL
- Kiểm tra frontend đã được redeploy sau khi thay đổi biến môi trường
- Kiểm tra backend có đang chạy không (health check)

### Lỗi 401 Unauthorized
- Kiểm tra token có được lưu trong localStorage không
- Kiểm tra backend có nhận được token trong header Authorization không
</file>

<file path="README.md">
# QuanLyBenXe - Bus Station Management System

**A comprehensive bus station management platform for Vietnamese transportation operators.**

QuanLyBenXe (Bus Management) is a full-stack web application designed to streamline operations at bus stations, including dispatch management, fleet tracking, driver management, financial reporting, and route planning.

---

## Quick Start

### Prerequisites
- Node.js 16+
- npm or yarn
- Firebase account with Realtime Database and Firestore enabled

### Installation

```bash
# Clone repository
git clone https://github.com/your-repo/quanlybenxe.git
cd Quanlybenxe

# Install dependencies
npm install

# Setup environment variables
cp .env.example .env.local

# Start development servers
npm run dev
```

The app runs on `http://localhost:5173` (client) and backend API on configured port.

---

## Project Structure

```
quanlybenxe/
├── client/                 # React 18 frontend (Vite)
│   └── src/
│       ├── features/       # Feature modules (auth, dispatch, fleet)
│       ├── pages/          # 27 lazy-loaded page components
│       ├── components/     # 50+ shared UI components
│       ├── services/       # API client services
│       ├── store/          # Zustand global stores
│       ├── types/          # TypeScript definitions
│       └── lib/            # Utilities and helpers
│
├── server/                 # Express.js backend
│   └── src/
│       ├── modules/        # Feature modules (dispatch, fleet, operator)
│       ├── controllers/    # 23 HTTP request handlers
│       ├── services/       # Business logic layer
│       ├── middleware/     # Auth, error handling, upload
│       ├── config/         # Database and external service config
│       └── types/          # Shared TypeScript types
│
└── docs/                   # Technical documentation
```

---

## Tech Stack

### Frontend
- **React 18** with TypeScript
- **Vite** for fast builds and HMR
- **React Router v6** for navigation
- **Zustand** for state management
- **React Hook Form** for form handling
- **Tailwind CSS** + **shadcn/ui** for styling
- **Recharts** for data visualization
- **SheetJS** for Excel export

### Backend
- **Express.js** with TypeScript
- **Firebase Realtime Database** for primary storage
- **Firestore** for secondary queries
- **JWT** for authentication
- **Cloudinary** for image storage

---

## Key Features

### 1. Dispatch Management (Điều Độ)
- Create and manage dispatch orders
- Vehicle assignment and optimization
- Driver and passenger tracking
- Status workflow: entered → passengers_dropped → permit_issued → paid → departed
- Settlement and payment processing

### 2. Fleet Management (Quản Lý Xe)
- Vehicle registry with maintenance history
- Driver profiles and qualifications
- Operator (company) management
- Vehicle badges (badge types, routes)
- Real-time vehicle location tracking

### 3. Financial Reporting (Báo Cáo Tài Chính)
- 20+ specialized report pages
- Revenue and expense tracking
- Driver salary calculations
- Trip and mileage analytics
- Excel export for further analysis

### 4. Route & Location Management (Tuyến Đường)
- Route creation and modification
- Pickup/drop-off location management
- Geographic mapping
- Schedule coordination

### 5. Shift Management (Ca Làm Việc)
- Shift scheduling
- Driver shift assignment
- Shift history and analytics

### 6. Chat Integration
- AI-powered chat widget
- Intent classification (what user is asking)
- Semantic data queries
- Context-aware responses

---

## Architecture Overview

### Data Flow

```
Client Request
    ↓
Routes (URL routing)
    ↓
Controller (HTTP handling)
    ↓
Validation (Input validation)
    ↓
Service (Business logic)
    ↓
Repository (Database layer)
    ↓
Firebase (RTDB + Firestore)
```

### State Management

**Frontend:**
- **Zustand stores** for feature-local state
- **React Query** patterns for async data
- **Context API** for UI-wide settings

**Backend:**
- Service layer handles complex workflows
- Repository pattern for data access
- Firebase dual-write (RTDB ↔ Firestore sync)

---

## Development Workflow

### Running Locally

```bash
# Terminal 1: Start client (Vite dev server)
cd client && npm run dev

# Terminal 2: Start backend (Node.js)
cd server && npm run dev

# Terminal 3: Run tests (optional)
npm run test
```

### Code Organization

- **Features** are organized by business domain (auth, dispatch, fleet)
- **Components** follow feature-based structure
- **Services** handle API calls and business logic
- **Types** are TypeScript-first with strict checking

### Making Changes

1. Create a feature branch: `git checkout -b feature/feature-name`
2. Make changes following code standards in `docs/code-standards.md`
3. Run tests: `npm run test`
4. Commit with conventional messages: `feat: add new feature`
5. Push and create pull request

---

## Documentation

- **[Code Standards](./docs/code-standards.md)** - Coding conventions and patterns
- **[Codebase Summary](./docs/codebase-summary.md)** - Complete codebase structure
- **[System Architecture](./docs/system-architecture.md)** - Architecture decisions
- **[Project Roadmap](./docs/project-roadmap.md)** - Current status and roadmap
- **[Troubleshooting](./docs/troubleshoot_tips.md)** - Common issues and solutions

---

## Deployment

### Backend
- Deployed to Render.com
- Environment: Node.js with Express.js
- Database: Firebase (cloud-managed)

### Frontend
- Deployed to Vercel or similar
- Automatic builds on main branch push
- Environment variables configured in deployment platform

See `DEPLOYMENT_CONFIG.md` for detailed setup.

---

## Contributing

1. Read `docs/code-standards.md` for conventions
2. Check `docs/project-roadmap.md` for active features
3. Follow commit message format: `feat|fix|docs|refactor: description`
4. Ensure all tests pass before pushing
5. Create detailed pull requests with context

---

## Performance Metrics

### Frontend Bundle
- **React vendor**: ~163KB
- **UI components (Radix)**: ~68KB
- **Utilities**: ~89KB
- **Icons**: ~38KB
- **Charts**: ~382KB
- **Excel export**: ~283KB

### Code Quality
- TypeScript strict mode enabled
- No `any` types allowed
- Controller max: 200 lines
- Service/Helper functions: <50 lines average

---

## Support & Issues

For bug reports or feature requests, please create an issue on GitHub with:
- Clear description
- Steps to reproduce
- Expected vs actual behavior
- Screenshots (if applicable)

---

## License

Proprietary - Freelance Project

---

**Last Updated:** 2025-12-21
**Maintainers:** Development Team
**Status:** Active Development
</file>

<file path="render.yaml">
services:
  - type: web
    name: ben-xe-backend
    env: node
    plan: free
    buildCommand: cd server && npm install && npm run build
    startCommand: cd server && npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 10000
      - key: FIREBASE_DATABASE_URL
        sync: false
      - key: GOOGLE_APPLICATION_CREDENTIALS
        sync: false
      - key: CORS_ORIGIN
        sync: false
      - key: JWT_SECRET
        sync: false
</file>

<file path="scripts/analyze-operator-data.ts">
/**
 * Script: Analyze Operator Data Quality
 * 
 * Checks all operators for missing/empty fields and generates a report
 * 
 * Usage: npx ts-node scripts/analyze-operator-data.ts
 */

import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import * as path from 'path'
import * as fs from 'fs'

// Initialize Firebase Admin
const serviceAccountPath = path.resolve(__dirname, '../server/config/firebase-service-account.json')

if (getApps().length === 0) {
  initializeApp({
    credential: cert(serviceAccountPath),
    databaseURL: 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'
  })
}

const db = getDatabase()

interface OperatorDB {
  id?: string
  name: string
  code: string
  tax_code?: string
  phone?: string
  email?: string
  address?: string
  province?: string
  district?: string
  representative_name?: string
  representative_position?: string
  is_ticket_delegated?: boolean
  is_active?: boolean
  created_at?: number
  updated_at?: number
}

interface DataQualityReport {
  totalOperators: number
  completeOperators: number
  incompleteOperators: number
  completionRate: number
  fieldAnalysis: {
    [field: string]: {
      filled: number
      empty: number
      fillRate: number
    }
  }
  operatorDetails: {
    id: string
    name: string
    code: string
    missingFields: string[]
    completionScore: number
  }[]
}

const REQUIRED_FIELDS = ['name', 'code']
const IMPORTANT_FIELDS = [
  'tax_code',
  'phone', 
  'email',
  'address',
  'province',
  'representative_name'
]
const OPTIONAL_FIELDS = [
  'district',
  'representative_position',
  'is_ticket_delegated'
]

const ALL_FIELDS = [...REQUIRED_FIELDS, ...IMPORTANT_FIELDS, ...OPTIONAL_FIELDS]

function isFieldEmpty(value: any): boolean {
  if (value === undefined || value === null) return true
  if (typeof value === 'string' && value.trim() === '') return true
  return false
}

async function analyzeOperators(): Promise<DataQualityReport> {
  console.log('🔍 Fetching operators from Firebase RTDB...\n')
  
  const snapshot = await db.ref('operators').once('value')
  const data = snapshot.val() || {}
  
  const operators: (OperatorDB & { id: string })[] = Object.entries(data).map(([id, op]) => ({
    ...(op as OperatorDB),
    id
  }))
  
  console.log(`📊 Found ${operators.length} operators\n`)
  
  // Initialize field analysis
  const fieldAnalysis: DataQualityReport['fieldAnalysis'] = {}
  ALL_FIELDS.forEach(field => {
    fieldAnalysis[field] = { filled: 0, empty: 0, fillRate: 0 }
  })
  
  // Analyze each operator
  const operatorDetails: DataQualityReport['operatorDetails'] = []
  let completeOperators = 0
  
  for (const op of operators) {
    const missingFields: string[] = []
    let filledCount = 0
    
    for (const field of ALL_FIELDS) {
      const value = (op as any)[field]
      if (isFieldEmpty(value)) {
        fieldAnalysis[field].empty++
        missingFields.push(field)
      } else {
        fieldAnalysis[field].filled++
        filledCount++
      }
    }
    
    const completionScore = Math.round((filledCount / ALL_FIELDS.length) * 100)
    
    // Only count as complete if all important fields are filled
    const hasAllImportant = IMPORTANT_FIELDS.every(f => !isFieldEmpty((op as any)[f]))
    if (hasAllImportant) completeOperators++
    
    operatorDetails.push({
      id: op.id,
      name: op.name || 'N/A',
      code: op.code || 'N/A',
      missingFields,
      completionScore
    })
  }
  
  // Calculate fill rates
  for (const field of ALL_FIELDS) {
    const total = fieldAnalysis[field].filled + fieldAnalysis[field].empty
    fieldAnalysis[field].fillRate = total > 0 
      ? Math.round((fieldAnalysis[field].filled / total) * 100)
      : 0
  }
  
  // Sort by completion score (worst first)
  operatorDetails.sort((a, b) => a.completionScore - b.completionScore)
  
  return {
    totalOperators: operators.length,
    completeOperators,
    incompleteOperators: operators.length - completeOperators,
    completionRate: Math.round((completeOperators / operators.length) * 100),
    fieldAnalysis,
    operatorDetails
  }
}

function generateReport(report: DataQualityReport): string {
  let output = `# Operator Data Quality Report

Generated: ${new Date().toISOString()}

## Summary

| Metric | Value |
|--------|-------|
| Total Operators | ${report.totalOperators} |
| Complete (all important fields) | ${report.completeOperators} |
| Incomplete | ${report.incompleteOperators} |
| Completion Rate | ${report.completionRate}% |

## Field Analysis

| Field | Filled | Empty | Fill Rate |
|-------|--------|-------|-----------|
`

  for (const [field, stats] of Object.entries(report.fieldAnalysis)) {
    const indicator = stats.fillRate < 50 ? '⚠️' : stats.fillRate < 80 ? '🟡' : '✅'
    output += `| ${indicator} ${field} | ${stats.filled} | ${stats.empty} | ${stats.fillRate}% |\n`
  }

  output += `\n## Operators Needing Attention (sorted by completion)\n\n`
  
  const needsAttention = report.operatorDetails.filter(op => op.completionScore < 80)
  
  if (needsAttention.length === 0) {
    output += `✅ All operators have good data quality!\n`
  } else {
    output += `| Operator | Code | Completion | Missing Fields |\n`
    output += `|----------|------|------------|----------------|\n`
    
    for (const op of needsAttention.slice(0, 20)) {
      const missing = op.missingFields.length > 3 
        ? `${op.missingFields.slice(0, 3).join(', ')}... (+${op.missingFields.length - 3})`
        : op.missingFields.join(', ')
      output += `| ${op.name} | ${op.code} | ${op.completionScore}% | ${missing} |\n`
    }
    
    if (needsAttention.length > 20) {
      output += `\n... and ${needsAttention.length - 20} more operators need attention\n`
    }
  }

  output += `\n## Recommendations

### Immediate Actions
1. **Add validation** - Require important fields when creating new operators
2. **UI improvements** - Hide empty fields or show "Chưa cập nhật" instead of N/A
3. **Data cleanup** - Contact operators to update missing information

### Suggested Field Requirements

**Required (must have):**
- name, code

**Important (should have):**
- tax_code, phone, email, address, province, representative_name

**Optional:**
- district, representative_position, is_ticket_delegated
`

  return output
}

async function main() {
  try {
    const report = await analyzeOperators()
    const markdown = generateReport(report)
    
    // Print to console
    console.log(markdown)
    
    // Save to file
    const outputPath = path.resolve(__dirname, '../docs/operator-data-quality-report.md')
    fs.writeFileSync(outputPath, markdown, 'utf-8')
    console.log(`\n📁 Report saved to: ${outputPath}`)
    
    process.exit(0)
  } catch (error) {
    console.error('❌ Error:', error)
    process.exit(1)
  }
}

main()
</file>

<file path="scripts/capture-pages.js">
const puppeteer = require('C:/Users/USER/.factory/skills/chrome-devtools/scripts/node_modules/puppeteer');
const path = require('path');

const BASE_URL = 'http://localhost:5173';
const OUTPUT_DIR = path.join(__dirname, '../docs/screenshots');

async function capturePages() {
  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: { width: 1920, height: 1080 },
    args: ['--start-maximized']
  });
  
  const page = await browser.newPage();
  
  try {
    // Login
    console.log('Navigating to login...');
    await page.goto(`${BASE_URL}/login`, { waitUntil: 'networkidle2', timeout: 30000 });
    
    console.log('Filling credentials...');
    await page.waitForSelector('#usernameOrEmail', { timeout: 10000 });
    await page.type('#usernameOrEmail', 'admin');
    await page.type('#password', '123456');
    
    console.log('Clicking login...');
    await Promise.all([
      page.click('button[type="submit"]'),
      page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 })
    ]);
    
    console.log('Logged in, current URL:', page.url());
    await new Promise(r => setTimeout(r, 2000));
    
    // Capture Dashboard (Tổng quan)
    console.log('Capturing Tổng quan (Dashboard)...');
    await page.goto(`${BASE_URL}/dashboard`, { waitUntil: 'networkidle2', timeout: 30000 });
    await new Promise(r => setTimeout(r, 3000));
    await page.screenshot({ 
      path: path.join(OUTPUT_DIR, 'dashboard.png'), 
      fullPage: true 
    });
    console.log('Saved dashboard.png');
    
    // Capture Điều độ
    console.log('Capturing Điều độ...');
    await page.goto(`${BASE_URL}/dieu-do`, { waitUntil: 'networkidle2', timeout: 30000 });
    await new Promise(r => setTimeout(r, 3000));
    await page.screenshot({ 
      path: path.join(OUTPUT_DIR, 'dieu-do.png'), 
      fullPage: true 
    });
    console.log('Saved dieu-do.png');
    
    // Capture Thanh toán
    console.log('Capturing Thanh toán...');
    await page.goto(`${BASE_URL}/thanh-toan`, { waitUntil: 'networkidle2', timeout: 30000 });
    await new Promise(r => setTimeout(r, 3000));
    await page.screenshot({ 
      path: path.join(OUTPUT_DIR, 'thanh-toan.png'), 
      fullPage: true 
    });
    console.log('Saved thanh-toan.png');
    
    console.log('All pages captured successfully!');
    
  } catch (error) {
    console.error('Error:', error.message);
  } finally {
    await browser.close();
  }
}

capturePages();
</file>

<file path="scripts/firebase-workarounds/firestore-query-helper.js">
#!/usr/bin/env node
/**
 * Firestore Query Helper
 * Workaround for broken MCP tool: firestore_query_collection
 *
 * Root Cause: MCP plugin sends read_time timestamp in the future (clock sync issue)
 * Solution: Use REST API without read_time parameter
 *
 * Usage:
 *   node firestore-query-helper.js list-collections
 *   node firestore-query-helper.js query <collection> [--where field=value] [--limit N]
 *   node firestore-query-helper.js get <document-path>
 */

const https = require('https');
const { execSync } = require('child_process');

// Configuration
const CONFIG = {
  projectId: 'benxe-management-20251218',
  databaseId: '(default)'
};

function getAccessToken() {
  try {
    return execSync('gcloud auth print-access-token', { encoding: 'utf8' }).trim();
  } catch (error) {
    console.error('Error getting access token. Run: gcloud auth login');
    process.exit(1);
  }
}

async function firestoreRequest(method, path, body = null) {
  const token = getAccessToken();

  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'firestore.googleapis.com',
      path: `/v1/projects/${CONFIG.projectId}/databases/${CONFIG.databaseId}${path}`,
      method,
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(data));
          } catch {
            resolve(data);
          }
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', reject);

    if (body) {
      req.write(JSON.stringify(body));
    }

    req.end();
  });
}

async function listCollections() {
  console.log('Listing root collections...');
  const result = await firestoreRequest('POST', '/documents:listCollectionIds', {});

  if (result.collectionIds && result.collectionIds.length > 0) {
    console.log('\nCollections:');
    result.collectionIds.forEach(id => console.log(`  - ${id}`));
  } else {
    console.log('No collections found.');
  }

  return result;
}

async function queryCollection(collectionPath, filters = [], limit = 10, orderBy = null) {
  console.log(`Querying collection: ${collectionPath}`);

  // Build structured query WITHOUT read_time (this is the fix!)
  const structuredQuery = {
    from: [{ collectionId: collectionPath.split('/').pop() }],
    limit: limit
  };

  // Add parent path for subcollections
  const parentPath = collectionPath.includes('/')
    ? `/documents/${collectionPath.split('/').slice(0, -1).join('/')}`
    : '/documents';

  // Add filters if provided
  if (filters.length > 0) {
    const whereFilters = filters.map(f => {
      const [field, op, value] = parseFilter(f);
      return {
        fieldFilter: {
          field: { fieldPath: field },
          op: op,
          value: convertValue(value)
        }
      };
    });

    if (whereFilters.length === 1) {
      structuredQuery.where = whereFilters[0];
    } else {
      structuredQuery.where = {
        compositeFilter: {
          op: 'AND',
          filters: whereFilters
        }
      };
    }
  }

  // Add orderBy if provided
  if (orderBy) {
    const [field, direction] = orderBy.split(':');
    structuredQuery.orderBy = [{
      field: { fieldPath: field },
      direction: direction?.toUpperCase() === 'DESC' ? 'DESCENDING' : 'ASCENDING'
    }];
  }

  const result = await firestoreRequest('POST', `${parentPath}:runQuery`, { structuredQuery });

  if (Array.isArray(result)) {
    const docs = result
      .filter(r => r.document)
      .map(r => ({
        id: r.document.name.split('/').pop(),
        path: r.document.name,
        data: parseFirestoreDocument(r.document.fields)
      }));

    console.log(`\nFound ${docs.length} documents:\n`);
    docs.forEach(doc => {
      console.log(`ID: ${doc.id}`);
      console.log(JSON.stringify(doc.data, null, 2));
      console.log('---');
    });

    return docs;
  }

  return result;
}

async function getDocument(documentPath) {
  console.log(`Getting document: ${documentPath}`);
  const result = await firestoreRequest('GET', `/documents/${documentPath}`);

  if (result.fields) {
    const data = parseFirestoreDocument(result.fields);
    console.log(JSON.stringify(data, null, 2));
    return data;
  }

  return result;
}

// Helper: Parse filter string like "name=John" or "age>18"
function parseFilter(filterStr) {
  const operators = ['>=', '<=', '!=', '==', '=', '>', '<'];

  for (const op of operators) {
    if (filterStr.includes(op)) {
      const [field, value] = filterStr.split(op);
      const firestoreOp = {
        '>=': 'GREATER_THAN_OR_EQUAL',
        '<=': 'LESS_THAN_OR_EQUAL',
        '>': 'GREATER_THAN',
        '<': 'LESS_THAN',
        '!=': 'NOT_EQUAL',
        '==': 'EQUAL',
        '=': 'EQUAL'
      }[op];
      return [field.trim(), firestoreOp, value.trim()];
    }
  }

  throw new Error(`Invalid filter format: ${filterStr}. Use format: field=value`);
}

// Helper: Convert JS value to Firestore value format
function convertValue(value) {
  // Try to parse as number
  if (!isNaN(value) && value !== '') {
    const num = Number(value);
    if (Number.isInteger(num)) {
      return { integerValue: num.toString() };
    }
    return { doubleValue: num };
  }

  // Boolean
  if (value.toLowerCase() === 'true') return { booleanValue: true };
  if (value.toLowerCase() === 'false') return { booleanValue: false };

  // Null
  if (value.toLowerCase() === 'null') return { nullValue: null };

  // Default to string
  return { stringValue: value };
}

// Helper: Parse Firestore document fields to plain JS object
function parseFirestoreDocument(fields) {
  const result = {};

  for (const [key, value] of Object.entries(fields)) {
    result[key] = parseFirestoreValue(value);
  }

  return result;
}

function parseFirestoreValue(value) {
  if (value.stringValue !== undefined) return value.stringValue;
  if (value.integerValue !== undefined) return parseInt(value.integerValue);
  if (value.doubleValue !== undefined) return value.doubleValue;
  if (value.booleanValue !== undefined) return value.booleanValue;
  if (value.nullValue !== undefined) return null;
  if (value.timestampValue !== undefined) return new Date(value.timestampValue);
  if (value.arrayValue !== undefined) {
    return (value.arrayValue.values || []).map(parseFirestoreValue);
  }
  if (value.mapValue !== undefined) {
    return parseFirestoreDocument(value.mapValue.fields || {});
  }
  if (value.geoPointValue !== undefined) {
    return { lat: value.geoPointValue.latitude, lng: value.geoPointValue.longitude };
  }
  if (value.referenceValue !== undefined) return value.referenceValue;

  return value;
}

// CLI Handler
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  if (!command) {
    console.log(`
Firestore Query Helper
======================
Workaround for broken MCP tool (read_time bug)

Commands:
  list-collections                    - List all root collections
  query <collection> [options]        - Query a collection
  get <document-path>                 - Get a single document

Query Options:
  --where <field>=<value>             - Add filter (can use multiple)
  --where <field>><value>             - Greater than filter
  --limit <N>                         - Limit results (default: 10)
  --order <field>[:asc|:desc]         - Order by field

Examples:
  node firestore-query-helper.js list-collections
  node firestore-query-helper.js query users --limit 5
  node firestore-query-helper.js query users --where role=admin
  node firestore-query-helper.js query orders --where status=pending --order createdAt:desc
  node firestore-query-helper.js get users/abc123
`);
    return;
  }

  try {
    switch (command.toLowerCase()) {
      case 'list-collections':
        await listCollections();
        break;

      case 'query': {
        const collection = args[1];
        if (!collection) throw new Error('Collection name required');

        const filters = [];
        let limit = 10;
        let orderBy = null;

        for (let i = 2; i < args.length; i++) {
          if (args[i] === '--where' && args[i + 1]) {
            filters.push(args[++i]);
          } else if (args[i] === '--limit' && args[i + 1]) {
            limit = parseInt(args[++i]);
          } else if (args[i] === '--order' && args[i + 1]) {
            orderBy = args[++i];
          }
        }

        await queryCollection(collection, filters, limit, orderBy);
        break;
      }

      case 'get': {
        const docPath = args[1];
        if (!docPath) throw new Error('Document path required');
        await getDocument(docPath);
        break;
      }

      default:
        console.error(`Unknown command: ${command}`);
        process.exit(1);
    }
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="scripts/firebase-workarounds/rtdb-helper.js">
#!/usr/bin/env node
/**
 * Firebase Realtime Database Helper
 * Workaround for broken MCP tools: realtimedatabase_get_data, realtimedatabase_set_data
 *
 * Root Cause: MCP plugin uses wrong URL (missing region)
 * Correct URL: https://<project>-default-rtdb.<region>.firebasedatabase.app
 *
 * Usage:
 *   node rtdb-helper.js get /path
 *   node rtdb-helper.js set /path '{"key":"value"}'
 *   node rtdb-helper.js delete /path
 */

const https = require('https');
const { execSync } = require('child_process');

// Configuration - Update these for your project
const CONFIG = {
  projectId: 'benxe-management-20251218',
  databaseInstance: 'benxe-management-20251218-default-rtdb',
  region: 'asia-southeast1' // CRITICAL: Must match your RTDB region
};

function getAccessToken() {
  try {
    return execSync('gcloud auth print-access-token', { encoding: 'utf8' }).trim();
  } catch (error) {
    console.error('Error getting access token. Make sure gcloud is installed and authenticated.');
    console.error('Run: gcloud auth login');
    process.exit(1);
  }
}

function getDatabaseUrl() {
  return `${CONFIG.databaseInstance}.${CONFIG.region}.firebasedatabase.app`;
}

async function rtdbRequest(method, path, data = null) {
  const token = getAccessToken();
  const hostname = getDatabaseUrl();

  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }

  return new Promise((resolve, reject) => {
    const options = {
      hostname,
      path: `${path}.json`,
      method,
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      res.on('data', chunk => responseData += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(responseData));
          } catch {
            resolve(responseData);
          }
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${responseData}`));
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(JSON.stringify(data));
    }

    req.end();
  });
}

async function getData(path) {
  console.log(`Getting data from: ${path}`);
  const result = await rtdbRequest('GET', path);
  console.log(JSON.stringify(result, null, 2));
  return result;
}

async function setData(path, data) {
  console.log(`Setting data at: ${path}`);
  const result = await rtdbRequest('PUT', path, data);
  console.log('Success:', JSON.stringify(result, null, 2));
  return result;
}

async function updateData(path, data) {
  console.log(`Updating data at: ${path}`);
  const result = await rtdbRequest('PATCH', path, data);
  console.log('Success:', JSON.stringify(result, null, 2));
  return result;
}

async function deleteData(path) {
  console.log(`Deleting data at: ${path}`);
  const result = await rtdbRequest('DELETE', path);
  console.log('Deleted successfully');
  return result;
}

async function getRules() {
  console.log('Getting RTDB security rules...');
  const token = getAccessToken();
  const hostname = getDatabaseUrl();

  return new Promise((resolve, reject) => {
    const options = {
      hostname,
      path: '/.settings/rules.json',
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          console.log(data);
          resolve(data);
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

// CLI Handler
async function main() {
  const [,, command, path, dataArg] = process.argv;

  if (!command) {
    console.log(`
Firebase Realtime Database Helper
==================================
Workaround for broken MCP tools

Commands:
  get <path>              - Get data at path
  set <path> <json>       - Set data at path (overwrites)
  update <path> <json>    - Update data at path (merges)
  delete <path>           - Delete data at path
  rules                   - Get security rules
  info                    - Show configuration

Examples:
  node rtdb-helper.js get /users
  node rtdb-helper.js set /test '{"hello":"world"}'
  node rtdb-helper.js update /users/123 '{"name":"John"}'
  node rtdb-helper.js delete /test
  node rtdb-helper.js rules
`);
    return;
  }

  try {
    switch (command.toLowerCase()) {
      case 'get':
        if (!path) throw new Error('Path required');
        await getData(path);
        break;

      case 'set':
        if (!path || !dataArg) throw new Error('Path and JSON data required');
        await setData(path, JSON.parse(dataArg));
        break;

      case 'update':
        if (!path || !dataArg) throw new Error('Path and JSON data required');
        await updateData(path, JSON.parse(dataArg));
        break;

      case 'delete':
        if (!path) throw new Error('Path required');
        await deleteData(path);
        break;

      case 'rules':
        await getRules();
        break;

      case 'info':
        console.log('Configuration:');
        console.log(`  Project: ${CONFIG.projectId}`);
        console.log(`  Database: ${CONFIG.databaseInstance}`);
        console.log(`  Region: ${CONFIG.region}`);
        console.log(`  URL: https://${getDatabaseUrl()}`);
        break;

      default:
        console.error(`Unknown command: ${command}`);
        process.exit(1);
    }
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="scripts/screenshot-dialog.js">
/**
 * Screenshot Dialog Script
 * 
 * Purpose: Automatically login and capture screenshots of CapPhepDialog
 * 
 * TROUBLESHOOTING TIPS:
 * 
 * 1. RATE LIMITING / LOGIN BLOCKED:
 *    - If login fails repeatedly, the server may have rate limiting enabled
 *    - Wait 5-10 minutes before trying again
 *    - Or restart the backend server to reset rate limit
 *    - Script now includes delays between attempts to avoid this
 * 
 * 2. LOGIN CREDENTIALS:
 *    - Default: admin / 123456
 *    - If credentials changed, update in the script below
 * 
 * 3. SERVER NOT RUNNING:
 *    - Ensure both frontend (localhost:5173) and backend are running
 *    - Check: npm run dev in client folder
 *    - Check: npm run dev in server folder
 * 
 * 4. NAVIGATION TIMEOUT:
 *    - Increase timeout values if network is slow
 *    - Current: 30000ms for page load, 8000ms for login redirect
 * 
 * 5. ELEMENT NOT FOUND:
 *    - UI selectors may have changed
 *    - Check browser DevTools for current selectors
 *    - Update selectors in script accordingly
 * 
 * 6. PUPPETEER ISSUES:
 *    - Ensure puppeteer is installed in chrome-devtools skill
 *    - Path: C:/Users/USER/.factory/skills/chrome-devtools/scripts/node_modules/puppeteer
 * 
 * Usage: node scripts/screenshot-dialog.js
 */

import puppeteer from 'file:///C:/Users/USER/.factory/skills/chrome-devtools/scripts/node_modules/puppeteer/lib/esm/puppeteer/puppeteer.js';

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Configuration - Edit these if needed
const CONFIG = {
  baseUrl: 'http://localhost:5173',
  credentials: {
    username: 'admin',
    password: '123456'
  },
  timeouts: {
    pageLoad: 30000,
    loginRedirect: 8000,
    elementWait: 10000,
    rateLimitDelay: 3000,  // Delay before login to avoid rate limiting
    betweenActions: 500    // Delay between form actions
  },
  outputDir: 'E:/Github_Repos/Freelance_upcode/Quanlybenxe/docs/screenshots'
};

async function main() {
  const browser = await puppeteer.launch({ 
    headless: false,
    defaultViewport: { width: 1920, height: 1080 }
  });
  
  const page = await browser.newPage();
  
  try {
    // Check if already logged in by going directly to dieu-do
    console.log('Checking if already logged in...');
    await page.goto(`${CONFIG.baseUrl}/dieu-do`, { waitUntil: 'networkidle2', timeout: CONFIG.timeouts.pageLoad });
    await sleep(2000);
    
    // If redirected to login, need to authenticate
    if (page.url().includes('login')) {
      console.log('Not logged in, waiting before login attempt (to avoid rate limit)...');
      await sleep(CONFIG.timeouts.rateLimitDelay);
      
      // Fill login form
      console.log(`Filling login form with username: ${CONFIG.credentials.username}...`);
      await page.waitForSelector('#usernameOrEmail', { timeout: CONFIG.timeouts.elementWait });
      
      // Clear any existing values first
      await page.click('#usernameOrEmail', { clickCount: 3 });
      await page.keyboard.type(CONFIG.credentials.username, { delay: 100 });
      
      await sleep(CONFIG.timeouts.betweenActions);
      
      await page.click('#password', { clickCount: 3 });
      await page.keyboard.type(CONFIG.credentials.password, { delay: 100 });
      
      await sleep(1000);
      
      // Click login button
      console.log('Clicking login...');
      await page.click('button[type="submit"]');
      
      // Wait longer for redirect (in case of rate limiting delay)
      await sleep(CONFIG.timeouts.loginRedirect);
      console.log('Current URL after login:', page.url());
      
      // If still on login page, check for errors
      if (page.url().includes('login')) {
        console.log('');
        console.log('⚠️  LOGIN FAILED - Possible causes:');
        console.log('   1. Rate limiting - Wait 5-10 minutes and try again');
        console.log('   2. Wrong credentials - Check CONFIG.credentials');
        console.log('   3. Backend not running - Start server with npm run dev');
        console.log('');
        
        const errorMsg = await page.evaluate(() => {
          const err = document.querySelector('[class*="error"], [class*="alert"], [class*="toast"], .text-red-500, .text-rose-500');
          return err ? err.textContent : 'No visible error message';
        });
        console.log('Error/Message from page:', errorMsg);
        
        // Take screenshot of login page to see what's happening
        await page.screenshot({ 
          path: `${CONFIG.outputDir}/login-error.png`,
          fullPage: true 
        });
        console.log('Saved login page screenshot to login-error.png');
        
        // Exit early since we can't proceed without login
        console.log('\nExiting due to login failure. Fix the issue and try again.');
        await browser.close();
        return;
      }
    } else {
      console.log('Already logged in!');
    }
    
    // Navigate to dieu-do page
    console.log('Navigating to dieu-do...');
    await page.goto(`${CONFIG.baseUrl}/dieu-do`, { waitUntil: 'networkidle2' });
    await sleep(5000); // Wait longer for data to load
    
    // Take screenshot of the page
    console.log('Taking page screenshot...');
    await page.screenshot({ 
      path: `${CONFIG.outputDir}/dieu-do-page.png`,
      fullPage: false 
    });
    
    // Click on the green "Cấp phép" button (emerald/green colored button on vehicle card)
    console.log('Looking for Cấp phép button (green/emerald)...');
    
    // The cấp phép button should be the emerald/green button on the card
    const clicked = await page.evaluate(() => {
      // Find emerald/green buttons (cấp phép) - they have bg-emerald class
      const emeraldButtons = document.querySelectorAll('button[class*="bg-emerald"], button[class*="bg-green"]');
      if (emeraldButtons.length > 0) {
        emeraldButtons[0].click();
        return 'emerald button clicked';
      }
      
      // Alternative: find by title or aria-label
      const buttons = document.querySelectorAll('button');
      for (const btn of buttons) {
        const title = btn.getAttribute('title')?.toLowerCase() || '';
        const ariaLabel = btn.getAttribute('aria-label')?.toLowerCase() || '';
        if (title.includes('cấp phép') || title.includes('permit') || ariaLabel.includes('cấp phép')) {
          btn.click();
          return 'titled button clicked';
        }
      }
      
      return false;
    });
    
    console.log('Click result:', clicked);
    
    if (clicked) {
      console.log('Waiting for dialog...');
      await sleep(5000); // Wait longer for dialog to fully render
      
      // Take screenshot of dialog - full page
      console.log('Taking dialog screenshot (full page)...');
      await page.screenshot({ 
        path: `${CONFIG.outputDir}/cap-phep-dialog.png`,
        fullPage: true 
      });
      
      // Also scroll down and take another screenshot
      console.log('Scrolling down...');
      await page.evaluate(() => {
        const dialog = document.querySelector('[role="dialog"]') || document.querySelector('.fixed.inset-0');
        if (dialog) {
          dialog.scrollTop = dialog.scrollHeight;
        }
        window.scrollTo(0, document.body.scrollHeight);
      });
      await sleep(1000);
      
      console.log('Taking scrolled screenshot...');
      await page.screenshot({ 
        path: `${CONFIG.outputDir}/cap-phep-dialog-scrolled.png`,
        fullPage: true 
      });
    } else {
      console.log('No cấp phép button found');
    }
    
    console.log('Done!');
    
  } catch (error) {
    console.error('Error:', error.message);
  } finally {
    await browser.close();
  }
}

main();
</file>

<file path="scripts/verify-firebase-security.sh">
#!/bin/bash

# Firebase Security Verification Script
# Run this AFTER deploying firebase-rules.json to verify security

FIREBASE_URL="https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app"
BACKEND_LOCAL="http://localhost:3000/api"
BACKEND_PROD="https://ben-xe-backend.onrender.com/api"

echo "================================================"
echo "Firebase Security Verification Script"
echo "================================================"
echo ""

# Test 1: Direct Firebase access should be DENIED
echo "[TEST 1] Testing direct Firebase access (should be DENIED)..."
echo "GET $FIREBASE_URL/vehicles.json"
RESPONSE=$(curl -s "$FIREBASE_URL/vehicles.json")
echo "Response: $RESPONSE"

if echo "$RESPONSE" | grep -q "Permission denied"; then
    echo "✅ PASS: Firebase correctly denies public access"
else
    echo "❌ FAIL: Firebase is still publicly accessible!"
    echo "   Expected: Permission denied"
    echo "   Got: $RESPONSE"
fi
echo ""

# Test 2: Test multiple collections
echo "[TEST 2] Testing other collections..."
for COLLECTION in "drivers" "operators" "routes" "dispatch_records"; do
    RESPONSE=$(curl -s "$FIREBASE_URL/$COLLECTION.json")
    if echo "$RESPONSE" | grep -q "Permission denied"; then
        echo "✅ $COLLECTION: Access denied"
    else
        echo "❌ $COLLECTION: Still accessible!"
    fi
done
echo ""

# Test 3: Backend local should still work
echo "[TEST 3] Testing Backend (local)..."
echo "GET $BACKEND_LOCAL/vehicles"
RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/backend_response.txt "$BACKEND_LOCAL/vehicles" 2>/dev/null)
HTTP_CODE="${RESPONSE: -3}"
BODY=$(cat /tmp/backend_response.txt 2>/dev/null)

if [ "$HTTP_CODE" == "200" ]; then
    echo "✅ PASS: Backend (local) works - HTTP $HTTP_CODE"
elif [ "$HTTP_CODE" == "401" ]; then
    echo "⚠️  Backend requires auth (expected) - HTTP $HTTP_CODE"
elif [ "$HTTP_CODE" == "000" ]; then
    echo "⚠️  Backend not running locally (skip this test)"
else
    echo "❌ FAIL: Backend error - HTTP $HTTP_CODE"
fi
echo ""

# Test 4: Backend production should still work
echo "[TEST 4] Testing Backend (production)..."
echo "GET $BACKEND_PROD/vehicles"
RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/backend_prod_response.txt "$BACKEND_PROD/vehicles" 2>/dev/null)
HTTP_CODE="${RESPONSE: -3}"

if [ "$HTTP_CODE" == "200" ]; then
    echo "✅ PASS: Backend (production) works - HTTP $HTTP_CODE"
elif [ "$HTTP_CODE" == "401" ]; then
    echo "⚠️  Backend requires auth (expected) - HTTP $HTTP_CODE"
else
    echo "❌ FAIL: Backend (production) error - HTTP $HTTP_CODE"
fi
echo ""

echo "================================================"
echo "Verification Complete"
echo "================================================"
echo ""
echo "If all tests pass:"
echo "  ✅ Firebase is locked (no public access)"
echo "  ✅ Backend still works (Admin SDK bypasses rules)"
echo ""
echo "If Firebase tests fail:"
echo "  1. Go to Firebase Console"
echo "  2. Realtime Database > Rules"
echo "  3. Replace with: {\"rules\": {\".read\": false, \".write\": false}}"
echo "  4. Click Publish"
echo "  5. Run this script again"
</file>

<file path="server/.firebaserc">
{
  "projects": {
    "default": "benxe-management-20251218"
  }
}
</file>

<file path="server/firebase-rules.json">
{
  "rules": {
    ".read": false,
    ".write": false
  }
}
</file>

<file path="server/firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "vehicle_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "driver_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "route_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "vehicle_operator_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "route_destination_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "vehicle_operator_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "route_destination_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "vehicles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operator_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "vehicles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "plate_number", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "drivers",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operator_id", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "drivers",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "full_name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "routes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "origin_id", "order": "ASCENDING" },
        { "fieldPath": "route_name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "routes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "destination_id", "order": "ASCENDING" },
        { "fieldPath": "route_name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "routes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "route_name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "schedules",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "route_id", "order": "ASCENDING" },
        { "fieldPath": "departure_time", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "schedules",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "vehicle_id", "order": "ASCENDING" },
        { "fieldPath": "departure_time", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "schedules",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "driver_id", "order": "ASCENDING" },
        { "fieldPath": "departure_time", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "schedules",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "departure_time", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "operators",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "locations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "route_stops",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "route_id", "order": "ASCENDING" },
        { "fieldPath": "stop_order", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "driver_operators",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "driver_id", "order": "ASCENDING" },
        { "fieldPath": "is_primary", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "driver_operators",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operator_id", "order": "ASCENDING" },
        { "fieldPath": "is_primary", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "created_at", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "is_active", "order": "ASCENDING" },
        { "fieldPath": "full_name", "order": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "dispatch_records",
      "fieldPath": "created_at",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" },
        { "order": "DESCENDING", "queryScope": "COLLECTION" }
      ]
    },
    {
      "collectionGroup": "dispatch_records",
      "fieldPath": "status",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" },
        { "arrayConfig": "CONTAINS", "queryScope": "COLLECTION" }
      ]
    },
    {
      "collectionGroup": "vehicles",
      "fieldPath": "plate_number",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" }
      ]
    },
    {
      "collectionGroup": "drivers",
      "fieldPath": "full_name",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" }
      ]
    },
    {
      "collectionGroup": "routes",
      "fieldPath": "route_name",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" }
      ]
    }
  ]
}
</file>

<file path="server/firestore.rules">
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Deny all access by default - all access goes through Cloud Functions API
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
</file>

<file path="server/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  extensionsToTreatAsEsm: ['.ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/__tests__/**',
    '!src/index.ts',
    '!src/scripts/**',
  ],
  coverageThreshold: {
    global: {
      branches: 50,
      functions: 50,
      lines: 50,
      statements: 50,
    },
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};
</file>

<file path="server/README.md">
# Backend API - Hệ thống Quản lý Bến Xe

Backend API sử dụng **Node.js + Express.js + Firebase Realtime Database**.

## Cài đặt nhanh

1. Cài đặt dependencies:
```bash
npm install
```

2. Tạo file `.env`:
```env
PORT=3000
NODE_ENV=development
FIREBASE_DATABASE_URL=https://webbenxe-default-rtdb.asia-southeast1.firebasedatabase.app/
JWT_SECRET=your_very_secure_random_secret_key_here
JWT_EXPIRES_IN=7d
CORS_ORIGIN=http://localhost:5173
```

3. Seed dữ liệu mẫu:
```bash
npm run seed
```

4. Chạy server:
```bash
npm run dev
```

## Thông tin đăng nhập mặc định

- Username: `admin` | Password: `123456` (Admin)
- Username: `dieudo` | Password: `123456` (Dispatcher)
- Username: `ketoan` | Password: `123456` (Accountant)

## API Endpoints

### Authentication
- `POST /api/auth/login` - Đăng nhập
- `GET /api/auth/me` - Lấy thông tin user hiện tại

### Drivers
- `GET /api/drivers` - Lấy danh sách lái xe
- `GET /api/drivers/:id` - Lấy thông tin lái xe
- `POST /api/drivers` - Tạo lái xe mới
- `PUT /api/drivers/:id` - Cập nhật lái xe
- `DELETE /api/drivers/:id` - Xóa lái xe

### Vehicles
- `GET /api/vehicles` - Lấy danh sách xe
- `GET /api/vehicles/:id` - Lấy thông tin xe
- `POST /api/vehicles` - Tạo xe mới
- `PUT /api/vehicles/:id` - Cập nhật xe
- `DELETE /api/vehicles/:id` - Xóa xe

### Dispatch
- `GET /api/dispatch` - Lấy danh sách điều độ
- `GET /api/dispatch/:id` - Lấy thông tin điều độ
- `POST /api/dispatch` - Tạo bản ghi điều độ
- `PATCH /api/dispatch/:id/status` - Cập nhật trạng thái
- `POST /api/dispatch/:id/permit` - Cấp phép
- `POST /api/dispatch/:id/payment` - Xử lý thanh toán
- `POST /api/dispatch/:id/depart` - Ghi nhận xuất bến

### Reports
- `GET /api/reports/invoices` - Báo cáo hóa đơn
- `GET /api/reports/vehicle-logs` - Nhật ký xe
- `GET /api/reports/station-activity` - Hoạt động bến
- `GET /api/reports/invalid-vehicles` - Xe không hợp lệ
- `GET /api/reports/revenue` - Báo cáo doanh thu
- `GET /api/reports/export/:type` - Xuất Excel (chưa implement)

## Database

Firebase Realtime Database tự động tạo collections khi sử dụng API:
- `users` - Người dùng
- `operators` - Đơn vị vận tải
- `drivers` - Lái xe
- `vehicles` - Xe
- `vehicle_documents` - Giấy tờ xe
- `dispatch_records` - Bản ghi điều độ
- `routes` - Tuyến đường
- `locations` - Bến xe
- `shifts` - Ca trực
- `services` - Dịch vụ
- `invoices` - Hóa đơn

## Authentication

API sử dụng JWT để xác thực. Sau khi đăng nhập thành công, client cần gửi token trong header:
```
Authorization: Bearer <token>
```

Tất cả các endpoint (trừ `/api/auth/login`) đều yêu cầu authentication.

## Scripts

- `npm run dev` - Development mode với hot reload
- `npm run build` - Build cho production
- `npm start` - Chạy production build
- `npm run seed` - Seed dữ liệu mẫu vào Firebase
- `npm run create-admin [user] [pass] [name]` - Tạo admin user

## Lưu ý

- Database được tạo tự động, không cần migration
- JWT_SECRET nên là chuỗi mạnh trong production (tạo bằng: `openssl rand -base64 32`)
- CORS_ORIGIN phải khớp với URL frontend
- Xem file `SETUP.md` để biết chi tiết
</file>

<file path="server/scripts/analyze-operator-data.cjs">
/**
 * Script: Analyze Operator Data Quality
 * 
 * Checks all operators for missing/empty fields and generates a report
 * 
 * Usage: node scripts/analyze-operator-data.js
 */

const { initializeApp, cert, getApps } = require('firebase-admin/app')
const { getDatabase } = require('firebase-admin/database')
const path = require('path')
const fs = require('fs')

// Initialize Firebase Admin
const serviceAccountPath = path.resolve(__dirname, '../firebase-service-account.json')

if (getApps().length === 0) {
  initializeApp({
    credential: cert(serviceAccountPath),
    databaseURL: 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'
  })
}

const db = getDatabase()

const REQUIRED_FIELDS = ['name', 'code']
const IMPORTANT_FIELDS = [
  'tax_code',
  'phone', 
  'email',
  'address',
  'province',
  'representative_name'
]
const OPTIONAL_FIELDS = [
  'district',
  'representative_position',
  'is_ticket_delegated'
]

const ALL_FIELDS = [...REQUIRED_FIELDS, ...IMPORTANT_FIELDS, ...OPTIONAL_FIELDS]

function isFieldEmpty(value) {
  if (value === undefined || value === null) return true
  if (typeof value === 'string' && value.trim() === '') return true
  return false
}

async function analyzeOperators() {
  console.log('🔍 Fetching operators from Firebase RTDB...\n')
  
  const snapshot = await db.ref('operators').once('value')
  const data = snapshot.val() || {}
  
  const operators = Object.entries(data).map(([id, op]) => ({
    ...op,
    id
  }))
  
  console.log(`📊 Found ${operators.length} operators\n`)
  
  // Initialize field analysis
  const fieldAnalysis = {}
  ALL_FIELDS.forEach(field => {
    fieldAnalysis[field] = { filled: 0, empty: 0, fillRate: 0 }
  })
  
  // Analyze each operator
  const operatorDetails = []
  let completeOperators = 0
  
  for (const op of operators) {
    const missingFields = []
    let filledCount = 0
    
    for (const field of ALL_FIELDS) {
      const value = op[field]
      if (isFieldEmpty(value)) {
        fieldAnalysis[field].empty++
        missingFields.push(field)
      } else {
        fieldAnalysis[field].filled++
        filledCount++
      }
    }
    
    const completionScore = Math.round((filledCount / ALL_FIELDS.length) * 100)
    
    // Only count as complete if all important fields are filled
    const hasAllImportant = IMPORTANT_FIELDS.every(f => !isFieldEmpty(op[f]))
    if (hasAllImportant) completeOperators++
    
    operatorDetails.push({
      id: op.id,
      name: op.name || 'N/A',
      code: op.code || 'N/A',
      missingFields,
      completionScore
    })
  }
  
  // Calculate fill rates
  for (const field of ALL_FIELDS) {
    const total = fieldAnalysis[field].filled + fieldAnalysis[field].empty
    fieldAnalysis[field].fillRate = total > 0 
      ? Math.round((fieldAnalysis[field].filled / total) * 100)
      : 0
  }
  
  // Sort by completion score (worst first)
  operatorDetails.sort((a, b) => a.completionScore - b.completionScore)
  
  return {
    totalOperators: operators.length,
    completeOperators,
    incompleteOperators: operators.length - completeOperators,
    completionRate: operators.length > 0 ? Math.round((completeOperators / operators.length) * 100) : 0,
    fieldAnalysis,
    operatorDetails
  }
}

function generateReport(report) {
  let output = `# Operator Data Quality Report

Generated: ${new Date().toISOString()}

## Summary

| Metric | Value |
|--------|-------|
| Total Operators | ${report.totalOperators} |
| Complete (all important fields) | ${report.completeOperators} |
| Incomplete | ${report.incompleteOperators} |
| Completion Rate | ${report.completionRate}% |

## Field Analysis

| Field | Filled | Empty | Fill Rate |
|-------|--------|-------|-----------|
`

  for (const [field, stats] of Object.entries(report.fieldAnalysis)) {
    const indicator = stats.fillRate < 50 ? '⚠️' : stats.fillRate < 80 ? '🟡' : '✅'
    output += `| ${indicator} ${field} | ${stats.filled} | ${stats.empty} | ${stats.fillRate}% |\n`
  }

  output += `\n## Operators Needing Attention (sorted by completion)\n\n`
  
  const needsAttention = report.operatorDetails.filter(op => op.completionScore < 80)
  
  if (needsAttention.length === 0) {
    output += `✅ All operators have good data quality!\n`
  } else {
    output += `| Operator | Code | Completion | Missing Fields |\n`
    output += `|----------|------|------------|----------------|\n`
    
    for (const op of needsAttention.slice(0, 20)) {
      const missing = op.missingFields.length > 3 
        ? `${op.missingFields.slice(0, 3).join(', ')}... (+${op.missingFields.length - 3})`
        : op.missingFields.join(', ')
      output += `| ${op.name} | ${op.code} | ${op.completionScore}% | ${missing} |\n`
    }
    
    if (needsAttention.length > 20) {
      output += `\n... and ${needsAttention.length - 20} more operators need attention\n`
    }
  }

  output += `\n## Recommendations

### Immediate Actions
1. **Add validation** - Require important fields when creating new operators
2. **UI improvements** - Hide empty fields or show "Chưa cập nhật" instead of N/A
3. **Data cleanup** - Contact operators to update missing information

### Suggested Field Requirements

**Required (must have):**
- name, code

**Important (should have):**
- tax_code, phone, email, address, province, representative_name

**Optional:**
- district, representative_position, is_ticket_delegated
`

  return output
}

async function main() {
  try {
    const report = await analyzeOperators()
    const markdown = generateReport(report)
    
    // Print to console
    console.log(markdown)
    
    // Save to file
    const outputPath = path.resolve(__dirname, '../../docs/operator-data-quality-report.md')
    fs.writeFileSync(outputPath, markdown, 'utf-8')
    console.log(`\n📁 Report saved to: ${outputPath}`)
    
    process.exit(0)
  } catch (error) {
    console.error('❌ Error:', error)
    process.exit(1)
  }
}

main()
</file>

<file path="server/src/__tests__/fixtures/dispatch.fixtures.ts">
/**
 * Dispatch Test Fixtures
 * Sample data for dispatch module testing
 */

import { DISPATCH_STATUS } from '../../modules/dispatch/dispatch-validation.js';

export const mockDispatchDBRecord = {
  id: 'dispatch-1',
  vehicle_id: 'vehicle-1',
  driver_id: 'driver-1',
  route_id: 'route-1',
  schedule_id: null,
  current_status: DISPATCH_STATUS.ENTERED,
  entry_time: '2024-12-18T08:00:00Z',
  entry_by: 'user-1',
  entry_shift_id: 'shift-1',
  vehicle_plate_number: '51A-12345',
  vehicle_seat_capacity: 45,
  vehicle_type_name: 'Ghế ngồi',
  driver_full_name: 'Nguyễn Văn A',
  route_name: 'Sài Gòn - Vũng Tàu',
  operator_id: 'operator-1',
  operator_name: 'Nhà Xe ABC',
  operator_code: 'ABC',
  created_at: '2024-12-18T08:00:00Z',
  updated_at: '2024-12-18T08:00:00Z',
};

export const mockDispatchRecord = {
  id: 'dispatch-1',
  vehicleId: 'vehicle-1',
  driverId: 'driver-1',
  routeId: 'route-1',
  scheduleId: null,
  currentStatus: DISPATCH_STATUS.ENTERED,
  entryTime: '2024-12-18T08:00:00Z',
  entryBy: 'user-1',
  entryShiftId: 'shift-1',
  vehiclePlateNumber: '51A-12345',
  vehicleSeatCapacity: 45,
  vehicleTypeName: 'Ghế ngồi',
  driverName: 'Nguyễn Văn A',
  routeName: 'Sài Gòn - Vũng Tàu',
  operatorId: 'operator-1',
  operatorName: 'Nhà Xe ABC',
  operatorCode: 'ABC',
  createdAt: '2024-12-18T08:00:00Z',
  updatedAt: '2024-12-18T08:00:00Z',
};

export const validCreateDispatchInput = {
  vehicleId: 'vehicle-1',
  driverId: 'driver-1',
  routeId: 'route-1',
  entryTime: '2024-12-18T08:00:00+07:00',
  notes: 'Test entry',
};

export const validPassengerDropInput = {
  passengersArrived: 30,
  routeId: 'route-1',
};

export const validIssuePermitInput = {
  permitStatus: 'approved' as const,
  transportOrderCode: 'TO-2024-001',
  plannedDepartureTime: '2024-12-18T10:00:00+07:00',
  seatCount: 45,
  routeId: 'route-1',
};

export const validPaymentInput = {
  paymentAmount: 150000,
  paymentMethod: 'cash' as const,
  invoiceNumber: 'INV-2024-001',
};

export const validDepartureOrderInput = {
  passengersDeparting: 42,
};

export const validExitInput = {
  exitTime: '2024-12-18T10:30:00+07:00',
  passengersDeparting: 42,
};
</file>

<file path="server/src/__tests__/fixtures/fleet.fixtures.ts">
/**
 * Fleet Test Fixtures
 * Sample data for fleet module testing
 */

export const mockVehicleDBRecord = {
  id: 'vehicle-1',
  plate_number: '51A-12345',
  operator_id: 'operator-1',
  vehicle_type_id: 'type-1',
  seat_capacity: 45,
  bed_capacity: 0,
  chassis_number: 'CH123456',
  engine_number: 'EN789012',
  is_active: true,
  operator_name: 'Nhà Xe ABC',
  operator_code: 'ABC',
  vehicle_type_name: 'Ghế ngồi',
  created_at: '2024-12-01T00:00:00Z',
  updated_at: '2024-12-18T08:00:00Z',
};

export const mockVehicleRecord = {
  id: 'vehicle-1',
  plateNumber: '51A-12345',
  operatorId: 'operator-1',
  vehicleTypeId: 'type-1',
  seatCapacity: 45,
  bedCapacity: 0,
  chassisNumber: 'CH123456',
  engineNumber: 'EN789012',
  isActive: true,
  operatorName: 'Nhà Xe ABC',
  operatorCode: 'ABC',
  vehicleTypeName: 'Ghế ngồi',
  createdAt: '2024-12-01T00:00:00Z',
  updatedAt: '2024-12-18T08:00:00Z',
};

export const mockDriverDBRecord = {
  id: 'driver-1',
  first_name: 'Văn A',
  last_name: 'Nguyễn',
  phone_number: '0901234567',
  id_number: '123456789012',
  license_number: 'B2-123456',
  license_class: 'B2',
  license_expiry: '2026-12-31',
  is_active: true,
  created_at: '2024-01-01T00:00:00Z',
  updated_at: '2024-12-18T08:00:00Z',
};

export const mockDriverRecord = {
  id: 'driver-1',
  firstName: 'Văn A',
  lastName: 'Nguyễn',
  fullName: 'Nguyễn Văn A',
  phoneNumber: '0901234567',
  idNumber: '123456789012',
  licenseNumber: 'B2-123456',
  licenseClass: 'B2',
  licenseExpiry: '2026-12-31',
  isActive: true,
  createdAt: '2024-01-01T00:00:00Z',
  updatedAt: '2024-12-18T08:00:00Z',
};

export const validCreateVehicleInput = {
  plateNumber: '51B-67890',
  operatorId: 'operator-1',
  vehicleTypeId: 'type-1',
  seatCapacity: 45,
  bedCapacity: 0,
  chassisNumber: 'CH999888',
  engineNumber: 'EN777666',
};

export const validUpdateVehicleInput = {
  seatCapacity: 50,
  isActive: true,
};

export const validCreateDriverInput = {
  firstName: 'Văn B',
  lastName: 'Trần',
  phoneNumber: '0909876543',
  idNumber: '987654321098',
  licenseNumber: 'C-654321',
  licenseClass: 'C',
  licenseExpiry: '2027-06-30',
};

export const validUpdateDriverInput = {
  phoneNumber: '0912345678',
  isActive: true,
};

export const validVehicleDocumentInput = {
  registrationCertificate: {
    documentNumber: 'REG-2024-001',
    expiryDate: '2025-12-31',
    isValid: true,
  },
  insurance: {
    documentNumber: 'INS-2024-001',
    expiryDate: '2025-06-30',
    isValid: true,
  },
};
</file>

<file path="server/src/__tests__/utils/test-helpers.ts">
/**
 * Test Helper Utilities
 * Common utilities for unit testing
 */

import type { Request, Response } from 'express';

/**
 * Create mock Express request
 */
export function mockRequest(overrides: Partial<Request> = {}): Partial<Request> {
  return {
    params: {},
    query: {},
    body: {},
    user: { id: 'test-user-id', email: 'test@example.com' },
    ...overrides,
  };
}

/**
 * Create mock Express response
 */
export function mockResponse(): Partial<Response> & {
  _getStatusCode: () => number;
  _getData: () => unknown;
} {
  let statusCode = 200;
  let data: unknown = null;

  const res = {
    status: jest.fn().mockImplementation((code: number) => {
      statusCode = code;
      return res;
    }),
    json: jest.fn().mockImplementation((d: unknown) => {
      data = d;
      return res;
    }),
    send: jest.fn().mockImplementation((d: unknown) => {
      data = d;
      return res;
    }),
    _getStatusCode: () => statusCode,
    _getData: () => data,
  };

  return res as Partial<Response> & {
    _getStatusCode: () => number;
    _getData: () => unknown;
  };
}

/**
 * Create mock Firebase REST client
 */
export function mockFirebaseREST() {
  return {
    get: jest.fn().mockResolvedValue(null),
    set: jest.fn().mockResolvedValue(undefined),
    update: jest.fn().mockResolvedValue(undefined),
    remove: jest.fn().mockResolvedValue(undefined),
    push: jest.fn().mockResolvedValue({ name: 'new-id' }),
  };
}

/**
 * Generate unique ID for tests
 */
export function generateTestId(prefix = 'test'): string {
  return `${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Create ISO timestamp for tests
 */
export function createTestTimestamp(offsetMinutes = 0): string {
  const date = new Date();
  date.setMinutes(date.getMinutes() + offsetMinutes);
  return date.toISOString();
}
</file>

<file path="server/src/config/cloudinary.ts">
import { v2 as cloudinary } from 'cloudinary'
import dotenv from 'dotenv'

dotenv.config()

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
})

export default cloudinary
</file>

<file path="server/src/config/dual-write.ts">
/**
 * Dual-Write Module for Gradual Migration
 *
 * This module enables writing to both RTDB and Firestore simultaneously
 * during the gradual migration phase. This ensures data consistency
 * and allows for safe rollback if needed.
 *
 * Configuration via environment variables:
 * - DUAL_WRITE_ENABLED: Enable/disable dual-write (default: false)
 * - PRIMARY_DATABASE: 'rtdb' or 'firestore' (default: 'rtdb')
 * - FIRESTORE_WRITE_ENABLED: Enable writing to Firestore (default: false)
 *
 * Usage:
 * 1. Start with PRIMARY_DATABASE=rtdb, FIRESTORE_WRITE_ENABLED=true
 * 2. Run migration script to copy existing data
 * 3. Enable DUAL_WRITE_ENABLED=true
 * 4. Verify data consistency
 * 5. Switch PRIMARY_DATABASE=firestore
 * 6. Disable DUAL_WRITE_ENABLED when confident
 */

import { firebase as rtdbClient, firebaseDb } from './database.js'
import { firestore as firestoreClient, getFirestoreInstance } from './firestore.js'

// Configuration
interface DualWriteConfig {
  enabled: boolean
  primaryDatabase: 'rtdb' | 'firestore'
  firestoreWriteEnabled: boolean
}

// Get configuration from environment
function getConfig(): DualWriteConfig {
  return {
    enabled: process.env.DUAL_WRITE_ENABLED === 'true',
    primaryDatabase: (process.env.PRIMARY_DATABASE as 'rtdb' | 'firestore') || 'rtdb',
    firestoreWriteEnabled: process.env.FIRESTORE_WRITE_ENABLED === 'true',
  }
}

// Log configuration on startup
const config = getConfig()
console.log(`[Dual-Write] Configuration:`)
console.log(`  - Enabled: ${config.enabled}`)
console.log(`  - Primary: ${config.primaryDatabase}`)
console.log(`  - Firestore Write: ${config.firestoreWriteEnabled}`)

// Error tracking for dual-write failures
interface WriteError {
  database: 'rtdb' | 'firestore'
  collection: string
  operation: string
  error: string
  timestamp: string
}

const writeErrors: WriteError[] = []

function logWriteError(db: 'rtdb' | 'firestore', collection: string, operation: string, error: any) {
  const writeError: WriteError = {
    database: db,
    collection,
    operation,
    error: error.message || String(error),
    timestamp: new Date().toISOString(),
  }
  writeErrors.push(writeError)
  console.error(`[Dual-Write] ${db} error on ${collection}.${operation}: ${writeError.error}`)

  // Keep only last 100 errors
  if (writeErrors.length > 100) {
    writeErrors.shift()
  }
}

// Get write errors for monitoring
export function getWriteErrors(): WriteError[] {
  return [...writeErrors]
}

// Clear write errors
export function clearWriteErrors(): void {
  writeErrors.length = 0
}

// Dual-write query builder
class DualWriteQuery {
  private collectionName: string
  private filters: Array<{ method: string; args: any[] }> = []
  private orderByData?: { field: string; options?: { ascending?: boolean } }
  private limitCount?: number
  private selectFieldsStr?: string
  private isSingle: boolean = false
  private updateData?: Record<string, any>
  private insertData?: Record<string, any> | Record<string, any>[]
  private isDelete: boolean = false

  constructor(collectionName: string) {
    this.collectionName = collectionName
  }

  select(fields: string): this {
    this.selectFieldsStr = fields
    return this
  }

  eq(field: string, value: any): this {
    this.filters.push({ method: 'eq', args: [field, value] })
    return this
  }

  neq(field: string, value: any): this {
    this.filters.push({ method: 'neq', args: [field, value] })
    return this
  }

  gt(field: string, value: any): this {
    this.filters.push({ method: 'gt', args: [field, value] })
    return this
  }

  gte(field: string, value: any): this {
    this.filters.push({ method: 'gte', args: [field, value] })
    return this
  }

  lt(field: string, value: any): this {
    this.filters.push({ method: 'lt', args: [field, value] })
    return this
  }

  lte(field: string, value: any): this {
    this.filters.push({ method: 'lte', args: [field, value] })
    return this
  }

  in(field: string, values: any[]): this {
    this.filters.push({ method: 'in', args: [field, values] })
    return this
  }

  order(field: string, options?: { ascending?: boolean }): this {
    this.orderByData = { field, options }
    return this
  }

  limit(count: number): this {
    this.limitCount = count
    return this
  }

  single(): this {
    this.isSingle = true
    return this
  }

  insert(data: Record<string, any> | Record<string, any>[]): this {
    this.insertData = data
    return this
  }

  update(data: Record<string, any>): this {
    this.updateData = data
    return this
  }

  delete(): this {
    this.isDelete = true
    return this
  }

  // Build query for a specific database
  private buildQuery(db: 'rtdb' | 'firestore') {
    const client = db === 'rtdb' ? rtdbClient : firestoreClient
    let query = client.from(this.collectionName)

    if (this.selectFieldsStr) {
      query = query.select(this.selectFieldsStr)
    }

    for (const filter of this.filters) {
      query = (query as any)[filter.method](...filter.args)
    }

    if (this.orderByData) {
      query = query.order(this.orderByData.field, this.orderByData.options)
    }

    if (this.limitCount) {
      query = query.limit(this.limitCount)
    }

    if (this.isSingle) {
      query = query.single()
    }

    if (this.insertData) {
      query = query.insert(this.insertData)
    }

    if (this.updateData) {
      query = query.update(this.updateData)
    }

    if (this.isDelete) {
      query = query.delete()
    }

    return query
  }

  async execute(): Promise<{ data: any; error: any }> {
    const cfg = getConfig()
    const isWrite = this.insertData || this.updateData || this.isDelete
    const operation = this.insertData ? 'insert' : this.updateData ? 'update' : this.isDelete ? 'delete' : 'select'

    // For read operations, use primary database only
    if (!isWrite) {
      try {
        const result = await this.buildQuery(cfg.primaryDatabase)
        return result
      } catch (error: any) {
        return { data: null, error: { message: error.message } }
      }
    }

    // For write operations
    let primaryResult: { data: any; error: any } = { data: null, error: null }
    let secondaryResult: { data: any; error: any } = { data: null, error: null }

    // Write to primary database
    try {
      primaryResult = await this.buildQuery(cfg.primaryDatabase)
    } catch (error: any) {
      logWriteError(cfg.primaryDatabase, this.collectionName, operation, error)
      return { data: null, error: { message: error.message } }
    }

    // If primary failed, don't write to secondary
    if (primaryResult.error) {
      return primaryResult
    }

    // Write to secondary database if dual-write is enabled
    const secondaryDb = cfg.primaryDatabase === 'rtdb' ? 'firestore' : 'rtdb'
    const shouldWriteSecondary = cfg.enabled || (secondaryDb === 'firestore' && cfg.firestoreWriteEnabled)

    if (shouldWriteSecondary) {
      try {
        secondaryResult = await this.buildQuery(secondaryDb)
        if (secondaryResult.error) {
          logWriteError(secondaryDb, this.collectionName, operation, secondaryResult.error)
        }
      } catch (error: any) {
        logWriteError(secondaryDb, this.collectionName, operation, error)
        // Don't fail the operation if secondary write fails
        // The primary write succeeded
      }
    }

    return primaryResult
  }
}

// Create thenable query builder
function createThenableQuery(query: DualWriteQuery): any {
  const proxy = new Proxy(query, {
    get(target: DualWriteQuery, prop: string) {
      if (prop === 'then' || prop === 'catch' || prop === 'finally') {
        return (onResolve: any, onReject?: any) => {
          return target.execute().then(onResolve, onReject)
        }
      }
      const value = (target as any)[prop]
      if (typeof value === 'function') {
        return function(...args: any[]) {
          const result = value.apply(target, args)
          return result === target ? proxy : result
        }
      }
      return value
    }
  })
  return proxy
}

/**
 * Dual-write database client
 * API compatible with both firebase and firestore clients
 */
export const dualWrite = {
  from: (collection: string) => {
    const query = new DualWriteQuery(collection)
    return createThenableQuery(query)
  },

  // RPC placeholder
  rpc: async (_functionName: string, _params?: any) => {
    return { data: null, error: { message: 'RPC not supported in dual-write mode' } }
  },

  // Get current configuration
  getConfig,

  // Check if dual-write is enabled
  isEnabled: () => getConfig().enabled,

  // Get primary database
  getPrimary: () => getConfig().primaryDatabase,

  // Get write errors
  getErrors: getWriteErrors,

  // Clear errors
  clearErrors: clearWriteErrors,
}

/**
 * Utility to compare data between RTDB and Firestore
 * Useful for verifying data consistency during migration
 */
export async function compareCollectionData(collectionName: string): Promise<{
  rtdbCount: number
  firestoreCount: number
  matched: number
  missingInFirestore: string[]
  missingInRtdb: string[]
}> {
  const result = {
    rtdbCount: 0,
    firestoreCount: 0,
    matched: 0,
    missingInFirestore: [] as string[],
    missingInRtdb: [] as string[],
  }

  try {
    // Get RTDB data
    const rtdbData = await firebaseDb.get(collectionName)
    const rtdbIds = rtdbData ? Object.keys(rtdbData) : []
    result.rtdbCount = rtdbIds.length

    // Get Firestore data
    const firestoreDb = getFirestoreInstance()
    const firestoreSnapshot = await firestoreDb.collection(collectionName).get()
    const firestoreIds = firestoreSnapshot.docs.map(doc => doc.id)
    result.firestoreCount = firestoreIds.length

    // Compare
    const rtdbSet = new Set(rtdbIds)
    const firestoreSet = new Set(firestoreIds)

    for (const id of rtdbIds) {
      if (firestoreSet.has(id)) {
        result.matched++
      } else {
        result.missingInFirestore.push(id)
      }
    }

    for (const id of firestoreIds) {
      if (!rtdbSet.has(id)) {
        result.missingInRtdb.push(id)
      }
    }
  } catch (error) {
    console.error(`Error comparing ${collectionName}:`, error)
  }

  return result
}

/**
 * Utility to sync a single document from RTDB to Firestore
 */
export async function syncDocumentToFirestore(collectionName: string, documentId: string): Promise<boolean> {
  try {
    const rtdbData = await firebaseDb.get(`${collectionName}/${documentId}`)
    if (!rtdbData) {
      console.log(`Document ${documentId} not found in RTDB`)
      return false
    }

    const firestoreDb = getFirestoreInstance()
    await firestoreDb.collection(collectionName).doc(documentId).set({
      id: documentId,
      ...rtdbData,
    })

    console.log(`Synced ${collectionName}/${documentId} to Firestore`)
    return true
  } catch (error) {
    console.error(`Error syncing ${collectionName}/${documentId}:`, error)
    return false
  }
}

// Export for direct RTDB access when needed
export { rtdbClient as rtdb, firestoreClient as fs }
</file>

<file path="server/src/config/firestore.ts">
/**
 * Cloud Firestore Configuration and Query Builder
 *
 * This module provides a Firestore client with a query builder API
 * that is compatible with the existing RTDB query interface.
 *
 * This allows for gradual migration from RTDB to Firestore without
 * changing the existing controller code.
 */

import { getFirestore, Firestore, CollectionReference, Query, WhereFilterOp } from 'firebase-admin/firestore'
import { getApps } from 'firebase-admin/app'

// Firestore instance
let firestoreDb: Firestore | null = null

// Initialize Firestore (uses same Firebase Admin app as RTDB)
function getFirestoreInstance(): Firestore {
  if (firestoreDb) return firestoreDb

  const apps = getApps()
  if (apps.length === 0) {
    throw new Error('Firebase Admin app not initialized. Please ensure database.ts is imported first.')
  }

  firestoreDb = getFirestore(apps[0])

  // Configure Firestore settings for better performance
  firestoreDb.settings({
    ignoreUndefinedProperties: true,
  })

  return firestoreDb
}

// Type definitions for query builder
interface FilterCondition {
  field: string
  operator: WhereFilterOp
  value: any
}

interface OrderByCondition {
  field: string
  direction: 'asc' | 'desc'
}

// Firestore Query Builder - chainable API compatible with RTDB interface
class FirestoreQuery {
  private collectionName: string
  private filters: FilterCondition[] = []
  private orderByConditions: OrderByCondition[] = []
  private limitCount?: number
  private selectFields?: string[]
  private isSingle: boolean = false
  private updateData?: Record<string, any>
  private insertData?: Record<string, any> | Record<string, any>[]
  private isDelete: boolean = false

  constructor(collectionName: string) {
    this.collectionName = collectionName
  }

  select(fields: string): this {
    // Parse fields like "*, origin:origin_id(id, name, code)"
    // Note: Firestore doesn't support field selection in queries,
    // but we store this for API compatibility (filtering happens client-side if needed)
    this.selectFields = fields.split(',').map(f => f.trim())
    return this
  }

  // Getter for selectFields (used for compatibility checks)
  getSelectFields(): string[] | undefined {
    return this.selectFields
  }

  eq(field: string, value: any): this {
    this.filters.push({ field, operator: '==', value })
    return this
  }

  neq(field: string, value: any): this {
    this.filters.push({ field, operator: '!=', value })
    return this
  }

  gt(field: string, value: any): this {
    this.filters.push({ field, operator: '>', value })
    return this
  }

  gte(field: string, value: any): this {
    this.filters.push({ field, operator: '>=', value })
    return this
  }

  lt(field: string, value: any): this {
    this.filters.push({ field, operator: '<', value })
    return this
  }

  lte(field: string, value: any): this {
    this.filters.push({ field, operator: '<=', value })
    return this
  }

  in(field: string, values: any[]): this {
    if (values.length === 0) {
      // Empty array - return no results by using impossible condition
      this.filters.push({ field: '__impossible__', operator: '==', value: '__never_match__' })
    } else if (values.length <= 30) {
      // Firestore supports up to 30 values in 'in' query
      this.filters.push({ field, operator: 'in', value: values })
    } else {
      // For more than 30 values, we'll need to handle in execute()
      this.filters.push({ field, operator: 'in', value: values })
    }
    return this
  }

  order(field: string, options?: { ascending?: boolean }): this {
    this.orderByConditions.push({
      field,
      direction: options?.ascending === false ? 'desc' : 'asc'
    })
    return this
  }

  limit(count: number): this {
    this.limitCount = count
    return this
  }

  single(): this {
    this.limitCount = 1
    this.isSingle = true
    return this
  }

  insert(data: Record<string, any> | Record<string, any>[]): this {
    this.insertData = data
    return this
  }

  update(data: Record<string, any>): this {
    this.updateData = data
    return this
  }

  delete(): this {
    this.isDelete = true
    return this
  }

  async execute(): Promise<{ data: any; error: any }> {
    try {
      const db = getFirestoreInstance()
      const collectionRef = db.collection(this.collectionName)

      // Handle INSERT
      if (this.insertData) {
        return await this.executeInsert(collectionRef)
      }

      // Handle UPDATE
      if (this.updateData) {
        return await this.executeUpdate(db, collectionRef)
      }

      // Handle DELETE
      if (this.isDelete) {
        return await this.executeDelete(db, collectionRef)
      }

      // Handle SELECT (read)
      return await this.executeSelect(collectionRef)
    } catch (error: any) {
      console.error(`Firestore query error on ${this.collectionName}:`, error)
      return { data: null, error: { message: error.message, code: error.code } }
    }
  }

  private async executeInsert(collectionRef: CollectionReference): Promise<{ data: any; error: any }> {
    const dataArray = Array.isArray(this.insertData) ? this.insertData : [this.insertData!]
    const results: any[] = []

    for (const item of dataArray) {
      // Generate ID if not provided
      const id = item.id || collectionRef.doc().id
      const dataWithId = { ...item, id }

      // Add timestamps if not present
      const now = new Date().toISOString()
      if (!dataWithId.created_at) {
        dataWithId.created_at = now
      }
      if (!dataWithId.updated_at) {
        dataWithId.updated_at = now
      }

      // Write to Firestore
      await collectionRef.doc(id).set(dataWithId)
      results.push(dataWithId)
    }

    return {
      data: Array.isArray(this.insertData) ? results : results[0],
      error: null
    }
  }

  private async executeUpdate(db: Firestore, collectionRef: CollectionReference): Promise<{ data: any; error: any }> {
    // Add updated_at timestamp
    const updateData = {
      ...this.updateData,
      updated_at: new Date().toISOString()
    }

    // Build query with filters
    let query: Query = collectionRef

    for (const filter of this.filters) {
      if (filter.field === '__impossible__') {
        // No documents to update
        return { data: null, error: { message: 'No records found' } }
      }
      query = query.where(filter.field, filter.operator, filter.value)
    }

    // Get matching documents
    const snapshot = await query.get()

    if (snapshot.empty) {
      return { data: null, error: { message: 'No records found' } }
    }

    // Update each document
    const batch = db.batch()
    const updatedRecords: any[] = []

    snapshot.docs.forEach(doc => {
      batch.update(doc.ref, updateData)
      updatedRecords.push({ id: doc.id, ...doc.data(), ...updateData })
    })

    await batch.commit()

    return {
      data: this.isSingle ? updatedRecords[0] : updatedRecords,
      error: null
    }
  }

  private async executeDelete(db: Firestore, collectionRef: CollectionReference): Promise<{ data: any; error: any }> {
    // Build query with filters
    let query: Query = collectionRef

    for (const filter of this.filters) {
      if (filter.field === '__impossible__') {
        // No documents to delete
        return { data: null, error: null }
      }
      query = query.where(filter.field, filter.operator, filter.value)
    }

    // Get matching documents
    const snapshot = await query.get()

    if (snapshot.empty) {
      return { data: null, error: null }
    }

    // Delete in batch
    const batch = db.batch()
    snapshot.docs.forEach(doc => {
      batch.delete(doc.ref)
    })

    await batch.commit()

    return { data: null, error: null }
  }

  private async executeSelect(collectionRef: CollectionReference): Promise<{ data: any; error: any }> {
    // Check for large 'in' queries that need chunking
    const largeInFilter = this.filters.find(f => f.operator === 'in' && Array.isArray(f.value) && f.value.length > 30)

    if (largeInFilter) {
      return await this.executeChunkedSelect(collectionRef, largeInFilter)
    }

    // Build query
    let query: Query = collectionRef

    // Apply filters
    for (const filter of this.filters) {
      if (filter.field === '__impossible__') {
        return { data: this.isSingle ? null : [], error: this.isSingle ? { message: 'Not found' } : null }
      }
      query = query.where(filter.field, filter.operator, filter.value)
    }

    // Apply ordering
    for (const orderBy of this.orderByConditions) {
      query = query.orderBy(orderBy.field, orderBy.direction)
    }

    // Apply limit
    if (this.limitCount) {
      query = query.limit(this.limitCount)
    }

    // Execute query
    const snapshot = await query.get()

    // Transform results
    const data = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }))

    // Handle single()
    if (this.isSingle) {
      return {
        data: data[0] || null,
        error: data[0] ? null : { message: 'Not found' }
      }
    }

    return { data, error: null }
  }

  private async executeChunkedSelect(
    collectionRef: CollectionReference,
    largeInFilter: FilterCondition
  ): Promise<{ data: any; error: any }> {
    const values = largeInFilter.value as any[]
    const chunks: any[][] = []

    // Split into chunks of 30 (Firestore limit)
    for (let i = 0; i < values.length; i += 30) {
      chunks.push(values.slice(i, i + 30))
    }

    // Execute queries for each chunk in parallel
    const results = await Promise.all(
      chunks.map(async chunk => {
        let query: Query = collectionRef

        // Apply the chunked 'in' filter
        query = query.where(largeInFilter.field, 'in', chunk)

        // Apply other filters
        for (const filter of this.filters) {
          if (filter !== largeInFilter && filter.field !== '__impossible__') {
            query = query.where(filter.field, filter.operator, filter.value)
          }
        }

        // Apply ordering
        for (const orderBy of this.orderByConditions) {
          query = query.orderBy(orderBy.field, orderBy.direction)
        }

        const snapshot = await query.get()
        return snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }))
      })
    )

    // Flatten results
    let data = results.flat()

    // Apply client-side sorting if we had to chunk (since each chunk is sorted independently)
    if (this.orderByConditions.length > 0) {
      data.sort((a, b) => {
        for (const orderBy of this.orderByConditions) {
          const aVal = (a as any)[orderBy.field]
          const bVal = (b as any)[orderBy.field]

          if (aVal < bVal) return orderBy.direction === 'asc' ? -1 : 1
          if (aVal > bVal) return orderBy.direction === 'asc' ? 1 : -1
        }
        return 0
      })
    }

    // Apply limit after merging
    if (this.limitCount) {
      data = data.slice(0, this.limitCount)
    }

    // Handle single()
    if (this.isSingle) {
      return {
        data: data[0] || null,
        error: data[0] ? null : { message: 'Not found' }
      }
    }

    return { data, error: null }
  }
}

// Create a thenable query builder (allows async/await without explicit execute())
function createThenableQuery(query: FirestoreQuery): any {
  const proxy = new Proxy(query, {
    get(target: FirestoreQuery, prop: string) {
      if (prop === 'then' || prop === 'catch' || prop === 'finally') {
        return (onResolve: any, onReject?: any) => {
          return target.execute().then(onResolve, onReject)
        }
      }
      const value = (target as any)[prop]
      if (typeof value === 'function') {
        return function(...args: any[]) {
          const result = value.apply(target, args)
          return result === target ? proxy : result
        }
      }
      return value
    }
  })
  return proxy
}

/**
 * Firestore client with chainable query builder
 * API compatible with existing RTDB interface (firebase.from())
 */
export const firestore = {
  from: (collection: string) => {
    const query = new FirestoreQuery(collection)
    return createThenableQuery(query)
  },

  // Direct Firestore access for advanced operations
  db: () => getFirestoreInstance(),

  // Batch operations
  batch: () => getFirestoreInstance().batch(),

  // Transaction support
  runTransaction: <T>(fn: (transaction: FirebaseFirestore.Transaction) => Promise<T>) => {
    return getFirestoreInstance().runTransaction(fn)
  },

  // RPC placeholder (for compatibility)
  rpc: async (_functionName: string, _params?: any) => {
    return { data: null, error: { message: 'RPC not supported directly. Use Cloud Functions instead.' } }
  }
}

// Export Firestore instance getter for advanced use cases
export { getFirestoreInstance }

// Type exports for use in other files
export type { FilterCondition, OrderByCondition }
</file>

<file path="server/src/controllers/invoice.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const invoiceSchema = z.object({
  invoiceNumber: z.string().min(1, 'Invoice number is required'),
  dispatchRecordId: z.string().uuid().optional(),
  operatorId: z.string().uuid('Invalid operator ID'),
  issueDate: z.string().min(1, 'Issue date is required'),
  dueDate: z.string().optional(),
  subtotal: z.number().nonnegative('Subtotal must be non-negative'),
  taxAmount: z.number().nonnegative('Tax amount must be non-negative').default(0),
  totalAmount: z.number().nonnegative('Total amount must be non-negative'),
  notes: z.string().optional(),
})

export const getAllInvoices = async (req: Request, res: Response) => {
  try {
    const { operatorId, paymentStatus, startDate, endDate } = req.query

    let query = firebase
      .from('invoices')
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .order('issue_date', { ascending: false })

    if (operatorId) {
      query = query.eq('operator_id', operatorId as string)
    }
    if (paymentStatus) {
      query = query.eq('payment_status', paymentStatus as string)
    }
    if (startDate) {
      query = query.gte('issue_date', startDate as string)
    }
    if (endDate) {
      query = query.lte('issue_date', endDate as string)
    }

    const { data, error } = await query

    if (error) throw error

    const invoices = data.map((invoice: any) => ({
      id: invoice.id,
      invoiceNumber: invoice.invoice_number,
      dispatchRecordId: invoice.dispatch_record_id,
      operatorId: invoice.operator_id,
      operator: invoice.operators ? {
        id: invoice.operators.id,
        name: invoice.operators.name,
        code: invoice.operators.code,
      } : undefined,
      issueDate: invoice.issue_date,
      dueDate: invoice.due_date,
      subtotal: parseFloat(invoice.subtotal),
      taxAmount: parseFloat(invoice.tax_amount),
      totalAmount: parseFloat(invoice.total_amount),
      paymentStatus: invoice.payment_status,
      paymentDate: invoice.payment_date,
      notes: invoice.notes,
      createdAt: invoice.created_at,
      updatedAt: invoice.updated_at,
    }))

    return res.json(invoices)
  } catch (error) {
    console.error('Error fetching invoices:', error)
    return res.status(500).json({ error: 'Failed to fetch invoices' })
  }
}

export const getInvoiceById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('invoices')
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Invoice not found' })
    }

    return res.json({
      id: data.id,
      invoiceNumber: data.invoice_number,
      dispatchRecordId: data.dispatch_record_id,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      issueDate: data.issue_date,
      dueDate: data.due_date,
      subtotal: parseFloat(data.subtotal),
      taxAmount: parseFloat(data.tax_amount),
      totalAmount: parseFloat(data.total_amount),
      paymentStatus: data.payment_status,
      paymentDate: data.payment_date,
      notes: data.notes,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error) {
    console.error('Error fetching invoice:', error)
    return res.status(500).json({ error: 'Failed to fetch invoice' })
  }
}

export const createInvoice = async (req: Request, res: Response) => {
  try {
    const validated = invoiceSchema.parse(req.body)

    const { data, error } = await firebase
      .from('invoices')
      .insert({
        invoice_number: validated.invoiceNumber,
        dispatch_record_id: validated.dispatchRecordId || null,
        operator_id: validated.operatorId,
        issue_date: validated.issueDate,
        due_date: validated.dueDate || null,
        subtotal: validated.subtotal,
        tax_amount: validated.taxAmount || 0,
        total_amount: validated.totalAmount,
        payment_status: 'pending',
        notes: validated.notes || null,
      })
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      invoiceNumber: data.invoice_number,
      dispatchRecordId: data.dispatch_record_id,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      issueDate: data.issue_date,
      dueDate: data.due_date,
      subtotal: parseFloat(data.subtotal),
      taxAmount: parseFloat(data.tax_amount),
      totalAmount: parseFloat(data.total_amount),
      paymentStatus: data.payment_status,
      paymentDate: data.payment_date,
      notes: data.notes,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error creating invoice:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Invoice with this number already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create invoice' })
  }
}

export const updateInvoice = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = invoiceSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.invoiceNumber) updateData.invoice_number = validated.invoiceNumber
    if (validated.dispatchRecordId !== undefined) updateData.dispatch_record_id = validated.dispatchRecordId || null
    if (validated.operatorId) updateData.operator_id = validated.operatorId
    if (validated.issueDate) updateData.issue_date = validated.issueDate
    if (validated.dueDate !== undefined) updateData.due_date = validated.dueDate || null
    if (validated.subtotal !== undefined) updateData.subtotal = validated.subtotal
    if (validated.taxAmount !== undefined) updateData.tax_amount = validated.taxAmount
    if (validated.totalAmount !== undefined) updateData.total_amount = validated.totalAmount
    if (validated.notes !== undefined) updateData.notes = validated.notes || null

    const { data, error } = await firebase
      .from('invoices')
      .update(updateData)
      .eq('id', id)
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Invoice not found' })
    }

    return res.json({
      id: data.id,
      invoiceNumber: data.invoice_number,
      dispatchRecordId: data.dispatch_record_id,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      issueDate: data.issue_date,
      dueDate: data.due_date,
      subtotal: parseFloat(data.subtotal),
      taxAmount: parseFloat(data.tax_amount),
      totalAmount: parseFloat(data.total_amount),
      paymentStatus: data.payment_status,
      paymentDate: data.payment_date,
      notes: data.notes,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error updating invoice:', error)
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update invoice' })
  }
}

export const updateInvoicePayment = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const { paymentStatus, paymentDate } = req.body

    if (!paymentStatus || !['pending', 'paid', 'overdue', 'cancelled'].includes(paymentStatus)) {
      return res.status(400).json({ error: 'Invalid payment status' })
    }

    const updateData: any = {
      payment_status: paymentStatus,
    }

    if (paymentStatus === 'paid' && paymentDate) {
      updateData.payment_date = paymentDate
    } else if (paymentStatus !== 'paid') {
      updateData.payment_date = null
    }

    const { data, error } = await firebase
      .from('invoices')
      .update(updateData)
      .eq('id', id)
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Invoice not found' })
    }

    return res.json({
      id: data.id,
      invoiceNumber: data.invoice_number,
      dispatchRecordId: data.dispatch_record_id,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      issueDate: data.issue_date,
      dueDate: data.due_date,
      subtotal: parseFloat(data.subtotal),
      taxAmount: parseFloat(data.tax_amount),
      totalAmount: parseFloat(data.total_amount),
      paymentStatus: data.payment_status,
      paymentDate: data.payment_date,
      notes: data.notes,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error updating invoice payment:', error)
    return res.status(500).json({ error: error.message || 'Failed to update invoice payment' })
  }
}
</file>

<file path="server/src/controllers/location.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const locationSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  code: z.string().min(1, 'Code is required'),
  stationType: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().email().optional().or(z.literal('')),
  address: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
})

export const getAllLocations = async (req: Request, res: Response) => {
  try {
    const { isActive } = req.query

    let query = firebase
      .from('locations')
      .select('*')
      .order('name', { ascending: true })

    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    const locations = data.map((loc: any) => ({
      id: loc.id,
      name: loc.name,
      code: loc.code,
      stationType: loc.station_type,
      phone: loc.phone,
      email: loc.email,
      address: loc.address,
      latitude: loc.latitude ? parseFloat(loc.latitude) : null,
      longitude: loc.longitude ? parseFloat(loc.longitude) : null,
      isActive: loc.is_active,
      createdAt: loc.created_at,
    }))

    return res.json(locations)
  } catch (error) {
    console.error('Error fetching locations:', error)
    return res.status(500).json({ error: 'Failed to fetch locations' })
  }
}

export const getLocationById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('locations')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Location not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      code: data.code,
      stationType: data.station_type,
      phone: data.phone,
      email: data.email,
      address: data.address,
      latitude: data.latitude ? parseFloat(data.latitude) : null,
      longitude: data.longitude ? parseFloat(data.longitude) : null,
      isActive: data.is_active,
      createdAt: data.created_at,
    })
  } catch (error) {
    console.error('Error fetching location:', error)
    return res.status(500).json({ error: 'Failed to fetch location' })
  }
}

export const createLocation = async (req: Request, res: Response) => {
  try {
    const validated = locationSchema.parse(req.body)

    const { data, error } = await firebase
      .from('locations')
      .insert({
        name: validated.name,
        code: validated.code,
        station_type: validated.stationType || null,
        phone: validated.phone || null,
        email: validated.email || null,
        address: validated.address || null,
        latitude: validated.latitude || null,
        longitude: validated.longitude || null,
        is_active: true,
      })
      .select()
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      name: data.name,
      code: data.code,
      stationType: data.station_type,
      phone: data.phone,
      email: data.email,
      province: data.province,
      district: data.district,
      address: data.address,
      latitude: data.latitude ? parseFloat(data.latitude) : null,
      longitude: data.longitude ? parseFloat(data.longitude) : null,
      isActive: data.is_active,
      createdAt: data.created_at,
    })
  } catch (error: any) {
    console.error('Error creating location:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Location with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create location' })
  }
}

export const updateLocation = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = locationSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.name) updateData.name = validated.name
    if (validated.code) updateData.code = validated.code
    if (validated.stationType !== undefined) updateData.station_type = validated.stationType || null
    if (validated.phone !== undefined) updateData.phone = validated.phone || null
    if (validated.email !== undefined) updateData.email = validated.email || null
    if (validated.address !== undefined) updateData.address = validated.address || null
    if (validated.latitude !== undefined) updateData.latitude = validated.latitude || null
    if (validated.longitude !== undefined) updateData.longitude = validated.longitude || null

    const { data, error } = await firebase
      .from('locations')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Location not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      code: data.code,
      stationType: data.station_type,
      phone: data.phone,
      email: data.email,
      address: data.address,
      latitude: data.latitude ? parseFloat(data.latitude) : null,
      longitude: data.longitude ? parseFloat(data.longitude) : null,
      isActive: data.is_active,
      createdAt: data.created_at,
    })
  } catch (error: any) {
    console.error('Error updating location:', error)
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update location' })
  }
}

export const deleteLocation = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('locations')
      .delete()
      .eq('id', id)

    if (error) throw error

    return res.status(204).send()
  } catch (error) {
    console.error('Error deleting location:', error)
    return res.status(500).json({ error: 'Failed to delete location' })
  }
}
</file>

<file path="server/src/controllers/quanly-data.controller.ts">
import { Request, Response } from 'express'
import { firebaseDb } from '../config/database.js'

// Unified cache for all quanly data - pre-filtered for Buýt and Tuyến cố định
interface QuanLyCache {
  badges: any[]
  vehicles: any[]
  operators: any[]
  routes: any[]
  timestamp: number
}

let quanLyCache: QuanLyCache | null = null
const CACHE_TTL = 30 * 60 * 1000 // 30 minutes - stable numbers for users
let cacheLoading: Promise<QuanLyCache> | null = null

const ALLOWED_BADGE_TYPES = ['Buýt', 'Tuyến cố định']

// Normalize plate number
const normalizePlate = (plate: string): string => {
  return (plate || '').replace(/[.\-\s]/g, '').toUpperCase()
}

// Extract seat count from registration_info text
const extractSeatCount = (registrationInfo: string): number => {
  if (!registrationInfo) return 0
  // Match patterns like "Số người cho phép chở (ngồi): 45 người" or "số chỗ ngồi: 16"
  const patterns = [
    /Số người cho phép chở[^:]*:\s*(\d+)/i,
    /số chỗ ngồi[^:]*:\s*(\d+)/i,
    /\(ngồi\):\s*(\d+)/i,
    /chở được\s*(\d+)\s*người/i,
  ]
  for (const pattern of patterns) {
    const match = registrationInfo.match(pattern)
    if (match) return parseInt(match[1]) || 0
  }
  return 0
}

// Load all data in parallel and pre-filter
async function loadQuanLyData(): Promise<QuanLyCache> {
  const now = Date.now()
  
  // Return cached data if valid
  if (quanLyCache && (now - quanLyCache.timestamp) < CACHE_TTL) {
    return quanLyCache
  }
  
  // Prevent multiple simultaneous loads
  if (cacheLoading) {
    return cacheLoading
  }
  
  cacheLoading = (async () => {
    try {
      const startTime = Date.now()
      
      // Load all data in parallel from Firebase RTDB
      const [badgeSnapshot, vehicleSnapshot, operatorSnapshot, routeSnapshot] = await Promise.all([
        firebaseDb.ref('datasheet/PHUHIEUXE').once('value'),
        firebaseDb.ref('datasheet/Xe').once('value'),
        firebaseDb.ref('datasheet/DONVIVANTAI').once('value'),
        firebaseDb.ref('datasheet/DANHMUCTUYENCODINH').once('value'),
      ])
      
      const badgeData = badgeSnapshot.val() || {}
      const vehicleData = vehicleSnapshot.val() || {}
      const operatorData = operatorSnapshot.val() || {}
      const routeData = routeSnapshot.val() || {}
      
      // Build vehicle plate lookup
      const vehiclePlateMap = new Map<string, string>()
      for (const [key, vehicle] of Object.entries(vehicleData)) {
        const v = vehicle as any
        const plate = v.plate_number || v.BienSo || ''
        if (plate) {
          vehiclePlateMap.set(key, plate)
        }
      }
      
      // Build operator name lookup from DONVIVANTAI
      const operatorNameMap = new Map<string, string>()
      for (const [key, op] of Object.entries(operatorData)) {
        const o = op as any
        const operatorId = o.id || key
        operatorNameMap.set(operatorId, o.name || '')
      }
      
      // Filter badges by allowed types and build plate set + vehicle-operator mapping
      const allowedPlates = new Set<string>()
      const operatorIdsWithBadges = new Set<string>()
      const vehicleOperatorMap = new Map<string, string>() // plate -> operator name
      const vehicleBadgeExpiryMap = new Map<string, string>() // plate -> badge expiry date
      const badges: any[] = []
      
      for (const [key, badge] of Object.entries(badgeData)) {
        const b = badge as any
        const badgeType = b.LoaiPH || b.badge_type || ''
        
        if (!ALLOWED_BADGE_TYPES.includes(badgeType)) continue
        
        // Get plate number (resolve from vehicle_id if needed)
        let plateNumber = b.BienSoXe || b.vehicle_id || ''
        const vehicleId = b.vehicle_id || ''
        if (vehiclePlateMap.has(vehicleId)) {
          plateNumber = vehiclePlateMap.get(vehicleId)!
        }
        
        if (plateNumber) {
          const normalizedPlate = normalizePlate(plateNumber)
          allowedPlates.add(normalizedPlate)
          
          // Map vehicle plate to operator name from badge's issuing authority
          const issuingAuth = b.Ref_DonViCapPhuHieu || b.issuing_authority_ref || ''
          if (issuingAuth && operatorNameMap.has(issuingAuth)) {
            vehicleOperatorMap.set(normalizedPlate, operatorNameMap.get(issuingAuth)!)
          }
          
          // Map vehicle plate to badge expiry date
          const badgeExpiry = b.NgayHetHan || b.expiry_date || ''
          if (badgeExpiry) {
            vehicleBadgeExpiryMap.set(normalizedPlate, badgeExpiry)
          }
        }
        
        // Track operator IDs
        const issuingAuth = b.Ref_DonViCapPhuHieu || b.issuing_authority_ref || ''
        if (issuingAuth) {
          operatorIdsWithBadges.add(issuingAuth)
        }
        
        badges.push({
          id: b.ID_PhuHieu || key,
          badge_number: b.SoPhuHieu || b.badge_number || '',
          license_plate_sheet: plateNumber,
          badge_type: badgeType,
          badge_color: b.MauPhuHieu || b.badge_color || '',
          issue_date: b.NgayCap || b.issue_date || '',
          expiry_date: b.NgayHetHan || b.expiry_date || '',
          status: b.TrangThai || b.status || '',
          file_code: b.MaHoSo || b.file_number || '',
          issuing_authority_ref: issuingAuth,
          route_id: b.Ref_Tuyen || b.route_ref || '',
          vehicle_type: b.LoaiXe || b.vehicle_type || '',
        })
      }
      
      // Filter vehicles by allowed plates (from badges) - dedupe by normalized plate
      // First pass: collect all matching vehicles grouped by plate
      const vehiclesByPlate = new Map<string, any[]>()
      for (const [key, vehicle] of Object.entries(vehicleData)) {
        const v = vehicle as any
        const plateNumber = v.plate_number || v.BienSo || ''
        const normalizedPlate = normalizePlate(plateNumber)
        
        if (!plateNumber || !allowedPlates.has(normalizedPlate)) continue
        
        if (!vehiclesByPlate.has(normalizedPlate)) {
          vehiclesByPlate.set(normalizedPlate, [])
        }
        vehiclesByPlate.get(normalizedPlate)!.push({ key, v, plateNumber })
      }
      
      // Second pass: for each plate, pick the entry with most data
      const vehicles: any[] = []
      for (const [normalizedPlate, entries] of vehiclesByPlate) {
        // Sort by data completeness: prefer entries with owner_name, seat_count, etc.
        entries.sort((a, b) => {
          const scoreA = (a.v.owner_name ? 2 : 0) + (a.v.seat_count ? 1 : 0) + (a.v.registration_info ? 1 : 0)
          const scoreB = (b.v.owner_name ? 2 : 0) + (b.v.seat_count ? 1 : 0) + (b.v.registration_info ? 1 : 0)
          return scoreB - scoreA // Higher score first
        })
        
        const { key, v, plateNumber } = entries[0]
        
        // Get seat capacity: prefer seat_count, then SoCho, fallback to parsing registration_info
        let seatCapacity = typeof v.seat_count === 'number' ? v.seat_count : (parseInt(v.seat_count) || 0)
        if (!seatCapacity && v.SoCho) {
          // Parse "4 người" or "45" format
          const soCho = String(v.SoCho)
          const match = soCho.match(/(\d+)/)
          if (match) seatCapacity = parseInt(match[1]) || 0
        }
        if (!seatCapacity && v.registration_info) {
          seatCapacity = extractSeatCount(v.registration_info)
        }
        
        // Get operator name: prefer from badge reference, fallback to vehicle owner_name
        const operatorFromBadge = vehicleOperatorMap.get(normalizedPlate) || ''
        const operatorName = operatorFromBadge || v.owner_name || ''
        
        // Get badge expiry date for inspection display
        const badgeExpiryDate = vehicleBadgeExpiryMap.get(normalizedPlate) || ''
        
        vehicles.push({
          id: key,
          plateNumber: plateNumber,
          seatCapacity,
          operatorName,
          vehicleType: v.vehicle_category || v.vehicle_type || '',
          inspectionExpiryDate: badgeExpiryDate || v.inspection_expiry || '',
          isActive: true,
          source: 'google_sheets',
        })
      }
      
      // Filter operators by badge issuing authority refs
      const operators: any[] = []
      for (const [key, op] of Object.entries(operatorData)) {
        const o = op as any
        const operatorId = o.id || key
        
        // Include if operator has badges with allowed types
        if (!operatorIdsWithBadges.has(operatorId) && operatorIdsWithBadges.size > 0) {
          continue
        }
        
        let province = (o.province || '').trim()
        province = province.replace(/^\s*→\s*"?/g, '').replace(/"$/g, '').trim()
        if (province.includes('Tỉnh Tỉnh')) province = province.replace('Tỉnh Tỉnh', 'Tỉnh')
        
        operators.push({
          id: operatorId,
          name: o.name || '',
          province: province,
          phone: o.phone || '',
          email: o.email || '',
          address: o.address || '',
          representativeName: o.representative_name || '',
          isActive: true,
          source: 'google_sheets',
        })
      }
      
      // Parse routes
      const routes: any[] = []
      for (const [key, route] of Object.entries(routeData)) {
        const r = route as any
        routes.push({
          id: key,
          code: r.MaTuyen || r.route_code || '',
          name: r.TenTuyen || r.route_name || '',
          startPoint: r.DiemDi || r.start_point || '',
          endPoint: r.DiemDen || r.end_point || '',
          distance: r.CuLy || r.distance || '',
        })
      }
      
      // Sort data
      badges.sort((a, b) => b.badge_number.localeCompare(a.badge_number))
      vehicles.sort((a, b) => a.plateNumber.localeCompare(b.plateNumber))
      operators.sort((a, b) => a.name.localeCompare(b.name, 'vi'))
      routes.sort((a, b) => a.code.localeCompare(b.code))
      
      const loadTime = Date.now() - startTime
      console.log(`[QuanLyData] Loaded ${badges.length} badges, ${vehicles.length} vehicles, ${operators.length} operators, ${routes.length} routes in ${loadTime}ms`)
      console.log(`[QuanLyData] Debug: ${allowedPlates.size} allowed plates from badges, ${Object.keys(vehicleData).length} total vehicles in datasheet`)
      console.log(`[QuanLyData] Debug: vehiclesByPlate unique plates = ${vehiclesByPlate.size}, final vehicles array = ${vehicles.length}`)
      
      // Log first 5 plates for debugging
      const samplePlates = Array.from(allowedPlates).slice(0, 5)
      console.log(`[QuanLyData] Sample allowed plates: ${samplePlates.join(', ')}`)
      
      quanLyCache = {
        badges,
        vehicles,
        operators,
        routes,
        timestamp: Date.now(),
      }
      
      return quanLyCache
    } finally {
      cacheLoading = null
    }
  })()
  
  return cacheLoading
}

// Invalidate cache
export const invalidateQuanLyCache = () => {
  quanLyCache = null
  cacheLoading = null
}

// Pre-warm cache on server startup
export const preWarmQuanLyCache = async () => {
  try {
    console.log('[QuanLyData] Pre-warming cache...')
    await loadQuanLyData()
    console.log('[QuanLyData] Cache pre-warmed successfully')
  } catch (error) {
    console.error('[QuanLyData] Failed to pre-warm cache:', error)
  }
}

// Unified endpoint - returns all data for Quản lý thông tin module
export const getQuanLyData = async (req: Request, res: Response) => {
  try {
    const { include } = req.query
    const forceRefresh = req.query.refresh === 'true'
    
    if (forceRefresh) {
      invalidateQuanLyCache()
    }
    
    const data = await loadQuanLyData()
    
    // Allow selective data loading
    const includes = include ? (include as string).split(',') : ['badges', 'vehicles', 'operators', 'routes']
    
    const response: Record<string, any> = {}
    if (includes.includes('badges')) response.badges = data.badges
    if (includes.includes('vehicles')) response.vehicles = data.vehicles
    if (includes.includes('operators')) response.operators = data.operators
    if (includes.includes('routes')) response.routes = data.routes
    
    response.meta = {
      badgeCount: data.badges.length,
      vehicleCount: data.vehicles.length,
      operatorCount: data.operators.length,
      routeCount: data.routes.length,
      cachedAt: new Date(data.timestamp).toISOString(),
    }
    
    res.json(response)
  } catch (error) {
    console.error('[QuanLyData] Error:', error)
    res.status(500).json({ error: 'Failed to fetch data' })
  }
}

// Stats endpoint - lightweight
export const getQuanLyStats = async (_req: Request, res: Response) => {
  try {
    const data = await loadQuanLyData()
    
    res.json({
      badges: data.badges.length,
      vehicles: data.vehicles.length,
      operators: data.operators.length,
      routes: data.routes.length,
      cachedAt: new Date(data.timestamp).toISOString(),
    })
  } catch (error) {
    console.error('[QuanLyStats] Error:', error)
    res.status(500).json({ error: 'Failed to fetch stats' })
  }
}
</file>

<file path="server/src/controllers/report.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'

export const getInvoices = async (req: Request, res: Response) => {
  try {
    const { startDate, endDate, operatorId, paymentStatus } = req.query

    let query = firebase
      .from('invoices')
      .select(`
        *,
        operators:operator_id(id, name, code)
      `)
      .gte('issue_date', startDate as string)
      .lte('issue_date', endDate as string)
      .order('issue_date', { ascending: false })

    if (operatorId) {
      query = query.eq('operator_id', operatorId as string)
    }
    if (paymentStatus) {
      query = query.eq('payment_status', paymentStatus as string)
    }

    const { data, error } = await query

    if (error) throw error

    const invoices = data.map((invoice: any) => ({
      id: invoice.id,
      invoiceNumber: invoice.invoice_number,
      dispatchId: invoice.dispatch_record_id,
      operatorName: invoice.operators?.name || '',
      amount: parseFloat(invoice.total_amount) || 0,
      issueDate: invoice.issue_date,
      status: invoice.payment_status,
    }))

    return res.json(invoices)
  } catch (error) {
    console.error('Error fetching invoices:', error)
    return res.status(500).json({ error: 'Failed to fetch invoices' })
  }
}

export const getVehicleLogs = async (req: Request, res: Response) => {
  try {
    const { startDate, endDate, vehicleId } = req.query

    let query = firebase
      .from('dispatch_records')
      .select('*')
      .gte('entry_time', startDate as string)
      .lte('entry_time', endDate as string)
      .order('entry_time', { ascending: false })

    if (vehicleId) {
      query = query.eq('vehicle_id', vehicleId as string)
    }

    const { data: records, error } = await query

    if (error) throw error

    // Fetch related data
    const vehicleIds = [...new Set(records.map((r: any) => r.vehicle_id))]
    const driverIds = [...new Set(records.map((r: any) => r.driver_id))]
    const routeIds = [...new Set(records.map((r: any) => r.route_id))]

    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id, plate_number')
      .in('id', vehicleIds)

    const { data: drivers } = await firebase
      .from('drivers')
      .select('id, full_name')
      .in('id', driverIds)

    const { data: routes } = await firebase
      .from('routes')
      .select('id, route_name')
      .in('id', routeIds)

    const vehicleMap = new Map(vehicles?.map((v: any) => [v.id, v.plate_number]) || [])
    const driverMap = new Map(drivers?.map((d: any) => [d.id, d.full_name]) || [])
    const routeMap = new Map(routes?.map((r: any) => [r.id, r.route_name]) || [])

    const result = records.map((record: any) => ({
      ...record,
      vehiclePlateNumber: vehicleMap.get(record.vehicle_id) || '',
      driverName: driverMap.get(record.driver_id) || '',
      routeName: routeMap.get(record.route_id) || '',
    }))

    return res.json(result)
  } catch (error) {
    console.error('Error fetching vehicle logs:', error)
    return res.status(500).json({ error: 'Failed to fetch vehicle logs' })
  }
}

export const getStationActivity = async (req: Request, res: Response) => {
  try {
    const { startDate, endDate } = req.query

    const { data: records, error } = await firebase
      .from('dispatch_records')
      .select('*')
      .gte('entry_time', startDate as string)
      .lte('entry_time', endDate as string)
      .order('entry_time', { ascending: false })

    if (error) throw error

    // Fetch related data
    const vehicleIds = [...new Set(records.map((r: any) => r.vehicle_id))]
    const driverIds = [...new Set(records.map((r: any) => r.driver_id))]
    const routeIds = [...new Set(records.map((r: any) => r.route_id))]

    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id, plate_number')
      .in('id', vehicleIds)

    const { data: drivers } = await firebase
      .from('drivers')
      .select('id, full_name')
      .in('id', driverIds)

    const { data: routes } = await firebase
      .from('routes')
      .select('id, route_name')
      .in('id', routeIds)

    const vehicleMap = new Map(vehicles?.map((v: any) => [v.id, v.plate_number]) || [])
    const driverMap = new Map(drivers?.map((d: any) => [d.id, d.full_name]) || [])
    const routeMap = new Map(routes?.map((r: any) => [r.id, r.route_name]) || [])

    const result = records.map((record: any) => ({
      ...record,
      vehiclePlateNumber: vehicleMap.get(record.vehicle_id) || '',
      driverName: driverMap.get(record.driver_id) || '',
      routeName: routeMap.get(record.route_id) || '',
    }))

    return res.json(result)
  } catch (error) {
    console.error('Error fetching station activity:', error)
    return res.status(500).json({ error: 'Failed to fetch station activity' })
  }
}

export const getInvalidVehicles = async (req: Request, res: Response) => {
  try {
    const { startDate, endDate } = req.query

    const { data: records, error } = await firebase
      .from('dispatch_records')
      .select('*')
      .eq('current_status', 'permit_rejected')
      .gte('entry_time', startDate as string)
      .lte('entry_time', endDate as string)
      .order('entry_time', { ascending: false })

    if (error) throw error

    // Fetch related data
    const vehicleIds = [...new Set(records.map((r: any) => r.vehicle_id))]
    const driverIds = [...new Set(records.map((r: any) => r.driver_id))]
    const routeIds = [...new Set(records.map((r: any) => r.route_id))]

    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id, plate_number')
      .in('id', vehicleIds)

    const { data: drivers } = await firebase
      .from('drivers')
      .select('id, full_name')
      .in('id', driverIds)

    const { data: routes } = await firebase
      .from('routes')
      .select('id, route_name')
      .in('id', routeIds)

    const vehicleMap = new Map(vehicles?.map((v: any) => [v.id, v.plate_number]) || [])
    const driverMap = new Map(drivers?.map((d: any) => [d.id, d.full_name]) || [])
    const routeMap = new Map(routes?.map((r: any) => [r.id, r.route_name]) || [])

    const result = records.map((record: any) => ({
      ...record,
      vehiclePlateNumber: vehicleMap.get(record.vehicle_id) || '',
      driverName: driverMap.get(record.driver_id) || '',
      routeName: routeMap.get(record.route_id) || '',
    }))

    return res.json(result)
  } catch (error) {
    console.error('Error fetching invalid vehicles:', error)
    return res.status(500).json({ error: 'Failed to fetch invalid vehicles' })
  }
}

export const getRevenue = async (req: Request, res: Response) => {
  try {
    const { startDate, endDate } = req.query

    const { data, error } = await firebase
      .from('dispatch_records')
      .select('payment_amount, entry_time, vehicle_id')
      .gte('entry_time', startDate as string)
      .lte('entry_time', endDate as string)
      .not('payment_amount', 'is', null)
      .eq('current_status', 'departed')

    if (error) throw error

    // Group by date
    const revenueByDate: Record<string, {
      date: string
      totalRevenue: number
      vehicleCount: Set<string>
      transactionCount: number
    }> = {}

    data.forEach((record: any) => {
      const date = new Date(record.entry_time).toISOString().split('T')[0]
      if (!revenueByDate[date]) {
        revenueByDate[date] = {
          date,
          totalRevenue: 0,
          vehicleCount: new Set(),
          transactionCount: 0,
        }
      }
      revenueByDate[date].totalRevenue += parseFloat(record.payment_amount) || 0
      revenueByDate[date].vehicleCount.add(record.vehicle_id)
      revenueByDate[date].transactionCount += 1
    })

    const revenue = Object.values(revenueByDate).map((item) => ({
      date: item.date,
      totalRevenue: item.totalRevenue,
      vehicleCount: item.vehicleCount.size,
      transactionCount: item.transactionCount,
    })).sort((a, b) => a.date.localeCompare(b.date))

    return res.json(revenue)
  } catch (error) {
    console.error('Error fetching revenue:', error)
    return res.status(500).json({ error: 'Failed to fetch revenue' })
  }
}

export const exportExcel = async (req: Request, res: Response) => {
  try {
    const { type: _type } = req.params
    const { startDate: _startDate, endDate: _endDate } = req.query

    // For now, return JSON. In production, you would use a library like exceljs
    // to generate actual Excel files
    return res.status(501).json({ 
      error: 'Excel export not yet implemented',
      message: 'This endpoint will generate Excel files in the future'
    })
  } catch (error) {
    console.error('Error exporting Excel:', error)
    return res.status(500).json({ error: 'Failed to export Excel' })
  }
}
</file>

<file path="server/src/controllers/schedule.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const scheduleSchema = z.object({
  scheduleCode: z.string().optional(), // Optional - will be auto-generated if not provided
  routeId: z.string().uuid('Invalid route ID'),
  operatorId: z.string().uuid('Invalid operator ID'),
  departureTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format (HH:MM)'),
  frequencyType: z.enum(['daily', 'weekly', 'specific_days']),
  daysOfWeek: z.array(z.number().int().min(1).max(7)).optional(),
  effectiveFrom: z.string().min(1, 'Effective from date is required'),
  effectiveTo: z.string().optional(),
})

export const getAllSchedules = async (req: Request, res: Response) => {
  try {
    const { routeId, operatorId, isActive } = req.query

    let query = firebase
      .from('schedules')
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .order('departure_time', { ascending: true })

    if (routeId) {
      query = query.eq('route_id', routeId as string)
    }
    if (operatorId) {
      query = query.eq('operator_id', operatorId as string)
    }
    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    const schedules = data.map((schedule: any) => ({
      id: schedule.id,
      scheduleCode: schedule.schedule_code,
      routeId: schedule.route_id,
      route: schedule.routes ? {
        id: schedule.routes.id,
        routeName: schedule.routes.route_name,
        routeCode: schedule.routes.route_code,
      } : undefined,
      operatorId: schedule.operator_id,
      operator: schedule.operators ? {
        id: schedule.operators.id,
        name: schedule.operators.name,
        code: schedule.operators.code,
      } : undefined,
      departureTime: schedule.departure_time,
      frequencyType: schedule.frequency_type,
      daysOfWeek: schedule.days_of_week || [],
      effectiveFrom: schedule.effective_from,
      effectiveTo: schedule.effective_to,
      isActive: schedule.is_active,
      createdAt: schedule.created_at,
      updatedAt: schedule.updated_at,
    }))

    return res.json(schedules)
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch schedules' })
  }
}

export const getScheduleById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('schedules')
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Schedule not found' })
    }

    return res.json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch schedule' })
  }
}

export const createSchedule = async (req: Request, res: Response) => {
  try {
    const validated = scheduleSchema.parse(req.body)

    const { data, error } = await firebase
      .from('schedules')
      .insert({
        schedule_code: validated.scheduleCode || null, // Will be auto-generated by trigger if null
        route_id: validated.routeId,
        operator_id: validated.operatorId,
        departure_time: validated.departureTime,
        frequency_type: validated.frequencyType,
        days_of_week: validated.daysOfWeek || null,
        effective_from: validated.effectiveFrom,
        effective_to: validated.effectiveTo || null,
        is_active: true,
      })
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.code === '23505') {
      return res.status(409).json({ error: 'Schedule with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create schedule' })
  }
}

export const updateSchedule = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = scheduleSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.scheduleCode) updateData.schedule_code = validated.scheduleCode
    if (validated.routeId) updateData.route_id = validated.routeId
    if (validated.operatorId) updateData.operator_id = validated.operatorId
    if (validated.departureTime) updateData.departure_time = validated.departureTime
    if (validated.frequencyType) updateData.frequency_type = validated.frequencyType
    if (validated.daysOfWeek !== undefined) updateData.days_of_week = validated.daysOfWeek || null
    if (validated.effectiveFrom) updateData.effective_from = validated.effectiveFrom
    if (validated.effectiveTo !== undefined) updateData.effective_to = validated.effectiveTo || null

    const { data, error } = await firebase
      .from('schedules')
      .update(updateData)
      .eq('id', id)
      .select(`
        *,
        routes:route_id(id, route_name, route_code),
        operators:operator_id(id, name, code)
      `)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Schedule not found' })
    }

    return res.json({
      id: data.id,
      scheduleCode: data.schedule_code,
      routeId: data.route_id,
      route: data.routes ? {
        id: data.routes.id,
        routeName: data.routes.route_name,
        routeCode: data.routes.route_code,
      } : undefined,
      operatorId: data.operator_id,
      operator: data.operators ? {
        id: data.operators.id,
        name: data.operators.name,
        code: data.operators.code,
      } : undefined,
      departureTime: data.departure_time,
      frequencyType: data.frequency_type,
      daysOfWeek: data.days_of_week || [],
      effectiveFrom: data.effective_from,
      effectiveTo: data.effective_to,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update schedule' })
  }
}

export const deleteSchedule = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('schedules')
      .delete()
      .eq('id', id)

    if (error) throw error

    res.status(204).send()
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to delete schedule' })
  }
}
</file>

<file path="server/src/controllers/service.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const serviceSchema = z.object({
  code: z.string().min(1, 'Code is required'),
  name: z.string().min(1, 'Name is required'),
  unit: z.string().min(1, 'Unit is required'),
  taxPercentage: z.number().min(0).max(100),
  materialType: z.string().min(1, 'Material type is required'),
  useQuantityFormula: z.boolean().default(false),
  usePriceFormula: z.boolean().default(false),
  displayOrder: z.number().int().min(0),
  isDefault: z.boolean().default(false),
  autoCalculateQuantity: z.boolean().default(false),
  isActive: z.boolean().default(true),
})

export const getAllServices = async (req: Request, res: Response) => {
  try {
    const { isActive } = req.query

    let query = firebase
      .from('services')
      .select('*')
      .order('display_order', { ascending: true })
      .order('name', { ascending: true })

    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    const services = data.map((svc: any) => ({
      id: svc.id,
      code: svc.code,
      name: svc.name,
      unit: svc.unit,
      taxPercentage: parseFloat(svc.tax_percentage) || 0,
      materialType: svc.material_type,
      useQuantityFormula: svc.use_quantity_formula,
      usePriceFormula: svc.use_price_formula,
      displayOrder: svc.display_order,
      isDefault: svc.is_default,
      autoCalculateQuantity: svc.auto_calculate_quantity,
      isActive: svc.is_active,
      createdAt: svc.created_at,
      updatedAt: svc.updated_at,
    }))

    return res.json(services)
  } catch (error) {
    console.error('Error fetching services:', error)
    return res.status(500).json({ error: 'Failed to fetch services' })
  }
}

export const getServiceById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('services')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Service not found' })
    }

    // Lấy thông tin biểu thức đã chọn
    const { data: usageData } = await firebase
      .from('service_formula_usage')
      .select('formula_id, usage_type')
      .eq('service_id', id)

    let quantityFormulaId = ''
    let priceFormulaId = ''
    
    if (usageData) {
      const quantityUsage = usageData.find((u: any) => u.usage_type === 'quantity')
      const priceUsage = usageData.find((u: any) => u.usage_type === 'price')
      quantityFormulaId = quantityUsage?.formula_id || ''
      priceFormulaId = priceUsage?.formula_id || ''
    }

    return res.json({
      id: data.id,
      code: data.code,
      name: data.name,
      unit: data.unit,
      taxPercentage: parseFloat(data.tax_percentage) || 0,
      materialType: data.material_type,
      useQuantityFormula: data.use_quantity_formula,
      usePriceFormula: data.use_price_formula,
      displayOrder: data.display_order,
      isDefault: data.is_default,
      autoCalculateQuantity: data.auto_calculate_quantity,
      isActive: data.is_active,
      quantityFormulaExpression: quantityFormulaId,
      priceFormulaExpression: priceFormulaId,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error) {
    console.error('Error fetching service:', error)
    return res.status(500).json({ error: 'Failed to fetch service' })
  }
}

export const createService = async (req: Request, res: Response) => {
  try {
    const validated = serviceSchema.parse(req.body)
    const { quantityFormulaExpression, priceFormulaExpression } = req.body

    const { data, error } = await firebase
      .from('services')
      .insert({
        code: validated.code,
        name: validated.name,
        unit: validated.unit,
        tax_percentage: validated.taxPercentage,
        material_type: validated.materialType,
        use_quantity_formula: validated.useQuantityFormula,
        use_price_formula: validated.usePriceFormula,
        display_order: validated.displayOrder,
        is_default: validated.isDefault,
        auto_calculate_quantity: validated.autoCalculateQuantity,
        is_active: validated.isActive,
      })
      .select()
      .single()

    if (error) throw error

    // Lưu mối quan hệ với biểu thức vào service_formula_usage
    // Lưu nếu có chọn biểu thức (không cần kiểm tra checkbox)
    const usageInserts: any[] = []
    
    if (quantityFormulaExpression) {
      usageInserts.push({
        service_id: data.id,
        formula_id: quantityFormulaExpression,
        usage_type: 'quantity',
      })
    }
    
    if (priceFormulaExpression) {
      usageInserts.push({
        service_id: data.id,
        formula_id: priceFormulaExpression,
        usage_type: 'price',
      })
    }

    if (usageInserts.length > 0) {
      const { error: usageError } = await firebase
        .from('service_formula_usage')
        .insert(usageInserts)

      if (usageError) {
        console.error('Error creating service formula usage:', usageError)
        // Không throw error, chỉ log vì service đã được tạo thành công
      }
    }

    return res.status(201).json({
      id: data.id,
      code: data.code,
      name: data.name,
      unit: data.unit,
      taxPercentage: parseFloat(data.tax_percentage) || 0,
      materialType: data.material_type,
      useQuantityFormula: data.use_quantity_formula,
      usePriceFormula: data.use_price_formula,
      displayOrder: data.display_order,
      isDefault: data.is_default,
      autoCalculateQuantity: data.auto_calculate_quantity,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error creating service:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Service with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create service' })
  }
}

export const updateService = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = serviceSchema.partial().parse(req.body)
    const { quantityFormulaExpression, priceFormulaExpression } = req.body

    const updateData: any = {}
    if (validated.code !== undefined) updateData.code = validated.code
    if (validated.name !== undefined) updateData.name = validated.name
    if (validated.unit !== undefined) updateData.unit = validated.unit
    if (validated.taxPercentage !== undefined) updateData.tax_percentage = validated.taxPercentage
    if (validated.materialType !== undefined) updateData.material_type = validated.materialType
    if (validated.useQuantityFormula !== undefined) updateData.use_quantity_formula = validated.useQuantityFormula
    if (validated.usePriceFormula !== undefined) updateData.use_price_formula = validated.usePriceFormula
    if (validated.displayOrder !== undefined) updateData.display_order = validated.displayOrder
    if (validated.isDefault !== undefined) updateData.is_default = validated.isDefault
    if (validated.autoCalculateQuantity !== undefined) updateData.auto_calculate_quantity = validated.autoCalculateQuantity
    if (validated.isActive !== undefined) updateData.is_active = validated.isActive
    
    updateData.updated_at = new Date().toISOString()

    const { data, error } = await firebase
      .from('services')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Service not found' })
    }

    // Cập nhật mối quan hệ với biểu thức
    // Xóa các usage cũ
    await firebase
      .from('service_formula_usage')
      .delete()
      .eq('service_id', id)

    // Tạo lại các usage mới
    // Lưu nếu có chọn biểu thức (không cần kiểm tra checkbox)
    const usageInserts: any[] = []
    
    if (quantityFormulaExpression) {
      usageInserts.push({
        service_id: id,
        formula_id: quantityFormulaExpression,
        usage_type: 'quantity',
      })
    }
    
    if (priceFormulaExpression) {
      usageInserts.push({
        service_id: id,
        formula_id: priceFormulaExpression,
        usage_type: 'price',
      })
    }

    if (usageInserts.length > 0) {
      const { error: usageError } = await firebase
        .from('service_formula_usage')
        .insert(usageInserts)

      if (usageError) {
        console.error('Error updating service formula usage:', usageError)
        // Không throw error, chỉ log vì service đã được cập nhật thành công
      }
    }

    return res.json({
      id: data.id,
      code: data.code,
      name: data.name,
      unit: data.unit,
      taxPercentage: parseFloat(data.tax_percentage) || 0,
      materialType: data.material_type,
      useQuantityFormula: data.use_quantity_formula,
      usePriceFormula: data.use_price_formula,
      displayOrder: data.display_order,
      isDefault: data.is_default,
      autoCalculateQuantity: data.auto_calculate_quantity,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error updating service:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Service with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update service' })
  }
}

export const deleteService = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('services')
      .delete()
      .eq('id', id)

    if (error) throw error

    return res.status(204).send()
  } catch (error: any) {
    console.error('Error deleting service:', error)
    // Check if service is referenced by other tables
    if (error.code === '23503') {
      return res.status(400).json({ error: 'Cannot delete service as it is being used' })
    }
    return res.status(500).json({ error: 'Failed to delete service' })
  }
}
</file>

<file path="server/src/controllers/shift.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const shiftSchema = z.object({
  name: z.string().min(1, 'Tên ca trực là bắt buộc'),
  startTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, 'Giờ bắt đầu không hợp lệ (HH:mm)'),
  endTime: z.string().regex(/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/, 'Giờ kết thúc không hợp lệ (HH:mm)'),
})

export const getAllShifts = async (_req: Request, res: Response) => {
  try {
    const { data, error } = await firebase
      .from('shifts')
      .select('*')
      .eq('is_active', true)
      .order('start_time', { ascending: true })

    if (error) throw error

    const shifts = data.map((shift: any) => ({
      id: shift.id,
      name: shift.name,
      startTime: shift.start_time.substring(0, 5), // Format TIME to HH:mm
      endTime: shift.end_time.substring(0, 5), // Format TIME to HH:mm
      createdAt: shift.created_at,
      updatedAt: shift.updated_at,
    }))

    return res.json(shifts)
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Không thể tải danh sách ca trực' })
  }
}

export const getShiftById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('shifts')
      .select('*')
      .eq('id', id)
      .eq('is_active', true)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Ca trực không tồn tại' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      startTime: data.start_time.substring(0, 5), // Format TIME to HH:mm
      endTime: data.end_time.substring(0, 5), // Format TIME to HH:mm
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Không thể tải thông tin ca trực' })
  }
}

export const createShift = async (req: Request, res: Response) => {
  try {
    const validated = shiftSchema.parse(req.body)

    // Convert HH:mm to TIME format (HH:mm:ss)
    const startTime = `${validated.startTime}:00`
    const endTime = `${validated.endTime}:00`

    const { data, error } = await firebase
      .from('shifts')
      .insert({
        name: validated.name,
        start_time: startTime,
        end_time: endTime,
        is_active: true,
      })
      .select()
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      name: data.name,
      startTime: data.start_time.substring(0, 5),
      endTime: data.end_time.substring(0, 5),
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    // Handle unique constraint violation
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Tên ca trực đã tồn tại' })
    }
    return res.status(500).json({ error: error.message || 'Không thể tạo ca trực' })
  }
}

export const updateShift = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = shiftSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.name) updateData.name = validated.name
    if (validated.startTime) updateData.start_time = `${validated.startTime}:00`
    if (validated.endTime) updateData.end_time = `${validated.endTime}:00`

    const { data, error } = await firebase
      .from('shifts')
      .update(updateData)
      .eq('id', id)
      .eq('is_active', true)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Ca trực không tồn tại' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      startTime: data.start_time.substring(0, 5),
      endTime: data.end_time.substring(0, 5),
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    // Handle unique constraint violation
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Tên ca trực đã tồn tại' })
    }
    return res.status(500).json({ error: error.message || 'Không thể cập nhật ca trực' })
  }
}

export const deleteShift = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Soft delete by setting is_active to false
    const { error } = await firebase
      .from('shifts')
      .update({ is_active: false })
      .eq('id', id)

    if (error) throw error

    return res.status(204).send()
  } catch (error: any) {
    // Check if shift is being referenced by other tables
    if (error.code === '23503') {
      return res.status(400).json({ error: 'Không thể xóa ca trực. Ca trực này đang được sử dụng trong hệ thống.' })
    }
    return res.status(500).json({ error: error.message || 'Không thể xóa ca trực' })
  }
}
</file>

<file path="server/src/controllers/violation.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'
import { AuthRequest } from '../middleware/auth.js'

const violationSchema = z.object({
  dispatchRecordId: z.string().uuid().optional(),
  vehicleId: z.string().uuid().optional(),
  driverId: z.string().uuid().optional(),
  violationTypeId: z.string().uuid('Invalid violation type ID'),
  violationDate: z.string().datetime('Invalid violation date'),
  description: z.string().optional(),
})

export const getAllViolations = async (req: Request, res: Response) => {
  try {
    const { vehicleId, driverId, dispatchRecordId, resolutionStatus } = req.query

    let query = firebase
      .from('violations')
      .select(`
        *,
        violation_types:violation_type_id(id, code, name, severity)
      `)
      .order('violation_date', { ascending: false })

    if (vehicleId) {
      query = query.eq('vehicle_id', vehicleId as string)
    }
    if (driverId) {
      query = query.eq('driver_id', driverId as string)
    }
    if (dispatchRecordId) {
      query = query.eq('dispatch_record_id', dispatchRecordId as string)
    }
    if (resolutionStatus) {
      query = query.eq('resolution_status', resolutionStatus as string)
    }

    const { data, error } = await query

    if (error) throw error

    const violations = data.map((violation: any) => ({
      id: violation.id,
      dispatchRecordId: violation.dispatch_record_id,
      vehicleId: violation.vehicle_id,
      driverId: violation.driver_id,
      violationTypeId: violation.violation_type_id,
      violationType: violation.violation_types ? {
        id: violation.violation_types.id,
        code: violation.violation_types.code,
        name: violation.violation_types.name,
        severity: violation.violation_types.severity,
      } : undefined,
      violationDate: violation.violation_date,
      description: violation.description,
      resolutionStatus: violation.resolution_status,
      resolutionNotes: violation.resolution_notes,
      recordedBy: violation.recorded_by,
      createdAt: violation.created_at,
      updatedAt: violation.updated_at,
    }))

    return res.json(violations)
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch violations' })
  }
}

export const getViolationById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('violations')
      .select(`
        *,
        violation_types:violation_type_id(id, code, name, severity)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Violation not found' })
    }

    return res.json({
      id: data.id,
      dispatchRecordId: data.dispatch_record_id,
      vehicleId: data.vehicle_id,
      driverId: data.driver_id,
      violationTypeId: data.violation_type_id,
      violationType: data.violation_types ? {
        id: data.violation_types.id,
        code: data.violation_types.code,
        name: data.violation_types.name,
        severity: data.violation_types.severity,
      } : undefined,
      violationDate: data.violation_date,
      description: data.description,
      resolutionStatus: data.resolution_status,
      resolutionNotes: data.resolution_notes,
      recordedBy: data.recorded_by,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch violation' })
  }
}

export const createViolation = async (req: AuthRequest, res: Response) => {
  try {
    const validated = violationSchema.parse(req.body)
    const userId = req.user?.id

    const { data, error } = await firebase
      .from('violations')
      .insert({
        dispatch_record_id: validated.dispatchRecordId || null,
        vehicle_id: validated.vehicleId || null,
        driver_id: validated.driverId || null,
        violation_type_id: validated.violationTypeId,
        violation_date: validated.violationDate,
        description: validated.description || null,
        resolution_status: 'pending',
        recorded_by: userId || null,
      })
      .select(`
        *,
        violation_types:violation_type_id(id, code, name, severity)
      `)
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      dispatchRecordId: data.dispatch_record_id,
      vehicleId: data.vehicle_id,
      driverId: data.driver_id,
      violationTypeId: data.violation_type_id,
      violationType: data.violation_types ? {
        id: data.violation_types.id,
        code: data.violation_types.code,
        name: data.violation_types.name,
        severity: data.violation_types.severity,
      } : undefined,
      violationDate: data.violation_date,
      description: data.description,
      resolutionStatus: data.resolution_status,
      resolutionNotes: data.resolution_notes,
      recordedBy: data.recorded_by,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create violation' })
  }
}

export const updateViolation = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const { resolutionStatus, resolutionNotes } = req.body

    if (!resolutionStatus || !['pending', 'resolved', 'dismissed'].includes(resolutionStatus)) {
      return res.status(400).json({ error: 'Invalid resolution status' })
    }

    const { data, error } = await firebase
      .from('violations')
      .update({
        resolution_status: resolutionStatus,
        resolution_notes: resolutionNotes || null,
      })
      .eq('id', id)
      .select(`
        *,
        violation_types:violation_type_id(id, code, name, severity)
      `)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Violation not found' })
    }

    return res.json({
      id: data.id,
      dispatchRecordId: data.dispatch_record_id,
      vehicleId: data.vehicle_id,
      driverId: data.driver_id,
      violationTypeId: data.violation_type_id,
      violationType: data.violation_types ? {
        id: data.violation_types.id,
        code: data.violation_types.code,
        name: data.violation_types.name,
        severity: data.violation_types.severity,
      } : undefined,
      violationDate: data.violation_date,
      description: data.description,
      resolutionStatus: data.resolution_status,
      resolutionNotes: data.resolution_notes,
      recordedBy: data.recorded_by,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to update violation' })
  }
}

export const getAllViolationTypes = async (_req: Request, res: Response) => {
  try {
    const { data, error } = await firebase
      .from('violation_types')
      .select('*')
      .order('name', { ascending: true })

    if (error) throw error

    const violationTypes = data.map((vt: any) => ({
      id: vt.id,
      code: vt.code,
      name: vt.name,
      description: vt.description,
      severity: vt.severity,
      createdAt: vt.created_at,
    }))

    res.json(violationTypes)
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to fetch violation types' })
  }
}
</file>

<file path="server/src/lib/cache.ts">
/**
 * In-memory cache with TTL support
 * Reduces Firebase RTDB reads by caching frequently accessed data
 */

interface CacheEntry<T> {
  data: T
  expiry: number
  tags: string[]
}

interface CacheOptions {
  ttl?: number // Time to live in seconds
  tags?: string[] // Tags for cache invalidation
}

export class MemoryCache {
  private cache = new Map<string, CacheEntry<any>>()
  private defaultTTL = 60 // 60 seconds default

  // TTL presets for different data types
  static TTL = {
    SHORT: 30,      // 30s - for frequently changing data (dispatch)
    MEDIUM: 120,    // 2min - for moderately changing data (service charges)
    LONG: 300,      // 5min - for rarely changing data (vehicles, routes)
    STATIC: 600,    // 10min - for static data (provinces, vehicle types)
  }

  /**
   * Get cached value or execute getter function
   */
  async getOrSet<T>(
    key: string,
    getter: () => Promise<T>,
    options: CacheOptions = {}
  ): Promise<T> {
    const cached = this.get<T>(key)
    if (cached !== undefined) {
      return cached
    }

    const data = await getter()
    this.set(key, data, options)
    return data
  }

  /**
   * Get value from cache
   */
  get<T>(key: string): T | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined

    if (Date.now() > entry.expiry) {
      this.cache.delete(key)
      return undefined
    }

    return entry.data as T
  }

  /**
   * Set value in cache
   */
  set<T>(key: string, data: T, options: CacheOptions = {}): void {
    const ttl = options.ttl ?? this.defaultTTL
    const tags = options.tags ?? []

    this.cache.set(key, {
      data,
      expiry: Date.now() + ttl * 1000,
      tags,
    })
  }

  /**
   * Delete specific key
   */
  delete(key: string): boolean {
    return this.cache.delete(key)
  }

  /**
   * Invalidate all entries with specific tag
   */
  invalidateByTag(tag: string): number {
    let count = 0
    for (const [key, entry] of this.cache.entries()) {
      if (entry.tags.includes(tag)) {
        this.cache.delete(key)
        count++
      }
    }
    return count
  }

  /**
   * Invalidate entries matching pattern
   */
  invalidateByPattern(pattern: string): number {
    let count = 0
    const regex = new RegExp(pattern)
    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key)
        count++
      }
    }
    return count
  }

  /**
   * Clear all cache
   */
  clear(): void {
    this.cache.clear()
  }

  /**
   * Get cache statistics
   */
  stats(): { size: number; keys: string[] } {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys()),
    }
  }

  /**
   * Cleanup expired entries
   */
  cleanup(): number {
    let count = 0
    const now = Date.now()
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key)
        count++
      }
    }
    return count
  }
}

// Singleton instance
export const cache = new MemoryCache()

// Cache key generators
export const cacheKeys = {
  // Collections
  vehicles: () => 'vehicles:all',
  vehicleById: (id: string) => `vehicles:${id}`,
  vehiclesByOperator: (operatorId: string) => `vehicles:operator:${operatorId}`,
  
  drivers: () => 'drivers:all',
  driverById: (id: string) => `drivers:${id}`,
  driversByOperator: (operatorId: string) => `drivers:operator:${operatorId}`,
  
  routes: () => 'routes:all',
  routeById: (id: string) => `routes:${id}`,
  
  operators: () => 'operators:all',
  operatorById: (id: string) => `operators:${id}`,
  
  schedules: () => 'schedules:all',
  schedulesByRoute: (routeId: string) => `schedules:route:${routeId}`,
  
  services: () => 'services:all',
  serviceFormulas: () => 'service-formulas:all',
  
  vehicleTypes: () => 'vehicle-types:all',
  vehicleBadges: () => 'vehicle-badges:all',
  shifts: () => 'shifts:all',
  locations: () => 'locations:all',
  provinces: () => 'provinces:all',
  
  // Dispatch - shorter TTL due to frequent changes
  dispatchAll: () => 'dispatch:all',
  dispatchById: (id: string) => `dispatch:${id}`,
  dispatchByStatus: (status: string) => `dispatch:status:${status}`,
  
  // Service charges
  serviceChargesByDispatch: (dispatchId: string) => `service-charges:dispatch:${dispatchId}`,
}

// Cache tags for invalidation
export const cacheTags = {
  VEHICLES: 'vehicles',
  DRIVERS: 'drivers',
  ROUTES: 'routes',
  OPERATORS: 'operators',
  SCHEDULES: 'schedules',
  SERVICES: 'services',
  DISPATCH: 'dispatch',
  SERVICE_CHARGES: 'service-charges',
  STATIC: 'static', // For rarely changing data
}

// Auto cleanup every 5 minutes
setInterval(() => {
  const cleaned = cache.cleanup()
  if (cleaned > 0) {
    console.log(`[Cache] Cleaned ${cleaned} expired entries`)
  }
}, 5 * 60 * 1000)
</file>

<file path="server/src/middleware/auth.ts">
import type { Request, Response, NextFunction } from 'express'
import jwt from 'jsonwebtoken'

export interface AuthRequest extends Request {
  user?: {
    id: string
    username: string
    role: string
  }
  body: any
  headers: any
}

export const authenticate = (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' })
    }

    const token = authHeader.substring(7)
    const jwtSecret = process.env.JWT_SECRET!

    if (!jwtSecret) {
      return res.status(500).json({ error: 'JWT secret not configured' })
    }

    const decoded = jwt.verify(token, jwtSecret) as {
      id: string
      username: string
      role: string
    }

    req.user = decoded
    return next()
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({ error: 'Invalid token' })
    }
    return res.status(500).json({ error: 'Authentication error' })
  }
}

/**
 * Authorization middleware - checks if user has required role
 */
export const authorize = (...allowedRoles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' })
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Not authorized' })
    }

    return next()
  }
}
</file>

<file path="server/src/middleware/errorHandler.ts">
import { Request, Response, NextFunction } from 'express'

export const errorHandler = (
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  console.error('Error:', err)

  if (err.name === 'ValidationError') {
    return res.status(400).json({ error: err.message })
  }

  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({ error: 'Unauthorized' })
  }

  return res.status(500).json({
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : err.message
  })
}
</file>

<file path="server/src/middleware/upload.ts">
import multer, { FileFilterCallback, StorageEngine } from 'multer'
import path from 'path'
import { Request } from 'express'

// Configure storage
const storage: StorageEngine = multer.diskStorage({
  destination: function (_req: Request, _file: Express.Multer.File, cb: (error: Error | null, destination: string) => void) {
    cb(null, 'uploads/') // Make sure this directory exists
  },
  filename: function (_req: Request, file: Express.Multer.File, cb: (error: Error | null, filename: string) => void) {
    cb(null, `${Date.now()}-${file.originalname}`)
  }
})

// File filter
const fileFilter = (_req: Request, file: Express.Multer.File, cb: FileFilterCallback) => {
  const filetypes = /jpeg|jpg|png|gif|webp/
  const mimetype = filetypes.test(file.mimetype)
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase())

  if (mimetype && extname) {
    return cb(null, true)
  }
  cb(new Error('Only image files are allowed!'))
}

export const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: fileFilter
})
</file>

<file path="server/src/modules/chat/__tests__/ai.service.test.ts">
/**
 * AI Service Integration Tests
 * Tests for Gemini AI integration with function calling
 * 
 * Uses jest.unstable_mockModule() for ESM compatibility
 */

import { describe, it, expect, beforeEach, afterEach, jest, beforeAll } from '@jest/globals';

// Import mock data first
import {
  mockVehicles,
  mockDrivers,
  mockOperators,
  mockRoutes,
  mockBadges,
  mockDispatchRecords,
  mockSchedules,
  mockServices,
  mockShifts,
  mockInvoices,
  mockViolations,
  mockServiceCharges,
  createMockSnapshot,
} from './mocks/chat-mock-data.js';

// Store original env
const originalEnv = { ...process.env };

// Define typed mock functions at module scope
const mockOnce = jest.fn<(path: string) => Promise<{ val: () => any; exists: () => boolean }>>();
const mockSendMessage = jest.fn<() => Promise<{
  response: {
    text: () => string;
    functionCalls: () => any[] | null;
  };
}>>();
const mockStartChat = jest.fn(() => ({
  sendMessage: mockSendMessage,
}));
const mockGetGenerativeModel = jest.fn(() => ({
  startChat: mockStartChat,
}));

// Setup environment before mocking
process.env.GEMINI_API_KEY = 'test-api-key';

// Register Firebase mock
jest.unstable_mockModule('../../../config/database.js', () => ({
  firebaseDb: {
    ref: (path: string) => ({
      once: () => mockOnce(path),
    }),
  },
}));

// Register Gemini API mock
jest.unstable_mockModule('@google/generative-ai', () => ({
  GoogleGenerativeAI: jest.fn(() => ({
    getGenerativeModel: mockGetGenerativeModel,
  })),
  FunctionCallingMode: {
    AUTO: 'AUTO',
  },
  SchemaType: {
    OBJECT: 'OBJECT',
    STRING: 'STRING',
  },
}));

// Dynamic import AFTER mock registration
const { aiService } = await import('../services/ai.service.js');
const { chatCacheService } = await import('../services/chat-cache.service.js');

// Helper to setup collection mocks
const setupCollectionMocks = () => {
  mockOnce.mockImplementation((path: string) => {
    const collectionMap: Record<string, any[]> = {
      'datasheet/Xe': mockVehicles,
      'datasheet/PHUHIEUXE': mockBadges,
      'datasheet/DONVIVANTAI': mockOperators,
      'datasheet/DANHMUCTUYENCODINH': mockRoutes,
      'drivers': mockDrivers,
      'dispatch_records': mockDispatchRecords,
      'schedules': mockSchedules,
      'services': mockServices,
      'shifts': mockShifts,
      'invoices': mockInvoices,
      'violations': mockViolations,
      'service_charges': mockServiceCharges,
    };
    const data = collectionMap[path] || [];
    return Promise.resolve(createMockSnapshot(data));
  });
};

describe('AIService', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
    process.env.GEMINI_API_KEY = 'test-api-key';
    setupCollectionMocks();
    await chatCacheService.preWarm();

    // Default mock response (no function calls)
    mockSendMessage.mockResolvedValue({
      response: {
        text: () => 'This is a test response',
        functionCalls: () => null,
      },
    });
  });

  afterEach(() => {
    process.env = { ...originalEnv };
  });

  describe('generateResponse', () => {
    it('should generate response for simple message', async () => {
      const response = await aiService.generateResponse('Hello', 'session-1');
      expect(typeof response).toBe('string');
      expect(response.length).toBeGreaterThan(0);
    });

    it('should call AI model with message', async () => {
      await aiService.generateResponse('Test message', 'session-test');
      expect(mockStartChat).toHaveBeenCalled();
      expect(mockSendMessage).toHaveBeenCalled();
    });

    it('should handle function calling response', async () => {
      // Mock function call response followed by text response
      mockSendMessage
        .mockResolvedValueOnce({
          response: {
            text: () => '',
            functionCalls: () => [
              {
                name: 'search_vehicle',
                args: { plate_number: '98H07480' },
              },
            ],
          },
        })
        .mockResolvedValueOnce({
          response: {
            text: () => 'Found vehicle 98H07480',
            functionCalls: () => null,
          },
        });

      const response = await aiService.generateResponse('xe 98H07480', 'session-fc-1');
      expect(typeof response).toBe('string');
      expect(mockSendMessage).toHaveBeenCalledTimes(2);
    });

    it('should handle multiple function calls', async () => {
      mockSendMessage
        .mockResolvedValueOnce({
          response: {
            text: () => '',
            functionCalls: () => [
              { name: 'search_vehicle', args: { plate_number: '98H07480' } },
              { name: 'get_system_stats', args: {} },
            ],
          },
        })
        .mockResolvedValueOnce({
          response: {
            text: () => 'Results found',
            functionCalls: () => null,
          },
        });

      const response = await aiService.generateResponse('xe va thong ke', 'session-mfc-1');
      expect(typeof response).toBe('string');
    });

    it('should limit function call iterations to 3', async () => {
      // Mock infinite loop scenario
      mockSendMessage.mockResolvedValue({
        response: {
          text: () => '',
          functionCalls: () => [{ name: 'get_system_stats', args: {} }],
        },
      });

      await aiService.generateResponse('test infinite', 'session-limit');
      // Should be called max 4 times (1 initial + 3 iterations)
      expect(mockSendMessage.mock.calls.length).toBeLessThanOrEqual(4);
    });
  });

  describe('Error Handling', () => {
    it('should return fallback response on API error', async () => {
      mockSendMessage.mockRejectedValue(new Error('API Error'));

      const response = await aiService.generateResponse('test error', 'session-error');
      expect(typeof response).toBe('string');
      expect(response.length).toBeGreaterThan(0);
    });

    it('should use cached data for fallback when available', async () => {
      mockSendMessage.mockRejectedValue(new Error('API Error'));

      const response = await aiService.generateResponse('xe 98H07480', 'session-fallback');
      expect(typeof response).toBe('string');
    });
  });

  describe('clearHistory', () => {
    it('should clear conversation history for session', async () => {
      await aiService.generateResponse('Message 1', 'session-clear');
      aiService.clearHistory('session-clear');

      // Next call should start fresh
      await aiService.generateResponse('Message 2', 'session-clear');
      expect(mockStartChat).toHaveBeenCalled();
    });

    it('should not throw when clearing non-existent session', () => {
      expect(() => aiService.clearHistory('non-existent-session')).not.toThrow();
    });
  });

  describe('hasApiKey', () => {
    it('should return true when API key is set', () => {
      expect(aiService.hasApiKey()).toBe(true);
    });
  });

  describe('Fallback Response Generation', () => {
    beforeEach(() => {
      mockSendMessage.mockRejectedValue(new Error('API Error'));
    });

    it('should search cached data for plate patterns', async () => {
      const response = await aiService.generateResponse('xe 98H07480', 'session-fb-1');
      expect(typeof response).toBe('string');
    });

    it('should provide helpful suggestions in fallback', async () => {
      const response = await aiService.generateResponse('random query', 'session-fb-2');
      expect(response).toContain('xe');
    });
  });

  describe('Session Management', () => {
    it('should create separate history for each session', async () => {
      await aiService.generateResponse('Session 1 message', 'session-a');
      await aiService.generateResponse('Session 2 message', 'session-b');
      await aiService.generateResponse('Session 3 message', 'session-c');

      expect(mockStartChat.mock.calls.length).toBeGreaterThanOrEqual(3);
    });

    it('should handle rapid messages in same session', async () => {
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(aiService.generateResponse(`Message ${i}`, 'rapid-session'));
      }

      const responses = await Promise.all(promises);
      responses.forEach((r) => expect(typeof r).toBe('string'));
    });
  });

  describe('Vietnamese Language Processing', () => {
    it('should handle Vietnamese queries', async () => {
      const response = await aiService.generateResponse('tim xe bien so 98H07480', 'session-vn-1');
      expect(typeof response).toBe('string');
    });

    it('should handle queries without diacritics', async () => {
      const response = await aiService.generateResponse('don vi van tai Phuong Trang', 'session-vn-2');
      expect(typeof response).toBe('string');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty message', async () => {
      const response = await aiService.generateResponse('', 'session-empty');
      expect(typeof response).toBe('string');
    });

    it('should handle very long message', async () => {
      const longMessage = 'test '.repeat(200);
      const response = await aiService.generateResponse(longMessage, 'session-long');
      expect(typeof response).toBe('string');
    });

    it('should handle special characters in message', async () => {
      const response = await aiService.generateResponse('!@#$%^&*()', 'session-special');
      expect(typeof response).toBe('string');
    });

    it('should handle unicode characters', async () => {
      const response = await aiService.generateResponse('emoji test 🚌🚗', 'session-unicode');
      expect(typeof response).toBe('string');
    });

    it('should handle newlines in message', async () => {
      const response = await aiService.generateResponse('line1\nline2\nline3', 'session-newline');
      expect(typeof response).toBe('string');
    });
  });

  describe('Function Call Result Formatting', () => {
    it('should format vehicle search results', async () => {
      mockSendMessage
        .mockResolvedValueOnce({
          response: {
            text: () => '',
            functionCalls: () => [{ name: 'search_vehicle', args: { plate_number: '98H07480' } }],
          },
        })
        .mockResolvedValueOnce({
          response: {
            text: () => 'Xe 98H07480 - Xe khach 45 cho',
            functionCalls: () => null,
          },
        });

      const response = await aiService.generateResponse('xe 98H07480', 'session-format-1');
      expect(response).toContain('98H07480');
    });

    it('should format system stats results', async () => {
      mockSendMessage
        .mockResolvedValueOnce({
          response: {
            text: () => '',
            functionCalls: () => [{ name: 'get_system_stats', args: {} }],
          },
        })
        .mockResolvedValueOnce({
          response: {
            text: () => 'He thong co 3 xe, 3 tai xe',
            functionCalls: () => null,
          },
        });

      const response = await aiService.generateResponse('thong ke he thong', 'session-format-2');
      expect(typeof response).toBe('string');
    });
  });

  describe('Rate Limiting & Concurrent Requests', () => {
    it('should handle concurrent requests to same session', async () => {
      const requests = [
        aiService.generateResponse('Query 1', 'concurrent-session'),
        aiService.generateResponse('Query 2', 'concurrent-session'),
        aiService.generateResponse('Query 3', 'concurrent-session'),
      ];

      const responses = await Promise.all(requests);
      responses.forEach((r) => expect(typeof r).toBe('string'));
    });

    it('should handle concurrent requests to different sessions', async () => {
      const requests = [
        aiService.generateResponse('Query', 'session-x'),
        aiService.generateResponse('Query', 'session-y'),
        aiService.generateResponse('Query', 'session-z'),
      ];

      const responses = await Promise.all(requests);
      responses.forEach((r) => expect(typeof r).toBe('string'));
    });
  });
});
</file>

<file path="server/src/modules/chat/__tests__/chat-cache.service.test.ts">
/**
 * ChatCacheService Unit Tests
 * Tests for cache service with indexed search functionality
 * 
 * Uses jest.unstable_mockModule() for ESM compatibility
 */

import { describe, it, expect, beforeEach, afterEach, jest, beforeAll } from '@jest/globals';

// Import mock data first (no mocking needed)
import {
  mockVehicles,
  mockDrivers,
  mockOperators,
  mockRoutes,
  mockBadges,
  mockDispatchRecords,
  mockSchedules,
  mockServices,
  mockShifts,
  mockInvoices,
  mockViolations,
  mockServiceCharges,
  createMockSnapshot,
  plateVariations,
} from './mocks/chat-mock-data.js';

// Define typed mock function at module scope BEFORE mock registration
const mockOnce = jest.fn<(path: string) => Promise<{ val: () => any; exists: () => boolean }>>();

// Register mock BEFORE importing the service (ESM requirement)
jest.unstable_mockModule('../../../config/database.js', () => ({
  firebaseDb: {
    ref: (path: string) => ({
      once: () => mockOnce(path),
    }),
  },
}));

// Dynamic import AFTER mock registration
const { chatCacheService } = await import('../services/chat-cache.service.js');

// Helper to setup mock for all collections
const setupCollectionMocks = () => {
  mockOnce.mockImplementation((path: string) => {
    const collectionMap: Record<string, any[]> = {
      'datasheet/Xe': mockVehicles,
      'datasheet/PHUHIEUXE': mockBadges,
      'datasheet/DONVIVANTAI': mockOperators,
      'datasheet/DANHMUCTUYENCODINH': mockRoutes,
      'drivers': mockDrivers,
      'dispatch_records': mockDispatchRecords,
      'schedules': mockSchedules,
      'services': mockServices,
      'shifts': mockShifts,
      'invoices': mockInvoices,
      'violations': mockViolations,
      'service_charges': mockServiceCharges,
    };
    const data = collectionMap[path] || [];
    return Promise.resolve(createMockSnapshot(data));
  });
};

describe('ChatCacheService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    setupCollectionMocks();
  });

  afterEach(() => {
    jest.clearAllTimers();
  });

  describe('preWarm', () => {
    it('should load all collections into cache', async () => {
      await chatCacheService.preWarm();
      expect(chatCacheService.isReady()).toBe(true);
    });

    it('should call Firebase for each collection', async () => {
      await chatCacheService.preWarm();
      expect(mockOnce).toHaveBeenCalled();
      // Should be called for 12 collections
      expect(mockOnce.mock.calls.length).toBeGreaterThanOrEqual(12);
    });

    it('should handle empty collections gracefully', async () => {
      mockOnce.mockImplementation(() => Promise.resolve({ val: () => null, exists: () => false }));
      await chatCacheService.preWarm();
      expect(chatCacheService.isReady()).toBe(true);
    });

    it('should handle Firebase errors gracefully', async () => {
      mockOnce.mockImplementation(() => Promise.reject(new Error('Firebase error')));
      await chatCacheService.preWarm();
      expect(chatCacheService.isReady()).toBe(true);
    });
  });

  describe('searchVehicleByPlate', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should find vehicle by exact plate number', () => {
      const results = chatCacheService.searchVehicleByPlate('98H07480');
      expect(results.length).toBeGreaterThan(0);
      expect(results[0].BienSo || results[0].plate_number).toBe('98H07480');
    });

    it('should find vehicle with different plate formats', () => {
      const variations = plateVariations['98H07480'];
      variations.forEach((variation: string) => {
        const results = chatCacheService.searchVehicleByPlate(variation);
        expect(results.length).toBeGreaterThan(0);
      });
    });

    it('should find vehicle by partial plate number', () => {
      const results = chatCacheService.searchVehicleByPlate('07480');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should be case-insensitive', () => {
      const upperResults = chatCacheService.searchVehicleByPlate('98H07480');
      const lowerResults = chatCacheService.searchVehicleByPlate('98h07480');
      expect(upperResults.length).toBe(lowerResults.length);
    });

    it('should return empty array for non-existent plate', () => {
      const results = chatCacheService.searchVehicleByPlate('ZZZZZZZ');
      expect(results).toEqual([]);
    });

    it('should handle special characters in plate number', () => {
      const results = chatCacheService.searchVehicleByPlate('98H-07480');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should handle empty string input', () => {
      const results = chatCacheService.searchVehicleByPlate('');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should deduplicate results', () => {
      const results = chatCacheService.searchVehicleByPlate('98H07480');
      const ids = results.map((r: any) => r.id);
      const uniqueIds = [...new Set(ids)];
      expect(ids.length).toBe(uniqueIds.length);
    });
  });

  describe('searchDriverByName', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should find driver by full name', () => {
      const results = chatCacheService.searchDriverByName('Nguyen Van An');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find driver by partial name', () => {
      const results = chatCacheService.searchDriverByName('Nguyen');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should be case-insensitive', () => {
      const upperResults = chatCacheService.searchDriverByName('NGUYEN');
      const lowerResults = chatCacheService.searchDriverByName('nguyen');
      expect(upperResults.length).toBe(lowerResults.length);
    });

    it('should handle Vietnamese text without diacritics', () => {
      const results = chatCacheService.searchDriverByName('nguyen van an');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty array for non-existent driver', () => {
      const results = chatCacheService.searchDriverByName('Nonexistent Driver Name');
      expect(results).toEqual([]);
    });

    it('should handle empty string input', () => {
      const results = chatCacheService.searchDriverByName('');
      expect(Array.isArray(results)).toBe(true);
    });
  });

  describe('searchOperatorByName', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should find operator by name', () => {
      const results = chatCacheService.searchOperatorByName('Phuong Trang');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find operator by partial name', () => {
      const results = chatCacheService.searchOperatorByName('Mai Linh');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should be case-insensitive', () => {
      const results = chatCacheService.searchOperatorByName('phuong trang');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should handle Vietnamese text normalization', () => {
      const results = chatCacheService.searchOperatorByName('thanh buoi');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty array for non-existent operator', () => {
      const results = chatCacheService.searchOperatorByName('Nonexistent Company');
      expect(results).toEqual([]);
    });
  });

  describe('searchRouteByCode', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should find route by code', () => {
      const results = chatCacheService.searchRouteByCode('TPHCM-DALAT-001');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find route by departure station', () => {
      const results = chatCacheService.searchRouteByCode('TP.HCM');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find route by arrival station', () => {
      const results = chatCacheService.searchRouteByCode('Da Lat');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should be case-insensitive', () => {
      const results = chatCacheService.searchRouteByCode('tphcm');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty array for non-existent route', () => {
      const results = chatCacheService.searchRouteByCode('NONEXISTENT');
      expect(results).toEqual([]);
    });
  });

  describe('searchBadgeByNumber', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should find badge by number', () => {
      const results = chatCacheService.searchBadgeByNumber('PH-12345');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find badge by plate number', () => {
      const results = chatCacheService.searchBadgeByNumber('98H07480');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should handle partial badge number', () => {
      const results = chatCacheService.searchBadgeByNumber('12345');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty array for non-existent badge', () => {
      const results = chatCacheService.searchBadgeByNumber('NONEXISTENT');
      expect(results).toEqual([]);
    });
  });

  describe('getDispatchStats', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return stats for today when no date provided', () => {
      const stats = chatCacheService.getDispatchStats();
      expect(stats).toHaveProperty('date');
      expect(stats).toHaveProperty('entered');
      expect(stats).toHaveProperty('departed');
      expect(stats).toHaveProperty('total');
    });

    it('should return stats for specific date', () => {
      const stats = chatCacheService.getDispatchStats('2025-12-25');
      expect(stats.date).toBe('2025-12-25');
      expect(typeof stats.entered).toBe('number');
      expect(typeof stats.departed).toBe('number');
    });

    it('should return zero stats for date with no records', () => {
      const stats = chatCacheService.getDispatchStats('2020-01-01');
      expect(stats.entered).toBe(0);
      expect(stats.departed).toBe(0);
    });
  });

  describe('getSystemStats', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return stats for all collections', () => {
      const stats = chatCacheService.getSystemStats();
      expect(stats).toHaveProperty('vehicles');
      expect(stats).toHaveProperty('badges');
      expect(stats).toHaveProperty('operators');
      expect(stats).toHaveProperty('routes');
      expect(stats).toHaveProperty('drivers');
      expect(stats).toHaveProperty('dispatch_records');
      expect(stats).toHaveProperty('schedules');
      expect(stats).toHaveProperty('services');
      expect(stats).toHaveProperty('shifts');
      expect(stats).toHaveProperty('invoices');
      expect(stats).toHaveProperty('violations');
      expect(stats).toHaveProperty('service_charges');
      expect(stats).toHaveProperty('lastRefresh');
    });

    it('should return correct counts', () => {
      const stats = chatCacheService.getSystemStats();
      expect(stats.vehicles).toBe(mockVehicles.length);
      expect(stats.drivers).toBe(mockDrivers.length);
      expect(stats.operators).toBe(mockOperators.length);
    });
  });

  describe('searchSchedules', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return schedules without search term', () => {
      const results = chatCacheService.searchSchedules('');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should return schedules for "today"', () => {
      const results = chatCacheService.searchSchedules('today');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should find schedule by code', () => {
      const results = chatCacheService.searchSchedules('SCH-001');
      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('searchServices', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return services without search term', () => {
      const results = chatCacheService.searchServices('');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should find service by name', () => {
      const results = chatCacheService.searchServices('Rua xe');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should find service by code', () => {
      const results = chatCacheService.searchServices('SV-RX');
      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('getShiftInfo', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return shifts without date', () => {
      const results = chatCacheService.getShiftInfo();
      expect(Array.isArray(results)).toBe(true);
    });

    it('should return shifts for specific date', () => {
      const results = chatCacheService.getShiftInfo('2025-12-25');
      expect(Array.isArray(results)).toBe(true);
    });
  });

  describe('getInvoices', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return invoices without date', () => {
      const results = chatCacheService.getInvoices();
      expect(Array.isArray(results)).toBe(true);
    });

    it('should return invoices for specific date', () => {
      const results = chatCacheService.getInvoices('2025-12-25');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should respect limit parameter', () => {
      const results = chatCacheService.getInvoices(undefined, 1);
      expect(results.length).toBeLessThanOrEqual(1);
    });
  });

  describe('getViolations', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return all violations without plate', () => {
      const results = chatCacheService.getViolations();
      expect(Array.isArray(results)).toBe(true);
    });

    it('should return violations for specific plate', () => {
      const results = chatCacheService.getViolations('98H07480');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty for plate with no violations', () => {
      const results = chatCacheService.getViolations('NONEXISTENT');
      expect(results).toEqual([]);
    });
  });

  describe('getServiceCharges', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should return all charges without service filter', () => {
      const results = chatCacheService.getServiceCharges();
      expect(Array.isArray(results)).toBe(true);
    });

    it('should return charges for specific service', () => {
      const results = chatCacheService.getServiceCharges('Phi vao ben');
      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('fuzzySearch', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should detect and search plate numbers', () => {
      const results = chatCacheService.fuzzySearch('xe 98H07480');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should search across multiple collections', () => {
      const results = chatCacheService.fuzzySearch('Phuong Trang');
      expect(results.length).toBeGreaterThan(0);
    });

    it('should limit results to 10', () => {
      const results = chatCacheService.fuzzySearch('a');
      expect(results.length).toBeLessThanOrEqual(10);
    });

    it('should handle empty query', () => {
      const results = chatCacheService.fuzzySearch('');
      expect(Array.isArray(results)).toBe(true);
    });
  });

  describe('isReady', () => {
    it('should return boolean', () => {
      expect(typeof chatCacheService.isReady()).toBe('boolean');
    });

    it('should return true after preWarm', async () => {
      await chatCacheService.preWarm();
      expect(chatCacheService.isReady()).toBe(true);
    });
  });

  describe('Text Normalization', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should normalize plate numbers correctly', () => {
      const variations = ['98H07480', '98H-07480', '98H 07480', '98h07480'];
      variations.forEach((v) => {
        const results = chatCacheService.searchVehicleByPlate(v);
        expect(results.length).toBeGreaterThan(0);
      });
    });

    it('should handle mixed case in operator names', () => {
      const variations = ['Phuong Trang', 'PHUONG TRANG', 'phuong trang'];
      variations.forEach((v) => {
        const results = chatCacheService.searchOperatorByName(v);
        expect(results.length).toBeGreaterThan(0);
      });
    });
  });

  describe('Edge Cases', () => {
    beforeEach(async () => {
      await chatCacheService.preWarm();
    });

    it('should handle very long search terms', () => {
      const longQuery = 'a'.repeat(1000);
      const results = chatCacheService.fuzzySearch(longQuery);
      expect(Array.isArray(results)).toBe(true);
    });

    it('should handle special characters', () => {
      const specialChars = '!@#$%^&*()[]{}';
      const results = chatCacheService.fuzzySearch(specialChars);
      expect(Array.isArray(results)).toBe(true);
    });

    it('should handle numeric-only queries', () => {
      const results = chatCacheService.fuzzySearch('12345');
      expect(Array.isArray(results)).toBe(true);
    });

    it('should handle whitespace-only queries', () => {
      const results = chatCacheService.fuzzySearch('   ');
      expect(Array.isArray(results)).toBe(true);
    });
  });
});
</file>

<file path="server/src/modules/chat/__tests__/chat-functions.test.ts">
/**
 * Chat Functions Unit Tests
 * Tests for the 13 function definitions used by Gemini AI
 * 
 * Uses jest.unstable_mockModule() for ESM compatibility
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';

// Import mock data first (no mocking needed)
import {
  mockVehicles,
  mockDrivers,
  mockOperators,
  mockRoutes,
  mockBadges,
  mockDispatchRecords,
  mockSchedules,
  mockServices,
  mockShifts,
  mockInvoices,
  mockViolations,
  mockServiceCharges,
  createMockSnapshot,
} from './mocks/chat-mock-data.js';

// Define typed mock function at module scope
const mockOnce = jest.fn<(path: string) => Promise<{ val: () => any; exists: () => boolean }>>();

// Register mock BEFORE importing the service
jest.unstable_mockModule('../../../config/database.js', () => ({
  firebaseDb: {
    ref: (path: string) => ({
      once: () => mockOnce(path),
    }),
  },
}));

// Dynamic import AFTER mock registration
const { executeFunction, CHAT_FUNCTIONS } = await import('../services/chat-functions.js');
const { chatCacheService } = await import('../services/chat-cache.service.js');

// Helper to setup mock for all collections
const setupCollectionMocks = () => {
  mockOnce.mockImplementation((path: string) => {
    const collectionMap: Record<string, any[]> = {
      'datasheet/Xe': mockVehicles,
      'datasheet/PHUHIEUXE': mockBadges,
      'datasheet/DONVIVANTAI': mockOperators,
      'datasheet/DANHMUCTUYENCODINH': mockRoutes,
      'drivers': mockDrivers,
      'dispatch_records': mockDispatchRecords,
      'schedules': mockSchedules,
      'services': mockServices,
      'shifts': mockShifts,
      'invoices': mockInvoices,
      'violations': mockViolations,
      'service_charges': mockServiceCharges,
    };
    const data = collectionMap[path] || [];
    return Promise.resolve(createMockSnapshot(data));
  });
};

describe('Chat Functions', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
    setupCollectionMocks();
    await chatCacheService.preWarm();
  });

  describe('CHAT_FUNCTIONS definitions', () => {
    it('should have 13 function definitions', () => {
      expect(CHAT_FUNCTIONS).toHaveLength(13);
    });

    it('should have required properties for each function', () => {
      CHAT_FUNCTIONS.forEach((fn: any) => {
        expect(fn).toHaveProperty('name');
        expect(fn).toHaveProperty('description');
        expect(fn).toHaveProperty('parameters');
      });
    });

    it('should have Vietnamese descriptions', () => {
      CHAT_FUNCTIONS.forEach((fn: any) => {
        expect(fn.description.length).toBeGreaterThan(10);
      });
    });

    const expectedFunctions = [
      'search_vehicle',
      'search_driver',
      'search_operator',
      'search_route',
      'search_badge',
      'get_dispatch_stats',
      'get_system_stats',
      'search_schedule',
      'search_service',
      'get_shift_info',
      'get_invoices',
      'get_violations',
      'get_service_charges',
    ];

    expectedFunctions.forEach((fnName) => {
      it(`should include ${fnName} function`, () => {
        const fn = CHAT_FUNCTIONS.find((f: any) => f.name === fnName);
        expect(fn).toBeDefined();
      });
    });
  });

  describe('search_vehicle', () => {
    it('should find vehicle by valid plate number', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: '98H07480' });
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data.length).toBeGreaterThan(0);
    });

    it('should return error for non-existent plate', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: 'NONEXISTENT' });
      expect(result.success).toBe(false);
      expect(result.error).toContain('NONEXISTENT');
    });

    it('should handle empty plate number', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: '' });
      expect(result.success).toBe(false);
    });

    it('should handle plate with different formats', async () => {
      const formats = ['98H07480', '98H-07480', '98h07480'];
      for (const format of formats) {
        const result = await executeFunction('search_vehicle', { plate_number: format });
        expect(result.success).toBe(true);
      }
    });

    it('should handle missing plate_number parameter', async () => {
      const result = await executeFunction('search_vehicle', {});
      expect(result.success).toBe(false);
    });
  });

  describe('search_driver', () => {
    it('should find driver by name', async () => {
      const result = await executeFunction('search_driver', { name: 'Nguyen Van An' });
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should find driver by partial name', async () => {
      const result = await executeFunction('search_driver', { name: 'Nguyen' });
      expect(result.success).toBe(true);
    });

    it('should return error for non-existent driver', async () => {
      const result = await executeFunction('search_driver', { name: 'Nonexistent Driver' });
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should handle empty name', async () => {
      const result = await executeFunction('search_driver', { name: '' });
      expect(result.success).toBe(false);
    });

    it('should be case-insensitive', async () => {
      const result = await executeFunction('search_driver', { name: 'nguyen van an' });
      expect(result.success).toBe(true);
    });
  });

  describe('search_operator', () => {
    it('should find operator by name', async () => {
      const result = await executeFunction('search_operator', { name: 'Phuong Trang' });
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should find operator by partial name', async () => {
      const result = await executeFunction('search_operator', { name: 'Mai Linh' });
      expect(result.success).toBe(true);
    });

    it('should return error for non-existent operator', async () => {
      const result = await executeFunction('search_operator', { name: 'Nonexistent Company' });
      expect(result.success).toBe(false);
    });

    it('should handle empty name', async () => {
      const result = await executeFunction('search_operator', { name: '' });
      expect(result.success).toBe(false);
    });
  });

  describe('search_route', () => {
    it('should find route by code', async () => {
      const result = await executeFunction('search_route', { search_term: 'TPHCM-DALAT-001' });
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should find route by station name', async () => {
      const result = await executeFunction('search_route', { search_term: 'Da Lat' });
      expect(result.success).toBe(true);
    });

    it('should return error for non-existent route', async () => {
      const result = await executeFunction('search_route', { search_term: 'NONEXISTENT' });
      expect(result.success).toBe(false);
    });

    it('should handle empty search term', async () => {
      const result = await executeFunction('search_route', { search_term: '' });
      expect(result.success).toBe(false);
    });
  });

  describe('search_badge', () => {
    it('should find badge by number', async () => {
      const result = await executeFunction('search_badge', { number: 'PH-12345' });
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should find badge by plate number', async () => {
      const result = await executeFunction('search_badge', { number: '98H07480' });
      expect(result.success).toBe(true);
    });

    it('should return error for non-existent badge', async () => {
      const result = await executeFunction('search_badge', { number: 'NONEXISTENT' });
      expect(result.success).toBe(false);
    });

    it('should handle empty number', async () => {
      const result = await executeFunction('search_badge', { number: '' });
      expect(result.success).toBe(false);
    });
  });

  describe('get_dispatch_stats', () => {
    it('should return stats without date (today)', async () => {
      const result = await executeFunction('get_dispatch_stats', {});
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('date');
      expect(result.data).toHaveProperty('entered');
      expect(result.data).toHaveProperty('departed');
      expect(result.data).toHaveProperty('total');
    });

    it('should return stats for specific date', async () => {
      const result = await executeFunction('get_dispatch_stats', { date: '2025-12-25' });
      expect(result.success).toBe(true);
      expect(result.data.date).toBe('2025-12-25');
    });

    it('should handle date with no records', async () => {
      const result = await executeFunction('get_dispatch_stats', { date: '2020-01-01' });
      expect(result.success).toBe(true);
      expect(result.data.entered).toBe(0);
    });
  });

  describe('get_system_stats', () => {
    it('should return complete system statistics', async () => {
      const result = await executeFunction('get_system_stats', {});
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('vehicles');
      expect(result.data).toHaveProperty('drivers');
      expect(result.data).toHaveProperty('operators');
      expect(result.data).toHaveProperty('routes');
      expect(result.data).toHaveProperty('badges');
      expect(result.data).toHaveProperty('lastRefresh');
    });

    it('should return correct counts', async () => {
      const result = await executeFunction('get_system_stats', {});
      expect(result.data.vehicles).toBe(mockVehicles.length);
      expect(result.data.drivers).toBe(mockDrivers.length);
    });
  });

  describe('search_schedule', () => {
    it('should return schedules without term', async () => {
      const result = await executeFunction('search_schedule', {});
      expect(result.success).toBe(true);
    });

    it('should find schedule by code', async () => {
      const result = await executeFunction('search_schedule', { term: 'SCH-001' });
      expect(result.success).toBe(true);
    });

    it('should return message when no schedules found', async () => {
      const result = await executeFunction('search_schedule', { term: 'NONEXISTENT' });
      expect(result.success).toBe(true);
    });
  });

  describe('search_service', () => {
    it('should return services without term', async () => {
      const result = await executeFunction('search_service', {});
      expect(result.success).toBe(true);
    });

    it('should find service by name', async () => {
      const result = await executeFunction('search_service', { term: 'Rua xe' });
      expect(result.success).toBe(true);
    });

    it('should find service by code', async () => {
      const result = await executeFunction('search_service', { term: 'SV-RX' });
      expect(result.success).toBe(true);
    });
  });

  describe('get_shift_info', () => {
    it('should return shifts without date', async () => {
      const result = await executeFunction('get_shift_info', {});
      expect(result.success).toBe(true);
    });

    it('should return shifts for specific date', async () => {
      const result = await executeFunction('get_shift_info', { date: '2025-12-25' });
      expect(result.success).toBe(true);
    });

    it('should return message when no shifts found', async () => {
      const result = await executeFunction('get_shift_info', { date: '2020-01-01' });
      expect(result.success).toBe(true);
    });
  });

  describe('get_invoices', () => {
    it('should return invoices without date', async () => {
      const result = await executeFunction('get_invoices', {});
      expect(result.success).toBe(true);
    });

    it('should return invoices for specific date', async () => {
      const result = await executeFunction('get_invoices', { date: '2025-12-25' });
      expect(result.success).toBe(true);
    });

    it('should return message when no invoices found', async () => {
      const result = await executeFunction('get_invoices', { date: '2020-01-01' });
      expect(result.success).toBe(true);
    });
  });

  describe('get_violations', () => {
    it('should return all violations without plate', async () => {
      const result = await executeFunction('get_violations', {});
      expect(result.success).toBe(true);
    });

    it('should return violations for specific plate', async () => {
      const result = await executeFunction('get_violations', { plate_number: '98H07480' });
      expect(result.success).toBe(true);
    });

    it('should return message when no violations found', async () => {
      const result = await executeFunction('get_violations', { plate_number: 'NONEXISTENT' });
      expect(result.success).toBe(true);
      expect(result.data.message).toBeDefined();
    });
  });

  describe('get_service_charges', () => {
    it('should return all charges without service filter', async () => {
      const result = await executeFunction('get_service_charges', {});
      expect(result.success).toBe(true);
    });

    it('should return charges for specific service', async () => {
      const result = await executeFunction('get_service_charges', { service: 'Phi vao ben' });
      expect(result.success).toBe(true);
    });

    it('should return message when no charges found', async () => {
      const result = await executeFunction('get_service_charges', { service: 'NONEXISTENT' });
      expect(result.success).toBe(true);
    });
  });

  describe('Unknown function', () => {
    it('should return error for unknown function name', async () => {
      const result = await executeFunction('unknown_function', {});
      expect(result.success).toBe(false);
      expect(result.error).toContain('Unknown function');
    });
  });

  describe('Error handling', () => {
    it('should handle null arguments gracefully', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: null as any });
      expect(result).toHaveProperty('success');
    });
  });

  describe('Vietnamese Language Support', () => {
    it('should search with Vietnamese text', async () => {
      const result = await executeFunction('search_operator', { name: 'Phuong Trang' });
      expect(result.success).toBe(true);
    });

    it('should search without diacritics', async () => {
      const result = await executeFunction('search_driver', { name: 'nguyen van an' });
      expect(result.success).toBe(true);
    });

    it('should handle mixed case Vietnamese', async () => {
      const result = await executeFunction('search_operator', { name: 'PHUONG TRANG' });
      expect(result.success).toBe(true);
    });
  });

  describe('Edge Cases', () => {
    it('should handle very long input strings', async () => {
      const longString = 'a'.repeat(1000);
      const result = await executeFunction('search_vehicle', { plate_number: longString });
      expect(result).toHaveProperty('success');
    });

    it('should handle special characters', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: '!@#$%^&*()' });
      expect(result).toHaveProperty('success');
    });

    it('should handle whitespace-only input', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: '   ' });
      expect(result).toHaveProperty('success');
    });

    it('should handle numeric-only input', async () => {
      const result = await executeFunction('search_vehicle', { plate_number: '12345' });
      expect(result).toHaveProperty('success');
    });
  });
});
</file>

<file path="server/src/modules/chat/__tests__/chat.controller.test.ts">
/**
 * Chat Controller E2E Tests
 * Tests for HTTP endpoints and request handling
 * 
 * Uses jest.unstable_mockModule() for ESM compatibility
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import type { Request, Response } from 'express';

// Import mock data first
import {
  mockVehicles,
  mockDrivers,
  mockOperators,
  mockRoutes,
  mockBadges,
  mockDispatchRecords,
  mockSchedules,
  mockServices,
  mockShifts,
  mockInvoices,
  mockViolations,
  mockServiceCharges,
  createMockSnapshot,
} from './mocks/chat-mock-data.js';

// Define typed mock functions at module scope
const mockOnce = jest.fn<(path: string) => Promise<{ val: () => any; exists: () => boolean }>>();
const mockGenerateResponse = jest.fn<(message: string, sessionId: string) => Promise<string>>();
const mockClearHistory = jest.fn<(sessionId: string) => void>();

// Register Firebase mock
jest.unstable_mockModule('../../../config/database.js', () => ({
  firebaseDb: {
    ref: (path: string) => ({
      once: () => mockOnce(path),
    }),
  },
}));

// Register AI service mock
jest.unstable_mockModule('../services/ai.service.js', () => ({
  aiService: {
    generateResponse: mockGenerateResponse,
    clearHistory: mockClearHistory,
    hasApiKey: () => true,
  },
}));

// Dynamic import AFTER mock registration
const { processMessage, clearHistory } = await import('../chat.controller.js');
const { chatCacheService } = await import('../services/chat-cache.service.js');

// Helper to setup collection mocks
const setupCollectionMocks = () => {
  mockOnce.mockImplementation((path: string) => {
    const collectionMap: Record<string, any[]> = {
      'datasheet/Xe': mockVehicles,
      'datasheet/PHUHIEUXE': mockBadges,
      'datasheet/DONVIVANTAI': mockOperators,
      'datasheet/DANHMUCTUYENCODINH': mockRoutes,
      'drivers': mockDrivers,
      'dispatch_records': mockDispatchRecords,
      'schedules': mockSchedules,
      'services': mockServices,
      'shifts': mockShifts,
      'invoices': mockInvoices,
      'violations': mockViolations,
      'service_charges': mockServiceCharges,
    };
    const data = collectionMap[path] || [];
    return Promise.resolve(createMockSnapshot(data));
  });
};

// Helper to create mock request/response
const createMockRequest = (body: any = {}, params: any = {}): Partial<Request> => ({
  body,
  params,
});

interface MockResponse extends Partial<Response> {
  jsonData?: any;
  statusCode?: number;
}

const createMockResponse = (): MockResponse => {
  const res: MockResponse = {
    jsonData: null,
    statusCode: 200,
  };

  res.status = jest.fn((code: number) => {
    res.statusCode = code;
    return res as Response;
  }) as any;

  res.json = jest.fn((data: any) => {
    res.jsonData = data;
    return res as Response;
  }) as any;

  return res;
};

describe('Chat Controller', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
    setupCollectionMocks();
    await chatCacheService.preWarm();
    mockGenerateResponse.mockResolvedValue('Test AI response');
  });

  describe('processMessage', () => {
    describe('Input Validation', () => {
      it('should return 400 for missing message', async () => {
        const req = createMockRequest({});
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
        expect(res.jsonData.type).toBe('error');
      });

      it('should return 400 for empty message', async () => {
        const req = createMockRequest({ message: '' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
        expect(res.jsonData.type).toBe('error');
      });

      it('should return 400 for whitespace-only message', async () => {
        const req = createMockRequest({ message: '   ' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
      });

      it('should return 400 for message exceeding 1000 characters', async () => {
        const longMessage = 'a'.repeat(1001);
        const req = createMockRequest({ message: longMessage });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
        expect(res.jsonData.response).toContain('1000');
      });

      it('should accept message with exactly 1000 characters', async () => {
        const message = 'a'.repeat(1000);
        const req = createMockRequest({ message });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });

      it('should return 400 for non-string message', async () => {
        const req = createMockRequest({ message: 123 });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
      });

      it('should return 400 for null message', async () => {
        const req = createMockRequest({ message: null });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(400);
      });
    });

    describe('Session Management', () => {
      it('should generate sessionId if not provided', async () => {
        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.sessionId).toBeDefined();
        expect(res.jsonData.sessionId).toContain('session_');
      });

      it('should use provided sessionId', async () => {
        const req = createMockRequest({
          message: 'test',
          sessionId: 'custom-session-123',
        });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.sessionId).toBe('custom-session-123');
      });

      it('should pass sessionId to AI service', async () => {
        const req = createMockRequest({
          message: 'test',
          sessionId: 'test-session',
        });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(mockGenerateResponse).toHaveBeenCalledWith('test', 'test-session');
      });
    });

    describe('Successful Response', () => {
      it('should return AI response with correct structure', async () => {
        const req = createMockRequest({ message: 'Hello' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
        expect(res.jsonData).toHaveProperty('response');
        expect(res.jsonData).toHaveProperty('type', 'ai');
        expect(res.jsonData).toHaveProperty('sessionId');
        expect(res.jsonData).toHaveProperty('metadata');
      });

      it('should include processing time in metadata', async () => {
        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.metadata).toHaveProperty('processingTime');
        expect(typeof res.jsonData.metadata.processingTime).toBe('number');
      });

      it('should include queryType in metadata', async () => {
        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.metadata).toHaveProperty('queryType', 'AI_FUNCTION_CALLING');
      });

      it('should trim message whitespace', async () => {
        const req = createMockRequest({ message: '  test message  ' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(mockGenerateResponse).toHaveBeenCalledWith('test message', expect.any(String));
      });
    });

    describe('Error Handling', () => {
      it('should return fallback response on AI service error', async () => {
        mockGenerateResponse.mockRejectedValue(new Error('AI Service Error'));

        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200); // Should still return 200 with fallback
        expect(res.jsonData.type).toBe('ai');
        expect(res.jsonData.metadata.error).toBe(true);
      });

      it('should provide helpful suggestions in error response', async () => {
        mockGenerateResponse.mockRejectedValue(new Error('Error'));

        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.response).toContain('xe');
      });

      it('should never return "busy" message', async () => {
        mockGenerateResponse.mockRejectedValue(new Error('Rate limited'));

        const req = createMockRequest({ message: 'test' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.jsonData.response).not.toContain('busy');
        expect(res.jsonData.response).not.toContain('ban');
      });
    });

    describe('Vietnamese Language Support', () => {
      it('should handle Vietnamese message', async () => {
        const req = createMockRequest({ message: 'tim xe bien so 98H07480' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
        expect(mockGenerateResponse).toHaveBeenCalled();
      });

      it('should handle message with diacritics', async () => {
        const req = createMockRequest({ message: 'tìm xe biển số' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });

      it('should handle mixed Vietnamese and English', async () => {
        const req = createMockRequest({ message: 'search xe 98H07480' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });
    });

    describe('Special Characters', () => {
      it('should handle message with special characters', async () => {
        const req = createMockRequest({ message: 'test @#$%' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });

      it('should handle message with emojis', async () => {
        const req = createMockRequest({ message: 'test 🚌 🚗' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });

      it('should handle message with newlines', async () => {
        const req = createMockRequest({ message: 'line1\nline2' });
        const res = createMockResponse();

        await processMessage(req as Request, res as Response);

        expect(res.statusCode).toBe(200);
      });
    });
  });

  describe('clearHistory', () => {
    it('should clear history successfully', async () => {
      const req = createMockRequest({}, { sessionId: 'test-session' });
      const res = createMockResponse();

      await clearHistory(req as Request, res as Response);

      expect(mockClearHistory).toHaveBeenCalledWith('test-session');
      expect(res.jsonData).toEqual({ success: true });
    });

    it('should return 400 for missing sessionId', async () => {
      const req = createMockRequest({}, {});
      const res = createMockResponse();

      await clearHistory(req as Request, res as Response);

      expect(res.statusCode).toBe(400);
      expect(res.jsonData).toHaveProperty('error');
    });

    it('should return 400 for empty sessionId', async () => {
      const req = createMockRequest({}, { sessionId: '' });
      const res = createMockResponse();

      await clearHistory(req as Request, res as Response);

      expect(res.statusCode).toBe(400);
    });
  });

  describe('Response Format Validation', () => {
    it('should return ChatResponse type structure', async () => {
      const req = createMockRequest({ message: 'test' });
      const res = createMockResponse();

      await processMessage(req as Request, res as Response);

      const { jsonData } = res;
      expect(jsonData).toMatchObject({
        response: expect.any(String),
        type: expect.stringMatching(/^(data|ai|error)$/),
        sessionId: expect.any(String),
      });
    });

    it('should include metadata object', async () => {
      const req = createMockRequest({ message: 'test' });
      const res = createMockResponse();

      await processMessage(req as Request, res as Response);

      expect(res.jsonData.metadata).toBeDefined();
      expect(typeof res.jsonData.metadata).toBe('object');
    });
  });

  describe('Edge Cases', () => {
    it('should handle rapid consecutive requests', async () => {
      const responses = [];

      for (let i = 0; i < 5; i++) {
        const req = createMockRequest({ message: `test ${i}` });
        const res = createMockResponse();
        await processMessage(req as Request, res as Response);
        responses.push(res);
      }

      responses.forEach((res) => {
        expect(res.statusCode).toBe(200);
      });
    });

    it('should handle concurrent requests', async () => {
      const promises = [];

      for (let i = 0; i < 3; i++) {
        const req = createMockRequest({ message: `concurrent ${i}` });
        const res = createMockResponse();
        promises.push(processMessage(req as Request, res as Response).then(() => res));
      }

      const responses = await Promise.all(promises);
      responses.forEach((res) => {
        expect(res.statusCode).toBe(200);
      });
    });

    it('should handle message with only numbers', async () => {
      const req = createMockRequest({ message: '12345' });
      const res = createMockResponse();

      await processMessage(req as Request, res as Response);

      expect(res.statusCode).toBe(200);
    });

    it('should handle message with only special chars', async () => {
      const req = createMockRequest({ message: '!@#$%' });
      const res = createMockResponse();

      await processMessage(req as Request, res as Response);

      expect(res.statusCode).toBe(200);
    });
  });

  describe('Performance', () => {
    it('should respond within reasonable time', async () => {
      const req = createMockRequest({ message: 'test' });
      const res = createMockResponse();

      const startTime = Date.now();
      await processMessage(req as Request, res as Response);
      const endTime = Date.now();

      expect(endTime - startTime).toBeLessThan(5000); // 5 seconds max
    });
  });
});
</file>

<file path="server/src/modules/chat/__tests__/mocks/chat-mock-data.ts">
/**
 * Mock Data for Chat Module Tests
 * Contains sample data for all collections used in chatbot testing
 */

// Vehicle mock data with Vietnamese fields (matching RTDB structure)
export const mockVehicles = [
  {
    id: 'vehicle-1',
    BienSo: '98H07480',
    plate_number: '98H07480',
    LoaiXe: 'Xe khach 45 cho',
    vehicle_type: 'Xe khach 45 cho',
    SoCho: 45,
    seat_capacity: 45,
    TrangThai: 'active',
    status: 'active',
    MaDonVi: 'operator-1',
    operator_id: 'operator-1',
  },
  {
    id: 'vehicle-2',
    BienSo: '51B12345',
    plate_number: '51B12345',
    LoaiXe: 'Xe khach 29 cho',
    vehicle_type: 'Xe khach 29 cho',
    SoCho: 29,
    seat_capacity: 29,
    TrangThai: 'active',
    status: 'active',
    MaDonVi: 'operator-2',
    operator_id: 'operator-2',
  },
  {
    id: 'vehicle-3',
    BienSo: '29A-12345',
    plate_number: '29A-12345',
    LoaiXe: 'Xe giuong nam',
    vehicle_type: 'Xe giuong nam',
    SoCho: 40,
    seat_capacity: 40,
    TrangThai: 'inactive',
    status: 'inactive',
    MaDonVi: 'operator-1',
    operator_id: 'operator-1',
  },
];

// Driver mock data
export const mockDrivers = [
  {
    id: 'driver-1',
    full_name: 'Nguyen Van An',
    fullName: 'Nguyen Van An',
    license_number: 'B2-123456',
    licenseNumber: 'B2-123456',
    phone: '0901234567',
    status: 'active',
  },
  {
    id: 'driver-2',
    full_name: 'Tran Thi Binh',
    fullName: 'Tran Thi Binh',
    license_number: 'C-654321',
    licenseNumber: 'C-654321',
    phone: '0907654321',
    status: 'active',
  },
  {
    id: 'driver-3',
    full_name: 'Le Van Cuong',
    fullName: 'Le Van Cuong',
    license_number: 'D-111222',
    licenseNumber: 'D-111222',
    phone: '0909111222',
    status: 'inactive',
  },
];

// Operator mock data (transport companies)
export const mockOperators = [
  {
    id: 'operator-1',
    TenDonVi: 'Cong ty Phuong Trang',
    name: 'Cong ty Phuong Trang',
    MaDonVi: 'PHUONGTRANG',
    code: 'PHUONGTRANG',
    DiaChi: '123 Nguyen Hue, Q.1, TP.HCM',
    address: '123 Nguyen Hue, Q.1, TP.HCM',
    DienThoai: '02838123456',
    phone: '02838123456',
  },
  {
    id: 'operator-2',
    TenDonVi: 'Nha xe Mai Linh',
    name: 'Nha xe Mai Linh',
    MaDonVi: 'MAILINH',
    code: 'MAILINH',
    DiaChi: '456 Le Loi, Q.1, TP.HCM',
    address: '456 Le Loi, Q.1, TP.HCM',
    DienThoai: '02838654321',
    phone: '02838654321',
  },
  {
    id: 'operator-3',
    TenDonVi: 'Xe Thanh Buoi',
    name: 'Xe Thanh Buoi',
    MaDonVi: 'THANHBUOI',
    code: 'THANHBUOI',
    DiaChi: '789 CMT8, Q.3, TP.HCM',
    address: '789 CMT8, Q.3, TP.HCM',
    DienThoai: '02838999888',
    phone: '02838999888',
  },
];

// Route mock data
export const mockRoutes = [
  {
    id: 'route-1',
    MaSoTuyen: 'TPHCM-DALAT-001',
    route_code: 'TPHCM-DALAT-001',
    BenDi: 'TP.HCM',
    departure_station: 'TP.HCM',
    BenDen: 'Da Lat',
    arrival_station: 'Da Lat',
    KhoangCach: 310,
    distance: 310,
  },
  {
    id: 'route-2',
    MaSoTuyen: 'TPHCM-CANTHO-002',
    route_code: 'TPHCM-CANTHO-002',
    BenDi: 'TP.HCM',
    departure_station: 'TP.HCM',
    BenDen: 'Can Tho',
    arrival_station: 'Can Tho',
    KhoangCach: 170,
    distance: 170,
  },
  {
    id: 'route-3',
    MaSoTuyen: 'HANOI-HAIPHONG-003',
    route_code: 'HANOI-HAIPHONG-003',
    BenDi: 'Ha Noi',
    departure_station: 'Ha Noi',
    BenDen: 'Hai Phong',
    arrival_station: 'Hai Phong',
    KhoangCach: 120,
    distance: 120,
  },
];

// Badge mock data
export const mockBadges = [
  {
    id: 'badge-1',
    SoPhuHieu: 'PH-12345',
    badge_number: 'PH-12345',
    BienSoXe: '98H07480',
    plate_number: '98H07480',
    NgayCap: '2024-01-15',
    issue_date: '2024-01-15',
    NgayHetHan: '2026-01-15',
    expiry_date: '2026-01-15',
    TrangThai: 'active',
    status: 'active',
  },
  {
    id: 'badge-2',
    SoPhuHieu: 'PH-67890',
    badge_number: 'PH-67890',
    BienSoXe: '51B12345',
    plate_number: '51B12345',
    NgayCap: '2024-06-01',
    issue_date: '2024-06-01',
    NgayHetHan: '2026-06-01',
    expiry_date: '2026-06-01',
    TrangThai: 'active',
    status: 'active',
  },
];

// Dispatch records mock data
export const mockDispatchRecords = [
  {
    id: 'dispatch-1',
    plate_number: '98H07480',
    driver_id: 'driver-1',
    entry_time: '2025-12-25T08:00:00Z',
    entryTime: '2025-12-25T08:00:00Z',
    exit_time: '2025-12-25T10:30:00Z',
    exitTime: '2025-12-25T10:30:00Z',
    status: 'departed',
  },
  {
    id: 'dispatch-2',
    plate_number: '51B12345',
    driver_id: 'driver-2',
    entry_time: '2025-12-25T09:00:00Z',
    entryTime: '2025-12-25T09:00:00Z',
    status: 'entered',
  },
  {
    id: 'dispatch-3',
    plate_number: '29A-12345',
    driver_id: 'driver-3',
    entry_time: '2025-12-24T14:00:00Z',
    entryTime: '2025-12-24T14:00:00Z',
    exit_time: '2025-12-24T16:00:00Z',
    exitTime: '2025-12-24T16:00:00Z',
    status: 'departed',
  },
];

// Schedule mock data
export const mockSchedules = [
  {
    id: 'schedule-1',
    schedule_code: 'SCH-001',
    scheduleCode: 'SCH-001',
    route_id: 'route-1',
    departure_time: '06:00',
    arrival_time: '12:00',
  },
  {
    id: 'schedule-2',
    schedule_code: 'SCH-002',
    scheduleCode: 'SCH-002',
    route_id: 'route-2',
    departure_time: '07:30',
    arrival_time: '10:30',
  },
];

// Service mock data
export const mockServices = [
  {
    id: 'service-1',
    name: 'Rua xe',
    service_name: 'Rua xe',
    code: 'SV-RX',
    service_code: 'SV-RX',
    price: 50000,
  },
  {
    id: 'service-2',
    name: 'Bao duong',
    service_name: 'Bao duong',
    code: 'SV-BD',
    service_code: 'SV-BD',
    price: 500000,
  },
];

// Shift mock data
export const mockShifts = [
  {
    id: 'shift-1',
    date: '2025-12-25',
    shift_date: '2025-12-25',
    shift_name: 'Ca sang',
    staff: ['staff-1', 'staff-2'],
  },
  {
    id: 'shift-2',
    date: '2025-12-25',
    shift_date: '2025-12-25',
    shift_name: 'Ca chieu',
    staff: ['staff-3', 'staff-4'],
  },
];

// Invoice mock data
export const mockInvoices = [
  {
    id: 'invoice-1',
    date: '2025-12-25',
    invoice_date: '2025-12-25',
    amount: 150000,
    status: 'paid',
    vehicle_id: 'vehicle-1',
  },
  {
    id: 'invoice-2',
    date: '2025-12-24',
    invoice_date: '2025-12-24',
    amount: 200000,
    status: 'pending',
    vehicle_id: 'vehicle-2',
  },
];

// Violation mock data
export const mockViolations = [
  {
    id: 'violation-1',
    plate_number: '98H07480',
    plateNumber: '98H07480',
    violation_type: 'Qua tai',
    fine_amount: 2000000,
    date: '2025-12-20',
  },
  {
    id: 'violation-2',
    plate_number: '51B12345',
    plateNumber: '51B12345',
    violation_type: 'Vi pham toc do',
    fine_amount: 1500000,
    date: '2025-12-22',
  },
];

// Service charges mock data
export const mockServiceCharges = [
  {
    id: 'charge-1',
    service_name: 'Phi vao ben',
    name: 'Phi vao ben',
    price: 30000,
    unit: 'luot',
  },
  {
    id: 'charge-2',
    service_name: 'Phi dau xe qua dem',
    name: 'Phi dau xe qua dem',
    price: 100000,
    unit: 'dem',
  },
];

// Helper to create Firebase-like snapshot
export const createMockSnapshot = (data: any[]) => {
  const dataObject: Record<string, any> = {};
  data.forEach((item) => {
    dataObject[item.id] = item;
  });
  return {
    val: () => dataObject,
    exists: () => data.length > 0,
  };
};

// All collections combined
export const mockCollections = {
  vehicles: mockVehicles,
  badges: mockBadges,
  operators: mockOperators,
  routes: mockRoutes,
  drivers: mockDrivers,
  dispatch_records: mockDispatchRecords,
  schedules: mockSchedules,
  services: mockServices,
  shifts: mockShifts,
  invoices: mockInvoices,
  violations: mockViolations,
  service_charges: mockServiceCharges,
};

// Plate number variations for testing
export const plateVariations = {
  '98H07480': ['98H07480', '98H-07480', '98H 07480', '98h07480', '98h-07480'],
  '51B12345': ['51B12345', '51B-12345', '51B 12345', '51b12345', '51b-12345'],
  '29A-12345': ['29A12345', '29A-12345', '29A 12345', '29a12345', '29a-12345'],
};
</file>

<file path="server/src/modules/chat/chat.routes.ts">
import { Router } from 'express'
import { processMessage, clearHistory } from './chat.controller.js'

const router = Router()

// POST /api/chat/message - Send a message
router.post('/message', processMessage)

// DELETE /api/chat/history/:sessionId - Clear chat history
router.delete('/history/:sessionId', clearHistory)

export default router
</file>

<file path="server/src/modules/chat/services/chat-cache.service.ts">
import { firebaseDb } from '../../../config/database.js'

const COLLECTIONS = {
  vehicles: 'datasheet/Xe',
  badges: 'datasheet/PHUHIEUXE',
  operators: 'datasheet/DONVIVANTAI',
  routes: 'datasheet/DANHMUCTUYENCODINH',
  drivers: 'drivers',
  dispatch_records: 'dispatch_records',
  schedules: 'schedules',
  services: 'services',
  shifts: 'shifts',
  invoices: 'invoices',
  violations: 'violations',
  service_charges: 'service_charges'
}

interface CacheStats {
  vehicles: number
  badges: number
  operators: number
  routes: number
  drivers: number
  dispatch_records: number
  schedules: number
  services: number
  shifts: number
  invoices: number
  violations: number
  service_charges: number
  lastRefresh: string
}

class ChatCacheService {
  private cache: Map<string, any[]> = new Map()
  private plateIndex: Map<string, any[]> = new Map()
  private nameIndex: Map<string, any[]> = new Map()
  private codeIndex: Map<string, any[]> = new Map()
  private lastRefresh: Date | null = null
  private refreshInterval: NodeJS.Timeout | null = null
  private isWarming = false

  async preWarm(): Promise<void> {
    if (this.isWarming) return
    this.isWarming = true

    console.log('[ChatCache] Pre-warming cache...')
    const startTime = Date.now()

    try {
      const loadPromises = Object.entries(COLLECTIONS).map(async ([key, path]) => {
        try {
          const snapshot = await firebaseDb.ref(path).once('value')
          const data = snapshot.val()
          if (data) {
            const items = Object.entries(data).map(([id, item]) => ({ id, ...(item as any) }))
            this.cache.set(key, items)
            return { key, count: items.length }
          }
          this.cache.set(key, [])
          return { key, count: 0 }
        } catch (error) {
          console.warn(`[ChatCache] Failed to load ${key}:`, error)
          this.cache.set(key, [])
          return { key, count: 0 }
        }
      })

      const results = await Promise.all(loadPromises)
      this.buildIndexes()
      this.lastRefresh = new Date()

      const totalItems = results.reduce((sum, r) => sum + r.count, 0)
      console.log(`[ChatCache] Loaded ${totalItems} items in ${Date.now() - startTime}ms`)
      results.forEach(r => console.log(`  - ${r.key}: ${r.count}`))

      // Start auto-refresh every 5 minutes
      if (!this.refreshInterval) {
        this.refreshInterval = setInterval(() => this.refresh(), 5 * 60 * 1000)
      }
    } finally {
      this.isWarming = false
    }
  }

  async refresh(): Promise<void> {
    console.log('[ChatCache] Refreshing cache...')
    await this.preWarm()
  }

  private buildIndexes(): void {
    this.plateIndex.clear()
    this.nameIndex.clear()
    this.codeIndex.clear()

    // Index vehicles by plate
    const vehicles = this.cache.get('vehicles') || []
    vehicles.forEach(v => {
      const plate = this.normalizePlate(v.plate_number || v.BienSo || '')
      if (plate) {
        const existing = this.plateIndex.get(plate) || []
        this.plateIndex.set(plate, [...existing, { ...v, _source: 'vehicles' }])
      }
    })

    // Index badges by plate
    const badges = this.cache.get('badges') || []
    badges.forEach(b => {
      const plate = this.normalizePlate(b.BienSoXe || b.plate_number || '')
      if (plate) {
        const existing = this.plateIndex.get(plate) || []
        this.plateIndex.set(plate, [...existing, { ...b, _source: 'badges' }])
      }
    })

    // Index operators by name
    const operators = this.cache.get('operators') || []
    operators.forEach(o => {
      const name = this.normalizeText(o.TenDonVi || o.name || '')
      if (name) {
        const existing = this.nameIndex.get(name) || []
        this.nameIndex.set(name, [...existing, { ...o, _source: 'operators' }])
      }
    })

    // Index drivers by name
    const drivers = this.cache.get('drivers') || []
    drivers.forEach(d => {
      const name = this.normalizeText(d.full_name || d.fullName || '')
      if (name) {
        const existing = this.nameIndex.get(name) || []
        this.nameIndex.set(name, [...existing, { ...d, _source: 'drivers' }])
      }
    })

    // Index routes by code
    const routes = this.cache.get('routes') || []
    routes.forEach(r => {
      const code = this.normalizeText(r.MaSoTuyen || r.route_code || '')
      if (code) {
        const existing = this.codeIndex.get(code) || []
        this.codeIndex.set(code, [...existing, { ...r, _source: 'routes' }])
      }
    })

    console.log(`[ChatCache] Built indexes: plates=${this.plateIndex.size}, names=${this.nameIndex.size}, codes=${this.codeIndex.size}`)
  }

  private normalizePlate(plate: string): string {
    return plate.toUpperCase().replace(/[^A-Z0-9]/g, '')
  }

  private normalizeText(text: string): string {
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/đ/g, 'd')
      .replace(/[^\w\s]/g, '')
      .trim()
  }

  // Search functions
  searchVehicleByPlate(plate: string): any[] {
    const normalized = this.normalizePlate(plate)
    const results: any[] = []

    // Exact match
    if (this.plateIndex.has(normalized)) {
      results.push(...(this.plateIndex.get(normalized) || []))
    }

    // Partial match
    if (results.length === 0) {
      this.plateIndex.forEach((items, key) => {
        if (key.includes(normalized) || normalized.includes(key)) {
          results.push(...items)
        }
      })
    }

    // Fallback to full scan
    if (results.length === 0 && normalized.length >= 3) {
      const vehicles = this.cache.get('vehicles') || []
      vehicles.forEach(v => {
        const vPlate = this.normalizePlate(v.plate_number || v.BienSo || '')
        if (vPlate.includes(normalized)) {
          results.push({ ...v, _source: 'vehicles' })
        }
      })
    }

    return this.deduplicateResults(results)
  }

  searchDriverByName(name: string): any[] {
    const normalized = this.normalizeText(name)
    const results: any[] = []

    // Search in name index
    this.nameIndex.forEach((items, key) => {
      if (key.includes(normalized) || normalized.includes(key)) {
        items.filter(i => i._source === 'drivers').forEach(item => results.push(item))
      }
    })

    // Fallback to full scan
    if (results.length === 0) {
      const drivers = this.cache.get('drivers') || []
      drivers.forEach(d => {
        const dName = this.normalizeText(d.full_name || d.fullName || '')
        if (dName.includes(normalized)) {
          results.push({ ...d, _source: 'drivers' })
        }
      })
    }

    return this.deduplicateResults(results)
  }

  searchOperatorByName(name: string): any[] {
    const normalized = this.normalizeText(name)
    const results: any[] = []

    // Search in name index
    this.nameIndex.forEach((items, key) => {
      if (key.includes(normalized) || normalized.includes(key)) {
        items.filter(i => i._source === 'operators').forEach(item => results.push(item))
      }
    })

    // Fallback to full scan
    if (results.length === 0) {
      const operators = this.cache.get('operators') || []
      operators.forEach(o => {
        const oName = this.normalizeText(o.TenDonVi || o.name || '')
        if (oName.includes(normalized)) {
          results.push({ ...o, _source: 'operators' })
        }
      })
    }

    return this.deduplicateResults(results)
  }

  searchRouteByCode(code: string): any[] {
    const normalized = this.normalizeText(code)
    const results: any[] = []

    // Search in code index
    this.codeIndex.forEach((items, key) => {
      if (key.includes(normalized) || normalized.includes(key)) {
        results.push(...items)
      }
    })

    // Search by departure/arrival station
    if (results.length === 0) {
      const routes = this.cache.get('routes') || []
      routes.forEach(r => {
        const departure = this.normalizeText(r.BenDi || r.departure_station || '')
        const arrival = this.normalizeText(r.BenDen || r.arrival_station || '')
        if (departure.includes(normalized) || arrival.includes(normalized)) {
          results.push({ ...r, _source: 'routes' })
        }
      })
    }

    return this.deduplicateResults(results)
  }

  searchBadgeByNumber(number: string): any[] {
    const normalized = this.normalizePlate(number)
    const badges = this.cache.get('badges') || []

    return badges.filter(b => {
      const badgeNum = this.normalizePlate(b.SoPhuHieu || b.badge_number || '')
      const plate = this.normalizePlate(b.BienSoXe || b.plate_number || '')
      return badgeNum.includes(normalized) || plate.includes(normalized)
    }).map(b => ({ ...b, _source: 'badges' }))
  }

  searchSchedules(term: string): any[] {
    const normalized = this.normalizeText(term)
    const schedules = this.cache.get('schedules') || []

    if (!term || term === 'today') {
      return schedules.slice(0, 20).map(s => ({ ...s, _source: 'schedules' }))
    }

    return schedules.filter(s => {
      const code = this.normalizeText(s.schedule_code || s.scheduleCode || '')
      return code.includes(normalized)
    }).map(s => ({ ...s, _source: 'schedules' }))
  }

  searchServices(term: string): any[] {
    const normalized = this.normalizeText(term)
    const services = this.cache.get('services') || []

    if (!term) {
      return services.slice(0, 20).map(s => ({ ...s, _source: 'services' }))
    }

    return services.filter(s => {
      const name = this.normalizeText(s.name || s.service_name || '')
      const code = this.normalizeText(s.code || s.service_code || '')
      return name.includes(normalized) || code.includes(normalized)
    }).map(s => ({ ...s, _source: 'services' }))
  }

  getDispatchStats(date?: string): { date: string; entered: number; departed: number; total: number } {
    const targetDate = date || new Date().toISOString().split('T')[0]
    const records = this.cache.get('dispatch_records') || []

    let entered = 0
    let departed = 0

    records.forEach(r => {
      const entryDate = (r.entry_time || r.entryTime || '').split('T')[0]
      const exitDate = (r.exit_time || r.exitTime || '').split('T')[0]
      const status = r.status || ''

      if (entryDate === targetDate) {
        entered++
      }
      if (exitDate === targetDate || (status === 'departed' && entryDate === targetDate)) {
        departed++
      }
    })

    return { date: targetDate, entered, departed, total: entered }
  }

  getSystemStats(): CacheStats {
    return {
      vehicles: (this.cache.get('vehicles') || []).length,
      badges: (this.cache.get('badges') || []).length,
      operators: (this.cache.get('operators') || []).length,
      routes: (this.cache.get('routes') || []).length,
      drivers: (this.cache.get('drivers') || []).length,
      dispatch_records: (this.cache.get('dispatch_records') || []).length,
      schedules: (this.cache.get('schedules') || []).length,
      services: (this.cache.get('services') || []).length,
      shifts: (this.cache.get('shifts') || []).length,
      invoices: (this.cache.get('invoices') || []).length,
      violations: (this.cache.get('violations') || []).length,
      service_charges: (this.cache.get('service_charges') || []).length,
      lastRefresh: this.lastRefresh?.toISOString() || 'never'
    }
  }

  getShiftInfo(date?: string): any[] {
    const shifts = this.cache.get('shifts') || []
    if (!date) {
      return shifts.slice(0, 10).map(s => ({ ...s, _source: 'shifts' }))
    }
    return shifts.filter(s => {
      const shiftDate = (s.date || s.shift_date || '').split('T')[0]
      return shiftDate === date
    }).map(s => ({ ...s, _source: 'shifts' }))
  }

  getInvoices(date?: string, limit: number = 10): any[] {
    const invoices = this.cache.get('invoices') || []
    if (!date) {
      return invoices.slice(0, limit).map(i => ({ ...i, _source: 'invoices' }))
    }
    return invoices.filter(i => {
      const invoiceDate = (i.date || i.invoice_date || i.created_at || '').split('T')[0]
      return invoiceDate === date
    }).slice(0, limit).map(i => ({ ...i, _source: 'invoices' }))
  }

  getViolations(plate?: string): any[] {
    const violations = this.cache.get('violations') || []
    if (!plate) {
      return violations.slice(0, 20).map(v => ({ ...v, _source: 'violations' }))
    }
    const normalized = this.normalizePlate(plate)
    return violations.filter(v => {
      const vPlate = this.normalizePlate(v.plate_number || v.plateNumber || '')
      return vPlate.includes(normalized)
    }).map(v => ({ ...v, _source: 'violations' }))
  }

  getServiceCharges(service?: string): any[] {
    const charges = this.cache.get('service_charges') || []
    if (!service) {
      return charges.slice(0, 20).map(c => ({ ...c, _source: 'service_charges' }))
    }
    const normalized = this.normalizeText(service)
    return charges.filter(c => {
      const name = this.normalizeText(c.service_name || c.name || '')
      return name.includes(normalized)
    }).map(c => ({ ...c, _source: 'service_charges' }))
  }

  // Fuzzy search across all collections (fallback)
  fuzzySearch(query: string): any[] {
    const normalized = this.normalizeText(query)
    const results: any[] = []

    // Check if it looks like a plate number
    const plateMatch = query.match(/([0-9]{2}[A-Z][0-9A-Z\-\.]+)/i)
    if (plateMatch) {
      results.push(...this.searchVehicleByPlate(plateMatch[1]))
    }

    // Search operators
    const operators = this.searchOperatorByName(normalized)
    if (operators.length > 0) {
      results.push(...operators)
    }

    // Search drivers
    const drivers = this.searchDriverByName(normalized)
    if (drivers.length > 0) {
      results.push(...drivers)
    }

    // Search routes
    const routes = this.searchRouteByCode(normalized)
    if (routes.length > 0) {
      results.push(...routes)
    }

    return this.deduplicateResults(results).slice(0, 10)
  }

  private deduplicateResults(results: any[]): any[] {
    const seen = new Set<string>()
    return results.filter(item => {
      const key = item.id || JSON.stringify(item)
      if (seen.has(key)) return false
      seen.add(key)
      return true
    })
  }

  isReady(): boolean {
    return this.lastRefresh !== null
  }
}

export const chatCacheService = new ChatCacheService()
</file>

<file path="server/src/modules/chat/services/chat-functions.ts">
import { chatCacheService } from './chat-cache.service.js'
import { SchemaType } from '@google/generative-ai'

// Use any for function declarations to avoid strict type checking issues
export const CHAT_FUNCTIONS: any[] = [
  {
    name: 'search_vehicle',
    description: 'Tìm kiếm thông tin xe theo biển số. Sử dụng khi người dùng hỏi về xe, biển số, BKS, thông tin xe cụ thể.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        plate_number: {
          type: SchemaType.STRING,
          description: 'Biển số xe cần tìm (VD: 98H07480, 51B12345, 29A-12345)'
        }
      },
      required: ['plate_number']
    }
  },
  {
    name: 'search_driver',
    description: 'Tìm kiếm tài xế theo tên hoặc số GPLX. Sử dụng khi người dùng hỏi về tài xế, lái xe, người lái.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        name: {
          type: SchemaType.STRING,
          description: 'Tên tài xế hoặc số giấy phép lái xe'
        }
      },
      required: ['name']
    }
  },
  {
    name: 'search_operator',
    description: 'Tìm đơn vị vận tải, nhà xe, công ty vận tải theo tên. Sử dụng khi người dùng hỏi về đơn vị, nhà xe, công ty.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        name: {
          type: SchemaType.STRING,
          description: 'Tên đơn vị vận tải, nhà xe (VD: Phương Trang, Mai Linh, Thành Bưởi)'
        }
      },
      required: ['name']
    }
  },
  {
    name: 'search_route',
    description: 'Tìm thông tin tuyến đường theo mã tuyến, bến đi, bến đến. Sử dụng khi người dùng hỏi về tuyến, hành trình, bến.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        search_term: {
          type: SchemaType.STRING,
          description: 'Mã tuyến, tên bến đi hoặc bến đến (VD: TP.HCM, Đà Lạt, Cần Thơ)'
        }
      },
      required: ['search_term']
    }
  },
  {
    name: 'search_badge',
    description: 'Tìm phù hiệu xe theo số phù hiệu hoặc biển số. Sử dụng khi người dùng hỏi về phù hiệu, giấy phép vận tải.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        number: {
          type: SchemaType.STRING,
          description: 'Số phù hiệu hoặc biển số xe'
        }
      },
      required: ['number']
    }
  },
  {
    name: 'get_dispatch_stats',
    description: 'Lấy thống kê điều độ xe vào/ra bến. Sử dụng khi người dùng hỏi về số xe vào bến, ra bến, thống kê điều độ.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        date: {
          type: SchemaType.STRING,
          description: 'Ngày cần thống kê (định dạng YYYY-MM-DD). Để trống nếu hỏi về hôm nay.'
        }
      }
    }
  },
  {
    name: 'get_system_stats',
    description: 'Lấy thống kê tổng quan hệ thống: tổng số xe, tài xế, đơn vị vận tải, tuyến đường. Sử dụng khi người dùng hỏi bao nhiêu xe, tài xế, đơn vị.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {}
    }
  },
  {
    name: 'search_schedule',
    description: 'Tìm lịch trình chạy xe. Sử dụng khi người dùng hỏi về lịch trình, giờ xuất bến, biểu đồ chạy xe.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        term: {
          type: SchemaType.STRING,
          description: 'Mã lịch trình hoặc thời gian'
        }
      }
    }
  },
  {
    name: 'search_service',
    description: 'Tìm dịch vụ theo tên hoặc mã. Sử dụng khi người dùng hỏi về dịch vụ, giá dịch vụ, phí dịch vụ.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        term: {
          type: SchemaType.STRING,
          description: 'Tên hoặc mã dịch vụ'
        }
      }
    }
  },
  {
    name: 'get_shift_info',
    description: 'Lấy thông tin ca trực. Sử dụng khi người dùng hỏi về ca trực, lịch làm việc.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        date: {
          type: SchemaType.STRING,
          description: 'Ngày cần xem ca trực (YYYY-MM-DD)'
        }
      }
    }
  },
  {
    name: 'get_invoices',
    description: 'Lấy danh sách hóa đơn. Sử dụng khi người dùng hỏi về hóa đơn, thanh toán.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        date: {
          type: SchemaType.STRING,
          description: 'Ngày cần xem hóa đơn (YYYY-MM-DD)'
        }
      }
    }
  },
  {
    name: 'get_violations',
    description: 'Lấy danh sách vi phạm. Sử dụng khi người dùng hỏi về vi phạm, lỗi, phạt.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        plate_number: {
          type: SchemaType.STRING,
          description: 'Biển số xe cần xem vi phạm'
        }
      }
    }
  },
  {
    name: 'get_service_charges',
    description: 'Lấy bảng giá dịch vụ. Sử dụng khi người dùng hỏi về giá, phí, bảng giá dịch vụ.',
    parameters: {
      type: SchemaType.OBJECT,
      properties: {
        service: {
          type: SchemaType.STRING,
          description: 'Tên dịch vụ cần xem giá'
        }
      }
    }
  }
]

export interface FunctionCallResult {
  success: boolean
  data?: any
  error?: string
}

export async function executeFunction(name: string, args: Record<string, any>): Promise<FunctionCallResult> {
  try {
    // Ensure cache is ready
    if (!chatCacheService.isReady()) {
      await chatCacheService.preWarm()
    }

    switch (name) {
      case 'search_vehicle': {
        const results = chatCacheService.searchVehicleByPlate(args.plate_number || '')
        return {
          success: results.length > 0,
          data: results.length > 0 ? results : null,
          error: results.length === 0 ? `Không tìm thấy xe với biển số "${args.plate_number}"` : undefined
        }
      }

      case 'search_driver': {
        const results = chatCacheService.searchDriverByName(args.name || '')
        return {
          success: results.length > 0,
          data: results.length > 0 ? results : null,
          error: results.length === 0 ? `Không tìm thấy tài xế "${args.name}"` : undefined
        }
      }

      case 'search_operator': {
        const results = chatCacheService.searchOperatorByName(args.name || '')
        return {
          success: results.length > 0,
          data: results.length > 0 ? results : null,
          error: results.length === 0 ? `Không tìm thấy đơn vị "${args.name}"` : undefined
        }
      }

      case 'search_route': {
        const results = chatCacheService.searchRouteByCode(args.search_term || '')
        return {
          success: results.length > 0,
          data: results.length > 0 ? results : null,
          error: results.length === 0 ? `Không tìm thấy tuyến "${args.search_term}"` : undefined
        }
      }

      case 'search_badge': {
        const results = chatCacheService.searchBadgeByNumber(args.number || '')
        return {
          success: results.length > 0,
          data: results.length > 0 ? results : null,
          error: results.length === 0 ? `Không tìm thấy phù hiệu "${args.number}"` : undefined
        }
      }

      case 'get_dispatch_stats': {
        const stats = chatCacheService.getDispatchStats(args.date)
        return { success: true, data: stats }
      }

      case 'get_system_stats': {
        const stats = chatCacheService.getSystemStats()
        return { success: true, data: stats }
      }

      case 'search_schedule': {
        const results = chatCacheService.searchSchedules(args.term || '')
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Chưa có lịch trình nào được thiết lập' }
        }
      }

      case 'search_service': {
        const results = chatCacheService.searchServices(args.term || '')
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Chưa có dịch vụ nào' }
        }
      }

      case 'get_shift_info': {
        const results = chatCacheService.getShiftInfo(args.date)
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Chưa có thông tin ca trực' }
        }
      }

      case 'get_invoices': {
        const results = chatCacheService.getInvoices(args.date)
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Chưa có hóa đơn nào' }
        }
      }

      case 'get_violations': {
        const results = chatCacheService.getViolations(args.plate_number)
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Không có vi phạm nào' }
        }
      }

      case 'get_service_charges': {
        const results = chatCacheService.getServiceCharges(args.service)
        return {
          success: true,
          data: results.length > 0 ? results : { message: 'Chưa có bảng giá dịch vụ' }
        }
      }

      default:
        return { success: false, error: `Unknown function: ${name}` }
    }
  } catch (error: any) {
    console.error(`[ChatFunctions] Error executing ${name}:`, error)
    return { success: false, error: error.message }
  }
}
</file>

<file path="server/src/modules/chat/services/data-query.service.ts">
import { firebaseDb } from '../../../config/database.js'
import type { IntentResult, QueryResult } from '../types/chat.types.js'

export class DataQueryService {
  async execute(intent: IntentResult): Promise<QueryResult> {
    const { type, extractedParams } = intent

    switch (type) {
      case 'VEHICLE_LOOKUP':
        return this.queryVehicleComplete(extractedParams.plateNumber, extractedParams.listAll === 'true')
      case 'DRIVER_SEARCH':
        return this.queryDriver(extractedParams.searchTerm)
      case 'ROUTE_INFO':
        return this.queryRoute(extractedParams.searchTerm, extractedParams.destination)
      case 'SCHEDULE_QUERY':
        return this.querySchedule(extractedParams.searchTerm)
      case 'DISPATCH_STATS':
        return this.queryDispatchStats(extractedParams.period)
      case 'BADGE_LOOKUP':
        return this.queryBadge(extractedParams.badgeNumber)
      case 'OPERATOR_INFO':
        return this.queryOperator(extractedParams.searchTerm)
      default:
        return { success: false, error: 'Unknown query type', source: 'none' }
    }
  }

  // Query xe + phù hiệu + datasheet/Xe theo biển số
  async queryVehicleComplete(plateNumber: string, listAll: boolean = false): Promise<QueryResult> {
    try {
      const results: any = {
        vehicles: [],
        badges: [],
        legacyVehicles: []
      }

      // If listAll mode, return summary
      if (listAll || !plateNumber) {
        const [vehiclesSnap, badgesSnap, xeSnap] = await Promise.all([
          firebaseDb.ref('vehicles').once('value'),
          firebaseDb.ref('vehicle_badges').once('value'),
          firebaseDb.ref('datasheet/Xe').once('value')
        ])

        const vehicleCount = vehiclesSnap.numChildren()
        const badgeCount = badgesSnap.numChildren()
        const legacyCount = xeSnap.numChildren()

        // Get sample plates
        const samplePlates: string[] = []
        const vehiclesData = vehiclesSnap.val()
        if (vehiclesData) {
          let count = 0
          for (const v of Object.values(vehiclesData)) {
            const plate = (v as any).plate_number || (v as any).plateNumber
            if (plate && count < 5) {
              samplePlates.push(plate)
              count++
            }
          }
        }

        return {
          success: true,
          data: {
            summary: true,
            vehicleCount,
            badgeCount,
            legacyCount,
            samplePlates,
            message: `Hệ thống có ${vehicleCount} xe đăng ký, ${badgeCount} phù hiệu, ${legacyCount} xe từ dữ liệu cũ. Hãy nhập biển số cụ thể để tra cứu (VD: xe 98H07480)`
          },
          source: 'vehicles'
        }
      }

      const searchPlate = plateNumber.toUpperCase()

      // 1. Search in vehicles collection
      const vehiclesSnap = await firebaseDb.ref('vehicles').once('value')
      const vehiclesData = vehiclesSnap.val()

      if (vehiclesData) {
        for (const [key, vehicle] of Object.entries(vehiclesData)) {
          const v = vehicle as any
          const plate = (v.plate_number || v.plateNumber || '').toUpperCase()
          if (plate.includes(searchPlate)) {
            // Get operator info
            let operatorName = ''
            if (v.operator_id || v.operatorId) {
              const opSnap = await firebaseDb.ref(`operators/${v.operator_id || v.operatorId}`).once('value')
              const opData = opSnap.val()
              operatorName = opData?.name || ''
            }
            results.vehicles.push({ ...v, id: key, operatorName })
          }
        }
      }

      // 2. Search in vehicle_badges
      const badgesSnap = await firebaseDb.ref('vehicle_badges').once('value')
      const badgesData = badgesSnap.val()

      if (badgesData) {
        for (const [key, badge] of Object.entries(badgesData)) {
          const b = badge as any
          const plate = (b.BienSoXe || b.plate_number || '').toUpperCase()
          if (plate.includes(searchPlate)) {
            results.badges.push({ ...b, id: key })
          }
        }
      }

      // 3. Search in datasheet/Xe (legacy data)
      const xeSnap = await firebaseDb.ref('datasheet/Xe').once('value')
      const xeData = xeSnap.val()

      if (xeData) {
        for (const [key, xe] of Object.entries(xeData)) {
          const x = xe as any
          if (!x) continue
          const plate = (x.plate_number || x.BienSo || '').toUpperCase()
          if (plate.includes(searchPlate)) {
            results.legacyVehicles.push({ ...x, id: key })
          }
        }
      }

      // Check if any results found
      const totalFound = results.vehicles.length + results.badges.length + results.legacyVehicles.length
      if (totalFound === 0) {
        return { 
          success: false, 
          error: `Không tìm thấy xe với biển số "${plateNumber}". Hãy kiểm tra lại biển số hoặc thử tìm kiếm khác.`, 
          source: 'vehicles' 
        }
      }

      return {
        success: true,
        data: {
          plateNumber,
          ...results,
          totalFound
        },
        source: 'vehicles+badges'
      }
    } catch (error: any) {
      console.error('queryVehicleComplete error:', error)
      return { success: false, error: error.message, source: 'vehicles' }
    }
  }

  // Keep old method for backward compatibility
  async queryVehicle(plateNumber: string): Promise<QueryResult> {
    return this.queryVehicleComplete(plateNumber, false)
  }

  async queryDriver(searchTerm: string): Promise<QueryResult> {
    if (!searchTerm) {
      return { success: false, error: 'Không có thông tin tìm kiếm', source: 'drivers' }
    }

    try {
      const driversSnap = await firebaseDb.ref('drivers').once('value')
      const driversData = driversSnap.val()
      const results: any[] = []

      if (driversData) {
        const searchLower = searchTerm.toLowerCase()
        for (const [key, driver] of Object.entries(driversData)) {
          const d = driver as any
          const fullName = (d.full_name || d.fullName || '').toLowerCase()
          const licenseNumber = (d.license_number || d.licenseNumber || '').toLowerCase()

          if (fullName.includes(searchLower) || licenseNumber.includes(searchLower)) {
            results.push({ ...d, id: key })
          }
        }
      }

      if (results.length > 0) {
        return { success: true, data: results, source: 'drivers' }
      }

      return { success: false, error: `Không tìm thấy tài xế "${searchTerm}"`, source: 'drivers' }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'drivers' }
    }
  }

  async queryRoute(searchTerm: string, _destination?: string): Promise<QueryResult> {
    if (!searchTerm) {
      return { success: false, error: 'Không có thông tin tuyến', source: 'routes' }
    }

    try {
      // Search in routes collection
      const routesSnap = await firebaseDb.ref('routes').once('value')
      const routesData = routesSnap.val()
      const results: any[] = []

      if (routesData) {
        const searchLower = searchTerm.toLowerCase()
        for (const [key, route] of Object.entries(routesData)) {
          const r = route as any
          const routeName = (r.route_name || r.routeName || '').toLowerCase()
          const routeCode = (r.route_code || r.routeCode || '').toLowerCase()

          if (routeName.includes(searchLower) || routeCode.includes(searchLower)) {
            results.push({ ...r, id: key })
          }
        }
      }

      // Also search in datasheet/DANHMUCTUYENCODINH
      const danhMucSnap = await firebaseDb.ref('datasheet/DANHMUCTUYENCODINH').once('value')
      const danhMucData = danhMucSnap.val()

      if (danhMucData) {
        const searchLower = searchTerm.toLowerCase()
        for (const [key, tuyen] of Object.entries(danhMucData)) {
          const t = tuyen as any
          if (!t) continue
          const routeCode = (t.route_code || t.MaSoTuyen || '').toLowerCase()
          const departureSt = (t.departure_station || t.BenDi || '').toLowerCase()
          const arrivalSt = (t.arrival_station || t.BenDen || '').toLowerCase()

          if (routeCode.includes(searchLower) ||
              departureSt.includes(searchLower) ||
              arrivalSt.includes(searchLower)) {
            results.push({ ...t, id: key, source: 'legacy' })
          }
        }
      }

      if (results.length > 0) {
        return { success: true, data: results.slice(0, 10), source: 'routes' }
      }

      return { success: false, error: `Không tìm thấy tuyến "${searchTerm}"`, source: 'routes' }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'routes' }
    }
  }

  async querySchedule(_searchTerm: string): Promise<QueryResult> {
    try {
      const schedulesSnap = await firebaseDb.ref('schedules').once('value')
      const schedulesData = schedulesSnap.val()

      if (!schedulesData) {
        return { success: false, error: 'Chưa có lịch trình nào', source: 'schedules' }
      }

      const results = Object.entries(schedulesData)
        .map(([key, schedule]) => ({ ...(schedule as any), id: key }))
        .filter((s: any) => s.is_active !== false)
        .slice(0, 20)

      return { success: true, data: results, source: 'schedules' }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'schedules' }
    }
  }

  async queryDispatchStats(_period: string): Promise<QueryResult> {
    try {
      const today = new Date().toISOString().split('T')[0]
      const dispatchSnap = await firebaseDb.ref('dispatch_records').once('value')
      const dispatchData = dispatchSnap.val()

      if (!dispatchData) {
        return { success: true, data: { totalToday: 0, entered: 0, exited: 0 }, source: 'dispatch_records' }
      }

      let entered = 0
      let exited = 0

      for (const [_key, record] of Object.entries(dispatchData)) {
        const r = record as any
        const entryDate = (r.entry_time || r.entryTime || '').split('T')[0]
        const exitDate = (r.exit_time || r.exitTime || '').split('T')[0]

        if (entryDate === today) entered++
        if (exitDate === today) exited++
      }

      return {
        success: true,
        data: { date: today, totalToday: entered, entered, exited },
        source: 'dispatch_records'
      }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'dispatch_records' }
    }
  }

  async queryBadge(badgeNumber: string): Promise<QueryResult> {
    if (!badgeNumber) {
      return { success: false, error: 'Không có số phù hiệu', source: 'vehicle_badges' }
    }

    try {
      const badgesSnap = await firebaseDb.ref('vehicle_badges').once('value')
      const badgesData = badgesSnap.val()

      if (badgesData) {
        const searchUpper = badgeNumber.toUpperCase()
        for (const [key, badge] of Object.entries(badgesData)) {
          const b = badge as any
          const number = (b.SoPhuHieu || b.badge_number || '').toUpperCase()
          const plate = (b.BienSoXe || b.plate_number || '').toUpperCase()

          if (number.includes(searchUpper) || plate.includes(searchUpper)) {
            return { success: true, data: { ...b, id: key }, source: 'vehicle_badges' }
          }
        }
      }

      return { success: false, error: `Không tìm thấy phù hiệu "${badgeNumber}"`, source: 'vehicle_badges' }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'vehicle_badges' }
    }
  }

  async queryOperator(searchTerm: string): Promise<QueryResult> {
    if (!searchTerm) {
      return { success: false, error: 'Không có thông tin đơn vị', source: 'operators' }
    }

    try {
      const operatorsSnap = await firebaseDb.ref('operators').once('value')
      const operatorsData = operatorsSnap.val()
      const results: any[] = []

      if (operatorsData) {
        const searchLower = searchTerm.toLowerCase()
        for (const [key, operator] of Object.entries(operatorsData)) {
          const o = operator as any
          const name = (o.name || '').toLowerCase()
          const code = (o.code || '').toLowerCase()

          if (name.includes(searchLower) || code.includes(searchLower)) {
            results.push({ ...o, id: key })
          }
        }
      }

      if (results.length > 0) {
        return { success: true, data: results, source: 'operators' }
      }

      return { success: false, error: `Không tìm thấy đơn vị "${searchTerm}"`, source: 'operators' }
    } catch (error: any) {
      return { success: false, error: error.message, source: 'operators' }
    }
  }

  async getContextForAI(message: string): Promise<any> {
    const context: any = {}

    // Extract potential vehicle reference
    const vehicleMatch = message.match(/([0-9]{2}[A-Z][0-9A-Z\-\.]+)/i)
    if (vehicleMatch) {
      const vehicleResult = await this.queryVehicle(vehicleMatch[1])
      if (vehicleResult.success) {
        context.vehicle = vehicleResult.data
      }
    }

    // Get general stats
    try {
      const [vehiclesSnap, driversSnap, operatorsSnap] = await Promise.all([
        firebaseDb.ref('vehicles').once('value'),
        firebaseDb.ref('drivers').once('value'),
        firebaseDb.ref('operators').once('value')
      ])

      context.stats = {
        totalVehicles: vehiclesSnap.numChildren(),
        totalDrivers: driversSnap.numChildren(),
        totalOperators: operatorsSnap.numChildren()
      }
    } catch {
      // Ignore stats errors
    }

    return context
  }
}

export const dataQueryService = new DataQueryService()
</file>

<file path="server/src/modules/chat/services/intent-classifier.service.ts">
import type { IntentResult, QueryType } from '../types/chat.types.js'

interface PatternConfig {
  type: QueryType
  patterns: RegExp[]
  paramExtractor: (match: RegExpMatchArray) => Record<string, string>
}

const INTENT_PATTERNS: PatternConfig[] = [
  {
    type: 'VEHICLE_LOOKUP',
    patterns: [
      // Direct plate number patterns (most specific first)
      /([0-9]{2}[A-Z][0-9]{4,5})/i,  // 98H07480, 51B12345
      /([0-9]{2}[A-Z]\-?[0-9]{3,5})/i,  // 98H-07480
      /([0-9]{2}[A-Z][0-9]+\.[0-9]+)/i,  // 98H07.480
      // With keywords
      /(?:xe|tim xe|tra cuu xe|thong tin xe|xem xe)\s+([A-Z0-9\-\.]+)/i,
      /(?:bien|bien so|bks|bien kiem soat)\s*(?:xe|so)?\s*([A-Z0-9\-\.]+)/i,
      // List all queries
      /^(?:bien\s*so\s*xe?|danh\s*sach\s*xe|tat\s*ca\s*xe|liet\s*ke\s*xe|ds\s*xe|list\s*xe)$/i,
      /^(?:co bao nhieu|so luong|tong so)\s*xe/i,
      /^xe$/i,  // Just "xe"
    ],
    paramExtractor: (match) => {
      const input = match[0].toLowerCase()
      // Check if it's a "list all" query
      if (/^(?:bien\s*so\s*xe?|danh\s*sach\s*xe|tat\s*ca\s*xe|liet\s*ke\s*xe|ds\s*xe|list\s*xe|xe)$/i.test(input) ||
          /^(?:co bao nhieu|so luong|tong so)\s*xe/i.test(input)) {
        return { plateNumber: '', listAll: 'true' }
      }
      // Extract plate number
      const plateMatch = match[1] || match[0].match(/[0-9]{2}[A-Z][0-9\-\.]+/i)?.[0]
      return { plateNumber: plateMatch?.toUpperCase().trim() || '', listAll: '' }
    }
  },
  {
    type: 'DRIVER_SEARCH',
    patterns: [
      /(?:tai\s*xe|lai\s*xe|tim tai xe|tra cuu tai xe|thong tin tai xe)\s+(.+?)(?:\s*$|\s+(?:cua|o|tai))/i,
      /(?:gplx|giay phep lai xe)\s*(?:so)?\s*([A-Z0-9]+)/i,
      /^(?:danh\s*sach\s*tai\s*xe|ds\s*tai\s*xe|tat\s*ca\s*tai\s*xe)$/i,
      /^tai\s*xe$/i,
    ],
    paramExtractor: (match) => {
      const input = match[0].toLowerCase()
      if (/^(?:danh\s*sach\s*tai\s*xe|ds\s*tai\s*xe|tat\s*ca\s*tai\s*xe|tai\s*xe)$/i.test(input)) {
        return { searchTerm: '', listAll: 'true' }
      }
      return { searchTerm: match[1]?.trim() || '', listAll: '' }
    }
  },
  {
    type: 'ROUTE_INFO',
    patterns: [
      /(?:tuyen|tuyen duong|thong tin tuyen)\s+(.+?)(?:\s*$|\s+(?:co|di|tu))/i,
      /(?:ma\s*tuyen|ma so tuyen)\s*([A-Z0-9\.\-]+)/i,
      /tuyen\s+(.+?)\s*[-–]\s*(.+?)(?:\s*$)/i,
      /^(?:danh\s*sach\s*tuyen|ds\s*tuyen|tat\s*ca\s*tuyen)$/i,
      /^tuyen$/i,
    ],
    paramExtractor: (match) => {
      const input = match[0].toLowerCase()
      if (/^(?:danh\s*sach\s*tuyen|ds\s*tuyen|tat\s*ca\s*tuyen|tuyen)$/i.test(input)) {
        return { searchTerm: '', destination: '', listAll: 'true' }
      }
      return {
        searchTerm: match[1]?.trim() || '',
        destination: match[2]?.trim() || '',
        listAll: ''
      }
    }
  },
  {
    type: 'SCHEDULE_QUERY',
    patterns: [
      /(?:lich|lich trinh|bieu do|gio chay)\s*(?:xe)?\s*(.+)?/i,
      /(?:chuyen|chuyen xe)\s+(\d{1,2}:\d{2})/i,
      /(?:xe|chuyen)\s+(?:luc|vao)\s+(\d{1,2}:\d{2})/i,
      /^(?:lich trinh|lich|bieu do)$/i,
    ],
    paramExtractor: (match) => ({ searchTerm: match[1]?.trim() || 'today' })
  },
  {
    type: 'DISPATCH_STATS',
    patterns: [
      /(?:thong ke|bao cao)\s*(?:dieu do|xe vao|xe ra)/i,
      /(?:xe vao ben|xe ra ben)\s*(?:hom nay|ngay)?/i,
      /(?:so luong|bao nhieu)\s*xe\s*(?:da|vao|ra)/i,
      /^(?:dieu do|thong ke|bao cao)$/i,
    ],
    paramExtractor: () => ({ period: 'today' })
  },
  {
    type: 'BADGE_LOOKUP',
    patterns: [
      /(?:phu\s*hieu|phu hieu xe)\s*(?:so)?\s*([A-Z0-9\-]+)/i,
      /(?:tra cuu|tim)\s*phu\s*hieu\s+(.+)/i,
      /^(?:danh\s*sach\s*phu\s*hieu|ds\s*phu\s*hieu|tat\s*ca\s*phu\s*hieu)$/i,
      /^phu\s*hieu$/i,
    ],
    paramExtractor: (match) => {
      const input = match[0].toLowerCase()
      if (/^(?:danh\s*sach\s*phu\s*hieu|ds\s*phu\s*hieu|tat\s*ca\s*phu\s*hieu|phu\s*hieu)$/i.test(input)) {
        return { badgeNumber: '', listAll: 'true' }
      }
      return { badgeNumber: match[1]?.trim() || '', listAll: '' }
    }
  },
  {
    type: 'OPERATOR_INFO',
    patterns: [
      /(?:don vi|don vi van tai|nha xe|cong ty)\s+(.+?)(?:\s*$|\s+(?:co|o))/i,
      /(?:thong tin|tra cuu)\s*(?:don vi|nha xe)\s+(.+)/i,
      /^(?:danh\s*sach\s*don\s*vi|ds\s*don\s*vi|tat\s*ca\s*don\s*vi|danh\s*sach\s*nha\s*xe)$/i,
      /^(?:don\s*vi|nha\s*xe)$/i,
    ],
    paramExtractor: (match) => {
      const input = match[0].toLowerCase()
      if (/^(?:danh\s*sach\s*don\s*vi|ds\s*don\s*vi|tat\s*ca\s*don\s*vi|danh\s*sach\s*nha\s*xe|don\s*vi|nha\s*xe)$/i.test(input)) {
        return { searchTerm: '', listAll: 'true' }
      }
      return { searchTerm: match[1]?.trim() || '', listAll: '' }
    }
  },
]

export class IntentClassifierService {
  classify(message: string): IntentResult {
    const normalizedMessage = this.normalizeMessage(message)

    for (const config of INTENT_PATTERNS) {
      for (const pattern of config.patterns) {
        const match = normalizedMessage.match(pattern)
        if (match) {
          return {
            type: config.type,
            confidence: this.calculateConfidence(match, pattern),
            extractedParams: config.paramExtractor(match)
          }
        }
      }
    }

    return {
      type: 'GENERAL_QUESTION',
      confidence: 1.0,
      extractedParams: {}
    }
  }

  private normalizeMessage(message: string): string {
    return message
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/đ/g, 'd')
      .replace(/[^\w\s\-\.]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim()
  }

  private calculateConfidence(match: RegExpMatchArray, _pattern: RegExp): number {
    const matchLength = match[0].length
    const fullLength = match.input?.length || matchLength
    const ratio = matchLength / fullLength

    if (ratio > 0.8) return 0.95
    if (ratio > 0.5) return 0.85
    if (ratio > 0.3) return 0.75
    return 0.65
  }
}

export const intentClassifier = new IntentClassifierService()
</file>

<file path="server/src/modules/chat/services/response-formatter.service.ts">
import type { QueryType, QueryResult } from '../types/chat.types.js'

export class ResponseFormatterService {
  format(queryType: QueryType, result: QueryResult): string {
    if (!result.success) {
      return result.error || 'Không thể tìm thấy thông tin'
    }

    switch (queryType) {
      case 'VEHICLE_LOOKUP':
        return this.formatVehicle(result.data)
      case 'DRIVER_SEARCH':
        return this.formatDrivers(result.data)
      case 'ROUTE_INFO':
        return this.formatRoutes(result.data)
      case 'SCHEDULE_QUERY':
        return this.formatSchedules(result.data)
      case 'DISPATCH_STATS':
        return this.formatDispatchStats(result.data)
      case 'BADGE_LOOKUP':
        return this.formatBadge(result.data)
      case 'OPERATOR_INFO':
        return this.formatOperators(result.data)
      default:
        return JSON.stringify(result.data, null, 2)
    }
  }

  private formatVehicle(data: any): string {
    if (!data) return 'Không tìm thấy thông tin xe'

    // Handle summary mode (list all)
    if (data.summary) {
      let response = `📊 **Thống kê xe trong hệ thống**\n\n`
      response += `• Xe đăng ký: ${data.vehicleCount} xe\n`
      response += `• Phù hiệu: ${data.badgeCount} phù hiệu\n`
      response += `• Dữ liệu cũ: ${data.legacyCount} xe\n`
      
      if (data.samplePlates && data.samplePlates.length > 0) {
        response += `\n**Một số biển số mẫu:**\n`
        data.samplePlates.forEach((plate: string) => {
          response += `• ${plate}\n`
        })
      }
      
      response += `\n💡 Nhập biển số cụ thể để tra cứu (VD: xe 98H07480)`
      return response
    }

    // Handle combined results (vehicles + badges + legacy)
    if (data.totalFound !== undefined) {
      let response = `🔍 **Kết quả tra cứu biển số "${data.plateNumber}"**\n`
      response += `Tìm thấy ${data.totalFound} kết quả\n\n`

      // Format vehicles
      if (data.vehicles && data.vehicles.length > 0) {
        response += `**🚌 Xe đăng ký (${data.vehicles.length}):**\n`
        data.vehicles.forEach((v: any) => {
          const plate = v.plate_number || v.plateNumber || 'N/A'
          const type = v.vehicle_type || v.vehicleType || ''
          const operator = v.operatorName || v.operator_name || ''
          const seats = v.seat_capacity || v.seatCapacity || 0
          response += `• ${plate}`
          if (type) response += ` - ${type}`
          if (seats > 0) response += ` (${seats} chỗ)`
          if (operator) response += ` - ${operator}`
          response += '\n'
        })
        response += '\n'
      }

      // Format badges
      if (data.badges && data.badges.length > 0) {
        response += `**🏷️ Phù hiệu (${data.badges.length}):**\n`
        data.badges.forEach((b: any) => {
          const plate = b.BienSoXe || b.plate_number || 'N/A'
          const badgeNum = b.SoPhuHieu || b.badge_number || ''
          const status = b.TrangThai || b.status || ''
          const expiry = b.NgayHetHan || b.expiry_date || ''
          response += `• ${plate}`
          if (badgeNum) response += ` - Phù hiệu: ${badgeNum}`
          if (status) response += ` (${status})`
          if (expiry) response += ` - HH: ${expiry}`
          response += '\n'
        })
        response += '\n'
      }

      // Format legacy vehicles
      if (data.legacyVehicles && data.legacyVehicles.length > 0) {
        response += `**📁 Dữ liệu cũ (${data.legacyVehicles.length}):**\n`
        data.legacyVehicles.slice(0, 3).forEach((x: any) => {
          const plate = x.BienSo || x.plate_number || 'N/A'
          const owner = x.TenDangKyXe || x.owner_name || ''
          const type = x.LoaiXe || x.vehicle_type || ''
          response += `• ${plate}`
          if (type) response += ` - ${type}`
          if (owner) response += ` - ${owner}`
          response += '\n'
        })
        if (data.legacyVehicles.length > 3) {
          response += `  ...và ${data.legacyVehicles.length - 3} xe khác\n`
        }
      }

      return response.trim()
    }

    // Handle single vehicle (legacy format)
    const vehicle = data
    const plateNumber = vehicle.plate_number || vehicle.plateNumber || vehicle.BienSo || 'N/A'
    const vehicleType = vehicle.vehicle_type || vehicle.vehicleType || vehicle.LoaiXe || 'N/A'
    const seatCapacity = vehicle.seat_capacity || vehicle.seatCapacity || vehicle.SoCho || 0
    const bedCapacity = vehicle.bed_capacity || vehicle.bedCapacity || 0
    const manufacturer = vehicle.manufacturer || vehicle.NhanHieu || 'N/A'
    const manufactureYear = vehicle.manufacture_year || vehicle.manufactureYear || vehicle.NamSanXuat || 'N/A'
    const operatorName = vehicle.operatorName || vehicle.operator_name || vehicle.TenDangKyXe || 'N/A'
    const color = vehicle.color || vehicle.MauSon || 'N/A'
    const isActive = vehicle.is_active !== false ? 'Hoạt động' : 'Ngừng hoạt động'

    let response = `🚌 **Thông tin xe ${plateNumber}**\n\n`
    response += `• Loại xe: ${vehicleType}\n`
    
    if (seatCapacity > 0) {
      response += `• Số chỗ ngồi: ${seatCapacity}\n`
    }
    if (bedCapacity > 0) {
      response += `• Số giường: ${bedCapacity}\n`
    }
    
    response += `• Hãng xe: ${manufacturer}\n`
    response += `• Năm sản xuất: ${manufactureYear}\n`
    response += `• Màu sơn: ${color}\n`
    response += `• Đơn vị/Chủ xe: ${operatorName}\n`
    response += `• Trạng thái: ${isActive}\n`

    if (vehicle.chassis_number || vehicle.SoKhung) {
      response += `• Số khung: ${vehicle.chassis_number || vehicle.SoKhung}\n`
    }
    if (vehicle.engine_number || vehicle.SoMay) {
      response += `• Số máy: ${vehicle.engine_number || vehicle.SoMay}\n`
    }

    return response
  }

  private formatDrivers(drivers: any[]): string {
    if (!drivers || drivers.length === 0) {
      return 'Không tìm thấy tài xế nào'
    }

    if (drivers.length === 1) {
      const d = drivers[0]
      const fullName = d.full_name || d.fullName || 'N/A'
      const licenseNumber = d.license_number || d.licenseNumber || 'N/A'
      const phone = d.phone || d.phone_number || 'N/A'
      const isActive = d.is_active !== false ? 'Hoạt động' : 'Ngừng hoạt động'

      let response = `👤 **Thông tin tài xế ${fullName}**\n\n`
      response += `• GPLX: ${licenseNumber}\n`
      response += `• Điện thoại: ${phone}\n`
      response += `• Trạng thái: ${isActive}\n`

      if (d.address) {
        response += `• Địa chỉ: ${d.address}\n`
      }

      return response
    }

    let response = `👥 **Tìm thấy ${drivers.length} tài xế:**\n\n`
    drivers.slice(0, 5).forEach((d, index) => {
      const fullName = d.full_name || d.fullName || 'N/A'
      const licenseNumber = d.license_number || d.licenseNumber || ''
      response += `${index + 1}. ${fullName}`
      if (licenseNumber) response += ` (GPLX: ${licenseNumber})`
      response += '\n'
    })

    if (drivers.length > 5) {
      response += `\n...và ${drivers.length - 5} tài xế khác`
    }

    return response
  }

  private formatRoutes(routes: any[]): string {
    if (!routes || routes.length === 0) {
      return 'Không tìm thấy tuyến nào'
    }

    if (routes.length === 1) {
      const r = routes[0]
      const routeCode = r.route_code || r.routeCode || r.MaSoTuyen || 'N/A'
      const routeName = r.route_name || r.routeName || ''
      const departure = r.departure_station || r.BenDi || 'N/A'
      const arrival = r.arrival_station || r.BenDen || 'N/A'
      const distance = r.distance_km || r.CuLyTuyen_km || 0
      const routePath = r.route_path || r.HanhTrinh || ''

      let response = `🛣️ **Thông tin tuyến ${routeCode}**\n\n`
      if (routeName) response += `• Tên tuyến: ${routeName}\n`
      response += `• Bến đi: ${departure}\n`
      response += `• Bến đến: ${arrival}\n`
      if (distance > 0) response += `• Cự ly: ${distance} km\n`
      if (routePath) response += `• Hành trình: ${routePath}\n`

      return response
    }

    let response = `🛣️ **Tìm thấy ${routes.length} tuyến:**\n\n`
    routes.slice(0, 5).forEach((r, index) => {
      const routeCode = r.route_code || r.routeCode || r.MaSoTuyen || ''
      const departure = r.departure_station || r.BenDi || ''
      const arrival = r.arrival_station || r.BenDen || ''
      response += `${index + 1}. ${routeCode ? `[${routeCode}] ` : ''}${departure} - ${arrival}\n`
    })

    if (routes.length > 5) {
      response += `\n...và ${routes.length - 5} tuyến khác`
    }

    return response
  }

  private formatSchedules(schedules: any[]): string {
    if (!schedules || schedules.length === 0) {
      return 'Chưa có lịch trình nào được thiết lập'
    }

    let response = `📅 **Danh sách lịch trình (${schedules.length} lịch):**\n\n`

    schedules.slice(0, 10).forEach((s, index) => {
      const code = s.schedule_code || s.scheduleCode || ''
      const time = s.departure_time || s.departureTime || ''
      response += `${index + 1}. ${code ? `[${code}] ` : ''}${time}\n`
    })

    if (schedules.length > 10) {
      response += `\n...và ${schedules.length - 10} lịch trình khác`
    }

    return response
  }

  private formatDispatchStats(stats: any): string {
    const { date, entered, exited } = stats

    let response = `📊 **Thống kê điều độ ngày ${date}**\n\n`
    response += `• Xe vào bến: ${entered} lượt\n`
    response += `• Xe ra bến: ${exited} lượt\n`
    response += `• Tổng điều độ: ${entered + exited} lượt\n`

    return response
  }

  private formatBadge(badge: any): string {
    if (!badge) return 'Không tìm thấy thông tin phù hiệu'

    const badgeNumber = badge.SoPhuHieu || badge.badge_number || 'N/A'
    const plateNumber = badge.BienSoXe || badge.plate_number || 'N/A'
    const badgeType = badge.LoaiPH || badge.badge_type || 'N/A'
    const badgeColor = badge.MauPhuHieu || badge.badge_color || 'N/A'
    const issueDate = badge.NgayCap || badge.issue_date || 'N/A'
    const expiryDate = badge.NgayHetHan || badge.expiry_date || 'N/A'
    const status = badge.TrangThai || badge.status || 'N/A'
    const route = badge.TuyenDuong || badge.route || ''

    let response = `🏷️ **Thông tin phù hiệu ${badgeNumber}**\n\n`
    response += `• Biển số xe: ${plateNumber}\n`
    response += `• Loại phù hiệu: ${badgeType}\n`
    response += `• Màu phù hiệu: ${badgeColor}\n`
    response += `• Ngày cấp: ${issueDate}\n`
    response += `• Ngày hết hạn: ${expiryDate}\n`
    response += `• Trạng thái: ${status}\n`
    if (route) response += `• Tuyến đường: ${route}\n`

    return response
  }

  private formatOperators(operators: any[]): string {
    if (!operators || operators.length === 0) {
      return 'Không tìm thấy đơn vị vận tải nào'
    }

    if (operators.length === 1) {
      const o = operators[0]
      const name = o.name || 'N/A'
      const code = o.code || 'N/A'
      const phone = o.phone || 'N/A'
      const address = o.address || 'N/A'
      const representative = o.representative_name || ''
      const isActive = o.is_active !== false ? 'Hoạt động' : 'Ngừng hoạt động'

      let response = `🏢 **Thông tin đơn vị ${name}**\n\n`
      response += `• Mã đơn vị: ${code}\n`
      response += `• Điện thoại: ${phone}\n`
      response += `• Địa chỉ: ${address}\n`
      if (representative) response += `• Người đại diện: ${representative}\n`
      response += `• Trạng thái: ${isActive}\n`

      return response
    }

    let response = `🏢 **Tìm thấy ${operators.length} đơn vị:**\n\n`
    operators.slice(0, 5).forEach((o, index) => {
      const name = o.name || 'N/A'
      const code = o.code || ''
      response += `${index + 1}. ${name}${code ? ` (${code})` : ''}\n`
    })

    return response
  }
}

export const responseFormatter = new ResponseFormatterService()
</file>

<file path="server/src/modules/dispatch/__tests__/dispatch-validation.test.ts">
/**
 * Dispatch Validation Tests
 * Tests for dispatch module validation functions
 */

import { describe, it, expect } from '@jest/globals';
import {
  validateCreateDispatch,
  validatePassengerDrop,
  validateIssuePermit,
  validatePayment,
  validateDepartureOrder,
  validateExit,
  DISPATCH_STATUS,
  validateStatusTransition,
} from '../dispatch-validation.js';

describe('Dispatch Validation', () => {
  describe('validateCreateDispatch', () => {
    it('should validate valid dispatch create data', () => {
      const validData = {
        vehicleId: 'vehicle-1',
        driverId: 'driver-1',
        routeId: 'route-1',
        entryTime: '2024-12-18T08:00:00+07:00',
      };

      const result = validateCreateDispatch(validData);

      expect(result.vehicleId).toBe('vehicle-1');
      expect(result.driverId).toBe('driver-1');
      expect(result.routeId).toBe('route-1');
    });

    it('should validate data with optional fields', () => {
      const validData = {
        vehicleId: 'vehicle-1',
        driverId: 'driver-1',
        entryTime: '2024-12-18T08:00:00Z',
        notes: 'Test notes',
        entryShiftId: 'shift-1',
      };

      const result = validateCreateDispatch(validData);

      expect(result.notes).toBe('Test notes');
      expect(result.entryShiftId).toBe('shift-1');
    });

    it('should throw error for missing vehicleId', () => {
      const invalidData = {
        driverId: 'driver-1',
        entryTime: '2024-12-18T08:00:00Z',
      };

      expect(() => validateCreateDispatch(invalidData)).toThrow();
    });

    it('should throw error for missing driverId', () => {
      const invalidData = {
        vehicleId: 'vehicle-1',
        entryTime: '2024-12-18T08:00:00Z',
      };

      expect(() => validateCreateDispatch(invalidData)).toThrow();
    });

    it('should throw error for invalid entryTime format', () => {
      const invalidData = {
        vehicleId: 'vehicle-1',
        driverId: 'driver-1',
        entryTime: 'not-a-date',
      };

      expect(() => validateCreateDispatch(invalidData)).toThrow();
    });

    it('should throw error for empty vehicleId', () => {
      const invalidData = {
        vehicleId: '',
        driverId: 'driver-1',
        entryTime: '2024-12-18T08:00:00Z',
      };

      expect(() => validateCreateDispatch(invalidData)).toThrow();
    });
  });

  describe('validatePassengerDrop', () => {
    it('should validate valid passenger drop data', () => {
      const validData = {
        passengersArrived: 30,
        routeId: 'route-1',
      };

      const result = validatePassengerDrop(validData);

      expect(result.passengersArrived).toBe(30);
      expect(result.routeId).toBe('route-1');
    });

    it('should allow empty object (all fields optional)', () => {
      const result = validatePassengerDrop({});

      expect(result.passengersArrived).toBeUndefined();
      expect(result.routeId).toBeUndefined();
    });

    it('should allow zero passengers', () => {
      const validData = { passengersArrived: 0 };

      const result = validatePassengerDrop(validData);

      expect(result.passengersArrived).toBe(0);
    });

    it('should throw error for negative passengers', () => {
      const invalidData = { passengersArrived: -5 };

      expect(() => validatePassengerDrop(invalidData)).toThrow();
    });

    it('should throw error for non-integer passengers', () => {
      const invalidData = { passengersArrived: 30.5 };

      expect(() => validatePassengerDrop(invalidData)).toThrow();
    });
  });

  describe('validateIssuePermit', () => {
    it('should validate approved permit with transport order code', () => {
      const validData = {
        permitStatus: 'approved',
        transportOrderCode: 'TO-001',
        seatCount: 45,
        plannedDepartureTime: '2024-12-18T10:00:00Z',
      };

      const result = validateIssuePermit(validData);

      expect(result.permitStatus).toBe('approved');
      expect(result.transportOrderCode).toBe('TO-001');
      expect(result.seatCount).toBe(45);
    });

    it('should throw error for approved permit without transport order code', () => {
      const invalidData = {
        permitStatus: 'approved',
        seatCount: 45,
      };

      expect(() => validateIssuePermit(invalidData)).toThrow();
    });

    it('should allow rejected permit without transport order code', () => {
      const validData = {
        permitStatus: 'rejected',
        rejectionReason: 'Invalid documents',
      };

      const result = validateIssuePermit(validData);

      expect(result.permitStatus).toBe('rejected');
      expect(result.rejectionReason).toBe('Invalid documents');
    });

    it('should validate with optional replacement vehicle', () => {
      const validData = {
        permitStatus: 'approved',
        transportOrderCode: 'TO-001',
        replacementVehicleId: 'vehicle-2',
      };

      const result = validateIssuePermit(validData);

      expect(result.replacementVehicleId).toBe('vehicle-2');
    });

    it('should throw error for invalid permit status', () => {
      const invalidData = {
        permitStatus: 'pending', // Not in enum
      };

      expect(() => validateIssuePermit(invalidData)).toThrow();
    });
  });

  describe('validatePayment', () => {
    it('should validate valid payment data', () => {
      const validData = {
        paymentAmount: 150000,
        paymentMethod: 'cash',
        invoiceNumber: 'INV-001',
      };

      const result = validatePayment(validData);

      expect(result.paymentAmount).toBe(150000);
      expect(result.paymentMethod).toBe('cash');
    });

    it('should allow zero payment amount', () => {
      const validData = { paymentAmount: 0 };

      const result = validatePayment(validData);

      expect(result.paymentAmount).toBe(0);
    });

    it('should throw error for negative payment', () => {
      const invalidData = { paymentAmount: -100 };

      expect(() => validatePayment(invalidData)).toThrow();
    });

    it('should throw error for invalid payment method', () => {
      const invalidData = {
        paymentAmount: 100,
        paymentMethod: 'crypto', // Not in enum
      };

      expect(() => validatePayment(invalidData)).toThrow();
    });

    it('should accept all valid payment methods', () => {
      const methods = ['cash', 'transfer', 'card'] as const;

      methods.forEach((method) => {
        const result = validatePayment({
          paymentAmount: 100,
          paymentMethod: method,
        });
        expect(result.paymentMethod).toBe(method);
      });
    });
  });

  describe('validateDepartureOrder', () => {
    it('should validate valid departure order data', () => {
      const validData = {
        passengersDeparting: 40,
        departureOrderShiftId: 'shift-2',
      };

      const result = validateDepartureOrder(validData);

      expect(result.passengersDeparting).toBe(40);
      expect(result.departureOrderShiftId).toBe('shift-2');
    });

    it('should allow empty object (all fields optional)', () => {
      const result = validateDepartureOrder({});

      expect(result.passengersDeparting).toBeUndefined();
    });

    it('should throw error for negative passengers', () => {
      const invalidData = { passengersDeparting: -1 };

      expect(() => validateDepartureOrder(invalidData)).toThrow();
    });
  });

  describe('validateExit', () => {
    it('should validate valid exit data', () => {
      const validData = {
        exitTime: '2024-12-18T10:30:00Z',
        passengersDeparting: 42,
        exitShiftId: 'shift-3',
      };

      const result = validateExit(validData);

      expect(result.exitTime).toBe('2024-12-18T10:30:00Z');
      expect(result.passengersDeparting).toBe(42);
    });

    it('should allow empty object (all fields optional)', () => {
      const result = validateExit({});

      expect(result.exitTime).toBeUndefined();
      expect(result.passengersDeparting).toBeUndefined();
    });
  });

  describe('validateStatusTransition', () => {
    it('should allow valid transition: entered -> passengers_dropped', () => {
      expect(() => {
        validateStatusTransition(
          DISPATCH_STATUS.ENTERED,
          DISPATCH_STATUS.PASSENGERS_DROPPED
        );
      }).not.toThrow();
    });

    it('should allow valid transition: passengers_dropped -> permit_issued', () => {
      expect(() => {
        validateStatusTransition(
          DISPATCH_STATUS.PASSENGERS_DROPPED,
          DISPATCH_STATUS.PERMIT_ISSUED
        );
      }).not.toThrow();
    });

    it('should allow valid transition: permit_issued -> paid', () => {
      expect(() => {
        validateStatusTransition(
          DISPATCH_STATUS.PERMIT_ISSUED,
          DISPATCH_STATUS.PAID
        );
      }).not.toThrow();
    });

    it('should allow valid transition: paid -> departure_ordered', () => {
      expect(() => {
        validateStatusTransition(
          DISPATCH_STATUS.PAID,
          DISPATCH_STATUS.DEPARTURE_ORDERED
        );
      }).not.toThrow();
    });

    it('should allow valid transition: departure_ordered -> departed', () => {
      expect(() => {
        validateStatusTransition(
          DISPATCH_STATUS.DEPARTURE_ORDERED,
          DISPATCH_STATUS.DEPARTED
        );
      }).not.toThrow();
    });

    it('should throw for invalid transition: entered -> paid (skipping steps)', () => {
      expect(() => {
        validateStatusTransition(DISPATCH_STATUS.ENTERED, DISPATCH_STATUS.PAID);
      }).toThrow();
    });

    it('should throw for backward transition: paid -> entered', () => {
      expect(() => {
        validateStatusTransition(DISPATCH_STATUS.PAID, DISPATCH_STATUS.ENTERED);
      }).toThrow();
    });
  });
});
</file>

<file path="server/src/modules/dispatch/dispatch-repository.ts">
/**
 * Dispatch Repository
 * Handles all Firebase operations for dispatch records
 */

import { firebase } from '../../config/database.js'
import type { DispatchDBRecord, DispatchFilters } from './dispatch-types.js'

/**
 * Dispatch Repository class
 */
class DispatchRepository {
  private collection = 'dispatch_records'

  /**
   * Find all dispatch records with optional filters
   */
  async findAll(filters?: DispatchFilters): Promise<DispatchDBRecord[]> {
    let query = firebase
      .from(this.collection)
      .select('*')
      .order('entry_time', { ascending: false })

    if (filters?.status) {
      query = query.eq('current_status', filters.status)
    }
    if (filters?.vehicleId) {
      query = query.eq('vehicle_id', filters.vehicleId)
    }
    if (filters?.driverId) {
      query = query.eq('driver_id', filters.driverId)
    }
    if (filters?.routeId) {
      query = query.eq('route_id', filters.routeId)
    }

    const { data, error } = await query
    if (error) throw error
    return data || []
  }

  /**
   * Find single dispatch record by ID
   */
  async findById(id: string): Promise<DispatchDBRecord | null> {
    const { data, error } = await firebase
      .from(this.collection)
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    return data || null
  }

  /**
   * Create new dispatch record
   */
  async create(insertData: Partial<DispatchDBRecord>): Promise<DispatchDBRecord> {
    const { data, error } = await firebase
      .from(this.collection)
      .insert(insertData)
      .select('*')
      .single()

    if (error) throw error
    return data
  }

  /**
   * Update dispatch record
   */
  async update(id: string, updateData: Partial<DispatchDBRecord>): Promise<DispatchDBRecord | null> {
    const { data, error } = await firebase
      .from(this.collection)
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    return data || null
  }

  /**
   * Delete dispatch record
   */
  async delete(id: string): Promise<void> {
    const { error } = await firebase
      .from(this.collection)
      .delete()
      .eq('id', id)

    if (error) throw error
  }
}

// Export singleton instance
export const dispatchRepository = new DispatchRepository()
</file>

<file path="server/src/modules/dispatch/index.ts">
/**
 * Dispatch Module
 * Export all dispatch-related functionality
 */

// Types (without input types that are also in validation)
export type {
  DispatchRecord,
  DispatchDBRecord,
  DispatchFilters,
} from './dispatch-types.js'

// Validation (includes input types)
export {
  DISPATCH_STATUS,
  validateStatusTransition,
  createDispatchSchema,
  passengerDropSchema,
  issuePermitSchema,
  paymentSchema,
  departureOrderSchema,
  exitSchema,
  validateCreateDispatch,
  validatePassengerDrop,
  validateIssuePermit,
  validatePayment,
  validateDepartureOrder,
  validateExit,
} from './dispatch-validation.js'
export type {
  DispatchStatusType,
  CreateDispatchInput,
  PassengerDropInput,
  IssuePermitInput,
  PaymentInput,
  DepartureOrderInput,
  ExitInput,
} from './dispatch-validation.js'

// Mappers
export { mapDispatchToAPI, mapDispatchListToAPI } from './dispatch-mappers.js'

// Repository
export { dispatchRepository } from './dispatch-repository.js'

// Controller
export {
  getAllDispatchRecords,
  getDispatchRecordById,
  createDispatchRecord,
  recordPassengerDrop,
  issuePermit,
  processPayment,
  issueDepartureOrder,
  recordExit,
} from './controllers/dispatch.controller.js'

// Routes
export { default as dispatchRoutes } from './dispatch.routes.js'
</file>

<file path="server/src/modules/fleet/__tests__/fleet-validation.test.ts">
/**
 * Fleet Validation Tests
 * Tests for fleet module validation functions
 */

import { describe, it, expect } from '@jest/globals';
import {
  validateCreateVehicle,
  validateUpdateVehicle,
  validateCreateDriver,
  validateUpdateDriver,
} from '../fleet-validation.js';

describe('Fleet Validation', () => {
  describe('validateCreateVehicle', () => {
    it('should validate valid vehicle data', () => {
      const validData = {
        plateNumber: '51A-12345',
        operatorId: 'operator-1',
        vehicleTypeId: 'type-1',
        seatCapacity: 45,
      };

      const result = validateCreateVehicle(validData);

      expect(result.plateNumber).toBe('51A-12345');
      expect(result.seatCapacity).toBe(45);
    });

    it('should validate vehicle with all optional fields', () => {
      const validData = {
        plateNumber: '51B-67890',
        seatCapacity: 45,
        bedCapacity: 20,
        chassisNumber: 'CH123456',
        engineNumber: 'EN789012',
        insuranceExpiryDate: '2025-12-31',
        inspectionExpiryDate: '2025-06-30',
        province: 'TP.HCM',
        notes: 'Test vehicle',
      };

      const result = validateCreateVehicle(validData);

      expect(result.chassisNumber).toBe('CH123456');
      expect(result.bedCapacity).toBe(20);
      expect(result.province).toBe('TP.HCM');
    });

    it('should validate vehicle with documents', () => {
      const validData = {
        plateNumber: '51A-12345',
        seatCapacity: 45,
        documents: {
          registration: {
            number: 'REG-001',
            issueDate: '2024-01-01',
            expiryDate: '2025-01-01',
          },
          insurance: {
            number: 'INS-001',
            issueDate: '2024-01-01',
            expiryDate: '2025-01-01',
            issuingAuthority: 'Insurance Co.',
          },
        },
      };

      const result = validateCreateVehicle(validData);

      expect(result.documents?.registration?.number).toBe('REG-001');
      expect(result.documents?.insurance?.issuingAuthority).toBe('Insurance Co.');
    });

    it('should throw error for missing plate number', () => {
      const invalidData = {
        operatorId: 'operator-1',
        seatCapacity: 45,
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should throw error for empty plate number', () => {
      const invalidData = {
        plateNumber: '',
        seatCapacity: 45,
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should throw error for missing seat capacity', () => {
      const invalidData = {
        plateNumber: '51A-12345',
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should throw error for negative seat capacity', () => {
      const invalidData = {
        plateNumber: '51A-12345',
        seatCapacity: -1,
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should throw error for zero seat capacity', () => {
      const invalidData = {
        plateNumber: '51A-12345',
        seatCapacity: 0,
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should throw error for non-integer seat capacity', () => {
      const invalidData = {
        plateNumber: '51A-12345',
        seatCapacity: 45.5,
      };

      expect(() => validateCreateVehicle(invalidData)).toThrow();
    });

    it('should allow empty string for imageUrl', () => {
      const validData = {
        plateNumber: '51A-12345',
        seatCapacity: 45,
        imageUrl: '',
      };

      const result = validateCreateVehicle(validData);

      expect(result.imageUrl).toBe('');
    });

    it('should validate valid URL for imageUrl', () => {
      const validData = {
        plateNumber: '51A-12345',
        seatCapacity: 45,
        imageUrl: 'https://example.com/image.jpg',
      };

      const result = validateCreateVehicle(validData);

      expect(result.imageUrl).toBe('https://example.com/image.jpg');
    });
  });

  describe('validateUpdateVehicle', () => {
    it('should validate partial update with only seatCapacity', () => {
      const validData = {
        seatCapacity: 50,
      };

      const result = validateUpdateVehicle(validData);

      expect(result.seatCapacity).toBe(50);
    });

    it('should validate empty object (no fields required)', () => {
      const result = validateUpdateVehicle({});

      expect(result).toEqual({});
    });

    it('should validate update with multiple fields', () => {
      const validData = {
        plateNumber: '51A-99999',
        seatCapacity: 50,
        notes: 'Updated notes',
      };

      const result = validateUpdateVehicle(validData);

      expect(result.plateNumber).toBe('51A-99999');
      expect(result.seatCapacity).toBe(50);
    });
  });

  describe('validateCreateDriver', () => {
    it('should validate valid driver data', () => {
      const validData = {
        operatorIds: ['operator-1'],
        fullName: 'Nguyễn Văn A',
        idNumber: '123456789012',
        licenseNumber: 'B2-123456',
        licenseClass: 'B2',
        licenseExpiryDate: '2026-12-31',
      };

      const result = validateCreateDriver(validData);

      expect(result.fullName).toBe('Nguyễn Văn A');
      expect(result.operatorIds).toEqual(['operator-1']);
      expect(result.licenseClass).toBe('B2');
    });

    it('should validate driver with multiple operators', () => {
      const validData = {
        operatorIds: ['operator-1', 'operator-2', 'operator-3'],
        fullName: 'Trần Văn B',
        idNumber: '987654321098',
        licenseNumber: 'C-654321',
        licenseClass: 'C',
        licenseExpiryDate: '2027-06-30',
      };

      const result = validateCreateDriver(validData);

      expect(result.operatorIds).toHaveLength(3);
    });

    it('should validate driver with optional address fields', () => {
      const validData = {
        operatorIds: ['operator-1'],
        fullName: 'Lê Văn C',
        idNumber: '111222333444',
        licenseNumber: 'D-111222',
        licenseClass: 'D',
        licenseExpiryDate: '2028-01-01',
        phone: '0909123456',
        province: 'TP.HCM',
        district: 'Quận 1',
        address: '123 Nguyễn Huệ',
      };

      const result = validateCreateDriver(validData);

      expect(result.phone).toBe('0909123456');
      expect(result.province).toBe('TP.HCM');
      expect(result.address).toBe('123 Nguyễn Huệ');
    });

    it('should throw error for empty operatorIds array', () => {
      const invalidData = {
        operatorIds: [],
        fullName: 'Test Driver',
        idNumber: '123456789',
        licenseNumber: 'B2-123',
        licenseClass: 'B2',
        licenseExpiryDate: '2026-12-31',
      };

      expect(() => validateCreateDriver(invalidData)).toThrow();
    });

    it('should throw error for missing fullName', () => {
      const invalidData = {
        operatorIds: ['operator-1'],
        idNumber: '123456789012',
        licenseNumber: 'B2-123456',
        licenseClass: 'B2',
        licenseExpiryDate: '2026-12-31',
      };

      expect(() => validateCreateDriver(invalidData)).toThrow();
    });

    it('should throw error for empty fullName', () => {
      const invalidData = {
        operatorIds: ['operator-1'],
        fullName: '',
        idNumber: '123456789012',
        licenseNumber: 'B2-123456',
        licenseClass: 'B2',
        licenseExpiryDate: '2026-12-31',
      };

      expect(() => validateCreateDriver(invalidData)).toThrow();
    });

    it('should throw error for missing license fields', () => {
      const invalidData = {
        operatorIds: ['operator-1'],
        fullName: 'Test Driver',
        idNumber: '123456789012',
      };

      expect(() => validateCreateDriver(invalidData)).toThrow();
    });
  });

  describe('validateUpdateDriver', () => {
    it('should validate partial update', () => {
      const validData = {
        phone: '0912345678',
      };

      const result = validateUpdateDriver(validData);

      expect(result.phone).toBe('0912345678');
    });

    it('should validate empty object (no fields required)', () => {
      const result = validateUpdateDriver({});

      expect(result).toEqual({});
    });

    it('should validate update with multiple fields', () => {
      const validData = {
        fullName: 'Updated Name',
        phone: '0999888777',
        address: 'New Address',
      };

      const result = validateUpdateDriver(validData);

      expect(result.fullName).toBe('Updated Name');
      expect(result.phone).toBe('0999888777');
    });
  });
});
</file>

<file path="server/src/modules/fleet/driver.routes.ts">
/**
 * Driver Routes
 * API endpoints for driver operations
 */

import { Router } from 'express'
import { authenticate } from '../../middleware/auth.js'
import {
  getAllDrivers,
  getDriverById,
  createDriver,
  updateDriver,
  deleteDriver,
} from './controllers/driver.controller.js'

const router = Router()

// Apply authentication to all routes
router.use(authenticate)

// Driver CRUD
router.get('/', getAllDrivers)
router.get('/:id', getDriverById)
router.post('/', createDriver)
router.put('/:id', updateDriver)
router.delete('/:id', deleteDriver)

export default router
</file>

<file path="server/src/modules/fleet/fleet-types.ts">
/**
 * Fleet Module Types
 * Type definitions for Vehicle and Driver entities
 */

// ========== Vehicle Types ==========

export interface VehicleDocument {
  number: string
  issueDate: string
  expiryDate: string
  issuingAuthority?: string | null
  documentUrl?: string | null
  notes?: string | null
  isValid?: boolean
}

export interface VehicleDocuments {
  registration?: VehicleDocument
  inspection?: VehicleDocument
  insurance?: VehicleDocument
  operation_permit?: VehicleDocument
  emblem?: VehicleDocument
}

export type DocumentType = 'registration' | 'inspection' | 'insurance' | 'operation_permit' | 'emblem'

export interface VehicleRecord {
  id: string
  plateNumber: string
  vehicleTypeId?: string | null
  vehicleType?: {
    id: string
    name: string
  }
  operatorId?: string | null
  operator?: {
    id: string
    name: string
    code: string
  }
  seatCapacity: number
  bedCapacity?: number
  manufactureYear?: number | null
  chassisNumber?: string | null
  engineNumber?: string | null
  color?: string | null
  imageUrl?: string | null
  insuranceExpiryDate?: string | null
  inspectionExpiryDate?: string | null
  cargoLength?: number | null
  cargoWidth?: number | null
  cargoHeight?: number | null
  gpsProvider?: string | null
  gpsUsername?: string | null
  gpsPassword?: string | null
  province?: string | null
  isActive: boolean
  notes?: string | null
  documents?: VehicleDocuments
  createdAt: string
  updatedAt: string
}

export interface VehicleDBRecord {
  id: string
  plate_number: string
  vehicle_type_id?: string | null
  operator_id?: string | null
  seat_capacity: number
  bed_capacity?: number | null
  manufacture_year?: number | null
  chassis_number?: string | null
  engine_number?: string | null
  color?: string | null
  image_url?: string | null
  insurance_expiry_date?: string | null
  inspection_expiry_date?: string | null
  cargo_length?: number | null
  cargo_width?: number | null
  cargo_height?: number | null
  gps_provider?: string | null
  gps_username?: string | null
  gps_password?: string | null
  province?: string | null
  is_active: boolean
  notes?: string | null
  created_at: string
  updated_at: string
  // Joined relations (optional)
  operators?: {
    id: string
    name: string
    code: string
  }
  vehicle_types?: {
    id: string
    name: string
  }
}

export interface VehicleDocumentDB {
  id: string
  vehicle_id: string
  document_type: DocumentType
  document_number: string
  issue_date: string
  expiry_date: string
  issuing_authority?: string | null
  document_url?: string | null
  notes?: string | null
  updated_by?: string | null
  created_at: string
  updated_at: string
}

export interface VehicleFilters {
  operatorId?: string
  isActive?: boolean
  vehicleTypeId?: string
}

// ========== Driver Types ==========

export interface OperatorInfo {
  id: string
  name: string
  code: string
  isPrimary?: boolean
}

export interface DriverRecord {
  id: string
  operatorId?: string | null
  operator?: OperatorInfo
  operatorIds: string[]
  operators: OperatorInfo[]
  fullName: string
  idNumber: string
  phone?: string | null
  email?: string | null
  province?: string | null
  district?: string | null
  address?: string | null
  licenseNumber: string
  licenseClass: string
  licenseIssueDate?: string | null
  licenseExpiryDate?: string | null
  imageUrl?: string | null
  isActive: boolean
  createdAt: string
  updatedAt: string
}

export interface DriverDBRecord {
  id: string
  operator_id?: string | null
  full_name: string
  id_number: string
  phone?: string | null
  email?: string | null
  province?: string | null
  district?: string | null
  address?: string | null
  license_number: string
  license_class: string
  license_issue_date?: string | null
  license_expiry_date?: string | null
  image_url?: string | null
  is_active: boolean
  created_at: string
  updated_at: string
  // Joined relations (optional)
  operators?: {
    id: string
    name: string
    code: string
  }
  driver_operators?: Array<{
    operator_id: string
    is_primary: boolean
    operators?: {
      id: string
      name: string
      code: string
    }
  }>
}

export interface DriverFilters {
  operatorId?: string
  isActive?: boolean
}

// ========== Audit Log Types ==========

export interface AuditLogRecord {
  id: string
  userId?: string | null
  userName: string
  action: string
  recordId: string
  oldValues?: Record<string, unknown> | null
  newValues?: Record<string, unknown> | null
  createdAt: string
}
</file>

<file path="server/src/modules/fleet/fleet-validation.ts">
/**
 * Fleet Module Validation
 * Zod schemas for Vehicle and Driver input validation
 */

import { z } from 'zod'

// ========== Document Schema ==========

const documentSchema = z.object({
  number: z.string().min(1, 'Document number is required'),
  issueDate: z.string().min(1, 'Issue date is required'),
  expiryDate: z.string().min(1, 'Expiry date is required'),
  issuingAuthority: z.string().optional(),
  documentUrl: z.string().optional(),
  notes: z.string().optional(),
})

const documentsSchema = z.object({
  registration: documentSchema.optional(),
  inspection: documentSchema.optional(),
  insurance: documentSchema.optional(),
  operation_permit: documentSchema.optional(),
  emblem: documentSchema.optional(),
})

// ========== Vehicle Schemas ==========

export const createVehicleSchema = z.object({
  plateNumber: z.string().min(1, 'Plate number is required'),
  vehicleTypeId: z.string().min(1).optional(),
  operatorId: z.string().min(1, 'Invalid operator ID').optional(),
  seatCapacity: z.number().int().positive('Seat capacity must be positive'),
  bedCapacity: z.number().int().optional(),
  chassisNumber: z.string().optional(),
  engineNumber: z.string().optional(),
  imageUrl: z.string().url().optional().or(z.literal('')),
  insuranceExpiryDate: z.string().optional(),
  inspectionExpiryDate: z.string().optional(),
  cargoLength: z.number().optional(),
  cargoWidth: z.number().optional(),
  cargoHeight: z.number().optional(),
  gpsProvider: z.string().optional(),
  gpsUsername: z.string().optional(),
  gpsPassword: z.string().optional(),
  province: z.string().optional(),
  notes: z.string().optional(),
  documents: documentsSchema.optional(),
})

export const updateVehicleSchema = createVehicleSchema.partial()

// ========== Driver Schemas ==========

export const createDriverSchema = z.object({
  operatorIds: z.array(z.string().min(1, 'Invalid operator ID')).min(1, 'At least one operator is required'),
  fullName: z.string().min(1, 'Full name is required'),
  idNumber: z.string().min(1, 'ID number is required'),
  phone: z.string().optional(),
  province: z.string().optional(),
  district: z.string().optional(),
  address: z.string().optional(),
  licenseNumber: z.string().min(1, 'License number is required'),
  licenseClass: z.string().min(1, 'License class is required'),
  licenseExpiryDate: z.string().min(1, 'License expiry date is required'),
  imageUrl: z.string().url().optional().or(z.literal('')),
})

export const updateDriverSchema = createDriverSchema.partial()

// ========== Type Exports ==========

export type CreateVehicleInput = z.infer<typeof createVehicleSchema>
export type UpdateVehicleInput = z.infer<typeof updateVehicleSchema>
export type CreateDriverInput = z.infer<typeof createDriverSchema>
export type UpdateDriverInput = z.infer<typeof updateDriverSchema>
export type VehicleDocumentInput = z.infer<typeof documentSchema>
export type VehicleDocumentsInput = z.infer<typeof documentsSchema>

// ========== Validation Functions ==========

export function validateCreateVehicle(data: unknown): CreateVehicleInput {
  return createVehicleSchema.parse(data)
}

export function validateUpdateVehicle(data: unknown): UpdateVehicleInput {
  return updateVehicleSchema.parse(data)
}

export function validateCreateDriver(data: unknown): CreateDriverInput {
  return createDriverSchema.parse(data)
}

export function validateUpdateDriver(data: unknown): UpdateDriverInput {
  return updateDriverSchema.parse(data)
}
</file>

<file path="server/src/modules/fleet/repositories/driver.repository.ts">
/**
 * Driver Repository
 * Data access layer for Driver entity
 */

import { firebaseREST } from '../../../lib/firebase-rest.js'
import { BaseRepository } from '../../../shared/database/base-repository.js'
import {
  DriverDB,
  DriverAPI,
  OperatorDB,
  mapDriver,
  mapDriverToDB,
} from '../../../shared/mappers/entity-mappers.js'
import { DatabaseError } from '../../../shared/errors/app-error.js'

export class DriverRepository extends BaseRepository<DriverDB, DriverAPI> {
  constructor() {
    super('drivers')
  }

  protected mapToAPI(db: DriverDB): DriverAPI {
    return mapDriver(db)
  }

  protected mapToDB(api: Partial<DriverAPI>): Partial<DriverDB> {
    return mapDriverToDB(api)
  }

  /**
   * Find all drivers with operator relations
   */
  async findAllWithRelations(): Promise<DriverAPI[]> {
    try {
      const [driversData, operatorsData] = await Promise.all([
        firebaseREST.get(this.collectionPath),
        firebaseREST.get('operators'),
      ])

      if (!driversData) return []

      const operators = operatorsData || {}

      return Object.keys(driversData).map((key) => {
        const driver: DriverDB = { id: key, ...driversData[key] }
        const operator = driver.operator_id
          ? (operators[driver.operator_id] as OperatorDB)
          : null

        return mapDriver(driver, operator)
      })
    } catch (error) {
      console.error('[drivers] findAllWithRelations error:', error)
      throw new DatabaseError('Failed to fetch drivers with relations')
    }
  }

  /**
   * Find driver by ID with relations
   */
  async findByIdWithRelations(id: string): Promise<DriverAPI | null> {
    try {
      const [driverData, operatorsData] = await Promise.all([
        firebaseREST.get(`${this.collectionPath}/${id}`),
        firebaseREST.get('operators'),
      ])

      if (!driverData) return null

      const driver: DriverDB = { id, ...driverData }
      const operator = driver.operator_id
        ? ((operatorsData || {})[driver.operator_id] as OperatorDB)
        : null

      return mapDriver(driver, operator)
    } catch (error) {
      console.error('[drivers] findByIdWithRelations error:', error)
      throw new DatabaseError(`Failed to fetch driver ${id}`)
    }
  }

  /**
   * Find drivers by operator ID
   */
  async findByOperatorId(operatorId: string): Promise<DriverAPI[]> {
    const all = await this.findAllWithRelations()
    return all.filter((d) => d.operatorId === operatorId)
  }

  /**
   * Find drivers by active status
   */
  async findByActiveStatus(isActive: boolean): Promise<DriverAPI[]> {
    const all = await this.findAllWithRelations()
    return all.filter((d) => d.isActive === isActive)
  }

  /**
   * Find driver by ID number
   */
  async findByIdNumber(idNumber: string): Promise<DriverAPI | null> {
    const all = await this.findAll()
    return all.find((d) => d.idNumber === idNumber) || null
  }

  /**
   * Find driver by license number
   */
  async findByLicenseNumber(licenseNumber: string): Promise<DriverAPI | null> {
    const all = await this.findAll()
    return all.find((d) => d.licenseNumber === licenseNumber) || null
  }

  /**
   * Check if ID number exists
   */
  async idNumberExists(idNumber: string, excludeId?: string): Promise<boolean> {
    const all = await this.findAll()
    return all.some((d) => d.idNumber === idNumber && d.id !== excludeId)
  }

  /**
   * Check if license number exists
   */
  async licenseNumberExists(licenseNumber: string, excludeId?: string): Promise<boolean> {
    const all = await this.findAll()
    return all.some((d) => d.licenseNumber === licenseNumber && d.id !== excludeId)
  }
}

// Export singleton instance
export const driverRepository = new DriverRepository()
</file>

<file path="server/src/modules/fleet/repositories/vehicle-type.repository.ts">
/**
 * Vehicle Type Repository
 * Data access layer for VehicleType entity
 */

import { BaseRepository } from '../../../shared/database/base-repository.js'
import {
  VehicleTypeDB,
  VehicleTypeAPI,
  mapVehicleType,
} from '../../../shared/mappers/entity-mappers.js'

export class VehicleTypeRepository extends BaseRepository<VehicleTypeDB, VehicleTypeAPI> {
  constructor() {
    super('vehicle_types')
  }

  protected mapToAPI(db: VehicleTypeDB): VehicleTypeAPI {
    return mapVehicleType(db)
  }

  protected mapToDB(api: Partial<VehicleTypeAPI>): Partial<VehicleTypeDB> {
    const result: Partial<VehicleTypeDB> = {}
    if (api.name !== undefined) result.name = api.name
    if (api.description !== undefined) result.description = api.description
    return result
  }

  /**
   * Find by name
   */
  async findByName(name: string): Promise<VehicleTypeAPI | null> {
    return this.findOneByField('name', name)
  }

  /**
   * Check if name exists
   */
  async nameExists(name: string, excludeId?: string): Promise<boolean> {
    const all = await this.findAll()
    return all.some((vt) => vt.name === name && vt.id !== excludeId)
  }
}

// Export singleton instance
export const vehicleTypeRepository = new VehicleTypeRepository()
</file>

<file path="server/src/modules/fleet/repositories/vehicle.repository.ts">
/**
 * Vehicle Repository
 * Data access layer for Vehicle entity
 */

import { firebaseREST } from '../../../lib/firebase-rest.js'
import { BaseRepository } from '../../../shared/database/base-repository.js'
import {
  VehicleDB,
  VehicleAPI,
  VehicleTypeDB,
  OperatorDB,
  mapVehicle,
  mapVehicleToDB,
} from '../../../shared/mappers/entity-mappers.js'
import { DatabaseError } from '../../../shared/errors/app-error.js'

export class VehicleRepository extends BaseRepository<VehicleDB, VehicleAPI> {
  constructor() {
    super('vehicles')
  }

  protected mapToAPI(db: VehicleDB): VehicleAPI {
    return mapVehicle(db)
  }

  protected mapToDB(api: Partial<VehicleAPI>): Partial<VehicleDB> {
    return mapVehicleToDB(api)
  }

  /**
   * Find all vehicles with related data (vehicleType, operator)
   */
  async findAllWithRelations(): Promise<VehicleAPI[]> {
    try {
      const [vehiclesData, vehicleTypesData, operatorsData] = await Promise.all([
        firebaseREST.get(this.collectionPath),
        firebaseREST.get('vehicle_types'),
        firebaseREST.get('operators'),
      ])

      if (!vehiclesData) return []

      const vehicleTypes = vehicleTypesData || {}
      const operators = operatorsData || {}

      return Object.keys(vehiclesData).map((key) => {
        const vehicle: VehicleDB = { id: key, ...vehiclesData[key] }
        const vehicleType = vehicle.vehicle_type_id
          ? (vehicleTypes[vehicle.vehicle_type_id] as VehicleTypeDB)
          : null
        const operator = vehicle.operator_id
          ? (operators[vehicle.operator_id] as OperatorDB)
          : null

        return mapVehicle(vehicle, vehicleType, operator)
      })
    } catch (error) {
      console.error('[vehicles] findAllWithRelations error:', error)
      throw new DatabaseError('Failed to fetch vehicles with relations')
    }
  }

  /**
   * Find vehicle by ID with relations
   */
  async findByIdWithRelations(id: string): Promise<VehicleAPI | null> {
    try {
      const [vehicleData, vehicleTypesData, operatorsData] = await Promise.all([
        firebaseREST.get(`${this.collectionPath}/${id}`),
        firebaseREST.get('vehicle_types'),
        firebaseREST.get('operators'),
      ])

      if (!vehicleData) return null

      const vehicle: VehicleDB = { id, ...vehicleData }
      const vehicleType = vehicle.vehicle_type_id
        ? ((vehicleTypesData || {})[vehicle.vehicle_type_id] as VehicleTypeDB)
        : null
      const operator = vehicle.operator_id
        ? ((operatorsData || {})[vehicle.operator_id] as OperatorDB)
        : null

      return mapVehicle(vehicle, vehicleType, operator)
    } catch (error) {
      console.error('[vehicles] findByIdWithRelations error:', error)
      throw new DatabaseError(`Failed to fetch vehicle ${id}`)
    }
  }

  /**
   * Find vehicles by operator ID
   */
  async findByOperatorId(operatorId: string): Promise<VehicleAPI[]> {
    const all = await this.findAllWithRelations()
    return all.filter((v) => v.operatorId === operatorId)
  }

  /**
   * Find vehicles by active status
   */
  async findByActiveStatus(isActive: boolean): Promise<VehicleAPI[]> {
    const all = await this.findAllWithRelations()
    return all.filter((v) => v.isActive === isActive)
  }

  /**
   * Find vehicle by plate number
   */
  async findByPlateNumber(plateNumber: string): Promise<VehicleAPI | null> {
    const all = await this.findAll()
    return all.find((v) => v.plateNumber === plateNumber) || null
  }

  /**
   * Check if plate number exists
   */
  async plateNumberExists(plateNumber: string, excludeId?: string): Promise<boolean> {
    const all = await this.findAll()
    return all.some((v) => v.plateNumber === plateNumber && v.id !== excludeId)
  }
}

// Export singleton instance
export const vehicleRepository = new VehicleRepository()
</file>

<file path="server/src/modules/fleet/services/driver.service.ts">
/**
 * Driver Service
 * Business logic layer for Driver entity
 */

import { DriverAPI } from '../../../shared/mappers/entity-mappers.js'
import { AlreadyExistsError, ValidationError } from '../../../shared/errors/app-error.js'
import { driverRepository, DriverRepository } from '../repositories/driver.repository.js'

export interface CreateDriverDTO {
  operatorId?: string
  fullName: string
  idNumber: string
  phone?: string
  email?: string
  province?: string
  district?: string
  address?: string
  licenseNumber: string
  licenseClass: string
  licenseIssueDate?: string
  licenseExpiryDate?: string
  imageUrl?: string
  isActive?: boolean
}

export interface UpdateDriverDTO extends Partial<CreateDriverDTO> {}

export interface DriverFilters {
  operatorId?: string
  isActive?: boolean
}

export class DriverService {
  constructor(private repository: DriverRepository) {}

  /**
   * Get all drivers with optional filters
   */
  async getAll(filters?: DriverFilters): Promise<DriverAPI[]> {
    let drivers = await this.repository.findAllWithRelations()

    if (filters?.operatorId) {
      drivers = drivers.filter((d) => d.operatorId === filters.operatorId)
    }
    if (filters?.isActive !== undefined) {
      drivers = drivers.filter((d) => d.isActive === filters.isActive)
    }

    return drivers
  }

  /**
   * Get driver by ID with relations
   */
  async getById(id: string): Promise<DriverAPI> {
    const driver = await this.repository.findByIdWithRelations(id)
    if (!driver) {
      throw new ValidationError(`Driver with ID '${id}' not found`)
    }
    return driver
  }

  /**
   * Create a new driver
   */
  async create(data: CreateDriverDTO): Promise<DriverAPI> {
    // Validate required fields
    if (!data.fullName?.trim()) {
      throw new ValidationError('Driver name is required')
    }
    if (!data.idNumber?.trim()) {
      throw new ValidationError('ID number is required')
    }
    if (!data.licenseNumber?.trim()) {
      throw new ValidationError('License number is required')
    }
    if (!data.licenseClass?.trim()) {
      throw new ValidationError('License class is required')
    }

    // Check for duplicate ID number
    const idExists = await this.repository.idNumberExists(data.idNumber)
    if (idExists) {
      throw new AlreadyExistsError('Driver', 'idNumber', data.idNumber)
    }

    // Check for duplicate license number
    const licenseExists = await this.repository.licenseNumberExists(data.licenseNumber)
    if (licenseExists) {
      throw new AlreadyExistsError('Driver', 'licenseNumber', data.licenseNumber)
    }

    return this.repository.create({
      ...data,
      isActive: data.isActive ?? true,
    })
  }

  /**
   * Update a driver
   */
  async update(id: string, data: UpdateDriverDTO): Promise<DriverAPI> {
    // Ensure driver exists
    await this.getById(id)

    // Check for duplicate ID number if updating
    if (data.idNumber) {
      const idExists = await this.repository.idNumberExists(data.idNumber, id)
      if (idExists) {
        throw new AlreadyExistsError('Driver', 'idNumber', data.idNumber)
      }
    }

    // Check for duplicate license number if updating
    if (data.licenseNumber) {
      const licenseExists = await this.repository.licenseNumberExists(data.licenseNumber, id)
      if (licenseExists) {
        throw new AlreadyExistsError('Driver', 'licenseNumber', data.licenseNumber)
      }
    }

    await this.repository.updateById(id, data)
    return this.getById(id)
  }

  /**
   * Delete a driver
   */
  async delete(id: string): Promise<void> {
    await this.repository.deleteById(id)
  }

  /**
   * Toggle driver active status
   */
  async toggleActive(id: string): Promise<DriverAPI> {
    const driver = await this.getById(id)
    await this.repository.updateById(id, { isActive: !driver.isActive })
    return this.getById(id)
  }

  /**
   * Get drivers by operator
   */
  async getByOperator(operatorId: string): Promise<DriverAPI[]> {
    return this.repository.findByOperatorId(operatorId)
  }
}

// Export singleton instance
export const driverService = new DriverService(driverRepository)
</file>

<file path="server/src/modules/index.ts">
/**
 * Modules Index
 * Central export point for all application modules
 */

// Operator module
export * from './operator/index.js'

// Fleet module (vehicles, drivers)
export * from './fleet/index.js'
</file>

<file path="server/src/modules/operator/controllers/operator.controller.ts">
/**
 * Operator Controller
 * HTTP request handlers for Operator entity
 */

import { Request, Response } from 'express'
import { operatorService } from '../services/operator.service.js'
import { asyncHandler } from '../../../shared/errors/error-handler.js'
import {
  sendSuccess,
  sendCreated,
  sendNoContent,
} from '../../../shared/response/api-response.js'

/**
 * GET /operators
 * Get all operators
 */
export const getAll = asyncHandler(async (req: Request, res: Response) => {
  const { isActive } = req.query
  const operators = await operatorService.getAll(
    isActive !== undefined ? isActive === 'true' : undefined
  )
  sendSuccess(res, operators)
})

/**
 * GET /operators/:id
 * Get operator by ID
 */
export const getById = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params
  const operator = await operatorService.getById(id)
  sendSuccess(res, operator)
})

/**
 * POST /operators
 * Create a new operator
 */
export const create = asyncHandler(async (req: Request, res: Response) => {
  const operator = await operatorService.create(req.body)
  sendCreated(res, operator)
})

/**
 * PUT /operators/:id
 * Update an operator
 */
export const update = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params
  const operator = await operatorService.update(id, req.body)
  sendSuccess(res, operator)
})

/**
 * DELETE /operators/:id
 * Delete an operator
 */
export const remove = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params
  await operatorService.delete(id)
  sendNoContent(res)
})

/**
 * PATCH /operators/:id/toggle-active
 * Toggle operator active status
 */
export const toggleActive = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params
  const operator = await operatorService.toggleActive(id)
  sendSuccess(res, operator)
})
</file>

<file path="server/src/modules/operator/operator.routes.ts">
/**
 * Operator Routes
 * Defines HTTP routes for Operator module
 */

import { Router } from 'express'
import * as operatorController from './controllers/operator.controller.js'
import { authenticate, authorize } from '../../middleware/auth.js'

const router = Router()

// Apply authentication to all routes
router.use(authenticate)

// GET /operators - Get all operators
router.get('/', operatorController.getAll)

// GET /operators/:id - Get operator by ID
router.get('/:id', operatorController.getById)

// POST /operators - Create operator (admin only)
router.post('/', authorize('admin'), operatorController.create)

// PUT /operators/:id - Update operator (admin only)
router.put('/:id', authorize('admin'), operatorController.update)

// DELETE /operators/:id - Delete operator (admin only)
router.delete('/:id', authorize('admin'), operatorController.remove)

// PATCH /operators/:id/toggle-active - Toggle active status (admin only)
router.patch('/:id/toggle-active', authorize('admin'), operatorController.toggleActive)

export default router
</file>

<file path="server/src/modules/operator/repositories/operator.repository.ts">
/**
 * Operator Repository
 * Data access layer for Operator entity
 */

import { BaseRepository } from '../../../shared/database/base-repository.js'
import {
  OperatorDB,
  OperatorAPI,
  mapOperator,
  mapOperatorToDB,
} from '../../../shared/mappers/entity-mappers.js'

export class OperatorRepository extends BaseRepository<OperatorDB, OperatorAPI> {
  constructor() {
    super('operators')
  }

  protected mapToAPI(db: OperatorDB): OperatorAPI {
    return mapOperator(db)
  }

  protected mapToDB(api: Partial<OperatorAPI>): Partial<OperatorDB> {
    return mapOperatorToDB(api)
  }

  /**
   * Find operators by active status
   */
  async findByActiveStatus(isActive: boolean): Promise<OperatorAPI[]> {
    return this.findAllFiltered((op) => op.isActive === isActive)
  }

  /**
   * Find operator by code
   */
  async findByCode(code: string): Promise<OperatorAPI | null> {
    return this.findOneByField('code', code)
  }

  /**
   * Check if code already exists
   */
  async codeExists(code: string, excludeId?: string): Promise<boolean> {
    const all = await this.findAll()
    return all.some((op) => op.code === code && op.id !== excludeId)
  }
}

// Export singleton instance
export const operatorRepository = new OperatorRepository()
</file>

<file path="server/src/modules/operator/services/operator.service.ts">
/**
 * Operator Service
 * Business logic layer for Operator entity
 */

import { OperatorAPI } from '../../../shared/mappers/entity-mappers.js'
import { AlreadyExistsError, ValidationError } from '../../../shared/errors/app-error.js'
import { operatorRepository, OperatorRepository } from '../repositories/operator.repository.js'

export interface CreateOperatorDTO {
  name: string
  code: string
  taxCode?: string
  phone?: string
  email?: string
  address?: string
  province?: string
  district?: string
  representativeName?: string
  representativePosition?: string
  isTicketDelegated?: boolean
  isActive?: boolean
}

export interface UpdateOperatorDTO extends Partial<CreateOperatorDTO> {}

export class OperatorService {
  constructor(private repository: OperatorRepository) {}

  /**
   * Get all operators
   */
  async getAll(isActive?: boolean): Promise<OperatorAPI[]> {
    if (isActive !== undefined) {
      return this.repository.findByActiveStatus(isActive)
    }
    return this.repository.findAll()
  }

  /**
   * Get operator by ID
   */
  async getById(id: string): Promise<OperatorAPI> {
    return this.repository.findByIdOrFail(id)
  }

  /**
   * Create a new operator
   */
  async create(data: CreateOperatorDTO): Promise<OperatorAPI> {
    // Validate required fields
    if (!data.name?.trim()) {
      throw new ValidationError('Operator name is required')
    }
    if (!data.code?.trim()) {
      throw new ValidationError('Operator code is required')
    }

    // Check for duplicate code
    const codeExists = await this.repository.codeExists(data.code)
    if (codeExists) {
      throw new AlreadyExistsError('Operator', 'code', data.code)
    }

    return this.repository.create({
      ...data,
      isActive: data.isActive ?? true,
    })
  }

  /**
   * Update an operator
   */
  async update(id: string, data: UpdateOperatorDTO): Promise<OperatorAPI> {
    // Ensure operator exists
    await this.repository.findByIdOrFail(id)

    // Check for duplicate code if updating code
    if (data.code) {
      const codeExists = await this.repository.codeExists(data.code, id)
      if (codeExists) {
        throw new AlreadyExistsError('Operator', 'code', data.code)
      }
    }

    return this.repository.updateById(id, data)
  }

  /**
   * Delete an operator
   */
  async delete(id: string): Promise<void> {
    await this.repository.deleteById(id)
  }

  /**
   * Toggle operator active status
   */
  async toggleActive(id: string): Promise<OperatorAPI> {
    const operator = await this.repository.findByIdOrFail(id)
    return this.repository.updateById(id, { isActive: !operator.isActive })
  }
}

// Export singleton instance
export const operatorService = new OperatorService(operatorRepository)
</file>

<file path="server/src/routes/auth.routes.ts">
import { Router } from 'express'
import { login, register, getCurrentUser } from '../controllers/auth.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.post('/login', login)
router.post('/register', register)
router.get('/me', authenticate, getCurrentUser)

export default router
</file>

<file path="server/src/routes/driver.routes.ts">
import { Router } from 'express'
import {
  getAllDrivers,
  getDriverById,
  createDriver,
  updateDriver,
  deleteDriver,
} from '../controllers/driver.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllDrivers)
router.get('/:id', getDriverById)
router.post('/', createDriver)
router.put('/:id', updateDriver)
router.delete('/:id', deleteDriver)

export default router
</file>

<file path="server/src/routes/invoice.routes.ts">
import { Router } from 'express'
import {
  getAllInvoices,
  getInvoiceById,
  createInvoice,
  updateInvoice,
  updateInvoicePayment,
} from '../controllers/invoice.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllInvoices)
router.get('/:id', getInvoiceById)
router.post('/', createInvoice)
router.put('/:id', updateInvoice)
router.patch('/:id/payment', updateInvoicePayment)

export default router
</file>

<file path="server/src/routes/location.routes.ts">
import { Router } from 'express'
import {
  getAllLocations,
  getLocationById,
  createLocation,
  updateLocation,
  deleteLocation,
} from '../controllers/location.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllLocations)
router.get('/:id', getLocationById)
router.post('/', createLocation)
router.put('/:id', updateLocation)
router.delete('/:id', deleteLocation)

export default router
</file>

<file path="server/src/routes/quanly-data.routes.ts">
import { Router } from 'express'
import { getQuanLyData, getQuanLyStats } from '../controllers/quanly-data.controller.js'

const router = Router()

// GET /api/quanly-data - unified data endpoint
router.get('/', getQuanLyData)

// GET /api/quanly-data/stats - lightweight stats
router.get('/stats', getQuanLyStats)

export default router
</file>

<file path="server/src/routes/report.routes.ts">
import { Router } from 'express'
import {
  getInvoices,
  getVehicleLogs,
  getStationActivity,
  getInvalidVehicles,
  getRevenue,
  exportExcel,
} from '../controllers/report.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/invoices', getInvoices)
router.get('/vehicle-logs', getVehicleLogs)
router.get('/station-activity', getStationActivity)
router.get('/invalid-vehicles', getInvalidVehicles)
router.get('/revenue', getRevenue)
router.get('/export/:type', exportExcel)

export default router
</file>

<file path="server/src/routes/schedule.routes.ts">
import { Router } from 'express'
import {
  getAllSchedules,
  getScheduleById,
  createSchedule,
  updateSchedule,
  deleteSchedule,
} from '../controllers/schedule.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllSchedules)
router.get('/:id', getScheduleById)
router.post('/', createSchedule)
router.put('/:id', updateSchedule)
router.delete('/:id', deleteSchedule)

export default router
</file>

<file path="server/src/routes/service-charge.routes.ts">
import { Router } from 'express'
import {
  getAllServiceCharges,
  getServiceChargeById,
  createServiceCharge,
  deleteServiceCharge,
  getAllServiceTypes,
} from '../controllers/service-charge.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/types', getAllServiceTypes)
router.get('/', getAllServiceCharges)
router.get('/:id', getServiceChargeById)
router.post('/', createServiceCharge)
router.delete('/:id', deleteServiceCharge)

export default router
</file>

<file path="server/src/routes/service-formula.routes.ts">
import { Router } from 'express'
import {
  getAllServiceFormulas,
  getServiceFormulaById,
  createServiceFormula,
  updateServiceFormula,
  deleteServiceFormula,
} from '../controllers/service-formula.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllServiceFormulas)
router.get('/:id', getServiceFormulaById)
router.post('/', createServiceFormula)
router.put('/:id', updateServiceFormula)
router.delete('/:id', deleteServiceFormula)

export default router
</file>

<file path="server/src/routes/service.routes.ts">
import { Router } from 'express'
import {
  getAllServices,
  getServiceById,
  createService,
  updateService,
  deleteService,
} from '../controllers/service.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllServices)
router.get('/:id', getServiceById)
router.post('/', createService)
router.put('/:id', updateService)
router.delete('/:id', deleteService)

export default router
</file>

<file path="server/src/routes/shift.routes.ts">
import { Router } from 'express'
import {
  getAllShifts,
  getShiftById,
  createShift,
  updateShift,
  deleteShift,
} from '../controllers/shift.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllShifts)
router.get('/:id', getShiftById)
router.post('/', createShift)
router.put('/:id', updateShift)
router.delete('/:id', deleteShift)

export default router
</file>

<file path="server/src/routes/upload.routes.ts">
import { Router } from 'express';
import { uploadImage } from '../controllers/upload.controller.js';
import { upload } from '../middleware/upload.js';
import { authenticate } from '../middleware/auth.js';

const router = Router();

// Protect upload route
router.use(authenticate);

// 'image' is the field name in the form-data
router.post('/', upload.single('image'), uploadImage);

export default router;
</file>

<file path="server/src/routes/vehicle-type.routes.ts">
import { Router } from 'express'
import {
  getAllVehicleTypes,
  getVehicleTypeById,
  createVehicleType,
  updateVehicleType,
  deleteVehicleType,
} from '../controllers/vehicle-type.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllVehicleTypes)
router.get('/:id', getVehicleTypeById)
router.post('/', createVehicleType)
router.put('/:id', updateVehicleType)
router.delete('/:id', deleteVehicleType)

export default router
</file>

<file path="server/src/routes/violation.routes.ts">
import { Router } from 'express'
import {
  getAllViolations,
  getViolationById,
  createViolation,
  updateViolation,
  getAllViolationTypes,
} from '../controllers/violation.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/types', getAllViolationTypes)
router.get('/', getAllViolations)
router.get('/:id', getViolationById)
router.post('/', createViolation)
router.put('/:id', updateViolation)

export default router
</file>

<file path="server/src/scripts/check-and-fix-vehicle-data.ts">
/**
 * Script to check and fix vehicle data links to operators and vehicle_types
 * 
 * Usage:
 *   npx tsx src/scripts/check-and-fix-vehicle-data.ts          # Check only
 *   npx tsx src/scripts/check-and-fix-vehicle-data.ts --fix    # Check and fix
 */

import admin from 'firebase-admin'
import dotenv from 'dotenv'
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import { readFileSync, existsSync } from 'fs'

dotenv.config()

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// Initialize Firebase Admin
function initializeFirebase() {
  if (admin.apps.length > 0) return admin.database()
  
  // Try to find service account file
  const possiblePaths = [
    resolve(__dirname, '../../firebase-service-account.json'),
    resolve(__dirname, '../../../server/firebase-service-account.json'),
    resolve(process.cwd(), 'firebase-service-account.json'),
  ]
  
  let serviceAccountPath = ''
  for (const p of possiblePaths) {
    if (existsSync(p)) {
      serviceAccountPath = p
      break
    }
  }
  
  if (!serviceAccountPath) {
    throw new Error('Service account file not found. Please ensure benxe-management-20251218-firebase-adminsdk.json exists.')
  }
  
  const serviceAccount = JSON.parse(readFileSync(serviceAccountPath, 'utf8'))
  const databaseURL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/'
  
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL
  })
  
  return admin.database()
}

// Helper function to generate ID
function generateId(): string {
  const timestamp = Date.now().toString(36)
  const randomPart = Math.random().toString(36).substring(2, 15)
  return `${timestamp}-${randomPart}`
}

function now(): string {
  return new Date().toISOString()
}

async function main() {
  const shouldFix = process.argv.includes('--fix')
  
  console.log('🔍 Checking vehicle data in Firebase...\n')
  
  const db = initializeFirebase()
  console.log('✅ Firebase Admin initialized\n')
  
  // 1. Get all operators
  console.log('📋 Loading operators...')
  const operatorsSnapshot = await db.ref('operators').once('value')
  const operatorsData = operatorsSnapshot.val()
  const operators = operatorsData ? Object.entries(operatorsData).map(([id, data]: [string, any]) => ({
    id,
    name: data.name,
    code: data.code
  })) : []
  console.log(`   Found ${operators.length} operators:`)
  operators.forEach(op => console.log(`   - ${op.name} (${op.code})`))
  
  // 2. Get all vehicle_types
  console.log('\n📋 Loading vehicle_types...')
  const vehicleTypesSnapshot = await db.ref('vehicle_types').once('value')
  const vehicleTypesData = vehicleTypesSnapshot.val()
  const vehicleTypes = vehicleTypesData ? Object.entries(vehicleTypesData).map(([id, data]: [string, any]) => ({
    id,
    name: data.name,
    defaultSeatCapacity: data.default_seat_capacity,
    defaultBedCapacity: data.default_bed_capacity
  })) : []
  console.log(`   Found ${vehicleTypes.length} vehicle types:`)
  vehicleTypes.forEach(vt => console.log(`   - ${vt.name} (seats: ${vt.defaultSeatCapacity ?? 'N/A'}, beds: ${vt.defaultBedCapacity ?? 'N/A'})`))
  
  // 3. Get all vehicles
  console.log('\n📋 Loading vehicles...')
  const vehiclesSnapshot = await db.ref('vehicles').once('value')
  const vehiclesData = vehiclesSnapshot.val()
  const vehicles = vehiclesData ? Object.entries(vehiclesData).map(([id, data]: [string, any]) => ({
    id,
    plateNumber: data.plate_number,
    vehicleTypeId: data.vehicle_type_id,
    operatorId: data.operator_id,
    seatCapacity: data.seat_capacity,
    bedCapacity: data.bed_capacity
  })) : []
  console.log(`   Found ${vehicles.length} vehicles`)
  
  // 4. Check for issues
  console.log('\n🔍 Checking for data issues...\n')
  
  const vehiclesWithoutOperator = vehicles.filter(v => !v.operatorId || !operators.find(op => op.id === v.operatorId))
  const vehiclesWithoutType = vehicles.filter(v => !v.vehicleTypeId || !vehicleTypes.find(vt => vt.id === v.vehicleTypeId))
  
  console.log(`⚠️  Vehicles without valid operator: ${vehiclesWithoutOperator.length}`)
  vehiclesWithoutOperator.forEach(v => console.log(`   - ${v.plateNumber} (operatorId: ${v.operatorId || 'null'})`))
  
  console.log(`\n⚠️  Vehicles without valid vehicle type: ${vehiclesWithoutType.length}`)
  vehiclesWithoutType.forEach(v => console.log(`   - ${v.plateNumber} (vehicleTypeId: ${v.vehicleTypeId || 'null'})`))
  
  // 5. Create missing vehicle_types if needed
  if (vehicleTypes.length === 0 && shouldFix) {
    console.log('\n🔧 Creating default vehicle types...')
    const defaultTypes = [
      { name: 'Xe khách 16 chỗ', default_seat_capacity: 16, default_bed_capacity: 0 },
      { name: 'Xe khách 29 chỗ', default_seat_capacity: 29, default_bed_capacity: 0 },
      { name: 'Xe khách 45 chỗ', default_seat_capacity: 45, default_bed_capacity: 0 },
      { name: 'Xe giường nằm 34 chỗ', default_seat_capacity: 0, default_bed_capacity: 34 },
      { name: 'Xe giường nằm 40 chỗ', default_seat_capacity: 0, default_bed_capacity: 40 },
      { name: 'Xe giường nằm 44 chỗ', default_seat_capacity: 0, default_bed_capacity: 44 },
    ]
    
    for (const vt of defaultTypes) {
      const id = generateId()
      await db.ref(`vehicle_types/${id}`).set({
        ...vt,
        description: vt.name,
        created_at: now()
      })
      vehicleTypes.push({ id, name: vt.name, defaultSeatCapacity: vt.default_seat_capacity, defaultBedCapacity: vt.default_bed_capacity })
      console.log(`   ✅ Created: ${vt.name}`)
    }
  }
  
  // 6. Create missing operators if needed
  if (operators.length === 0 && shouldFix) {
    console.log('\n🔧 Creating default operators...')
    const defaultOperators = [
      { name: 'Công ty CP Xe khách Phương Trang', code: 'FUTA' },
      { name: 'Công ty TNHH Thành Bưởi', code: 'THANHBUOI' },
      { name: 'Công ty TNHH Vận tải Kumho Samco', code: 'KUMHO' },
    ]
    
    for (const op of defaultOperators) {
      const id = generateId()
      await db.ref(`operators/${id}`).set({
        ...op,
        is_active: true,
        created_at: now(),
        updated_at: now()
      })
      operators.push({ id, name: op.name, code: op.code })
      console.log(`   ✅ Created: ${op.name}`)
    }
  }
  
  // 7. Summary and suggestion
  console.log('\n' + '='.repeat(60))
  console.log('📊 SUMMARY')
  console.log('='.repeat(60))
  console.log(`Total vehicles: ${vehicles.length}`)
  console.log(`Vehicles without operator: ${vehiclesWithoutOperator.length}`)
  console.log(`Vehicles without vehicle type: ${vehiclesWithoutType.length}`)
  console.log(`Available operators: ${operators.length}`)
  console.log(`Available vehicle types: ${vehicleTypes.length}`)
  
  if (!shouldFix && (vehiclesWithoutOperator.length > 0 || vehiclesWithoutType.length > 0 || operators.length === 0 || vehicleTypes.length === 0)) {
    console.log('\n💡 To fix issues, run:')
    console.log('   npx tsx src/scripts/check-and-fix-vehicle-data.ts --fix')
  }
  
  if (shouldFix) {
    console.log('\n✅ Fix completed!')
    console.log('\n📝 NOTE: Vehicles still need to be manually linked to operators/vehicle_types')
    console.log('   through the UI or by updating the database directly.')
  }
  
  // Terminate Firebase connection
  process.exit(0)
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})
</file>

<file path="server/src/scripts/cleanup-seed-data.ts">
/**
 * Cleanup Script: Remove seed/test data from Firebase RTDB
 * 
 * Removes:
 * - Vehicles with plate numbers like 51B-xxx.xx (seed format)
 * - Vehicles with is_active = false
 * - Test operators (FUTA, THANHBUOI, KUMHO)
 * - Test drivers associated with test operators
 * - Test vehicle badges
 * 
 * Run with: npx tsx src/scripts/cleanup-seed-data.ts
 * 
 * Optional flags:
 * --dry-run    (show what would be deleted without deleting)
 */

import { initializeApp, getApps, cert, App } from 'firebase-admin/app'
import { getDatabase, Database } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

const RTDB_URL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'
const SERVICE_ACCOUNT_PATH = process.env.SERVICE_ACCOUNT_PATH

let app: App | null = null
let db: Database | null = null

// Seed vehicle plate patterns (from seed-firebase-rest.ts)
const SEED_PLATE_PATTERNS = [
  /^51B-\d{3}\.\d{2}$/,  // 51B-123.45, 51B-678.90, etc.
  /^51B-\d{3}\.\d{2}$/,
  /^212121A$/i,
  /^98H07480$/i,
]

// Seed operator codes
const SEED_OPERATOR_CODES = ['FUTA', 'THANHBUOI', 'KUMHO', 'TEST']

function initializeFirebase() {
  if (app) return

  if (!getApps().length) {
    if (SERVICE_ACCOUNT_PATH) {
      const absolutePath = resolve(process.cwd(), SERVICE_ACCOUNT_PATH)
      const serviceAccount = JSON.parse(readFileSync(absolutePath, 'utf-8'))
      app = initializeApp({
        credential: cert(serviceAccount),
        databaseURL: RTDB_URL
      })
    } else {
      app = initializeApp({
        databaseURL: RTDB_URL
      })
    }
  } else {
    app = getApps()[0]
  }

  db = getDatabase(app)
}

function isSeedPlate(plateNumber: string): boolean {
  if (!plateNumber) return false
  return SEED_PLATE_PATTERNS.some(pattern => pattern.test(plateNumber))
}

function isSeedOperatorCode(code: string): boolean {
  if (!code) return false
  return SEED_OPERATOR_CODES.includes(code.toUpperCase())
}

async function cleanupCollection(
  collectionPath: string,
  shouldDelete: (key: string, data: any) => boolean,
  dryRun: boolean
): Promise<{ deleted: number; kept: number; deletedKeys: string[] }> {
  const stats = { deleted: 0, kept: 0, deletedKeys: [] as string[] }
  
  const snapshot = await db!.ref(collectionPath).once('value')
  const data = snapshot.val()
  
  if (!data) {
    console.log(`    No data in ${collectionPath}`)
    return stats
  }
  
  const keys = Object.keys(data)
  console.log(`    Found ${keys.length} records`)
  
  for (const key of keys) {
    const record = data[key]
    if (shouldDelete(key, record)) {
      stats.deletedKeys.push(key)
      stats.deleted++
      
      if (!dryRun) {
        await db!.ref(`${collectionPath}/${key}`).remove()
      }
    } else {
      stats.kept++
    }
  }
  
  return stats
}

async function main() {
  const args = process.argv.slice(2)
  const dryRun = args.includes('--dry-run')
  
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  CLEANUP SEED/TEST DATA')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')
  console.log(`  Target: ${RTDB_URL}`)
  console.log(`  Mode: ${dryRun ? 'DRY RUN (no changes)' : 'LIVE DELETE'}`)
  console.log('')
  
  initializeFirebase()
  
  // Collect seed operator IDs first
  console.log('  Step 1: Finding seed operators...')
  const operatorsSnap = await db!.ref('operators').once('value')
  const operatorsData = operatorsSnap.val() || {}
  const seedOperatorIds = new Set<string>()
  
  for (const [key, op] of Object.entries(operatorsData) as [string, any][]) {
    if (op && isSeedOperatorCode(op.code)) {
      seedOperatorIds.add(key)
      console.log(`    Found seed operator: ${op.code} (${key})`)
    }
  }
  
  // 1. Clean up vehicles
  console.log('\n  Step 2: Cleaning vehicles...')
  const vehicleStats = await cleanupCollection(
    'vehicles',
    (_key, vehicle) => {
      // Delete if: seed plate pattern, inactive, or belongs to seed operator
      if (!vehicle) return true
      if (isSeedPlate(vehicle.plate_number || vehicle.plateNumber)) return true
      if (vehicle.is_active === false) return true
      if (seedOperatorIds.has(vehicle.operator_id || vehicle.operatorId)) return true
      return false
    },
    dryRun
  )
  console.log(`    ${dryRun ? 'Would delete' : 'Deleted'}: ${vehicleStats.deleted}, Kept: ${vehicleStats.kept}`)
  if (vehicleStats.deletedKeys.length > 0 && vehicleStats.deletedKeys.length <= 20) {
    console.log(`    Deleted plates: ${vehicleStats.deletedKeys.slice(0, 10).join(', ')}${vehicleStats.deletedKeys.length > 10 ? '...' : ''}`)
  }
  
  // 2. Clean up drivers
  console.log('\n  Step 3: Cleaning drivers...')
  const driverStats = await cleanupCollection(
    'drivers',
    (_key, driver) => {
      if (!driver) return true
      if (driver.is_active === false) return true
      // Check if driver's operator is a seed operator
      const driverOperators = driver.operators || []
      if (Array.isArray(driverOperators)) {
        for (const op of driverOperators) {
          if (seedOperatorIds.has(op.operatorId || op.operator_id)) return true
        }
      }
      return false
    },
    dryRun
  )
  console.log(`    ${dryRun ? 'Would delete' : 'Deleted'}: ${driverStats.deleted}, Kept: ${driverStats.kept}`)
  
  // 3. Clean up vehicle badges with seed plates
  console.log('\n  Step 4: Cleaning vehicle badges...')
  const badgeStats = await cleanupCollection(
    'vehicle_badges',
    (_key, badge) => {
      if (!badge) return true
      const plateNumber = badge.BienSoXe || badge.plate_number || ''
      if (isSeedPlate(plateNumber)) return true
      if (badge.TrangThai === 'Hết hiệu lực' || badge.status === 'expired') return true
      return false
    },
    dryRun
  )
  console.log(`    ${dryRun ? 'Would delete' : 'Deleted'}: ${badgeStats.deleted}, Kept: ${badgeStats.kept}`)
  
  // 4. Clean up seed operators
  console.log('\n  Step 5: Cleaning operators...')
  const operatorStats = await cleanupCollection(
    'operators',
    (_key, operator) => {
      if (!operator) return true
      if (isSeedOperatorCode(operator.code)) return true
      if (operator.is_active === false) return true
      return false
    },
    dryRun
  )
  console.log(`    ${dryRun ? 'Would delete' : 'Deleted'}: ${operatorStats.deleted}, Kept: ${operatorStats.kept}`)
  
  // 5. Clean up driver_operators junction
  console.log('\n  Step 6: Cleaning driver_operators junction...')
  const junctionStats = await cleanupCollection(
    'driver_operators',
    (_key, junction) => {
      if (!junction) return true
      if (seedOperatorIds.has(junction.operator_id || junction.operatorId)) return true
      return false
    },
    dryRun
  )
  console.log(`    ${dryRun ? 'Would delete' : 'Deleted'}: ${junctionStats.deleted}, Kept: ${junctionStats.kept}`)
  
  // Summary
  const totalDeleted = vehicleStats.deleted + driverStats.deleted + badgeStats.deleted + operatorStats.deleted + junctionStats.deleted
  const totalKept = vehicleStats.kept + driverStats.kept + badgeStats.kept + operatorStats.kept + junctionStats.kept
  
  console.log('')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  SUMMARY')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log(`  Total ${dryRun ? 'would delete' : 'deleted'}: ${totalDeleted}`)
  console.log(`  Total kept: ${totalKept}`)
  console.log('')
  
  if (dryRun) {
    console.log('  Dry run complete. Run without --dry-run to actually delete.')
  } else {
    console.log('  Cleanup complete!')
  }
}

main()
  .then(() => process.exit(0))
  .catch(err => {
    console.error('Error:', err)
    process.exit(1)
  })
</file>

<file path="server/src/scripts/create-admin.ts">
import bcrypt from 'bcryptjs'
import { firebaseDb } from '../config/database.js'
import dotenv from 'dotenv'

dotenv.config()

// Helper function to generate Firebase-style ID
function generateId(): string {
  const timestamp = Date.now().toString(36)
  const randomPart = Math.random().toString(36).substring(2, 15)
  return `${timestamp}-${randomPart}`
}

async function createAdmin() {
  const username = process.argv[2] || 'admin'
  const password = process.argv[3] || 'admin123'
  const fullName = process.argv[4] || 'Administrator'

  try {
    // Hash password
    const passwordHash = await bcrypt.hash(password, 10)

    // Get all users to check if username exists
    const users = await firebaseDb.get('users')
    
    let existingUser: any = null
    let existingUserId: string | null = null
    
    if (users) {
      const usersArray = Object.keys(users).map(key => ({
        id: key,
        ...users[key]
      }))
      existingUser = usersArray.find((u: any) => u.username === username)
      if (existingUser) {
        existingUserId = existingUser.id
      }
    }

    if (existingUser) {
      console.log(`User "${username}" already exists. Updating password...`)
      await firebaseDb.update(`users/${existingUserId}`, {
        password_hash: passwordHash,
        updated_at: new Date().toISOString()
      })
      console.log(`✅ Password updated for user "${username}"`)
    } else {
      // Create new user
      const userId = generateId()
      const newUser = {
        id: userId,
        username,
        password_hash: passwordHash,
        full_name: fullName,
        role: 'admin',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      await firebaseDb.set(`users/${userId}`, newUser)
      console.log(`✅ Admin user created successfully!`)
      console.log(`   Username: ${username}`)
      console.log(`   Full Name: ${fullName}`)
      console.log(`   Role: admin`)
    }
    
    process.exit(0)
  } catch (error) {
    console.error('❌ Error creating admin user:', error)
    process.exit(1)
  }
}

createAdmin()
</file>

<file path="server/src/scripts/find-vehicle.ts">
import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

const serviceAccount = JSON.parse(readFileSync(resolve(process.cwd(), process.env.SERVICE_ACCOUNT_PATH!), 'utf-8'))

if (!getApps().length) {
  initializeApp({
    credential: cert(serviceAccount),
    databaseURL: process.env.RTDB_URL
  })
}
const db = getDatabase()

const plateToFind = process.argv[2] || '98H07480'

async function find() {
  console.log(`Searching for plate: ${plateToFind}`)
  
  // Check in datasheet/Xe (migrated data)
  console.log('\n1. Checking datasheet/Xe...')
  const xeSnap = await db.ref('datasheet/Xe').once('value')
  const xeData = xeSnap.val()
  
  if (xeData) {
    let found = false
    for (const [key, xe] of Object.entries(xeData)) {
      const x = xe as any
      if (x.plate_number === plateToFind || x.BienSo === plateToFind) {
        console.log('Found in datasheet/Xe:', key)
        console.log(JSON.stringify(x, null, 2).slice(0, 800))
        found = true
        break
      }
    }
    if (!found) {
      console.log('Not found in datasheet/Xe')
    }
  }
  
  // Check in vehicles collection
  console.log('\n2. Checking vehicles...')
  const vehSnap = await db.ref('vehicles').once('value')
  const vehData = vehSnap.val()
  
  if (vehData) {
    let found = false
    for (const [key, veh] of Object.entries(vehData)) {
      const v = veh as any
      if (v.plate_number === plateToFind || v.plateNumber === plateToFind) {
        console.log('Found in vehicles:', key)
        console.log(JSON.stringify(v, null, 2).slice(0, 800))
        found = true
        break
      }
    }
    if (!found) {
      console.log('Not found in vehicles. Total vehicles:', Object.keys(vehData).length)
    }
  } else {
    console.log('vehicles collection is empty')
  }
  
  process.exit(0)
}

find().catch(err => {
  console.error('Error:', err)
  process.exit(1)
})
</file>

<file path="server/src/scripts/HUONG_DAN_IMPORT_XE_TU_SHEETS.md">
# Hướng dẫn Import Dữ liệu Xe từ Google Sheets

> ⚠️ **DEPRECATED / LỖI THỜI**
>
> Script này được viết cho **Supabase** nhưng dự án đã migrate sang **Firebase Realtime Database**.
>
> **Không sử dụng script này nữa.** Để import dữ liệu vào Firebase, vui lòng:
> 1. Sử dụng Firebase Console để import JSON trực tiếp
> 2. Hoặc liên hệ admin để được hỗ trợ import qua API
>
> ---

## ⚡ Tốc độ cao với Batch Mode (DEPRECATED)

Script này sử dụng **Batch Insert** để import nhiều records cùng lúc, giúp tăng tốc độ đáng kể so với import từng record một.

- **Tốc độ**: ~50-100 records mỗi batch (tùy cấu hình)
- **Ưu điểm**: Nhanh hơn 10-50 lần so với import từng record
- **Tự động**: Xử lý lỗi từng phần, tiếp tục với các records còn lại

## Bước 1: Chuẩn bị

### 1.1. Lấy thông tin Supabase

1. Đăng nhập vào [Supabase Dashboard](https://app.supabase.com)
2. Chọn project của bạn
3. Vào **Settings** > **API**
4. Copy các thông tin sau:
   - **Project URL**: `https://xxxxx.supabase.co`
   - **service_role** key (Secret key) - **Lưu ý**: Nên dùng Service Role Key để có đầy đủ quyền

### 1.2. Chuẩn bị Google Sheets

1. Mở Google Sheets chứa dữ liệu xe
2. Đảm bảo sheet có các cột sau (theo đúng tên):
   - `IDXe`
   - `BienSo` (bắt buộc)
   - `SoKhung`
   - `SoMay`
   - `SoCho`
   - `NienHan`
   - `TenDangKyXe`
   - `DiaChiChuXe`
   - `NhanHieu`
   - `LoaiXe`
   - `LoaiPhuongTien`
   - `TaiTrong`
   - `MauSon`
   - `NamSanXuat`
   - `LaBienDinhDanh`
   - `TrangThaiBienDinhDanh`
   - `LyDoThuBienDinhDanh`
   - `ThongTinDangKyXe`
   - `User`
   - `ThoiGianNhap`
   - `Nienhan`
   - `CoKDVT`

3. Dòng đầu tiên phải là header (tên các cột)
4. Dữ liệu bắt đầu từ dòng thứ 2

## Bước 2: Cài đặt Google Apps Script

### 2.1. Mở Apps Script Editor

1. Trong Google Sheets, vào **Extensions** > **Apps Script**
2. Hoặc truy cập: https://script.google.com

### 2.2. Tạo Script mới

1. Xóa code mặc định (nếu có)
2. Copy toàn bộ nội dung từ file `import-vehicles-from-sheets.gs`
3. Paste vào editor

### 2.3. Cấu hình

Tìm và cập nhật các biến trong phần `CONFIG`:

```javascript
const CONFIG = {
  // Thay YOUR_SUPABASE_URL_HERE bằng URL thực tế
  SUPABASE_URL: 'https://xxxxx.supabase.co',
  
  // Thay YOUR_SUPABASE_SERVICE_ROLE_KEY_HERE bằng Service Role Key
  SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  
  // Tên sheet (null = sheet đang active)
  SHEET_NAME: null,
  
  // Số dòng header (thường là 1)
  HEADER_ROW: 1,
  
  // Dòng bắt đầu đọc dữ liệu (sau header)
  START_ROW: 2,
  
  // Cột để đánh dấu trạng thái import (ví dụ: 'Z')
  STATUS_COLUMN: 'Z',
  
  // Số lượng records gửi cùng lúc (batch size)
  // Tăng số này để import nhanh hơn, nhưng không nên quá 100 để tránh timeout
  BATCH_SIZE: 50,
  
  // Delay giữa các batch (ms) - giảm để tăng tốc, tăng để tránh rate limit
  BATCH_DELAY: 50,
  
  // Tự động skip các records bị duplicate (đã tồn tại) thay vì báo lỗi
  SKIP_DUPLICATES: true
};
```

### 2.4. Lưu Script

1. Nhấn **Ctrl+S** (hoặc **Cmd+S** trên Mac)
2. Đặt tên project: "Import Xe lên Supabase"

## Bước 3: Kiểm tra kết nối

### 3.1. Test kết nối Supabase

1. Trong Apps Script Editor, chọn hàm `testConnection` từ dropdown
2. Nhấn nút **Run** (▶)
3. Cho phép quyền truy cập (nếu được hỏi)
4. Nếu thấy thông báo "Kết nối Supabase thành công!" thì đã OK

## Bước 4: Chạy Import

### Cách 1: Chạy từ Apps Script Editor

1. Trong Apps Script Editor, chọn hàm `importVehicles` từ dropdown
2. Nhấn nút **Run** (▶)
3. Cho phép quyền truy cập (nếu được hỏi)
4. Đợi script chạy xong
5. Kiểm tra kết quả trong popup

### Cách 2: Chạy từ Google Sheets (Khuyến nghị)

1. Quay lại Google Sheets
2. Làm mới trang (F5)
3. Bạn sẽ thấy menu mới **"Import Xe"** ở thanh menu
4. Click **Import Xe** > **Import lên Supabase**
5. Đợi script chạy xong
6. Kiểm tra kết quả

## Bước 5: Kiểm tra kết quả

### 5.1. Trong Google Sheets

- Cột `Z` (hoặc cột bạn đã cấu hình trong `STATUS_COLUMN`) sẽ hiển thị:
  - **"Đã import"** (màu xanh) = Thành công
  - **"Đã tồn tại"** (màu vàng) = Biển số đã tồn tại, đã skip
  - **"Lỗi: ..."** (màu đỏ) = Có lỗi khác

### 5.2. Trong Supabase

1. Vào Supabase Dashboard
2. Chọn **Table Editor**
3. Mở bảng `vehicles`
4. Kiểm tra dữ liệu đã được import

## Xử lý lỗi thường gặp

### Lỗi: "Biển số không được để trống"

- **Nguyên nhân**: Cột `BienSo` bị trống
- **Giải pháp**: Kiểm tra và điền biển số cho các dòng bị lỗi

### Lỗi: "duplicate key value violates unique constraint"

- **Nguyên nhân**: Biển số đã tồn tại trong database
- **Giải pháp**: 
  - **Tự động skip**: Script sẽ tự động skip các records duplicate và đánh dấu "Đã tồn tại" (màu vàng)
  - Nếu muốn báo lỗi thay vì skip, đặt `SKIP_DUPLICATES: false` trong CONFIG
  - Hoặc xóa xe cũ trong Supabase trước khi import lại

### Lỗi: "HTTP 401" hoặc "HTTP 403"

- **Nguyên nhân**: Key Supabase không đúng hoặc không có quyền
- **Giải pháp**: 
  - Kiểm tra lại `SUPABASE_KEY` trong CONFIG
  - Đảm bảo dùng **Service Role Key** (không phải Anon Key)

### Lỗi: "HTTP 404"

- **Nguyên nhân**: URL Supabase không đúng
- **Giải pháp**: Kiểm tra lại `SUPABASE_URL` trong CONFIG

### Lỗi: "Invalid date format"

- **Nguyên nhân**: Định dạng ngày trong cột `NienHan` không đúng
- **Giải pháp**: 
  - Format ngày nên là: `DD/MM/YYYY` hoặc `YYYY-MM-DD`
  - Hoặc để trống nếu không có

## Mapping dữ liệu

Các cột từ sheet được map sang database như sau:

| Cột Sheet | Trường Database | Ghi chú |
|-----------|----------------|---------|
| `IDXe` | `id` | Nếu trống sẽ tự động generate UUID |
| `BienSo` | `plate_number` | **Bắt buộc** |
| `SoKhung` | `chassis_number` | |
| `SoMay` | `engine_number` | |
| `SoCho` | `seat_capacity` | Chuyển sang số nguyên |
| `NienHan` | `inspection_expiry_date` | Parse từ nhiều format |
| Các cột khác | `notes` | Tập hợp vào trường notes |

## Lưu ý quan trọng

1. **Backup dữ liệu**: Nên backup dữ liệu trước khi import
2. **Test với ít dòng**: Nên test với 5-10 dòng trước khi import toàn bộ
3. **Service Role Key**: Chỉ dùng trong script, không chia sẻ công khai
4. **Rate Limit**: Script có delay 100ms giữa các request để tránh rate limit
5. **Import lại**: Script sẽ bỏ qua các dòng đã có status "Đã import" hoặc "Đã tồn tại"
6. **Xử lý Duplicate tự động**: Script tự động skip các records có biển số đã tồn tại và đánh dấu "Đã tồn tại" (màu vàng)

## Tùy chỉnh nâng cao

### ⚡ Tăng tốc độ import

Để import nhanh hơn, bạn có thể:

1. **Tăng BATCH_SIZE** (khuyến nghị: 50-100):
```javascript
BATCH_SIZE: 100  // Tăng từ 50 lên 100
```

2. **Giảm BATCH_DELAY** (khuyến nghị: 50-100ms):
```javascript
BATCH_DELAY: 25  // Giảm từ 50ms xuống 25ms
```

**Lưu ý**: 
- Không nên tăng BATCH_SIZE quá 100 để tránh timeout
- Không nên giảm BATCH_DELAY xuống 0 để tránh rate limit của Supabase
- Với 1000 records, BATCH_SIZE=100 và BATCH_DELAY=50ms sẽ mất khoảng 0.5 giây

### Thay đổi cột status

Nếu muốn dùng cột khác để đánh dấu trạng thái:

```javascript
STATUS_COLUMN: 'AA' // Thay đổi thành cột bạn muốn
```

### Import từ sheet cụ thể

Nếu có nhiều sheet và muốn import từ sheet cụ thể:

```javascript
SHEET_NAME: 'Danh sách xe' // Tên sheet
```

### Thêm mapping cột mới

Nếu có thêm cột trong sheet và muốn map sang database:

```javascript
COLUMN_MAPPING: {
  // ... các mapping hiện có
  'TenCotMoi': 'ten_field_moi'
}
```

## So sánh tốc độ

| Phương pháp | Tốc độ | Thời gian (1000 records) |
|------------|--------|--------------------------|
| **Single insert** (cũ) | ~10 records/giây | ~100 giây |
| **Batch insert** (mới) | ~500-1000 records/giây | ~1-2 giây |

**Cải thiện**: Nhanh hơn **50-100 lần**! 🚀

## Hỗ trợ

Nếu gặp vấn đề, kiểm tra:
1. Log trong Apps Script Editor: **View** > **Execution log**
2. Log trong Supabase: **Logs** > **API Logs**
</file>

<file path="server/src/scripts/import-vehicle-badges-from-sheets.gs">
/**
 * @deprecated SCRIPT NÀY ĐÃ LỖI THỜI - KHÔNG SỬ DỤNG
 *
 * Script này được viết cho Supabase nhưng dự án đã migrate sang Firebase Realtime Database.
 *
 * KHÔNG SỬ DỤNG SCRIPT NÀY NỮA.
 *
 * Để import dữ liệu vào Firebase, vui lòng:
 * 1. Sử dụng Firebase Console để import JSON trực tiếp
 * 2. Hoặc liên hệ admin để được hỗ trợ import qua API backend
 *
 * ---
 *
 * [LEGACY] Google Apps Script để import dữ liệu phù hiệu xe từ Google Sheets lên Supabase
 *
 * HƯỚNG DẪN SỬ DỤNG (ĐÃ LỖI THỜI):
 * 1. Mở Google Sheets chứa dữ liệu phù hiệu xe
 * 2. Vào Extensions > Apps Script
 * 3. Dán code này vào editor
 * 4. Cập nhật các biến cấu hình ở dưới (SUPABASE_URL, SUPABASE_KEY)
 * 5. Chạy hàm importVehicleBadges() hoặc tạo menu để chạy
 */

// ============================================
// CẤU HÌNH
// ============================================
const CONFIG_BADGES = {
  // URL của Supabase project (ví dụ: https://xxxxx.supabase.co)
  SUPABASE_URL: 'YOUR_SUPABASE_URL_HERE',
  
  // Service Role Key hoặc Anon Key từ Supabase
  // Lưu ý: Nên dùng Service Role Key để có quyền ghi đầy đủ
  SUPABASE_KEY: 'YOUR_SUPABASE_SERVICE_ROLE_KEY_HERE',
  
  // Tên sheet chứa dữ liệu (mặc định là sheet đầu tiên)
  SHEET_NAME: null, // null = sheet đầu tiên
  
  // Số dòng header (thường là 1)
  HEADER_ROW: 1,
  
  // Bắt đầu đọc từ dòng nào (sau header)
  START_ROW: 2,
  
  // Cột ID trong sheet (để đánh dấu đã import)
  STATUS_COLUMN: 'AC', // Cột để đánh dấu trạng thái import
  
  // Số lượng records gửi cùng lúc (batch size)
  BATCH_SIZE: 50, // Tăng lên 50 để tối ưu tốc độ
  
  // Delay giữa các batch (ms)
  BATCH_DELAY: 10, // Delay 10ms để tránh rate limit
  
  // Số lượng records tối đa xử lý trong một lần chạy (để tránh timeout)
  MAX_RECORDS_PER_RUN: 1000,
  
  // Tự động skip các records bị duplicate (đã tồn tại) thay vì báo lỗi
  SKIP_DUPLICATES: true
};

// ============================================
// HÀM CHÍNH
// ============================================

/**
 * Hàm chính để import dữ liệu phù hiệu xe (Batch mode - tốc độ cao)
 */
function importVehicleBadges() {
  try {
    const sheet = getSheet();
    const data = readSheetData(sheet);
    
    Logger.log(`Đã đọc ${data.length} dòng dữ liệu từ sheet`);
    Logger.log(`Cấu hình: Batch size=${CONFIG_BADGES.BATCH_SIZE}, Delay=${CONFIG_BADGES.BATCH_DELAY}ms, Max records/run=${CONFIG_BADGES.MAX_RECORDS_PER_RUN}`);
    
    // Đọc trạng thái hiện tại của tất cả các dòng
    const statusColumnIndex = columnLetterToIndex(CONFIG_BADGES.STATUS_COLUMN);
    const statusRange = sheet.getRange(CONFIG_BADGES.START_ROW, statusColumnIndex, data.length, 1);
    const statusValues = statusRange.getValues();
    
    // Chuẩn bị dữ liệu và lọc các dòng chưa import
    const rowsToProcess = [];
    let alreadyImportedCount = 0;
    let alreadyExistsCount = 0;
    
    for (let i = 0; i < data.length; i++) {
      const status = statusValues[i][0];
      if (status === 'Đã import' || status === 'Success') {
        alreadyImportedCount++;
      } else if (status === 'Đã tồn tại') {
        alreadyExistsCount++;
      } else if (status !== '') {
        rowsToProcess.push({
          data: data[i],
          rowNumber: CONFIG_BADGES.START_ROW + i,
          index: i
        });
      } else {
        rowsToProcess.push({
          data: data[i],
          rowNumber: CONFIG_BADGES.START_ROW + i,
          index: i
        });
      }
    }
    
    Logger.log(`Tổng số dòng: ${data.length}`);
    Logger.log(`- Đã import: ${alreadyImportedCount}`);
    Logger.log(`- Đã tồn tại: ${alreadyExistsCount}`);
    Logger.log(`- Cần import: ${rowsToProcess.length}`);
    
    if (rowsToProcess.length === 0) {
      SpreadsheetApp.getUi().alert('Tất cả dữ liệu đã được import hoặc đã tồn tại!');
      return;
    }
    
    // Giới hạn số records xử lý trong một lần chạy để tránh timeout
    const recordsToProcess = rowsToProcess.slice(0, CONFIG_BADGES.MAX_RECORDS_PER_RUN);
    
    // Kiểm tra an toàn
    if (!recordsToProcess || recordsToProcess.length === 0) {
      SpreadsheetApp.getUi().alert('Không có dữ liệu để xử lý!');
      return;
    }
    
    if (rowsToProcess.length > CONFIG_BADGES.MAX_RECORDS_PER_RUN) {
      Logger.log(`⚠️ Cảnh báo: Có ${rowsToProcess.length} dòng cần import, nhưng chỉ xử lý ${CONFIG_BADGES.MAX_RECORDS_PER_RUN} dòng trong lần chạy này.`);
      Logger.log(`⚠️ Vui lòng chạy lại script để xử lý các dòng còn lại.`);
    }
    
    const totalBatches = Math.ceil(recordsToProcess.length / CONFIG_BADGES.BATCH_SIZE);
    Logger.log(`Sẽ xử lý ${totalBatches} batch(es) với ${recordsToProcess.length} records`);
    
    let successCount = 0;
    let errorCount = 0;
    let duplicateCount = 0;
    const errors = [];
    const statusUpdates = [];
    
    // Lưu thời gian bắt đầu để theo dõi
    const overallStartTime = new Date().getTime();
    
    // Lưu ý: Cột BienSoXe trong sheet chứa vehicle_id (VARCHAR)
    // Cần lookup plate_number từ vehicle_id để lưu vào license_plate_sheet
    Logger.log('Đang lookup plate_number từ vehicle_id...');
    
    // Cache để lưu vehicle_id -> plate_number
    const vehiclePlateCache = {};
    const allVehicleIds = [];
    const vehicleIdToRowMap = {};
    
    // Thu thập tất cả vehicle_id cần lookup
    for (let i = 0; i < recordsToProcess.length; i++) {
      const vehicleId = String(recordsToProcess[i].data['BienSoXe'] || '').trim();
      if (vehicleId && !vehiclePlateCache[vehicleId]) {
        if (!vehicleIdToRowMap[vehicleId]) {
          allVehicleIds.push(vehicleId);
          vehicleIdToRowMap[vehicleId] = [];
        }
        vehicleIdToRowMap[vehicleId].push(i);
      }
    }
    
    // Batch lookup plate_number từ vehicle_id
    if (allVehicleIds.length > 0) {
      Logger.log(`Cần lookup plate_number cho ${allVehicleIds.length} vehicle_id...`);
      const BATCH_LOOKUP_SIZE = 20; // Giảm xuống 20 để tránh URL quá dài
      for (let i = 0; i < allVehicleIds.length; i += BATCH_LOOKUP_SIZE) {
        const batch = allVehicleIds.slice(i, i + BATCH_LOOKUP_SIZE);
        Logger.log(`Lookup batch ${Math.floor(i / BATCH_LOOKUP_SIZE) + 1}/${Math.ceil(allVehicleIds.length / BATCH_LOOKUP_SIZE)} (${batch.length} vehicle_id)...`);
        const plateLookupResult = batchLookupPlateNumbersByVehicleIds(batch);
        for (const vid in plateLookupResult) {
          vehiclePlateCache[vid] = plateLookupResult[vid];
        }
        // Delay nhỏ giữa các batch để tránh rate limit
        if (i + BATCH_LOOKUP_SIZE < allVehicleIds.length) {
          Utilities.sleep(50);
        }
      }
      Logger.log(`Đã lookup xong ${Object.keys(vehiclePlateCache).length} plate_number`);
    }
    
    // Chia thành các batch
    for (let batchStart = 0; batchStart < recordsToProcess.length; batchStart += CONFIG_BADGES.BATCH_SIZE) {
      const batchEnd = Math.min(batchStart + CONFIG_BADGES.BATCH_SIZE, recordsToProcess.length);
      const batch = recordsToProcess.slice(batchStart, batchEnd);
      
      const batchNumber = Math.floor(batchStart / CONFIG_BADGES.BATCH_SIZE) + 1;
      const totalBatches = Math.ceil(recordsToProcess.length / CONFIG_BADGES.BATCH_SIZE);
      Logger.log(`Xử lý batch ${batchNumber}/${totalBatches} (${batch.length} records)...`);
      
      const batchStartTime = new Date().getTime();
      
      // Chuẩn bị dữ liệu cho batch
      const badgeBatch = [];
      const batchRowInfo = [];
      
      for (let j = 0; j < batch.length; j++) {
        const rowInfo = batch[j];
        try {
          const badgeData = mapRowToBadge(rowInfo.data, rowInfo.rowNumber, vehiclePlateCache);
          if (badgeData) {
            badgeBatch.push(badgeData);
            batchRowInfo.push({
              rowNumber: rowInfo.rowNumber,
              index: rowInfo.index,
              badgeNumber: badgeData.badge_number
            });
          } else {
            // Lỗi khi map dữ liệu (ví dụ: thiếu vehicle_id)
            errorCount++;
            const vehicleId = String(rowInfo.data['BienSoXe'] || '').trim();
            errors.push(`Dòng ${rowInfo.rowNumber}: Lỗi khi xử lý vehicle_id: ${vehicleId}`);
            statusUpdates.push({
              row: rowInfo.index,
              value: 'Lỗi: Xử lý dữ liệu',
              background: '#f8d7da'
            });
          }
        } catch (error) {
          errorCount++;
          const errorMsg = error.toString();
          errors.push(`Dòng ${rowInfo.rowNumber}: ${errorMsg}`);
          statusUpdates.push({
            row: rowInfo.index,
            value: `Lỗi: ${errorMsg}`,
            background: '#f8d7da'
          });
        }
      }
      
      // Gửi batch lên Supabase
      if (badgeBatch.length > 0) {
        // Normalize tất cả objects để có cùng keys (Supabase yêu cầu)
        const normalizedBatch = normalizeBadgeBatch(badgeBatch);
        Logger.log(`Đang gửi ${normalizedBatch.length} badges lên Supabase...`);
        const batchInsertStartTime = new Date().getTime();
        const result = insertBadgesBatchToSupabase(normalizedBatch);
        const batchInsertElapsed = ((new Date().getTime() - batchInsertStartTime) / 1000).toFixed(1);
        Logger.log(`Insert ${badgeBatch.length} badges hoàn thành trong ${batchInsertElapsed}s`);
        
        // Xử lý kết quả
        Logger.log(`Kết quả batch: success=${result.success}, partial=${result.partial || false}, count=${result.count || 0}, error=${result.error || 'none'}`);
        
        if (result.success) {
          Logger.log(`✅ Batch thành công: ${result.count || batchRowInfo.length} badges đã insert`);
          for (let k = 0; k < batchRowInfo.length; k++) {
            successCount++;
            statusUpdates.push({
              row: batchRowInfo[k].index,
              value: 'Đã import',
              background: '#d4edda'
            });
          }
        } else if (result.partial) {
          Logger.log(`⚠️ Batch một phần: ${result.successIndices?.length || 0} thành công, ${result.duplicateIndices?.length || 0} duplicate`);
          const successIndices = result.successIndices || [];
          const duplicateIndices = result.duplicateIndices || [];
          const errorDetails = result.errors || [];
          
          for (let k = 0; k < batchRowInfo.length; k++) {
            if (successIndices.includes(k)) {
              successCount++;
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: 'Đã import',
                background: '#d4edda'
              });
            } else if (duplicateIndices.includes(k)) {
              if (CONFIG_BADGES.SKIP_DUPLICATES) {
                duplicateCount++;
                statusUpdates.push({
                  row: batchRowInfo[k].index,
                  value: 'Đã tồn tại',
                  background: '#fff3cd'
                });
              } else {
                errorCount++;
                errors.push(`Dòng ${batchRowInfo[k].rowNumber}: Phù hiệu đã tồn tại`);
                statusUpdates.push({
                  row: batchRowInfo[k].index,
                  value: 'Lỗi: Đã tồn tại',
                  background: '#f8d7da'
                });
              }
            } else {
              errorCount++;
              const errorMsg = errorDetails[k] || 'Lỗi không xác định';
              errors.push(`Dòng ${batchRowInfo[k].rowNumber}: ${errorMsg}`);
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: `Lỗi: ${errorMsg}`,
                background: '#f8d7da'
              });
            }
          }
        } else {
          const duplicateIndices = result.duplicateIndices || [];
          const errorDetails = result.errors || [];
          
          for (let k = 0; k < batchRowInfo.length; k++) {
            if (duplicateIndices.includes(k) && CONFIG_BADGES.SKIP_DUPLICATES) {
              duplicateCount++;
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: 'Đã tồn tại',
                background: '#fff3cd'
              });
            } else {
              errorCount++;
              const errorMsg = errorDetails[k] || result.error || 'Lỗi không xác định';
              errors.push(`Dòng ${batchRowInfo[k].rowNumber}: ${errorMsg}`);
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: `Lỗi: ${errorMsg}`,
                background: '#f8d7da'
              });
            }
          }
        }
        
        const batchTotalElapsed = ((new Date().getTime() - batchStartTime) / 1000).toFixed(1);
        Logger.log(`Batch ${batchNumber} hoàn thành: ${result.success ? 'Thành công' : result.partial ? 'Một phần' : 'Lỗi'} trong ${batchTotalElapsed}s`);
      }
      
      // Batch update status
      if (statusUpdates.length > 0 && (statusUpdates.length >= 100 || batchEnd >= recordsToProcess.length)) {
        try {
          updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
          statusUpdates.length = 0;
        } catch (updateError) {
          Logger.log('Lỗi khi update status: ' + updateError.toString());
        }
      }
      
      // Delay giữa các batch
      if (CONFIG_BADGES.BATCH_DELAY > 0 && batchEnd < recordsToProcess.length) {
        Utilities.sleep(CONFIG_BADGES.BATCH_DELAY);
      }
      
      // Kiểm tra thời gian
      const totalElapsed = (new Date().getTime() - overallStartTime) / 1000;
      if (totalElapsed > 300) {
        Logger.log(`⚠️ Đã chạy ${Math.round(totalElapsed)} giây, dừng để tránh timeout.`);
        Logger.log(`⚠️ Đã xử lý ${batchEnd}/${recordsToProcess.length} records. Vui lòng chạy lại để tiếp tục.`);
        if (statusUpdates.length > 0) {
          try {
            updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
          } catch (e) {
            Logger.log('Lỗi khi update status cuối cùng: ' + e.toString());
          }
        }
        break;
      }
    }
    
    // Update status cuối cùng
    if (statusUpdates.length > 0) {
      try {
        updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
      } catch (e) {
        Logger.log('Lỗi khi update status cuối cùng: ' + e.toString());
      }
    }
    
    // Hiển thị kết quả
    const totalProcessed = successCount + errorCount + duplicateCount;
    let message = `Hoàn thành!\n\nThành công: ${successCount}`;
    if (duplicateCount > 0) {
      message += `\nĐã tồn tại (skip): ${duplicateCount}`;
    }
    message += `\nLỗi: ${errorCount}\nTổng: ${totalProcessed} records`;
    
    Logger.log('=== KẾT QUẢ CUỐI CÙNG ===');
    Logger.log(message);
    
    if (errors.length > 0 && errors.length <= 20) {
      Logger.log('Các lỗi:\n' + errors.slice(0, 20).join('\n'));
      if (errors.length > 20) {
        Logger.log(`... và ${errors.length - 20} lỗi khác`);
      }
    }
    
    try {
      SpreadsheetApp.getUi().alert(message);
    } catch (alertError) {
      Logger.log('Lỗi khi hiển thị thông báo: ' + alertError.toString());
    }
    Logger.log('Script đã hoàn thành!');
    
  } catch (error) {
    Logger.log('Lỗi tổng quát: ' + error.toString());
    SpreadsheetApp.getUi().alert('Lỗi: ' + error.toString());
  }
}

/**
 * Map dữ liệu từ sheet sang format database
 * Lưu ý: Cột BienSoXe chứa vehicle_id (VARCHAR)
 * @param {Object} row - Dữ liệu từ sheet
 * @param {number} rowNumber - Số dòng trong sheet
 * @param {Object} vehiclePlateCache - Cache vehicle_id -> plate_number
 */
function mapRowToBadge(row, rowNumber, vehiclePlateCache) {
  const badge = {};
  
  // ID - nếu có ID_PhuHieu thì dùng, không thì generate UUID
  if (row['ID_PhuHieu']) {
    badge.id = String(row['ID_PhuHieu']).trim();
  } else {
    badge.id = generateUUID();
  }
  
  // Badge number - bắt buộc
  if (!row['SoPhuHieu'] || !String(row['SoPhuHieu']).trim()) {
    throw new Error('Số phù hiệu không được để trống');
  }
  badge.badge_number = String(row['SoPhuHieu']).trim();
  
  // File code
  if (row['MaHoSo']) {
    badge.file_code = String(row['MaHoSo']).trim() || null;
  }
  
  // Badge type - bắt buộc
  if (!row['LoaiPH'] || !String(row['LoaiPH']).trim()) {
    throw new Error('Loại phù hiệu không được để trống');
  }
  badge.badge_type = String(row['LoaiPH']).trim();
  
  // Vehicle ID - cột BienSoXe chứa vehicle_id (VARCHAR), dùng trực tiếp
  if (!row['BienSoXe'] || !String(row['BienSoXe']).trim()) {
    throw new Error('ID xe (BienSoXe) không được để trống');
  }
  const vehicleId = String(row['BienSoXe']).trim();
  badge.vehicle_id = vehicleId;
  
  // License plate - lookup plate_number từ vehicle_id
  if (vehiclePlateCache && vehiclePlateCache[vehicleId]) {
    badge.license_plate_sheet = vehiclePlateCache[vehicleId];
  } else {
    // Fallback: thử lookup nếu không có trong cache
    const plateNumber = lookupPlateNumberByVehicleId(vehicleId);
    if (plateNumber) {
      badge.license_plate_sheet = plateNumber;
      if (vehiclePlateCache) {
        vehiclePlateCache[vehicleId] = plateNumber;
      }
    } else {
      // Không tìm thấy plate_number, có thể bỏ qua hoặc để null
      badge.license_plate_sheet = null;
    }
  }
  
  // Warning flag
  if (row['CanhBaoTrungBienSoKhiCapPH']) {
    badge.warn_duplicate_plate = String(row['CanhBaoTrungBienSoKhiCapPH']).toLowerCase() === 'true' || 
                                String(row['CanhBaoTrungBienSoKhiCapPH']) === '1' ||
                                String(row['CanhBaoTrungBienSoKhiCapPH']).toLowerCase() === 'có';
  }
  
  // References
  // issuing_authority_id - có thể là ID không tồn tại, set null nếu không hợp lệ
  if (row['Ref_DonViCapPhuHieu']) {
    const issuingAuthorityId = String(row['Ref_DonViCapPhuHieu']).trim();
    if (issuingAuthorityId) {
      // Lưu giá trị, nhưng sẽ validate sau hoặc để null nếu lỗi FK
      badge.issuing_authority_id = issuingAuthorityId;
    } else {
      badge.issuing_authority_id = null;
    }
  } else {
    badge.issuing_authority_id = null;
  }
  if (row['Ref_GPKD']) {
    badge.business_license_ref = String(row['Ref_GPKD']).trim() || null;
  }
  if (row['Ref_ThongBao']) {
    badge.notification_ref = String(row['Ref_ThongBao']).trim() || null;
  }
  if (row['Ref_Tuyen']) {
    badge.route_id = String(row['Ref_Tuyen']).trim() || null;
  }
  if (row['Ref_TuyenBuyt']) {
    badge.bus_route_ref = String(row['Ref_TuyenBuyt']).trim() || null;
  }
  
  // Dates
  if (row['NgayCap']) {
    const issueDate = parseDate(row['NgayCap']);
    if (issueDate) {
      badge.issue_date = issueDate;
    } else {
      throw new Error('Ngày cấp không hợp lệ');
    }
  } else {
    throw new Error('Ngày cấp không được để trống');
  }
  
  if (row['NgayHetHan']) {
    const expiryDate = parseDate(row['NgayHetHan']);
    if (expiryDate) {
      badge.expiry_date = expiryDate;
    } else {
      throw new Error('Ngày hết hạn không hợp lệ');
    }
  } else {
    throw new Error('Ngày hết hạn không được để trống');
  }
  
  if (row['Hancap']) {
    const renewalDueDate = parseDate(row['Hancap']);
    if (renewalDueDate) {
      badge.renewal_due_date = renewalDueDate;
    }
  }
  
  // Issue type - chỉ cho phép: 'new', 'renewal', 'replacement'
  if (row['LoaiCap']) {
    const issueType = String(row['LoaiCap']).trim().toLowerCase();
    // Xử lý các biến thể của "mới" / "new"
    if (issueType === 'mới' || issueType === 'new' || issueType === 'cấp mới' || issueType === 'cap moi' || issueType.includes('mới') || issueType.includes('new')) {
      badge.issue_type = 'new';
    } 
    // Xử lý các biến thể của "cấp lại" / "renewal"
    else if (issueType === 'cấp lại' || issueType === 'renewal' || issueType === 'cap lai' || issueType.includes('lại') || issueType.includes('renewal')) {
      badge.issue_type = 'renewal';
    } 
    // Xử lý các biến thể của "thay thế" / "replacement"
    else if (issueType === 'thay thế' || issueType === 'replacement' || issueType === 'thay the' || issueType.includes('thay') || issueType.includes('replacement')) {
      badge.issue_type = 'replacement';
    } else {
      // Nếu giá trị không hợp lệ, để null (không set issue_type)
      Logger.log(`⚠️ Dòng ${rowNumber}: LoaiCap không hợp lệ: "${issueType}", bỏ qua (để null)`);
      badge.issue_type = null; // Không set nếu không hợp lệ
    }
  } else {
    // Không có giá trị, để null
    badge.issue_type = null;
  }
  
  // Renewal reason
  if (row['LyDoCapLai']) {
    badge.renewal_reason = String(row['LyDoCapLai']).trim() || null;
  }
  
  // Previous badge number
  if (row['SoPhuHieuCu']) {
    badge.previous_badge_number = String(row['SoPhuHieuCu']).trim() || null;
  }
  
  // Status
  if (row['TrangThai']) {
    const status = String(row['TrangThai']).trim().toLowerCase();
    if (status === 'hoạt động' || status === 'active') {
      badge.status = 'active';
    } else if (status === 'hết hạn' || status === 'expired') {
      badge.status = 'expired';
    } else if (status === 'thu hồi' || status === 'revoked') {
      badge.status = 'revoked';
    } else if (status === 'thay thế' || status === 'replaced') {
      badge.status = 'replaced';
    } else if (status === 'chờ' || status === 'pending') {
      badge.status = 'pending';
    } else {
      badge.status = status;
    }
  } else {
    badge.status = 'active'; // Default
  }
  
  // Email notification
  if (row['GuiEmailbao']) {
    badge.email_notification_sent = String(row['GuiEmailbao']).toLowerCase() === 'true' || 
                                    String(row['GuiEmailbao']) === '1' ||
                                    String(row['GuiEmailbao']).toLowerCase() === 'có';
  }
  
  // Revocation
  if (row['QDThuHoi']) {
    badge.revocation_decision = String(row['QDThuHoi']).trim() || null;
  }
  if (row['LyDoThuHoi']) {
    badge.revocation_reason = String(row['LyDoThuHoi']).trim() || null;
  }
  if (row['NgayThuHoi']) {
    const revocationDate = parseDate(row['NgayThuHoi']);
    if (revocationDate) {
      badge.revocation_date = revocationDate;
    }
  }
  
  // Replacement vehicle - cũng là vehicle_id (VARCHAR)
  if (row['XeThayThe'] || row['Xebithaythe']) {
    const replacementVehicleId = String(row['XeThayThe'] || row['Xebithaythe']).trim();
    if (replacementVehicleId) {
      badge.replacement_vehicle_id = replacementVehicleId;
    }
  }
  
  // Badge color
  if (row['MauPhuHieu']) {
    badge.badge_color = String(row['MauPhuHieu']).trim() || null;
  }
  
  // Notes
  if (row['GhiChu']) {
    badge.notes = String(row['GhiChu']).trim() || null;
  }
  
  // Renewal reminder
  if (row['CanCapLaiPopup']) {
    badge.renewal_reminder_shown = String(row['CanCapLaiPopup']).toLowerCase() === 'true' || 
                                   String(row['CanCapLaiPopup']) === '1' ||
                                   String(row['CanCapLaiPopup']).toLowerCase() === 'có';
  }
  
  return badge;
}

/**
 * Batch lookup plate_number từ nhiều vehicle_id cùng lúc
 * @param {Array<string>} vehicleIds - Mảng các vehicle_id cần lookup
 * @returns {Object} Object với key là vehicle_id, value là plate_number
 */
function batchLookupPlateNumbersByVehicleIds(vehicleIds) {
  const result = {};
  
  if (!vehicleIds || vehicleIds.length === 0) {
    return result;
  }
  
  // Dùng mini-batch (10 records) để tránh lỗi URL với Google Apps Script
  // Google Apps Script có thể không hỗ trợ URL phức tạp với nhiều id
  const MINI_BATCH_SIZE = 10;
  let successCount = 0;
  
  for (let i = 0; i < vehicleIds.length; i += MINI_BATCH_SIZE) {
    const miniBatch = vehicleIds.slice(i, i + MINI_BATCH_SIZE);
    const batchEnd = Math.min(i + MINI_BATCH_SIZE, vehicleIds.length);
    
    try {
      // Thử dùng 'or' operator với format đơn giản
      const orConditions = miniBatch.map(id => {
        const cleanId = String(id).trim();
        return `id.eq.${encodeURIComponent(cleanId)}`;
      }).join(',');
      
      const baseUrl = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicles`;
      const filter = `or=(${orConditions})`;
      const select = `select=id,plate_number`;
      const url = `${baseUrl}?${filter}&${select}`;
      
      const options = {
        method: 'GET',
        headers: {
          'apikey': CONFIG_BADGES.SUPABASE_KEY,
          'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`
        },
        muteHttpExceptions: true
      };
      
      const response = UrlFetchApp.fetch(url, options);
      const responseCode = response.getResponseCode();
      const responseText = response.getContentText();
      
      if (responseCode >= 200 && responseCode < 300) {
        const data = JSON.parse(responseText);
        if (data && Array.isArray(data)) {
          for (let j = 0; j < data.length; j++) {
            if (data[j].id && data[j].plate_number) {
              result[data[j].id] = data[j].plate_number;
              successCount++;
            }
          }
        }
      } else {
        // Nếu mini-batch lỗi, fallback về từng cái
        for (let j = 0; j < miniBatch.length; j++) {
          const plateNumber = lookupPlateNumberByVehicleId(miniBatch[j]);
          if (plateNumber) {
            result[miniBatch[j]] = plateNumber;
            successCount++;
          }
        }
      }
    } catch (error) {
      // Nếu có lỗi, fallback về từng cái
      for (let j = 0; j < miniBatch.length; j++) {
        try {
          const plateNumber = lookupPlateNumberByVehicleId(miniBatch[j]);
          if (plateNumber) {
            result[miniBatch[j]] = plateNumber;
            successCount++;
          }
        } catch (e) {
          // Bỏ qua lỗi từng cái
        }
      }
    }
    
    // Delay nhỏ giữa các mini-batch
    if (batchEnd < vehicleIds.length) {
      Utilities.sleep(20);
    }
  }
  
  Logger.log(`Đã lookup xong ${successCount}/${vehicleIds.length} vehicle_id`);
  return result;
}

/**
 * Lookup plate_number từ vehicle_id (single)
 * @param {string} vehicleId - vehicle_id cần lookup
 * @returns {string|null} plate_number hoặc null nếu không tìm thấy
 */
function lookupPlateNumberByVehicleId(vehicleId) {
  try {
    const url = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicles?id=eq.${encodeURIComponent(vehicleId)}&select=plate_number&limit=1`;
    
    const options = {
      method: 'GET',
      headers: {
        'apikey': CONFIG_BADGES.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`
      },
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      if (data && data.length > 0 && data[0].plate_number) {
        return data[0].plate_number;
      }
    }
    
    return null;
  } catch (error) {
    Logger.log(`Lỗi khi lookup plate_number: ${error.toString()}`);
    return null;
  }
}

/**
 * Normalize batch để đảm bảo tất cả objects có cùng keys
 * Supabase PostgREST yêu cầu tất cả objects trong batch phải có cùng keys
 */
function normalizeBadgeBatch(badgesArray) {
  if (!badgesArray || badgesArray.length === 0) {
    return [];
  }
  
  // Bước 1: Lấy TẤT CẢ keys từ TẤT CẢ objects
  const allKeys = new Set();
  for (let i = 0; i < badgesArray.length; i++) {
    for (const key in badgesArray[i]) {
      if (badgesArray[i][key] !== undefined) {
        allKeys.add(key);
      }
    }
  }
  
  // Bước 2: Normalize mỗi object để có ĐẦY ĐỦ keys (từ tất cả objects)
  const normalized = [];
  for (let i = 0; i < badgesArray.length; i++) {
    const normalizedBadge = {};
    // Thêm TẤT CẢ keys vào mỗi object
    for (const key of allKeys) {
      if (badgesArray[i].hasOwnProperty(key) && badgesArray[i][key] !== undefined) {
        normalizedBadge[key] = badgesArray[i][key];
      } else {
        // Nếu key không có trong object này, set null (không phải undefined)
        // Supabase sẽ bỏ qua null values hoặc dùng default
        normalizedBadge[key] = null;
      }
    }
    normalized.push(normalizedBadge);
  }
  
  // Bước 3: Kiểm tra lại để đảm bảo tất cả có cùng keys
  const firstKeys = Object.keys(normalized[0] || {}).sort();
  for (let i = 1; i < normalized.length; i++) {
    const currentKeys = Object.keys(normalized[i] || {}).sort();
    if (JSON.stringify(firstKeys) !== JSON.stringify(currentKeys)) {
      Logger.log(`⚠️ Lỗi normalize: Object ${i} vẫn có keys khác sau khi normalize`);
      Logger.log(`First keys (${firstKeys.length}): ${firstKeys.join(', ')}`);
      Logger.log(`Current keys (${currentKeys.length}): ${currentKeys.join(', ')}`);
      
      // Force: thêm keys thiếu vào object hiện tại
      for (const key of firstKeys) {
        if (!normalized[i].hasOwnProperty(key)) {
          normalized[i][key] = null;
        }
      }
      // Thêm keys từ object hiện tại vào object đầu tiên
      for (const key of currentKeys) {
        if (!normalized[0].hasOwnProperty(key)) {
          normalized[0][key] = null;
        }
      }
    }
  }
  
  // Bước 4: Đảm bảo tất cả objects có cùng keys (lần cuối)
  const finalKeys = Object.keys(normalized[0] || {}).sort();
  for (let i = 0; i < normalized.length; i++) {
    const currentKeys = Object.keys(normalized[i] || {}).sort();
    if (JSON.stringify(finalKeys) !== JSON.stringify(currentKeys)) {
      // Thêm keys thiếu
      for (const key of finalKeys) {
        if (!normalized[i].hasOwnProperty(key)) {
          normalized[i][key] = null;
        }
      }
    }
  }
  
  return normalized;
}

/**
 * Gửi nhiều badges lên Supabase cùng lúc (Batch insert)
 */
function insertBadgesBatchToSupabase(badgesArray) {
  try {
    if (!badgesArray || badgesArray.length === 0) {
      return { success: false, error: 'Không có dữ liệu để gửi' };
    }
    
    const url = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicle_badges`;
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': CONFIG_BADGES.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`,
        'Prefer': 'return=representation'
      },
      payload: JSON.stringify(badgesArray),
      muteHttpExceptions: true
    };
    
    Logger.log(`Đang gửi request với ${badgesArray.length} badges...`);
    const requestStartTime = new Date().getTime();
    const response = UrlFetchApp.fetch(url, options);
    const requestElapsed = ((new Date().getTime() - requestStartTime) / 1000).toFixed(1);
    Logger.log(`Request hoàn thành trong ${requestElapsed}s`);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    Logger.log(`Response code: ${responseCode}`);
    Logger.log(`Response length: ${responseText ? responseText.length : 0} ký tự`);
    
    if (responseCode >= 200 && responseCode < 300) {
      // Kiểm tra response có rỗng không
      if (!responseText || responseText.trim() === '') {
        Logger.log(`⚠️ Response rỗng nhưng code ${responseCode} - có thể insert thành công nhưng không trả về data`);
        // Vẫn coi là thành công nếu code 200-299
        return { 
          success: true, 
          data: [],
          count: badgesArray.length // Giả định tất cả đã insert
        };
      }
      
      try {
        const insertedData = JSON.parse(responseText);
        const insertedCount = Array.isArray(insertedData) ? insertedData.length : (insertedData ? 1 : 0);
        Logger.log(`✅ Insert thành công: ${insertedCount} badges (gửi ${badgesArray.length})`);
        
        // Kiểm tra số lượng
        if (insertedCount === 0 && badgesArray.length > 0) {
          Logger.log(`⚠️ Cảnh báo: Response trả về 0 records nhưng đã gửi ${badgesArray.length}`);
        }
        
        return { 
          success: true, 
          data: insertedData,
          count: insertedCount
        };
      } catch (parseError) {
        Logger.log(`❌ Lỗi parse response: ${parseError.toString()}`);
        Logger.log(`Response text (first 500 chars): ${responseText.substring(0, 500)}`);
        return { 
          success: false, 
          error: 'Lỗi parse response: ' + parseError.toString(),
          partial: false
        };
      }
    } else {
      Logger.log(`❌ Response lỗi (HTTP ${responseCode}): ${responseText.substring(0, 500)}`);
      let error;
      try {
        error = JSON.parse(responseText);
      } catch (parseError) {
        error = { message: responseText };
      }
      
      // Kiểm tra nếu là lỗi foreign key constraint
      const errorMsg = (error.message || error.error_description || '').toLowerCase();
      if (errorMsg.includes('foreign key') || errorMsg.includes('violates foreign key') || error.code === '23503') {
        Logger.log(`⚠️ Lỗi foreign key constraint: ${error.message || error.error_description}`);
        Logger.log(`Thử set null cho các foreign keys không hợp lệ và insert từng record...`);
        // Thử lại với các foreign keys set null
        return handleForeignKeyError(badgesArray, error);
      }
      
      return handlePartialBatchError(badgesArray, error);
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.toString(),
      partial: false
    };
  }
}

/**
 * Xử lý lỗi foreign key constraint bằng cách set null cho các foreign keys không hợp lệ
 */
function handleForeignKeyError(badgesArray, originalError) {
  const successIndices = [];
  const duplicateIndices = [];
  const errors = [];
  
  // Các foreign key fields có thể gây lỗi
  const foreignKeyFields = ['issuing_authority_id', 'route_id', 'replacement_vehicle_id'];
  
  Logger.log(`Xử lý ${badgesArray.length} records với foreign key errors...`);
  
  // Thử lại từng record với foreign keys set null nếu cần
  for (let i = 0; i < badgesArray.length; i++) {
    const badge = JSON.parse(JSON.stringify(badgesArray[i])); // Deep copy
    let inserted = false;
    
    // Thử insert với giá trị hiện tại trước
    const firstResult = insertBadgeToSupabase(badge);
    Logger.log(`Record ${i}: firstResult success=${firstResult.success}, isDuplicate=${firstResult.isDuplicate}, isFK=${firstResult.isForeignKeyError}, error=${firstResult.error?.substring(0, 100)}`);
    
    if (firstResult.success) {
      successIndices.push(i);
      errors.push(null);
      inserted = true;
      Logger.log(`✅ Record ${i}: Insert thành công`);
    } else if (firstResult.isDuplicate && CONFIG_BADGES.SKIP_DUPLICATES) {
      duplicateIndices.push(i);
      errors.push('DUPLICATE');
      inserted = true;
      Logger.log(`🔄 Record ${i}: Đã tồn tại (duplicate)`);
    } else if (firstResult.isForeignKeyError || (firstResult.error && firstResult.error.includes('foreign key'))) {
      Logger.log(`🔑 Record ${i}: Lỗi foreign key, thử set null...`);
      // Nếu lỗi foreign key, thử set null cho từng foreign key
      for (const fkField of foreignKeyFields) {
        if (badge[fkField] && !inserted) {
          const testBadge = JSON.parse(JSON.stringify(badge));
          testBadge[fkField] = null;
          
          const result = insertBadgeToSupabase(testBadge);
          Logger.log(`Record ${i}: Thử set null ${fkField}, success=${result.success}, isDuplicate=${result.isDuplicate}, isFK=${result.isForeignKeyError}`);
          
          if (result.success) {
            successIndices.push(i);
            errors.push(null);
            inserted = true;
            Logger.log(`✅ Record ${i}: Set null cho ${fkField} và insert thành công`);
            break;
          } else if (result.isDuplicate && CONFIG_BADGES.SKIP_DUPLICATES) {
            duplicateIndices.push(i);
            errors.push('DUPLICATE');
            inserted = true;
            Logger.log(`🔄 Record ${i}: Set null ${fkField} nhưng vẫn duplicate`);
            break;
          } else if (result.isForeignKeyError) {
            Logger.log(`🔑 Record ${i}: Set null ${fkField} vẫn lỗi foreign key, thử tiếp...`);
            // Tiếp tục thử foreign key khác
          }
        }
      }
      
      // Nếu vẫn chưa insert được, thử set null cho tất cả foreign keys
      if (!inserted) {
        const allNullBadge = JSON.parse(JSON.stringify(badge));
        for (const fkField of foreignKeyFields) {
          allNullBadge[fkField] = null;
        }
        
        const result = insertBadgeToSupabase(allNullBadge);
        Logger.log(`Record ${i}: Thử set null tất cả FK, success=${result.success}, isDuplicate=${result.isDuplicate}, isFK=${result.isForeignKeyError}, error=${result.error?.substring(0, 100)}`);
        
        if (result.success) {
          successIndices.push(i);
          errors.push(null);
          inserted = true;
          Logger.log(`✅ Record ${i}: Set null cho tất cả foreign keys và insert thành công`);
        } else if (result.isDuplicate && CONFIG_BADGES.SKIP_DUPLICATES) {
          duplicateIndices.push(i);
          errors.push('DUPLICATE');
          inserted = true;
          Logger.log(`🔄 Record ${i}: Set null tất cả FK vẫn duplicate`);
        } else {
          Logger.log(`❌ Record ${i}: Vẫn lỗi sau khi set null tất cả FK: ${result.error}`);
          errors.push(result.error || 'Lỗi không xác định');
        }
      }
    } else {
      // Lỗi khác, không phải foreign key
      Logger.log(`❌ Record ${i}: Lỗi khác (không phải FK): ${firstResult.error}`);
      errors.push(firstResult.error || 'Lỗi không xác định');
    }
  }
  
  const totalProcessed = successIndices.length + duplicateIndices.length;
  Logger.log(`Xử lý foreign key errors: ${successIndices.length} thành công, ${duplicateIndices.length} duplicate, ${errors.filter(e => e && e !== 'DUPLICATE').length} lỗi`);
  
  return {
    success: successIndices.length === badgesArray.length,
    partial: totalProcessed > 0 && totalProcessed < badgesArray.length,
    successIndices: successIndices,
    duplicateIndices: duplicateIndices,
    errors: errors,
    error: originalError.message || originalError.error_description
  };
}

/**
 * Xử lý lỗi partial batch
 * Tránh đệ quy quá sâu bằng cách chỉ thử mini-batch một lần
 */
function handlePartialBatchError(badgesArray, originalError) {
  const successIndices = [];
  const duplicateIndices = [];
  const errors = [];
  
  // Nếu batch quá nhỏ rồi (<= 10), thử từng cái luôn
  if (badgesArray.length <= 10) {
    Logger.log(`Batch nhỏ (${badgesArray.length}), thử từng record...`);
    for (let j = 0; j < badgesArray.length; j++) {
      const result = insertBadgeToSupabase(badgesArray[j]);
      if (result.success) {
        successIndices.push(j);
        errors.push(null);
      } else if (result.isDuplicate && CONFIG_BADGES.SKIP_DUPLICATES) {
        duplicateIndices.push(j);
        errors.push('DUPLICATE');
      } else {
        errors.push(result.error || 'Lỗi không xác định');
      }
    }
  } else {
    // Chia thành mini-batch 10 records
    const miniBatchSize = 10;
    Logger.log(`Chia batch ${badgesArray.length} thành mini-batches ${miniBatchSize}...`);
    
    for (let i = 0; i < badgesArray.length; i += miniBatchSize) {
      const miniBatch = badgesArray.slice(i, i + miniBatchSize);
      const miniBatchEnd = Math.min(i + miniBatchSize, badgesArray.length);
      
      // Chỉ thử mini-batch một lần, không đệ quy
      const miniResult = insertBadgesBatchToSupabaseDirect(miniBatch);
      
      if (miniResult.success) {
        for (let j = i; j < miniBatchEnd; j++) {
          successIndices.push(j);
          errors.push(null);
        }
      } else {
        // Nếu mini-batch vẫn lỗi, thử từng cái
        for (let j = 0; j < miniBatch.length; j++) {
          const actualIndex = i + j;
          const result = insertBadgeToSupabase(miniBatch[j]);
          if (result.success) {
            successIndices.push(actualIndex);
            errors.push(null);
          } else if (result.isDuplicate && CONFIG_BADGES.SKIP_DUPLICATES) {
            duplicateIndices.push(actualIndex);
            errors.push('DUPLICATE');
          } else {
            errors.push(result.error || 'Lỗi không xác định');
          }
        }
      }
    }
  }
  
  const totalProcessed = successIndices.length + duplicateIndices.length;
  
  return {
    success: successIndices.length === badgesArray.length,
    partial: totalProcessed > 0 && totalProcessed < badgesArray.length,
    successIndices: successIndices,
    duplicateIndices: duplicateIndices,
    errors: errors,
    error: originalError.message || originalError.error_description
  };
}

/**
 * Insert batch trực tiếp (không gọi handlePartialBatchError để tránh đệ quy)
 */
function insertBadgesBatchToSupabaseDirect(badgesArray) {
  try {
    if (!badgesArray || badgesArray.length === 0) {
      return { success: false, error: 'Không có dữ liệu để gửi' };
    }
    
    const url = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicle_badges`;
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': CONFIG_BADGES.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`,
        'Prefer': 'return=representation'
      },
      payload: JSON.stringify(badgesArray),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode >= 200 && responseCode < 300) {
      const insertedData = JSON.parse(responseText);
      return { 
        success: true, 
        data: insertedData,
        count: Array.isArray(insertedData) ? insertedData.length : 1
      };
    } else {
      return { 
        success: false, 
        error: responseText.substring(0, 200),
        partial: false
      };
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.toString(),
      partial: false
    };
  }
}

/**
 * Gửi một badge lên Supabase
 */
function insertBadgeToSupabase(badgeData) {
  try {
    const url = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicle_badges`;
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': CONFIG_BADGES.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`,
        'Prefer': 'return=representation'
      },
      payload: JSON.stringify(badgeData),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode >= 200 && responseCode < 300) {
      return { success: true, data: JSON.parse(responseText) };
    } else {
      let error;
      try {
        error = JSON.parse(responseText);
      } catch (e) {
        error = { message: responseText };
      }
      
      const errorMsg = (error.message || error.error_description || `HTTP ${responseCode}`).toLowerCase();
      
      // Phân biệt rõ: foreign key (23503) vs duplicate (23505)
      const isForeignKeyError = error.code === '23503' ||
                               errorMsg.includes('foreign key') ||
                               errorMsg.includes('violates foreign key');
      
      const isDuplicate = !isForeignKeyError && (
                         responseCode === 409 || 
                         (error.code === '23505') || 
                         errorMsg.includes('duplicate') ||
                         errorMsg.includes('already exists') ||
                         errorMsg.includes('unique constraint')
                       );
      
      // Log chi tiết để debug
      if (isForeignKeyError) {
        Logger.log(`🔑 Foreign key error cho record: ${error.details || error.message}`);
      } else if (isDuplicate) {
        Logger.log(`🔄 Duplicate error cho record: ${error.details || error.message}`);
      }
      
      return { 
        success: false, 
        error: error.message || error.error_description || `HTTP ${responseCode}`,
        isDuplicate: isDuplicate,
        isForeignKeyError: isForeignKeyError
      };
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.toString(),
      isDuplicate: false
    };
  }
}

// ============================================
// CÁC HÀM HỖ TRỢ (giống như script import vehicles)
// ============================================

function getSheet() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  if (CONFIG_BADGES.SHEET_NAME) {
    const sheet = spreadsheet.getSheetByName(CONFIG_BADGES.SHEET_NAME);
    if (!sheet) {
      throw new Error(`Không tìm thấy sheet: ${CONFIG_BADGES.SHEET_NAME}`);
    }
    return sheet;
  } else {
    return spreadsheet.getActiveSheet();
  }
}

function readSheetData(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < CONFIG_BADGES.START_ROW) {
    return [];
  }
  
  const headerRange = sheet.getRange(CONFIG_BADGES.HEADER_ROW, 1, 1, sheet.getLastColumn());
  const headers = headerRange.getValues()[0];
  
  const dataRange = sheet.getRange(CONFIG_BADGES.START_ROW, 1, lastRow - CONFIG_BADGES.START_ROW + 1, sheet.getLastColumn());
  const dataValues = dataRange.getValues();
  
  const data = [];
  for (let i = 0; i < dataValues.length; i++) {
    const row = {};
    for (let j = 0; j < headers.length; j++) {
      const header = headers[j];
      if (header) {
        row[header] = dataValues[i][j];
      }
    }
    data.push(row);
  }
  
  return data;
}

function columnLetterToIndex(column) {
  let result = 0;
  for (let i = 0; i < column.length; i++) {
    result = result * 26 + (column.charCodeAt(i) - 'A'.charCodeAt(0) + 1);
  }
  return result;
}

function updateStatusBatch(sheet, updates, columnIndex) {
  if (updates.length === 0) return;
  
  try {
    updates.sort((a, b) => a.row - b.row);
    const updateMap = {};
    for (let i = 0; i < updates.length; i++) {
      updateMap[updates[i].row] = updates[i];
    }
    
    const rows = updates.map(u => u.row);
    if (rows.length === 0) return;
    
    const firstRow = Math.min(...rows) + CONFIG_BADGES.START_ROW - 1;
    const lastRow = Math.max(...rows) + CONFIG_BADGES.START_ROW - 1;
    const numRows = lastRow - firstRow + 1;
    
    const values = [];
    const backgrounds = [];
    for (let r = 0; r < numRows; r++) {
      const actualRow = firstRow + r;
      const rowIndex = actualRow - CONFIG_BADGES.START_ROW + 1;
      const update = updateMap[rowIndex];
      
      if (update) {
        values.push([update.value || '']);
        backgrounds.push([update.background || '#ffffff']);
      } else {
        values.push(['']);
        backgrounds.push(['#ffffff']);
      }
    }
    
    if (numRows > 0 && values.length > 0) {
      const range = sheet.getRange(firstRow, columnIndex, numRows, 1);
      range.setValues(values);
      range.setBackgrounds(backgrounds);
    }
  } catch (error) {
    Logger.log('Lỗi trong updateStatusBatch: ' + error.toString());
    throw error;
  }
}

function parseDate(dateValue) {
  if (!dateValue) return null;
  if (dateValue instanceof Date) {
    return formatDate(dateValue);
  }
  
  const str = String(dateValue).trim();
  if (!str) return null;
  
  const datePattern1 = /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/;
  const match1 = str.match(datePattern1);
  if (match1) {
    const day = parseInt(match1[1]);
    const month = parseInt(match1[2]) - 1;
    const year = parseInt(match1[3]);
    const date = new Date(year, month, day);
    if (!isNaN(date.getTime())) {
      return formatDate(date);
    }
  }
  
  const datePattern2 = /^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/;
  const match2 = str.match(datePattern2);
  if (match2) {
    const year = parseInt(match2[1]);
    const month = parseInt(match2[2]) - 1;
    const day = parseInt(match2[3]);
    const date = new Date(year, month, day);
    if (!isNaN(date.getTime())) {
      return formatDate(date);
    }
  }
  
  const date = new Date(str);
  if (!isNaN(date.getTime())) {
    return formatDate(date);
  }
  
  return null;
}

function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Import Phù Hiệu')
    .addItem('Import lên Supabase (Batch - Tốc độ cao)', 'importVehicleBadges')
    .addSeparator()
    .addItem('Test kết nối Supabase', 'testConnection')
    .addToUi();
}

function testConnection() {
  try {
    const url = `${CONFIG_BADGES.SUPABASE_URL}/rest/v1/vehicle_badges?select=id&limit=1`;
    
    const options = {
      method: 'GET',
      headers: {
        'apikey': CONFIG_BADGES.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG_BADGES.SUPABASE_KEY}`
      }
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      SpreadsheetApp.getUi().alert('Kết nối Supabase thành công!');
    } else {
      SpreadsheetApp.getUi().alert(`Lỗi kết nối: HTTP ${responseCode}`);
    }
  } catch (error) {
    SpreadsheetApp.getUi().alert('Lỗi: ' + error.toString());
  }
}
</file>

<file path="server/src/scripts/import-vehicle-badges-json.ts">
/**
 * Import Vehicle Badges from JSON file exported from old Firebase
 *
 * Usage:
 *   1. Place the exported JSON file as: ./data/PHUHIEUXE.json
 *   2. Run: npx tsx src/scripts/import-vehicle-badges-json.ts
 */

import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Configuration
const CONFIG = {
  // Path to the exported JSON file from old Firebase
  JSON_FILE_PATH: './data/PHUHIEUXE.json',

  // Destination path in new Firebase
  DESTINATION_PATH: 'datasheet/PHUHIEUXE',

  // New Firebase config
  DATABASE_URL: process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/',
  SERVICE_ACCOUNT_PATH: process.env.SERVICE_ACCOUNT_PATH || './benxe-management-20251218-firebase-adminsdk.json',

  // Batch size
  BATCH_SIZE: 500,
}

async function main() {
  console.log('='.repeat(50))
  console.log('IMPORT VEHICLE BADGES FROM JSON')
  console.log('='.repeat(50))
  console.log('')

  // Check if JSON file exists
  const jsonFilePath = resolve(process.cwd(), CONFIG.JSON_FILE_PATH)
  if (!existsSync(jsonFilePath)) {
    console.error(`File not found: ${jsonFilePath}`)
    console.log('')
    console.log('Please place the exported JSON file at:')
    console.log(`  ${jsonFilePath}`)
    console.log('')
    console.log('Or update JSON_FILE_PATH in the script.')
    process.exit(1)
  }

  // Read JSON file
  console.log(`Reading: ${jsonFilePath}`)
  const jsonContent = readFileSync(jsonFilePath, 'utf-8')
  const data = JSON.parse(jsonContent)

  const keys = Object.keys(data)
  console.log(`Found ${keys.length.toLocaleString()} records`)
  console.log('')

  // Initialize Firebase
  const serviceAccountPath = resolve(process.cwd(), CONFIG.SERVICE_ACCOUNT_PATH)
  if (!existsSync(serviceAccountPath)) {
    console.error(`Service account not found: ${serviceAccountPath}`)
    process.exit(1)
  }

  if (!getApps().length) {
    const serviceAccount = JSON.parse(readFileSync(serviceAccountPath, 'utf-8'))
    initializeApp({
      credential: cert(serviceAccount),
      databaseURL: CONFIG.DATABASE_URL
    })
  }

  const db = getDatabase()
  console.log(`Connected to: ${CONFIG.DATABASE_URL}`)
  console.log(`Destination: ${CONFIG.DESTINATION_PATH}`)
  console.log('')

  // Import in batches
  console.log('Starting import...')
  console.log('-'.repeat(50))

  let success = 0
  let failed = 0
  const totalBatches = Math.ceil(keys.length / CONFIG.BATCH_SIZE)

  for (let i = 0; i < keys.length; i += CONFIG.BATCH_SIZE) {
    const batchNum = Math.floor(i / CONFIG.BATCH_SIZE) + 1
    const batchKeys = keys.slice(i, i + CONFIG.BATCH_SIZE)
    const batchData: Record<string, any> = {}

    for (const key of batchKeys) {
      batchData[key] = data[key]
    }

    try {
      await db.ref(CONFIG.DESTINATION_PATH).update(batchData)
      success += batchKeys.length

      const progress = ((i + batchKeys.length) / keys.length * 100).toFixed(1)
      console.log(`Batch ${batchNum}/${totalBatches}: ${batchKeys.length} records (${progress}%)`)
    } catch (error: any) {
      failed += batchKeys.length
      console.error(`Batch ${batchNum} FAILED: ${error.message}`)
    }

    // Small delay
    if (i + CONFIG.BATCH_SIZE < keys.length) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }

  // Summary
  console.log('')
  console.log('='.repeat(50))
  console.log('RESULT')
  console.log('='.repeat(50))
  console.log(`Success: ${success.toLocaleString()}`)
  console.log(`Failed: ${failed.toLocaleString()}`)
  console.log('')

  // Verify
  const snapshot = await db.ref(CONFIG.DESTINATION_PATH).once('value')
  const newData = snapshot.val()
  const newCount = newData ? Object.keys(newData).length : 0
  console.log(`Verification: ${newCount.toLocaleString()} records in database`)

  if (newCount === keys.length) {
    console.log('Import completed successfully!')
  } else {
    console.log('Warning: Record count mismatch')
  }

  process.exit(0)
}

main().catch(error => {
  console.error('Error:', error)
  process.exit(1)
})
</file>

<file path="server/src/scripts/import-vehicles-from-sheets.gs">
/**
 * @deprecated SCRIPT NÀY ĐÃ LỖI THỜI - KHÔNG SỬ DỤNG
 *
 * Script này được viết cho Supabase nhưng dự án đã migrate sang Firebase Realtime Database.
 *
 * KHÔNG SỬ DỤNG SCRIPT NÀY NỮA.
 *
 * Để import dữ liệu vào Firebase, vui lòng:
 * 1. Sử dụng Firebase Console để import JSON trực tiếp
 * 2. Hoặc liên hệ admin để được hỗ trợ import qua API backend
 *
 * ---
 *
 * [LEGACY] Google Apps Script để import dữ liệu xe từ Google Sheets lên Supabase
 *
 * HƯỚNG DẪN SỬ DỤNG (ĐÃ LỖI THỜI):
 * 1. Mở Google Sheets chứa dữ liệu xe
 * 2. Vào Extensions > Apps Script
 * 3. Dán code này vào editor
 * 4. Cập nhật các biến cấu hình ở dưới (SUPABASE_URL, SUPABASE_KEY)
 * 5. Chạy hàm importVehicles() hoặc tạo menu để chạy
 */

// ============================================
// CẤU HÌNH
// ============================================
const CONFIG = {
  // URL của Supabase project (ví dụ: https://xxxxx.supabase.co)
  SUPABASE_URL: 'YOUR_SUPABASE_URL_HERE',
  
  // Service Role Key hoặc Anon Key từ Supabase
  // Lưu ý: Nên dùng Service Role Key để có quyền ghi đầy đủ
  SUPABASE_KEY: 'YOUR_SUPABASE_SERVICE_ROLE_KEY_HERE',
  
  // Tên sheet chứa dữ liệu (mặc định là sheet đầu tiên)
  SHEET_NAME: null, // null = sheet đầu tiên
  
  // Số dòng header (thường là 1)
  HEADER_ROW: 1,
  
  // Bắt đầu đọc từ dòng nào (sau header)
  START_ROW: 2,
  
  // Cột ID trong sheet (để đánh dấu đã import)
  STATUS_COLUMN: 'Z', // Cột để đánh dấu trạng thái import
  
  // Số lượng records gửi cùng lúc (batch size)
  // Tăng số này để import nhanh hơn, Supabase hỗ trợ tối đa ~1000 records/batch
  // Nhưng để an toàn, nên dùng 100-200
  BATCH_SIZE: 200, // Tăng lên 200 để giảm số lần gọi API
  
  // Delay giữa các batch (ms) - giảm để tăng tốc, tăng để tránh rate limit
  // Với Service Role Key, có thể giảm xuống 0 hoặc rất nhỏ
  BATCH_DELAY: 0, // Không delay để tăng tốc tối đa
  
  // Số lượng records tối đa xử lý trong một lần chạy (để tránh timeout)
  // Nếu có nhiều hơn, sẽ cần chạy nhiều lần
  MAX_RECORDS_PER_RUN: 1000, // Tăng lên 1000 để xử lý nhiều hơn mỗi lần
  
  // Tự động skip các records bị duplicate (đã tồn tại) thay vì báo lỗi
  SKIP_DUPLICATES: true,
  
  // Mapping các cột từ sheet sang database
  // Key = tên cột trong sheet, Value = tên field trong database
  COLUMN_MAPPING: {
    'IDXe': 'id',
    'BienSo': 'plate_number',
    'SoKhung': 'chassis_number',
    'SoMay': 'engine_number',
    'SoCho': 'seat_capacity',
    'NienHan': 'inspection_expiry_date',
    'TenDangKyXe': 'notes_owner_name',
    'DiaChiChuXe': 'notes_owner_address',
    'NhanHieu': 'notes_brand',
    'LoaiXe': 'notes_vehicle_type',
    'LoaiPhuongTien': 'notes_vehicle_category',
    'TaiTrong': 'notes_weight_capacity',
    'MauSon': 'notes_color',
    'NamSanXuat': 'notes_manufacture_year',
    'LaBienDinhDanh': 'notes_is_identification_plate',
    'TrangThaiBienDinhDanh': 'notes_plate_status',
    'LyDoThuBienDinhDanh': 'notes_plate_revocation_reason',
    'ThongTinDangKyXe': 'notes_registration_info',
    'User': 'created_by_username',
    'ThoiGianNhap': 'imported_at',
    'Nienhan': 'notes_expiry_year',
    'CoKDVT': 'notes_has_operator'
  }
};

// ============================================
// HÀM CHÍNH
// ============================================

/**
 * Hàm chính để import dữ liệu (Batch mode - tốc độ cao)
 */
function importVehicles() {
  try {
    const sheet = getSheet();
    const data = readSheetData(sheet);
    
    Logger.log(`Đã đọc ${data.length} dòng dữ liệu từ sheet`);
    Logger.log(`Sử dụng batch size: ${CONFIG.BATCH_SIZE}`);
    
    // Đọc trạng thái hiện tại của tất cả các dòng (để tránh đọc lại nhiều lần)
    const statusColumnIndex = columnLetterToIndex(CONFIG.STATUS_COLUMN);
    const statusRange = sheet.getRange(CONFIG.START_ROW, statusColumnIndex, data.length, 1);
    const statusValues = statusRange.getValues();
    
    // Chuẩn bị dữ liệu và lọc các dòng chưa import
    const rowsToProcess = [];
    let alreadyImportedCount = 0;
    let alreadyExistsCount = 0;
    
    for (let i = 0; i < data.length; i++) {
      const status = statusValues[i][0];
      if (status === 'Đã import' || status === 'Success') {
        alreadyImportedCount++;
      } else if (status === 'Đã tồn tại') {
        alreadyExistsCount++;
      } else if (status !== '') {
        // Có status nhưng không phải các trạng thái trên (có thể là lỗi cũ)
        rowsToProcess.push({
          data: data[i],
          rowNumber: CONFIG.START_ROW + i,
          index: i
        });
      } else {
        // Chưa có status - cần import
        rowsToProcess.push({
          data: data[i],
          rowNumber: CONFIG.START_ROW + i,
          index: i
        });
      }
    }
    
    Logger.log(`Tổng số dòng: ${data.length}`);
    Logger.log(`- Đã import: ${alreadyImportedCount}`);
    Logger.log(`- Đã tồn tại: ${alreadyExistsCount}`);
    Logger.log(`- Cần import: ${rowsToProcess.length}`);
    
    if (rowsToProcess.length === 0) {
      SpreadsheetApp.getUi().alert('Tất cả dữ liệu đã được import hoặc đã tồn tại!');
      return;
    }
    
    // Giới hạn số records xử lý trong một lần chạy để tránh timeout
    const recordsToProcess = rowsToProcess.slice(0, CONFIG.MAX_RECORDS_PER_RUN);
    
    // Kiểm tra an toàn
    if (!recordsToProcess || recordsToProcess.length === 0) {
      SpreadsheetApp.getUi().alert('Không có dữ liệu để xử lý!');
      return;
    }
    
    if (rowsToProcess.length > CONFIG.MAX_RECORDS_PER_RUN) {
      Logger.log(`⚠️ Cảnh báo: Có ${rowsToProcess.length} dòng cần import, nhưng chỉ xử lý ${CONFIG.MAX_RECORDS_PER_RUN} dòng trong lần chạy này.`);
      Logger.log(`⚠️ Vui lòng chạy lại script để xử lý các dòng còn lại.`);
    }
    
    const totalBatches = Math.ceil(recordsToProcess.length / CONFIG.BATCH_SIZE);
    Logger.log(`Sẽ xử lý ${totalBatches} batch(es) với ${recordsToProcess.length} records`);
    
    let successCount = 0;
    let errorCount = 0;
    let duplicateCount = 0;
    const errors = [];
    const statusUpdates = []; // Lưu các cập nhật status để batch update
    
    // Lưu thời gian bắt đầu để theo dõi
    const overallStartTime = new Date().getTime();
    
    // Chia thành các batch
    for (let batchStart = 0; batchStart < recordsToProcess.length; batchStart += CONFIG.BATCH_SIZE) {
      const batchEnd = Math.min(batchStart + CONFIG.BATCH_SIZE, recordsToProcess.length);
      const batch = recordsToProcess.slice(batchStart, batchEnd);
      
      // Kiểm tra thời gian còn lại (ước tính)
      const startTime = new Date().getTime();
      
      Logger.log(`Xử lý batch ${Math.floor(batchStart / CONFIG.BATCH_SIZE) + 1}/${Math.ceil(recordsToProcess.length / CONFIG.BATCH_SIZE)} (${batch.length} records)`);
      
      // Chuẩn bị dữ liệu cho batch
      const vehicleBatch = [];
      const batchRowInfo = []; // Lưu thông tin row để update status sau
      
      for (let j = 0; j < batch.length; j++) {
        const rowInfo = batch[j];
        try {
          const vehicleData = mapRowToVehicle(rowInfo.data, rowInfo.rowNumber);
          vehicleBatch.push(vehicleData);
          batchRowInfo.push({
            rowNumber: rowInfo.rowNumber,
            index: rowInfo.index,
            plateNumber: vehicleData.plate_number
          });
        } catch (error) {
          // Lỗi khi map dữ liệu (ví dụ: thiếu biển số)
          errorCount++;
          const errorMsg = error.toString();
          errors.push(`Dòng ${rowInfo.rowNumber}: ${errorMsg}`);
          statusUpdates.push({
            row: rowInfo.index,
            value: `Lỗi: ${errorMsg}`,
            background: '#f8d7da'
          });
        }
      }
      
      // Gửi batch lên Supabase
      if (vehicleBatch.length > 0) {
        const result = insertVehiclesBatchToSupabase(vehicleBatch);
        
        // Xử lý kết quả
        if (result.success) {
          // Tất cả đều thành công
          for (let k = 0; k < batchRowInfo.length; k++) {
            successCount++;
            statusUpdates.push({
              row: batchRowInfo[k].index,
              value: 'Đã import',
              background: '#d4edda'
            });
            Logger.log(`Dòng ${batchRowInfo[k].rowNumber}: Import thành công - ${batchRowInfo[k].plateNumber}`);
          }
        } else if (result.partial) {
          // Một số thành công, một số lỗi hoặc duplicate
          const successIndices = result.successIndices || [];
          const duplicateIndices = result.duplicateIndices || [];
          const errorDetails = result.errors || [];
          
          for (let k = 0; k < batchRowInfo.length; k++) {
            if (successIndices.includes(k)) {
              // Thành công
              successCount++;
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: 'Đã import',
                background: '#d4edda'
              });
            } else if (duplicateIndices.includes(k)) {
              // Duplicate - skip nếu SKIP_DUPLICATES = true
              if (CONFIG.SKIP_DUPLICATES) {
                // Đánh dấu là "Đã tồn tại" thay vì "Lỗi"
                duplicateCount++;
                statusUpdates.push({
                  row: batchRowInfo[k].index,
                  value: 'Đã tồn tại',
                  background: '#fff3cd' // Màu vàng nhạt
                });
                Logger.log(`Dòng ${batchRowInfo[k].rowNumber}: Đã tồn tại - ${batchRowInfo[k].plateNumber}`);
              } else {
                // Báo lỗi nếu không skip
                errorCount++;
                errors.push(`Dòng ${batchRowInfo[k].rowNumber}: Biển số đã tồn tại`);
                statusUpdates.push({
                  row: batchRowInfo[k].index,
                  value: 'Lỗi: Đã tồn tại',
                  background: '#f8d7da'
                });
              }
            } else {
              // Lỗi khác
              errorCount++;
              const errorMsg = errorDetails[k] || 'Lỗi không xác định';
              errors.push(`Dòng ${batchRowInfo[k].rowNumber}: ${errorMsg}`);
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: `Lỗi: ${errorMsg}`,
                background: '#f8d7da'
              });
            }
          }
        } else {
          // Tất cả đều lỗi - nhưng vẫn kiểm tra xem có duplicate không
          const duplicateIndices = result.duplicateIndices || [];
          const errorDetails = result.errors || [];
          
          for (let k = 0; k < batchRowInfo.length; k++) {
            if (duplicateIndices.includes(k) && CONFIG.SKIP_DUPLICATES) {
              // Duplicate - skip
              duplicateCount++;
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: 'Đã tồn tại',
                background: '#fff3cd'
              });
              Logger.log(`Dòng ${batchRowInfo[k].rowNumber}: Đã tồn tại - ${batchRowInfo[k].plateNumber}`);
            } else {
              // Lỗi thật sự
              errorCount++;
              const errorMsg = errorDetails[k] || result.error || 'Lỗi không xác định';
              errors.push(`Dòng ${batchRowInfo[k].rowNumber}: ${errorMsg}`);
              statusUpdates.push({
                row: batchRowInfo[k].index,
                value: `Lỗi: ${errorMsg}`,
                background: '#f8d7da'
              });
            }
          }
        }
      }
      
      // Batch update status trong sheet (cập nhật nhiều cell cùng lúc)
      // Chỉ update khi kết thúc batch hoặc khi có nhiều updates để giảm số lần gọi API
      if (statusUpdates.length > 0 && (statusUpdates.length >= 100 || batchEnd >= recordsToProcess.length)) {
        try {
          updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
          statusUpdates.length = 0; // Clear sau khi update
        } catch (updateError) {
          Logger.log('Lỗi khi update status: ' + updateError.toString());
          // Thử update từng cell nếu batch update lỗi (nhưng chỉ một số cell để tránh timeout)
          const maxCellUpdates = 20; // Giới hạn số cell update để tránh timeout
          for (let u = 0; u < Math.min(statusUpdates.length, maxCellUpdates); u++) {
            try {
              const update = statusUpdates[u];
              const cell = sheet.getRange(update.row + CONFIG.START_ROW - 1, statusColumnIndex);
              cell.setValue(update.value);
              cell.setBackground(update.background || '#ffffff');
            } catch (cellError) {
              Logger.log(`Lỗi khi update cell row ${update.row}: ${cellError.toString()}`);
            }
          }
          // Xóa các updates đã xử lý
          statusUpdates.splice(0, Math.min(statusUpdates.length, maxCellUpdates));
        }
      }
      
      // Delay giữa các batch (chỉ nếu cần)
      if (CONFIG.BATCH_DELAY > 0 && batchEnd < recordsToProcess.length) {
        Utilities.sleep(CONFIG.BATCH_DELAY);
      }
      
      // Kiểm tra thời gian đã chạy (ước tính 5 phút 30 giây để an toàn)
      const totalElapsed = (new Date().getTime() - overallStartTime) / 1000;
      if (totalElapsed > 300) { // 5 phút
        Logger.log(`⚠️ Đã chạy ${Math.round(totalElapsed)} giây, dừng để tránh timeout.`);
        Logger.log(`⚠️ Đã xử lý ${batchEnd}/${recordsToProcess.length} records. Vui lòng chạy lại để tiếp tục.`);
        // Update status cho các records đã xử lý trước khi dừng
        if (statusUpdates.length > 0) {
          try {
            updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
          } catch (e) {
            Logger.log('Lỗi khi update status cuối cùng: ' + e.toString());
          }
        }
        break;
      }
    }
    
    // Update status cuối cùng cho các records còn lại
    if (statusUpdates.length > 0) {
      try {
        updateStatusBatch(sheet, statusUpdates, statusColumnIndex);
      } catch (e) {
        Logger.log('Lỗi khi update status cuối cùng: ' + e.toString());
      }
    }
    
    // Hiển thị kết quả
    const totalProcessed = successCount + errorCount + duplicateCount;
    let message = `Hoàn thành!\n\nThành công: ${successCount}`;
    if (duplicateCount > 0) {
      message += `\nĐã tồn tại (skip): ${duplicateCount}`;
    }
    message += `\nLỗi: ${errorCount}\nTổng: ${totalProcessed} records`;
    
    Logger.log('=== KẾT QUẢ CUỐI CÙNG ===');
    Logger.log(message);
    
    if (errors.length > 0 && errors.length <= 20) {
      Logger.log('Các lỗi:\n' + errors.slice(0, 20).join('\n'));
      if (errors.length > 20) {
        Logger.log(`... và ${errors.length - 20} lỗi khác`);
      }
    }
    
    Logger.log('Đang hiển thị thông báo...');
    try {
      SpreadsheetApp.getUi().alert(message);
      Logger.log('Đã hiển thị thông báo thành công');
    } catch (alertError) {
      Logger.log('Lỗi khi hiển thị thông báo: ' + alertError.toString());
      // Vẫn tiếp tục, không throw exception
    }
    Logger.log('Script đã hoàn thành!');
    
  } catch (error) {
    Logger.log('Lỗi tổng quát: ' + error.toString());
    SpreadsheetApp.getUi().alert('Lỗi: ' + error.toString());
  }
}

/**
 * Chuyển đổi chữ cột thành số (A=1, B=2, ..., Z=26, AA=27, ...)
 */
function columnLetterToIndex(column) {
  let result = 0;
  for (let i = 0; i < column.length; i++) {
    result = result * 26 + (column.charCodeAt(i) - 'A'.charCodeAt(0) + 1);
  }
  return result;
}

/**
 * Batch update status trong sheet (cập nhật nhiều cell cùng lúc)
 */
function updateStatusBatch(sheet, updates, columnIndex) {
  if (updates.length === 0) return;
  
  try {
    // Sắp xếp updates theo row để tối ưu
    updates.sort((a, b) => a.row - b.row);
    
    // Tạo map để truy cập nhanh
    const updateMap = {};
    for (let i = 0; i < updates.length; i++) {
      updateMap[updates[i].row] = updates[i];
    }
    
    // Lấy range từ row đầu đến row cuối
    const rows = updates.map(u => u.row);
    if (rows.length === 0) return;
    
    const firstRow = Math.min(...rows) + CONFIG.START_ROW - 1;
    const lastRow = Math.max(...rows) + CONFIG.START_ROW - 1;
    const numRows = lastRow - firstRow + 1;
    
    // Tạo mảng values và backgrounds cho toàn bộ range
    const values = [];
    const backgrounds = [];
    for (let r = 0; r < numRows; r++) {
      const actualRow = firstRow + r;
      const rowIndex = actualRow - CONFIG.START_ROW + 1; // Convert về index trong data
      const update = updateMap[rowIndex];
      
      if (update) {
        values.push([update.value || '']);
        backgrounds.push([update.background || '#ffffff']);
      } else {
        // Giữ nguyên giá trị hiện tại (đọc từ sheet) - nhưng có thể bỏ qua để tăng tốc
        values.push(['']);
        backgrounds.push(['#ffffff']);
      }
    }
    
    // Batch update toàn bộ range cùng lúc
    if (numRows > 0 && values.length > 0) {
      const range = sheet.getRange(firstRow, columnIndex, numRows, 1);
      range.setValues(values);
      range.setBackgrounds(backgrounds);
    }
  } catch (error) {
    Logger.log('Lỗi trong updateStatusBatch: ' + error.toString());
    throw error; // Re-throw để xử lý ở nơi gọi
  }
}

/**
 * Lấy sheet để đọc dữ liệu
 */
function getSheet() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  
  if (CONFIG.SHEET_NAME) {
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet) {
      throw new Error(`Không tìm thấy sheet: ${CONFIG.SHEET_NAME}`);
    }
    return sheet;
  } else {
    return spreadsheet.getActiveSheet();
  }
}

/**
 * Đọc dữ liệu từ sheet
 */
function readSheetData(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < CONFIG.START_ROW) {
    return [];
  }
  
  // Đọc header để xác định vị trí cột
  const headerRange = sheet.getRange(CONFIG.HEADER_ROW, 1, 1, sheet.getLastColumn());
  const headers = headerRange.getValues()[0];
  
  // Đọc dữ liệu
  const dataRange = sheet.getRange(CONFIG.START_ROW, 1, lastRow - CONFIG.START_ROW + 1, sheet.getLastColumn());
  const dataValues = dataRange.getValues();
  
  // Chuyển đổi thành object với key là tên cột
  const data = [];
  for (let i = 0; i < dataValues.length; i++) {
    const row = {};
    for (let j = 0; j < headers.length; j++) {
      const header = headers[j];
      if (header) {
        row[header] = dataValues[i][j];
      }
    }
    data.push(row);
  }
  
  return data;
}

/**
 * Chuyển đổi dữ liệu từ sheet sang format của database
 */
function mapRowToVehicle(row, rowNumber) {
  const vehicle = {};
  
  // Map các trường cơ bản
  const mapping = CONFIG.COLUMN_MAPPING;
  
  // ID - nếu có IDXe thì dùng, không thì generate UUID
  if (row['IDXe']) {
    vehicle.id = String(row['IDXe']).trim();
  } else {
    // Generate UUID v4 (đơn giản)
    vehicle.id = generateUUID();
  }
  
  // Plate number - bắt buộc
  if (!row['BienSo'] || !String(row['BienSo']).trim()) {
    throw new Error('Biển số không được để trống');
  }
  vehicle.plate_number = String(row['BienSo']).trim();
  
  // Seat capacity
  if (row['SoCho']) {
    const seats = parseInt(row['SoCho']);
    vehicle.seat_capacity = isNaN(seats) ? 0 : seats;
  } else {
    vehicle.seat_capacity = 0;
  }
  
  // Chassis number
  if (row['SoKhung']) {
    vehicle.chassis_number = String(row['SoKhung']).trim() || null;
  }
  
  // Engine number
  if (row['SoMay']) {
    vehicle.engine_number = String(row['SoMay']).trim() || null;
  }
  
  // Inspection expiry date (NienHan)
  if (row['NienHan']) {
    const dateStr = parseDate(row['NienHan']);
    if (dateStr) {
      vehicle.inspection_expiry_date = dateStr;
    }
  }
  
  // Tập hợp các thông tin bổ sung vào notes
  const notesParts = [];
  
  if (row['TenDangKyXe']) notesParts.push(`Tên đăng ký: ${row['TenDangKyXe']}`);
  if (row['DiaChiChuXe']) notesParts.push(`Địa chỉ chủ xe: ${row['DiaChiChuXe']}`);
  if (row['NhanHieu']) notesParts.push(`Nhãn hiệu: ${row['NhanHieu']}`);
  if (row['LoaiXe']) notesParts.push(`Loại xe: ${row['LoaiXe']}`);
  if (row['LoaiPhuongTien']) notesParts.push(`Loại phương tiện: ${row['LoaiPhuongTien']}`);
  if (row['TaiTrong']) notesParts.push(`Tải trọng: ${row['TaiTrong']}`);
  if (row['MauSon']) notesParts.push(`Màu sơn: ${row['MauSon']}`);
  if (row['NamSanXuat']) notesParts.push(`Năm sản xuất: ${row['NamSanXuat']}`);
  if (row['LaBienDinhDanh']) notesParts.push(`Là biển định danh: ${row['LaBienDinhDanh']}`);
  if (row['TrangThaiBienDinhDanh']) notesParts.push(`Trạng thái biển định danh: ${row['TrangThaiBienDinhDanh']}`);
  if (row['LyDoThuBienDinhDanh']) notesParts.push(`Lý do thu biển định danh: ${row['LyDoThuBienDinhDanh']}`);
  if (row['ThongTinDangKyXe']) notesParts.push(`Thông tin đăng ký: ${row['ThongTinDangKyXe']}`);
  if (row['Nienhan']) notesParts.push(`Niên hạn: ${row['Nienhan']}`);
  if (row['CoKDVT']) notesParts.push(`Có KDV: ${row['CoKDVT']}`);
  if (row['User']) notesParts.push(`Người nhập: ${row['User']}`);
  if (row['ThoiGianNhap']) notesParts.push(`Thời gian nhập: ${row['ThoiGianNhap']}`);
  
  if (notesParts.length > 0) {
    vehicle.notes = notesParts.join('\n');
  }
  
  // Các trường mặc định
  vehicle.is_active = true;
  vehicle.bed_capacity = 0;
  
  return vehicle;
}

/**
 * Parse date từ nhiều format khác nhau
 */
function parseDate(dateValue) {
  if (!dateValue) return null;
  
  // Nếu là Date object
  if (dateValue instanceof Date) {
    return formatDate(dateValue);
  }
  
  // Nếu là string
  const str = String(dateValue).trim();
  if (!str) return null;
  
  // Thử parse các format phổ biến
  // Format: DD/MM/YYYY hoặc DD-MM-YYYY
  const datePattern1 = /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/;
  const match1 = str.match(datePattern1);
  if (match1) {
    const day = parseInt(match1[1]);
    const month = parseInt(match1[2]) - 1; // Month is 0-indexed
    const year = parseInt(match1[3]);
    const date = new Date(year, month, day);
    if (!isNaN(date.getTime())) {
      return formatDate(date);
    }
  }
  
  // Format: YYYY-MM-DD
  const datePattern2 = /^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/;
  const match2 = str.match(datePattern2);
  if (match2) {
    const year = parseInt(match2[1]);
    const month = parseInt(match2[2]) - 1;
    const day = parseInt(match2[3]);
    const date = new Date(year, month, day);
    if (!isNaN(date.getTime())) {
      return formatDate(date);
    }
  }
  
  // Thử parse trực tiếp
  const date = new Date(str);
  if (!isNaN(date.getTime())) {
    return formatDate(date);
  }
  
  return null;
}

/**
 * Format date thành YYYY-MM-DD
 */
function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Generate UUID v4 (đơn giản)
 */
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * Gửi một vehicle lên Supabase (dùng cho single insert)
 */
function insertVehicleToSupabase(vehicleData) {
  try {
    const url = `${CONFIG.SUPABASE_URL}/rest/v1/vehicles`;
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': CONFIG.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG.SUPABASE_KEY}`,
        'Prefer': 'return=representation'
      },
      payload: JSON.stringify(vehicleData),
      muteHttpExceptions: true // Để xem full error response
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode >= 200 && responseCode < 300) {
      return { success: true, data: JSON.parse(responseText) };
    } else {
      let error;
      try {
        error = JSON.parse(responseText);
      } catch (e) {
        error = { message: responseText };
      }
      
      // Kiểm tra lỗi duplicate (409 Conflict hoặc code 23505)
      const errorMsg = (error.message || error.error_description || `HTTP ${responseCode}`).toLowerCase();
      const isDuplicate = responseCode === 409 || 
                         (error.code === '23505') || 
                         errorMsg.includes('duplicate') ||
                         errorMsg.includes('already exists') ||
                         errorMsg.includes('unique constraint');
      
      return { 
        success: false, 
        error: error.message || error.error_description || `HTTP ${responseCode}`,
        isDuplicate: isDuplicate
      };
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.toString(),
      isDuplicate: false
    };
  }
}

/**
 * Gửi nhiều vehicles lên Supabase cùng lúc (Batch insert - TỐC ĐỘ CAO)
 */
function insertVehiclesBatchToSupabase(vehiclesArray) {
  try {
    if (!vehiclesArray || vehiclesArray.length === 0) {
      return { success: false, error: 'Không có dữ liệu để gửi' };
    }
    
    const url = `${CONFIG.SUPABASE_URL}/rest/v1/vehicles`;
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': CONFIG.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG.SUPABASE_KEY}`,
        'Prefer': 'return=representation'
      },
      payload: JSON.stringify(vehiclesArray), // Gửi mảng thay vì object đơn
      muteHttpExceptions: true // Để xem full error response
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode >= 200 && responseCode < 300) {
      // Thành công - tất cả đều được insert
      const insertedData = JSON.parse(responseText);
      return { 
        success: true, 
        data: insertedData,
        count: Array.isArray(insertedData) ? insertedData.length : 1
      };
    } else {
      // Có lỗi - có thể là một số records lỗi
      let error;
      try {
        error = JSON.parse(responseText);
      } catch (parseError) {
        error = { message: responseText };
      }
      
      // Kiểm tra lỗi duplicate (409 Conflict hoặc code 23505)
      const isDuplicate = responseCode === 409 || 
                         (error.code === '23505') || 
                         (error.message && (
                           error.message.toLowerCase().includes('duplicate') ||
                           error.message.toLowerCase().includes('already exists') ||
                           error.message.toLowerCase().includes('unique constraint')
                         ));
      
      // Luôn thử insert từng record để xác định record nào thành công/lỗi/duplicate
      // Vì Supabase batch insert có thể fail toàn bộ nếu một record lỗi
      return handlePartialBatchError(vehiclesArray, error);
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.toString(),
      partial: false
    };
  }
}

/**
 * Xử lý lỗi partial batch - thử insert từng record để xác định record nào lỗi
 * Tối ưu: Giảm logging và delay để tăng tốc tối đa
 */
function handlePartialBatchError(vehiclesArray, originalError) {
  const successIndices = [];
  const duplicateIndices = [];
  const errors = [];
  
  // Chỉ log khi batch rất lớn
  if (vehiclesArray.length > 50) {
    Logger.log(`Xử lý từng record (${vehiclesArray.length} records)...`);
  }
  
  // Tối ưu: Giảm logging tối đa - chỉ log khi cần thiết
  const logEvery = vehiclesArray.length > 100 ? 50 : (vehiclesArray.length > 20 ? 20 : 10);
  
  // Tối ưu: Sử dụng batch nhỏ hơn thay vì từng record một
  // Chia thành các mini-batch để tăng tốc
  const miniBatchSize = 10; // Thử insert 10 records cùng lúc
  
  for (let i = 0; i < vehiclesArray.length; i += miniBatchSize) {
    const miniBatch = vehiclesArray.slice(i, i + miniBatchSize);
    const miniBatchEnd = Math.min(i + miniBatchSize, vehiclesArray.length);
    
    // Thử insert mini-batch trước
    const miniResult = insertVehiclesBatchToSupabase(miniBatch);
    
    if (miniResult.success) {
      // Tất cả trong mini-batch thành công
      for (let j = i; j < miniBatchEnd; j++) {
        successIndices.push(j);
        errors.push(null);
      }
      if (i % logEvery === 0) {
        Logger.log(`Records ${i + 1}-${miniBatchEnd}/${vehiclesArray.length}: Thành công (mini-batch)`);
      }
    } else if (miniResult.partial) {
      // Một số thành công, một số lỗi - xử lý từng record
      const miniSuccess = miniResult.successIndices || [];
      const miniDuplicate = miniResult.duplicateIndices || [];
      const miniErrors = miniResult.errors || [];
      
      for (let j = 0; j < miniBatch.length; j++) {
        const actualIndex = i + j;
        if (miniSuccess.includes(j)) {
          successIndices.push(actualIndex);
          errors.push(null);
        } else if (miniDuplicate.includes(j) && CONFIG.SKIP_DUPLICATES) {
          duplicateIndices.push(actualIndex);
          errors.push('DUPLICATE');
        } else {
          errors.push(miniErrors[j] || 'Lỗi không xác định');
        }
      }
    } else {
      // Mini-batch lỗi - thử từng record
      for (let j = 0; j < miniBatch.length; j++) {
        const actualIndex = i + j;
        const result = insertVehicleToSupabase(miniBatch[j]);
        if (result.success) {
          successIndices.push(actualIndex);
          errors.push(null);
        } else if (result.isDuplicate && CONFIG.SKIP_DUPLICATES) {
          duplicateIndices.push(actualIndex);
          errors.push('DUPLICATE');
        } else {
          errors.push(result.error);
        }
      }
    }
    
    // Không delay để tăng tốc tối đa
  }
  
  const totalProcessed = successIndices.length + duplicateIndices.length;
  const realErrors = errors.filter(e => e !== null && e !== 'DUPLICATE').length;
  Logger.log(`Kết quả: ${successIndices.length} thành công, ${duplicateIndices.length} duplicate, ${realErrors} lỗi`);
  
  // Nếu có duplicate và SKIP_DUPLICATES = true, coi như partial (đã xử lý)
  // Nếu tất cả đều duplicate, vẫn coi như partial để xử lý đúng
  const hasProcessed = totalProcessed > 0 || (duplicateIndices.length > 0 && CONFIG.SKIP_DUPLICATES);
  
  return {
    success: successIndices.length === vehiclesArray.length,
    partial: hasProcessed && (totalProcessed < vehiclesArray.length || duplicateIndices.length > 0),
    successIndices: successIndices,
    duplicateIndices: duplicateIndices,
    errors: errors,
    error: originalError.message || originalError.error_description
  };
}

/**
 * Tạo menu trong Google Sheets
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Import Xe')
    .addItem('Import lên Supabase (Batch - Tốc độ cao)', 'importVehicles')
    .addSeparator()
    .addItem('Test kết nối Supabase', 'testConnection')
    .addToUi();
}

/**
 * Hàm test để kiểm tra kết nối Supabase
 */
function testConnection() {
  try {
    const url = `${CONFIG.SUPABASE_URL}/rest/v1/vehicles?select=id&limit=1`;
    
    const options = {
      method: 'GET',
      headers: {
        'apikey': CONFIG.SUPABASE_KEY,
        'Authorization': `Bearer ${CONFIG.SUPABASE_KEY}`
      }
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      SpreadsheetApp.getUi().alert('Kết nối Supabase thành công!');
    } else {
      SpreadsheetApp.getUi().alert(`Lỗi kết nối: HTTP ${responseCode}`);
    }
  } catch (error) {
    SpreadsheetApp.getUi().alert('Lỗi: ' + error.toString());
  }
}
</file>

<file path="server/src/scripts/migrate-denormalize-dispatch.ts">
/**
 * Migration Script: Denormalize Existing Dispatch Records
 *
 * This script populates denormalized fields in existing dispatch_records
 * to enable single-query reads for improved performance.
 *
 * Run with: npx tsx src/scripts/migrate-denormalize-dispatch.ts
 *
 * Fields populated:
 * - vehicle_plate_number, vehicle_operator_id, vehicle_operator_name, vehicle_operator_code
 * - driver_full_name
 * - route_name, route_type, route_destination_id, route_destination_name, route_destination_code
 * - entry_by_name, passenger_drop_by_name, boarding_permit_by_name
 * - payment_by_name, departure_order_by_name, exit_by_name
 */

import { firebase, firebaseDb } from '../config/database.js'

interface MigrationStats {
  total: number
  processed: number
  failed: number
  skipped: number
  startTime: number
}

async function migrateDispatchRecords() {
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  DISPATCH RECORDS DENORMALIZATION MIGRATION')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')

  const stats: MigrationStats = {
    total: 0,
    processed: 0,
    failed: 0,
    skipped: 0,
    startTime: Date.now(),
  }

  try {
    // Step 1: Fetch all dispatch records
    console.log('📥 Fetching all dispatch records...')
    const { data: records, error: recordsError } = await firebase.from('dispatch_records').select('*')

    if (recordsError) {
      console.error('❌ Failed to fetch dispatch records:', recordsError)
      return
    }

    stats.total = records.length
    console.log(`   Found ${stats.total} records to migrate`)
    console.log('')

    if (stats.total === 0) {
      console.log('✅ No records to migrate')
      return
    }

    // Step 2: Fetch all reference data in parallel
    console.log('📥 Fetching reference data (vehicles, drivers, routes, users)...')
    const [vehiclesResult, driversResult, routesResult, usersResult] = await Promise.all([
      firebase.from('vehicles').select('id, plate_number, operator_id, operators:operator_id(id, name, code)'),
      firebase.from('drivers').select('id, full_name'),
      firebase.from('routes').select('id, route_name, route_type, destination:destination_id(id, name, code)'),
      firebase.from('users').select('id, full_name'),
    ])

    // Create lookup maps for O(1) access
    const vehicleMap = new Map<string, any>()
    vehiclesResult.data?.forEach((v: any) => {
      const operatorData = Array.isArray(v.operators) ? v.operators[0] : v.operators
      vehicleMap.set(v.id, {
        plateNumber: v.plate_number || '',
        operatorId: v.operator_id || null,
        operatorName: operatorData?.name || null,
        operatorCode: operatorData?.code || null,
      })
    })

    const driverMap = new Map<string, string>()
    driversResult.data?.forEach((d: any) => {
      driverMap.set(d.id, d.full_name || '')
    })

    const routeMap = new Map<string, any>()
    routesResult.data?.forEach((r: any) => {
      const destData = Array.isArray(r.destination) ? r.destination[0] : r.destination
      routeMap.set(r.id, {
        name: r.route_name || null,
        type: r.route_type || null,
        destinationId: destData?.id || null,
        destinationName: destData?.name || null,
        destinationCode: destData?.code || null,
      })
    })

    const userMap = new Map<string, string>()
    usersResult.data?.forEach((u: any) => {
      userMap.set(u.id, u.full_name || '')
    })

    console.log(`   Vehicles: ${vehicleMap.size}`)
    console.log(`   Drivers: ${driverMap.size}`)
    console.log(`   Routes: ${routeMap.size}`)
    console.log(`   Users: ${userMap.size}`)
    console.log('')

    // Step 3: Process records in batches
    const batchSize = 50
    const totalBatches = Math.ceil(stats.total / batchSize)
    console.log(`🔄 Processing ${stats.total} records in ${totalBatches} batches of ${batchSize}...`)
    console.log('')

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * batchSize
      const endIdx = Math.min(startIdx + batchSize, stats.total)
      const batch = records.slice(startIdx, endIdx)

      const batchPromises = batch.map(async (record: any) => {
        try {
          // Check if record already has denormalized data
          if (record.vehicle_plate_number && record.driver_full_name) {
            stats.skipped++
            return
          }

          // Get related data from lookup maps
          const vehicle = vehicleMap.get(record.vehicle_id)
          const driver = driverMap.get(record.driver_id)
          const route = record.route_id ? routeMap.get(record.route_id) : null

          // Build update object with denormalized fields
          const updateData: Record<string, any> = {
            // Vehicle denormalized data
            vehicle_plate_number: vehicle?.plateNumber || '',
            vehicle_operator_id: vehicle?.operatorId || null,
            vehicle_operator_name: vehicle?.operatorName || null,
            vehicle_operator_code: vehicle?.operatorCode || null,

            // Driver denormalized data
            driver_full_name: driver || '',

            // Route denormalized data
            route_name: route?.name || null,
            route_type: route?.type || null,
            route_destination_id: route?.destinationId || null,
            route_destination_name: route?.destinationName || null,
            route_destination_code: route?.destinationCode || null,

            // User denormalized data (audit trail)
            entry_by_name: record.entry_by ? userMap.get(record.entry_by) || null : null,
            passenger_drop_by_name: record.passenger_drop_by ? userMap.get(record.passenger_drop_by) || null : null,
            boarding_permit_by_name: record.boarding_permit_by ? userMap.get(record.boarding_permit_by) || null : null,
            payment_by_name: record.payment_by ? userMap.get(record.payment_by) || null : null,
            departure_order_by_name: record.departure_order_by ? userMap.get(record.departure_order_by) || null : null,
            exit_by_name: record.exit_by ? userMap.get(record.exit_by) || null : null,
          }

          // Update record in Firebase
          await firebaseDb.update(`dispatch_records/${record.id}`, updateData)
          stats.processed++
        } catch (err) {
          console.error(`   ❌ Failed to migrate record ${record.id}:`, err)
          stats.failed++
        }
      })

      await Promise.all(batchPromises)

      // Progress update
      const progress = ((endIdx / stats.total) * 100).toFixed(1)
      const elapsed = ((Date.now() - stats.startTime) / 1000).toFixed(1)
      console.log(`   Batch ${batchIndex + 1}/${totalBatches} complete [${progress}%] - ${elapsed}s elapsed`)
    }

    // Final summary
    console.log('')
    console.log('═══════════════════════════════════════════════════════════════')
    console.log('  MIGRATION COMPLETE')
    console.log('═══════════════════════════════════════════════════════════════')
    console.log(`   Total records: ${stats.total}`)
    console.log(`   ✅ Processed: ${stats.processed}`)
    console.log(`   ⏭️  Skipped (already migrated): ${stats.skipped}`)
    console.log(`   ❌ Failed: ${stats.failed}`)
    console.log(`   ⏱️  Duration: ${((Date.now() - stats.startTime) / 1000).toFixed(2)}s`)
    console.log('')

    if (stats.failed > 0) {
      console.log('⚠️  Some records failed to migrate. Review logs above for details.')
    } else {
      console.log('✅ All records migrated successfully!')
    }
  } catch (error) {
    console.error('❌ Migration failed with error:', error)
    process.exit(1)
  }
}

// Run migration
console.log('')
migrateDispatchRecords()
  .then(() => {
    console.log('')
    console.log('Migration script finished.')
    process.exit(0)
  })
  .catch((err) => {
    console.error('Unhandled error:', err)
    process.exit(1)
  })
</file>

<file path="server/src/scripts/migrate-from-old-firebase.ts">
/**
 * Migration Script: Copy data from old Firebase (webbenxe) to new Firebase (benxe-management-20251218)
 *
 * Usage:
 *   1. Place the old Firebase service account JSON file as: ./webbenxe-firebase-adminsdk.json
 *   2. Ensure new Firebase service account is configured in .env (SERVICE_ACCOUNT_PATH)
 *   3. Run: npx tsx src/scripts/migrate-from-old-firebase.ts
 *
 * Data paths to migrate:
 *   - datasheet/PHUHIEUXE (vehicle badges - ~10,000 records)
 *   - users (if needed)
 */

import { initializeApp, cert, App, deleteApp } from 'firebase-admin/app'
import { getDatabase, Database } from 'firebase-admin/database'
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Configuration
const CONFIG = {
  // Old Firebase (source)
  OLD_DATABASE_URL: 'https://webbenxe-default-rtdb.asia-southeast1.firebasedatabase.app/',
  OLD_SERVICE_ACCOUNT_PATH: './webbenxe-firebase-adminsdk.json',

  // New Firebase (destination) - uses .env config
  NEW_DATABASE_URL: process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/',
  NEW_SERVICE_ACCOUNT_PATH: process.env.SERVICE_ACCOUNT_PATH || './benxe-management-20251218-firebase-adminsdk.json',

  // Data paths to migrate
  PATHS_TO_MIGRATE: [
    'datasheet/PHUHIEUXE',  // Vehicle badges (~10,000 records)
    // 'users',              // Uncomment if you want to migrate users too
  ],

  // Batch size for writing (to avoid timeout)
  BATCH_SIZE: 500,
}

let oldApp: App | null = null
let newApp: App | null = null
let oldDb: Database | null = null
let newDb: Database | null = null

/**
 * Initialize Firebase apps
 */
async function initializeFirebaseApps(): Promise<void> {
  console.log('🔧 Initializing Firebase apps...\n')

  // Check if old service account exists
  const oldServiceAccountPath = resolve(process.cwd(), CONFIG.OLD_SERVICE_ACCOUNT_PATH)
  if (!existsSync(oldServiceAccountPath)) {
    throw new Error(`
❌ Old Firebase service account not found!

Please download the service account JSON from Firebase Console:
1. Go to: https://console.firebase.google.com/project/webbenxe/settings/serviceaccounts/adminsdk
2. Click "Generate new private key"
3. Save the file as: ${oldServiceAccountPath}
`)
  }

  // Check if new service account exists
  const newServiceAccountPath = resolve(process.cwd(), CONFIG.NEW_SERVICE_ACCOUNT_PATH)
  if (!existsSync(newServiceAccountPath)) {
    throw new Error(`
❌ New Firebase service account not found!

Please ensure SERVICE_ACCOUNT_PATH in .env points to a valid service account JSON file.
Expected path: ${newServiceAccountPath}
`)
  }

  // Initialize old Firebase app
  const oldServiceAccount = JSON.parse(readFileSync(oldServiceAccountPath, 'utf-8'))
  oldApp = initializeApp({
    credential: cert(oldServiceAccount),
    databaseURL: CONFIG.OLD_DATABASE_URL
  }, 'old-firebase')
  oldDb = getDatabase(oldApp)
  console.log(`✅ Connected to OLD Firebase: ${CONFIG.OLD_DATABASE_URL}`)

  // Initialize new Firebase app
  const newServiceAccount = JSON.parse(readFileSync(newServiceAccountPath, 'utf-8'))
  newApp = initializeApp({
    credential: cert(newServiceAccount),
    databaseURL: CONFIG.NEW_DATABASE_URL
  }, 'new-firebase')
  newDb = getDatabase(newApp)
  console.log(`✅ Connected to NEW Firebase: ${CONFIG.NEW_DATABASE_URL}`)
  console.log('')
}

/**
 * Cleanup Firebase apps
 */
async function cleanupFirebaseApps(): Promise<void> {
  if (oldApp) {
    await deleteApp(oldApp)
  }
  if (newApp) {
    await deleteApp(newApp)
  }
}

/**
 * Count records in a path
 */
async function countRecords(db: Database, path: string): Promise<number> {
  const snapshot = await db.ref(path).once('value')
  const data = snapshot.val()
  if (!data) return 0
  return Object.keys(data).length
}

/**
 * Migrate data from one path
 */
async function migratePath(path: string): Promise<{ success: number; failed: number }> {
  console.log(`\n📦 Migrating: ${path}`)
  console.log('─'.repeat(50))

  // Read from old database
  console.log('   Reading from old database...')
  const snapshot = await oldDb!.ref(path).once('value')
  const data = snapshot.val()

  if (!data) {
    console.log('   ⚠️  No data found at this path')
    return { success: 0, failed: 0 }
  }

  const keys = Object.keys(data)
  const totalRecords = keys.length
  console.log(`   Found ${totalRecords.toLocaleString()} records`)

  // Write to new database in batches
  let success = 0
  let failed = 0
  const totalBatches = Math.ceil(keys.length / CONFIG.BATCH_SIZE)

  for (let i = 0; i < keys.length; i += CONFIG.BATCH_SIZE) {
    const batchNum = Math.floor(i / CONFIG.BATCH_SIZE) + 1
    const batchKeys = keys.slice(i, i + CONFIG.BATCH_SIZE)
    const batchData: Record<string, any> = {}

    for (const key of batchKeys) {
      batchData[key] = data[key]
    }

    try {
      // Use update to merge data (won't overwrite existing data at other keys)
      await newDb!.ref(path).update(batchData)
      success += batchKeys.length

      const progress = ((i + batchKeys.length) / totalRecords * 100).toFixed(1)
      console.log(`   ✅ Batch ${batchNum}/${totalBatches}: ${batchKeys.length} records (${progress}% complete)`)
    } catch (error: any) {
      failed += batchKeys.length
      console.error(`   ❌ Batch ${batchNum}/${totalBatches} failed: ${error.message}`)
    }

    // Small delay to avoid rate limiting
    if (i + CONFIG.BATCH_SIZE < keys.length) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }

  console.log(`   📊 Result: ${success.toLocaleString()} success, ${failed.toLocaleString()} failed`)
  return { success, failed }
}

/**
 * Verify migration
 */
async function verifyMigration(path: string): Promise<boolean> {
  const oldCount = await countRecords(oldDb!, path)
  const newCount = await countRecords(newDb!, path)

  console.log(`   🔍 Verification: Old=${oldCount.toLocaleString()}, New=${newCount.toLocaleString()}`)

  if (oldCount === newCount) {
    console.log(`   ✅ Counts match!`)
    return true
  } else {
    console.log(`   ⚠️  Counts don't match - some records may have been skipped`)
    return false
  }
}

/**
 * Main migration function
 */
async function main(): Promise<void> {
  console.log('═'.repeat(60))
  console.log('🚀 FIREBASE DATA MIGRATION')
  console.log('   From: webbenxe (old)')
  console.log('   To:   benxe-management-20251218 (new)')
  console.log('═'.repeat(60))
  console.log('')

  try {
    // Initialize Firebase apps
    await initializeFirebaseApps()

    // Show what will be migrated
    console.log('📋 Paths to migrate:')
    for (const path of CONFIG.PATHS_TO_MIGRATE) {
      const count = await countRecords(oldDb!, path)
      console.log(`   - ${path}: ${count.toLocaleString()} records`)
    }
    console.log('')

    // Confirm before proceeding
    console.log('⏳ Starting migration in 3 seconds... (Ctrl+C to cancel)')
    await new Promise(resolve => setTimeout(resolve, 3000))

    // Migrate each path
    const results: Record<string, { success: number; failed: number }> = {}

    for (const path of CONFIG.PATHS_TO_MIGRATE) {
      results[path] = await migratePath(path)
      await verifyMigration(path)
    }

    // Summary
    console.log('\n' + '═'.repeat(60))
    console.log('📊 MIGRATION SUMMARY')
    console.log('═'.repeat(60))

    let totalSuccess = 0
    let totalFailed = 0

    for (const path of CONFIG.PATHS_TO_MIGRATE) {
      const result = results[path]
      totalSuccess += result.success
      totalFailed += result.failed
      console.log(`   ${path}: ${result.success.toLocaleString()} success, ${result.failed.toLocaleString()} failed`)
    }

    console.log('─'.repeat(60))
    console.log(`   TOTAL: ${totalSuccess.toLocaleString()} success, ${totalFailed.toLocaleString()} failed`)
    console.log('')

    if (totalFailed === 0) {
      console.log('✅ Migration completed successfully!')
    } else {
      console.log('⚠️  Migration completed with some failures. Please check the logs.')
    }

  } catch (error: any) {
    console.error('\n❌ Migration failed:', error.message)
    process.exit(1)
  } finally {
    await cleanupFirebaseApps()
  }
}

// Run migration
main()
</file>

<file path="server/src/scripts/migrate-old-rtdb-to-firestore.ts">
/**
 * Migration Script: Old Firebase RTDB to New RTDB
 * 
 * Migrates data from webbenxe-default-rtdb to benxe-management-20251218-default-rtdb:
 * - datasheet/Xe -> datasheet/Xe
 * - datasheet/DANHMUCTUYENCODINH -> datasheet/DANHMUCTUYENCODINH
 * 
 * Uses REST API to read from old RTDB and Firebase Admin SDK to write to new RTDB
 * 
 * Run with: npx tsx src/scripts/migrate-old-rtdb-to-firestore.ts
 * 
 * Optional flags:
 * --dry-run    (simulate without writing)
 * --xe-only    (migrate only Xe)
 * --tuyen-only (migrate only DANHMUCTUYENCODINH)
 */

import { initializeApp, getApps, cert, App } from 'firebase-admin/app'
import { getDatabase, Database } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Old RTDB URL (REST API - source)
const OLD_RTDB_REST_URL = 'https://webbenxe-default-rtdb.asia-southeast1.firebasedatabase.app'

// New RTDB URL (target)
const NEW_RTDB_URL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'

// Service account path
const SERVICE_ACCOUNT_PATH = process.env.SERVICE_ACCOUNT_PATH

let app: App | null = null
let newDb: Database | null = null

// Initialize Firebase for new RTDB (target database)
function initializeNewRTDB() {
  if (app) return

  if (!getApps().length) {
    if (SERVICE_ACCOUNT_PATH) {
      const absolutePath = resolve(process.cwd(), SERVICE_ACCOUNT_PATH)
      const serviceAccount = JSON.parse(readFileSync(absolutePath, 'utf-8'))
      app = initializeApp({
        credential: cert(serviceAccount),
        databaseURL: NEW_RTDB_URL
      })
    } else {
      app = initializeApp({
        databaseURL: NEW_RTDB_URL
      })
    }
  } else {
    app = getApps()[0]
  }

  newDb = getDatabase(app)
}

// Fetch data from old RTDB using REST API
async function fetchFromOldRTDB(path: string): Promise<any> {
  const url = `${OLD_RTDB_REST_URL}/${path}.json`
  console.log(`    Fetching from ${url}...`)
  
  const response = await fetch(url)
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }
  
  return response.json()
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2)
  return {
    dryRun: args.includes('--dry-run'),
    xeOnly: args.includes('--xe-only'),
    tuyenOnly: args.includes('--tuyen-only'),
  }
}

// Transform Xe data - based on actual field names from old RTDB
function transformXe(key: string, data: any) {
  if (!data) return null // Skip null records
  
  return {
    id: key,
    plate_number: data.BienSo || '',
    vehicle_type: data.LoaiXe || '',
    vehicle_category: data.LoaiPhuongTien || '',
    seat_count: parseInt(data.SoCho || '0', 10) || 0,
    load_capacity: parseFloat(data.TaiTrong || '0') || 0,
    manufacturer: data.NhanHieu || '',
    manufacture_year: parseInt(data.NamSanXuat || '0', 10) || 0,
    color: data.MauSon || '',
    engine_number: data.SoMay || '',
    chassis_number: data.SoKhung || '',
    owner_name: data.TenDangKyXe || '',
    owner_address: data.DiaChiChuXe || '',
    has_transport_business: data.CoKDVT || '',
    is_identified_plate: data.LaBienDinhDanh || '',
    identified_plate_status: data.TrangThaiBienDinhDanh || '',
    identified_plate_revoke_reason: data.LyDoThuBienDinhDanh || '',
    validity_years: data.NienHan || data.Nienhan || '',
    import_time: data.ThoiGianNhap || '',
    registration_info: data.ThongTinDangKyXe || '',
    import_status: data.Column_26 || '',
    user: data.User || '',
    internal_id: data.IDXe || '',
    // Keep original data for reference
    _original: data,
    _migrated_at: new Date().toISOString(),
    _source: 'webbenxe-default-rtdb/datasheet/Xe'
  }
}

// Transform DANHMUCTUYENCODINH data - based on actual field names from old RTDB
function transformTuyen(key: string, data: any) {
  if (!data) return null // Skip null records
  
  return {
    id: key,
    route_code: data.MaSoTuyen || '',
    route_code_old: data.MaSoTuyen_Cu || '',
    route_code_fixed: data.MaSoTuyen_Fix || '',
    route_type: data.PhanLoaiTuyen || '',
    departure_station: data.BenDi || '',
    departure_station_ref: data.BenDi_Ref || '',
    departure_province: data.TinhDi || '',
    departure_province_old: data.TinhDi_Cu || '',
    arrival_station: data.BenDen || '',
    arrival_station_ref: data.BenDen_Ref || '',
    arrival_province: data.TinhDen || '',
    arrival_province_old: data.TinhDen_Cu || '',
    route_path: data.HanhTrinh || '',
    distance_km: parseFloat(data.CuLyTuyen_km || '0') || 0,
    min_interval_minutes: parseInt(data.GianCachToiThieu_phut || '0', 10) || 0,
    total_trips_month: parseInt(data.TongChuyenThang || '0', 10) || 0,
    trips_in_operation: parseInt(data.ChuyenDaKhaiThac || '0', 10) || 0,
    remaining_capacity: parseInt(data.LuuLuongConLai || '0', 10) || 0,
    operation_status: data.TinhTrangKhaiThac || '',
    decision_number: data.SoQuyetDinh || '',
    decision_date: data.NgayBanHanh || '',
    issuing_authority: data.DonViBanHanh || '',
    calendar_type: data.Kieulich || '',
    file_path: data.File || '',
    notes: data.Ghichu || '',
    original_info: data.ThongTinTuyenGoc || '',
    import_time: data.ThoiGianNhap || '',
    user: data.User || '',
    // Province codes
    departure_province_code_new: data.TinhdiN || '',
    departure_province_code_old: data.TinhdiO || '',
    arrival_province_code_new: data.TinhdenN || '',
    arrival_province_code_old: data.TinhdenO || '',
    departure_station_code_new: data.BendiN || '',
    departure_station_code_old: data.BendiO || '',
    arrival_station_code_new: data.BendenN || '',
    arrival_station_code_old: data.BendenO || '',
    province_code_fo: data.TinhdenFO || '',
    route_class: data.MaO || '',
    // Keep original data for reference
    _original: data,
    _migrated_at: new Date().toISOString(),
    _source: 'webbenxe-default-rtdb/datasheet/DANHMUCTUYENCODINH'
  }
}

// Migrate a collection
async function migrateCollection(
  rtdbPath: string,
  targetPath: string,
  transformer: (key: string, data: any) => any,
  dryRun: boolean
) {
  console.log(`\n  Migrating: ${rtdbPath} -> ${targetPath}`)
  
  const stats = { total: 0, migrated: 0, skipped: 0, failed: 0, errors: [] as string[] }

  try {
    // Fetch from old RTDB via REST API
    const data = await fetchFromOldRTDB(rtdbPath)

    if (!data) {
      console.log(`    No data found`)
      return stats
    }

    const keys = Object.keys(data)
    stats.total = keys.length
    console.log(`    Found ${stats.total} records`)

    // Filter out null records
    const validKeys = keys.filter(k => data[k] !== null)
    const nullCount = keys.length - validKeys.length
    if (nullCount > 0) {
      console.log(`    Skipping ${nullCount} null records`)
    }
    stats.total = validKeys.length

    if (dryRun) {
      console.log(`    [DRY RUN] Would migrate ${stats.total} valid records`)
      // Show sample data
      const sampleKey = validKeys[0]
      if (sampleKey) {
        console.log(`    Sample record (${sampleKey}):`)
        const sample = transformer(sampleKey, data[sampleKey])
        console.log(JSON.stringify(sample, null, 2).split('\n').slice(0, 20).join('\n'))
      }
      stats.migrated = stats.total
      return stats
    }

    // Check what already exists in target
    console.log(`    Checking existing data in target...`)
    const existingSnap = await newDb!.ref(targetPath).once('value')
    const existingData = existingSnap.val() || {}
    const existingKeys = new Set(Object.keys(existingData))
    
    // Filter keys that don't exist yet
    const keysToMigrate = validKeys.filter(k => !existingKeys.has(k))
    stats.skipped = validKeys.length - keysToMigrate.length
    
    if (stats.skipped > 0) {
      console.log(`    Skipping ${stats.skipped} existing records`)
    }
    
    if (keysToMigrate.length === 0) {
      console.log(`    All records already exist, nothing to migrate`)
      return stats
    }

    // Write to new RTDB in batches
    const batchSize = 1000
    const totalBatches = Math.ceil(keysToMigrate.length / batchSize)

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * batchSize
      const endIdx = Math.min(startIdx + batchSize, keysToMigrate.length)
      const batchKeys = keysToMigrate.slice(startIdx, endIdx)

      // Build batch update object
      const updates: Record<string, any> = {}

      for (const key of batchKeys) {
        try {
          const transformed = transformer(key, data[key])
          if (transformed) {
            updates[key] = transformed
            stats.migrated++
          }
        } catch (err: any) {
          stats.failed++
          stats.errors.push(`${key}: ${err.message}`)
        }
      }

      // Write batch to RTDB
      if (Object.keys(updates).length > 0) {
        await newDb!.ref(targetPath).update(updates)
      }

      const progress = (((batchIndex + 1) / totalBatches) * 100).toFixed(1)
      process.stdout.write(`\r    Progress: ${progress}% (${stats.migrated} migrated, ${stats.skipped} skipped, ${stats.failed} failed)`)
    }

    console.log() // New line
  } catch (error: any) {
    console.error(`    Error: ${error.message}`)
    stats.errors.push(`Collection error: ${error.message}`)
  }

  return stats
}

// Main
async function main() {
  const { dryRun, xeOnly, tuyenOnly } = parseArgs()

  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  OLD RTDB TO FIRESTORE MIGRATION')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')
  console.log(`  Source: ${OLD_RTDB_REST_URL}`)
  console.log(`  Target: ${NEW_RTDB_URL}`)
  console.log(`  Mode: ${dryRun ? 'DRY RUN (no writes)' : 'LIVE MIGRATION'}`)
  console.log('')

  initializeNewRTDB()

  const startTime = Date.now()
  const allStats = []

  // Migrate Xe
  if (!tuyenOnly) {
    const xeStats = await migrateCollection(
      'datasheet/Xe',
      'datasheet/Xe',
      transformXe,
      dryRun
    )
    allStats.push({ name: 'datasheet/Xe', ...xeStats })
  }

  // Migrate DANHMUCTUYENCODINH
  if (!xeOnly) {
    const tuyenStats = await migrateCollection(
      'datasheet/DANHMUCTUYENCODINH',
      'datasheet/DANHMUCTUYENCODINH',
      transformTuyen,
      dryRun
    )
    allStats.push({ name: 'datasheet/DANHMUCTUYENCODINH', ...tuyenStats })
  }

  // Summary
  const duration = ((Date.now() - startTime) / 1000).toFixed(2)

  console.log('')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  MIGRATION SUMMARY')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')

  for (const stats of allStats) {
    console.log(`  ${stats.name}`)
    console.log(`    Total: ${stats.total} | Migrated: ${stats.migrated} | Skipped: ${stats.skipped} | Failed: ${stats.failed}`)
    if (stats.errors.length > 0) {
      console.log(`    Errors: ${stats.errors.slice(0, 3).join(', ')}`)
    }
    console.log('')
  }

  console.log(`  Duration: ${duration}s`)
  console.log('')

  if (dryRun) {
    console.log('  Dry run complete. Run without --dry-run to perform actual migration.')
  } else {
    console.log('  Migration completed!')
  }
}

main()
  .then(() => process.exit(0))
  .catch(err => {
    console.error('Error:', err)
    process.exit(1)
  })
</file>

<file path="server/src/scripts/migrate-rtdb-to-firestore.ts">
/**
 * Migration Script: Firebase Realtime Database to Cloud Firestore
 *
 * This script migrates all data from RTDB to Firestore while:
 * - Preserving document IDs
 * - Applying data transformations where needed
 * - Providing progress updates and error handling
 * - Supporting resume from failures
 *
 * Run with: npx tsx src/scripts/migrate-rtdb-to-firestore.ts
 *
 * Optional flags:
 * --collections=dispatch_records,vehicles  (migrate specific collections)
 * --dry-run                                 (simulate without writing)
 * --batch-size=100                          (custom batch size)
 */

import { firebaseDb } from '../config/database.js'
import { getFirestoreInstance } from '../config/firestore.js'

// Collections to migrate
const COLLECTIONS = [
  'users',
  'operators',
  'locations',
  'vehicles',
  'drivers',
  'driver_operators',
  'routes',
  'route_stops',
  'schedules',
  'dispatch_records',
]

// Migration configuration
interface MigrationConfig {
  batchSize: number
  dryRun: boolean
  collections: string[]
}

// Migration statistics
interface MigrationStats {
  collection: string
  total: number
  migrated: number
  failed: number
  skipped: number
  errors: string[]
}

// Data transformers for specific collections
const dataTransformers: Record<string, (data: any) => any> = {
  // Transform dispatch_records to ensure proper field names
  dispatch_records: (data: any) => ({
    ...data,
    // Ensure denormalized fields exist (from Phase 1)
    vehicle_plate_number: data.vehicle_plate_number || '',
    vehicle_operator_id: data.vehicle_operator_id || null,
    vehicle_operator_name: data.vehicle_operator_name || null,
    vehicle_operator_code: data.vehicle_operator_code || null,
    driver_full_name: data.driver_full_name || '',
    route_name: data.route_name || null,
    route_type: data.route_type || null,
    route_destination_id: data.route_destination_id || null,
    route_destination_name: data.route_destination_name || null,
    route_destination_code: data.route_destination_code || null,
    // Ensure status field
    status: data.status || 'entered',
  }),

  // Ensure vehicles have required fields
  vehicles: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
    vehicle_type: data.vehicle_type || 'bus',
  }),

  // Ensure drivers have required fields
  drivers: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
  }),

  // Ensure routes have required fields
  routes: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
  }),

  // Ensure operators have required fields
  operators: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
  }),

  // Ensure locations have required fields
  locations: (data: any) => ({
    ...data,
    type: data.type || 'station',
  }),

  // Ensure users have required fields
  users: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
    role: data.role || 'user',
  }),

  // Ensure schedules have required fields
  schedules: (data: any) => ({
    ...data,
    is_active: data.is_active !== false,
  }),
}

// Parse command line arguments
function parseArgs(): MigrationConfig {
  const args = process.argv.slice(2)
  const config: MigrationConfig = {
    batchSize: 100,
    dryRun: false,
    collections: [...COLLECTIONS],
  }

  for (const arg of args) {
    if (arg === '--dry-run') {
      config.dryRun = true
    } else if (arg.startsWith('--batch-size=')) {
      config.batchSize = parseInt(arg.split('=')[1], 10)
    } else if (arg.startsWith('--collections=')) {
      config.collections = arg.split('=')[1].split(',')
    }
  }

  return config
}

// Migrate a single collection
async function migrateCollection(
  collectionName: string,
  config: MigrationConfig
): Promise<MigrationStats> {
  const stats: MigrationStats = {
    collection: collectionName,
    total: 0,
    migrated: 0,
    failed: 0,
    skipped: 0,
    errors: [],
  }

  console.log(`\n  Migrating: ${collectionName}`)

  try {
    // Fetch all data from RTDB
    const rtdbData = await firebaseDb.get(collectionName)

    if (!rtdbData) {
      console.log(`    No data found in RTDB`)
      return stats
    }

    // Convert to array
    const records = Object.entries(rtdbData).map(([id, data]: [string, any]) => ({
      id,
      ...data,
    }))

    stats.total = records.length
    console.log(`    Found ${stats.total} records`)

    if (config.dryRun) {
      console.log(`    [DRY RUN] Would migrate ${stats.total} records`)
      stats.migrated = stats.total
      return stats
    }

    // Get Firestore instance
    const db = getFirestoreInstance()
    const collectionRef = db.collection(collectionName)

    // Get transformer for this collection
    const transformer = dataTransformers[collectionName] || ((d: any) => d)

    // Process in batches
    const totalBatches = Math.ceil(records.length / config.batchSize)

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * config.batchSize
      const endIdx = Math.min(startIdx + config.batchSize, records.length)
      const batchRecords = records.slice(startIdx, endIdx)

      const batch = db.batch()

      for (const record of batchRecords) {
        try {
          // Check if document already exists in Firestore
          const existingDoc = await collectionRef.doc(record.id).get()

          if (existingDoc.exists) {
            stats.skipped++
            continue
          }

          // Transform data
          const transformedData = transformer(record)

          // Add to batch
          batch.set(collectionRef.doc(record.id), transformedData)
          stats.migrated++
        } catch (err: any) {
          stats.failed++
          stats.errors.push(`${record.id}: ${err.message}`)
        }
      }

      // Commit batch
      await batch.commit()

      // Progress update
      const progress = (((batchIndex + 1) / totalBatches) * 100).toFixed(1)
      process.stdout.write(`\r    Progress: ${progress}% (${stats.migrated} migrated, ${stats.skipped} skipped, ${stats.failed} failed)`)
    }

    console.log() // New line after progress
  } catch (error: any) {
    console.error(`    Error: ${error.message}`)
    stats.errors.push(`Collection error: ${error.message}`)
  }

  return stats
}

// Main migration function
async function runMigration() {
  const config = parseArgs()

  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  RTDB TO FIRESTORE MIGRATION')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')
  console.log(`  Mode: ${config.dryRun ? 'DRY RUN (no writes)' : 'LIVE MIGRATION'}`)
  console.log(`  Batch size: ${config.batchSize}`)
  console.log(`  Collections: ${config.collections.join(', ')}`)
  console.log('')

  const startTime = Date.now()
  const allStats: MigrationStats[] = []

  // Migrate each collection
  for (const collection of config.collections) {
    if (!COLLECTIONS.includes(collection)) {
      console.log(`  Skipping unknown collection: ${collection}`)
      continue
    }

    const stats = await migrateCollection(collection, config)
    allStats.push(stats)
  }

  // Summary
  const duration = ((Date.now() - startTime) / 1000).toFixed(2)
  const totalMigrated = allStats.reduce((sum, s) => sum + s.migrated, 0)
  const totalSkipped = allStats.reduce((sum, s) => sum + s.skipped, 0)
  const totalFailed = allStats.reduce((sum, s) => sum + s.failed, 0)

  console.log('')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  MIGRATION SUMMARY')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')

  // Table header
  console.log('  Collection            | Total | Migrated | Skipped | Failed')
  console.log('  ----------------------|-------|----------|---------|-------')

  // Table rows
  for (const stats of allStats) {
    const name = stats.collection.padEnd(20)
    const total = String(stats.total).padStart(5)
    const migrated = String(stats.migrated).padStart(8)
    const skipped = String(stats.skipped).padStart(7)
    const failed = String(stats.failed).padStart(6)
    console.log(`  ${name} | ${total} | ${migrated} | ${skipped} | ${failed}`)
  }

  console.log('  ----------------------|-------|----------|---------|-------')

  // Totals
  const totalRecords = allStats.reduce((sum, s) => sum + s.total, 0)
  console.log(`  ${'TOTAL'.padEnd(20)} | ${String(totalRecords).padStart(5)} | ${String(totalMigrated).padStart(8)} | ${String(totalSkipped).padStart(7)} | ${String(totalFailed).padStart(6)}`)

  console.log('')
  console.log(`  Duration: ${duration}s`)
  console.log('')

  // Errors
  const allErrors = allStats.flatMap(s => s.errors)
  if (allErrors.length > 0) {
    console.log('  ERRORS:')
    allErrors.slice(0, 10).forEach(err => console.log(`    - ${err}`))
    if (allErrors.length > 10) {
      console.log(`    ... and ${allErrors.length - 10} more errors`)
    }
    console.log('')
  }

  if (totalFailed > 0) {
    console.log('  Some records failed to migrate. Review errors above.')
    process.exit(1)
  } else if (config.dryRun) {
    console.log('  Dry run complete. Run without --dry-run to perform actual migration.')
  } else {
    console.log('  Migration completed successfully!')
  }
}

// Run migration
console.log('')
runMigration()
  .then(() => {
    console.log('')
    console.log('Migration script finished.')
    process.exit(0)
  })
  .catch((err) => {
    console.error('Unhandled error:', err)
    process.exit(1)
  })
</file>

<file path="server/src/scripts/migrate-vehicle-badges.ts">
/**
 * Migrate Vehicle Badges from old Firebase (public) to new Firebase
 *
 * Old Firebase has public rules, so we can fetch directly via REST API.
 *
 * Usage:
 *   npx tsx src/scripts/migrate-vehicle-badges.ts
 */

import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Configuration
const CONFIG = {
  // Old Firebase (public access)
  OLD_DATABASE_URL: 'https://webbenxe-default-rtdb.asia-southeast1.firebasedatabase.app',
  SOURCE_PATH: 'datasheet/PHUHIEUXE',

  // New Firebase
  NEW_DATABASE_URL: process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/',
  SERVICE_ACCOUNT_PATH: process.env.SERVICE_ACCOUNT_PATH || './benxe-management-20251218-firebase-adminsdk.json',
  DESTINATION_PATH: 'datasheet/PHUHIEUXE',

  // Batch size
  BATCH_SIZE: 500,
}

async function main() {
  console.log('='.repeat(60))
  console.log('MIGRATE VEHICLE BADGES')
  console.log('From: webbenxe (public)')
  console.log('To:   benxe-management-20251218')
  console.log('='.repeat(60))
  console.log('')

  // Step 1: Fetch from old Firebase (public REST API)
  const sourceUrl = `${CONFIG.OLD_DATABASE_URL}/${CONFIG.SOURCE_PATH}.json`
  console.log(`Fetching from: ${sourceUrl}`)
  console.log('Please wait...')
  console.log('')

  const response = await fetch(sourceUrl)

  if (!response.ok) {
    console.error(`Failed to fetch: ${response.status} ${response.statusText}`)
    process.exit(1)
  }

  const data = await response.json() as Record<string, any>

  if (!data) {
    console.log('No data found!')
    process.exit(1)
  }

  const keys = Object.keys(data)
  console.log(`Found ${keys.length.toLocaleString()} records`)
  console.log('')

  // Step 2: Connect to new Firebase
  const serviceAccountPath = resolve(process.cwd(), CONFIG.SERVICE_ACCOUNT_PATH)
  if (!existsSync(serviceAccountPath)) {
    console.error(`Service account not found: ${serviceAccountPath}`)
    console.log('Please check SERVICE_ACCOUNT_PATH in .env')
    process.exit(1)
  }

  if (!getApps().length) {
    const serviceAccount = JSON.parse(readFileSync(serviceAccountPath, 'utf-8'))
    initializeApp({
      credential: cert(serviceAccount),
      databaseURL: CONFIG.NEW_DATABASE_URL
    })
  }

  const db = getDatabase()
  console.log(`Connected to: ${CONFIG.NEW_DATABASE_URL}`)
  console.log(`Destination: ${CONFIG.DESTINATION_PATH}`)
  console.log('')

  // Step 3: Import in batches
  console.log('Starting import...')
  console.log('-'.repeat(60))

  let success = 0
  let failed = 0
  const totalBatches = Math.ceil(keys.length / CONFIG.BATCH_SIZE)

  for (let i = 0; i < keys.length; i += CONFIG.BATCH_SIZE) {
    const batchNum = Math.floor(i / CONFIG.BATCH_SIZE) + 1
    const batchKeys = keys.slice(i, i + CONFIG.BATCH_SIZE)
    const batchData: Record<string, any> = {}

    for (const key of batchKeys) {
      batchData[key] = data[key]
    }

    try {
      await db.ref(CONFIG.DESTINATION_PATH).update(batchData)
      success += batchKeys.length

      const progress = ((i + batchKeys.length) / keys.length * 100).toFixed(1)
      console.log(`Batch ${batchNum}/${totalBatches}: ${batchKeys.length} records (${progress}%)`)
    } catch (error: any) {
      failed += batchKeys.length
      console.error(`Batch ${batchNum} FAILED: ${error.message}`)
    }

    // Small delay to avoid rate limiting
    if (i + CONFIG.BATCH_SIZE < keys.length) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }

  // Summary
  console.log('')
  console.log('='.repeat(60))
  console.log('RESULT')
  console.log('='.repeat(60))
  console.log(`Success: ${success.toLocaleString()}`)
  console.log(`Failed: ${failed.toLocaleString()}`)
  console.log('')

  // Verify
  console.log('Verifying...')
  const snapshot = await db.ref(CONFIG.DESTINATION_PATH).once('value')
  const newData = snapshot.val()
  const newCount = newData ? Object.keys(newData).length : 0
  console.log(`Old database: ${keys.length.toLocaleString()} records`)
  console.log(`New database: ${newCount.toLocaleString()} records`)
  console.log('')

  if (newCount >= keys.length) {
    console.log('Migration completed successfully!')
  } else {
    console.log('Warning: Some records may be missing')
  }

  process.exit(0)
}

main().catch(error => {
  console.error('Error:', error)
  process.exit(1)
})
</file>

<file path="server/src/scripts/restore-operators.ts">
import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

const serviceAccount = JSON.parse(readFileSync(resolve(process.cwd(), process.env.SERVICE_ACCOUNT_PATH!), 'utf-8'))

if (!getApps().length) {
  initializeApp({
    credential: cert(serviceAccount),
    databaseURL: process.env.RTDB_URL
  })
}
const db = getDatabase()

const now = () => new Date().toISOString()
const generateId = () => Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 12)

const operators = [
  {
    id: generateId(),
    name: 'Công ty CP Xe khách Phương Trang',
    code: 'FUTA',
    tax_code: '0301234567',
    phone: '19006067',
    email: 'lienhe@futabus.vn',
    address: '80 Trần Hưng Đạo, Q.1, TP.HCM',
    province: 'TP. Hồ Chí Minh',
    district: 'Quận 1',
    representative_name: 'Nguyễn Hữu Luân',
    representative_position: 'Giám đốc',
    is_ticket_delegated: false,
    is_active: true,
    created_at: now(),
    updated_at: now()
  },
  {
    id: generateId(),
    name: 'Công ty TNHH Thành Bưởi',
    code: 'THANHBUOI',
    tax_code: '0309876543',
    phone: '19006079',
    email: 'lienhe@thanhbuoi.com.vn',
    address: '266 Lê Hồng Phong, Q.5, TP.HCM',
    province: 'TP. Hồ Chí Minh',
    district: 'Quận 5',
    representative_name: 'Lê Đức Thành',
    representative_position: 'Giám đốc',
    is_ticket_delegated: false,
    is_active: true,
    created_at: now(),
    updated_at: now()
  },
  {
    id: generateId(),
    name: 'Công ty TNHH Vận tải Kumho Samco',
    code: 'KUMHO',
    tax_code: '0305556667',
    phone: '19006065',
    email: 'lienhe@kumhosamco.com.vn',
    address: '292 Đinh Bộ Lĩnh, Q. Bình Thạnh, TP.HCM',
    province: 'TP. Hồ Chí Minh',
    district: 'Quận Bình Thạnh',
    representative_name: 'Kim Young Ho',
    representative_position: 'Tổng Giám đốc',
    is_ticket_delegated: true,
    is_active: true,
    created_at: now(),
    updated_at: now()
  },
]

async function restore() {
  console.log('Restoring operators...')
  
  // Check existing
  const existingSnap = await db.ref('operators').once('value')
  const existing = existingSnap.val()
  console.log('Existing operators:', existing ? Object.keys(existing).length : 0)
  
  // Restore
  for (const op of operators) {
    await db.ref('operators/' + op.id).set(op)
    console.log('Restored:', op.name, '(' + op.code + ')')
  }
  
  // Verify
  const afterSnap = await db.ref('operators').once('value')
  const after = afterSnap.val()
  console.log('Total operators now:', after ? Object.keys(after).length : 0)
  
  console.log('Done!')
  process.exit(0)
}

restore().catch(err => {
  console.error('Error:', err)
  process.exit(1)
})
</file>

<file path="server/src/scripts/restore-vehicle.ts">
import { initializeApp, cert, getApps } from 'firebase-admin/app'
import { getDatabase } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

const serviceAccount = JSON.parse(readFileSync(resolve(process.cwd(), process.env.SERVICE_ACCOUNT_PATH!), 'utf-8'))

if (!getApps().length) {
  initializeApp({
    credential: cert(serviceAccount),
    databaseURL: process.env.RTDB_URL
  })
}
const db = getDatabase()

const now = () => new Date().toISOString()
const generateId = () => Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 12)

async function restore() {
  console.log('Restoring vehicle 98H07480...')
  
  // Get operator ID (use FUTA for now)
  const opSnap = await db.ref('operators').orderByChild('code').equalTo('FUTA').once('value')
  const opData = opSnap.val()
  const operatorId = opData ? Object.keys(opData)[0] : null
  
  // Get vehicle type ID
  const vtSnap = await db.ref('vehicle_types').once('value')
  const vtData = vtSnap.val()
  let vehicleTypeId = null
  if (vtData) {
    for (const [key, _vt] of Object.entries(vtData)) {
      vehicleTypeId = key
      break
    }
  }
  
  const vehicle = {
    id: generateId(),
    plate_number: '98H07480',
    vehicle_type_id: vehicleTypeId,
    operator_id: operatorId,
    seat_capacity: 1,
    bed_capacity: 0,
    province: 'Bắc Giang',
    manufacturer: 'CNHTC',
    manufacture_year: 2025,
    color: 'Bạc',
    chassis_number: 'LZZ1CCND1SJ407542',
    engine_number: 'MC073150250507828527',
    owner_name: 'CÔNG TY TNHH HP BẮC GIANG',
    is_active: true,
    created_at: now(),
    updated_at: now()
  }
  
  await db.ref('vehicles/' + vehicle.id).set(vehicle)
  console.log('Restored:', vehicle.plate_number)
  console.log('ID:', vehicle.id)
  console.log('Operator ID:', operatorId)
  
  process.exit(0)
}

restore().catch(err => {
  console.error('Error:', err)
  process.exit(1)
})
</file>

<file path="server/src/scripts/rollback-firestore-to-rtdb.ts">
/**
 * Rollback Script: Cloud Firestore to Firebase Realtime Database
 *
 * This script copies data from Firestore back to RTDB in case
 * of issues during migration. It serves as a safety net.
 *
 * Run with: npx tsx src/scripts/rollback-firestore-to-rtdb.ts
 *
 * Optional flags:
 * --collections=dispatch_records,vehicles  (rollback specific collections)
 * --dry-run                                 (simulate without writing)
 * --batch-size=100                          (custom batch size)
 * --overwrite                               (overwrite existing RTDB data)
 */

import { firebaseDb } from '../config/database.js'
import { getFirestoreInstance } from '../config/firestore.js'

// Collections to rollback
const COLLECTIONS = [
  'users',
  'operators',
  'locations',
  'vehicles',
  'drivers',
  'driver_operators',
  'routes',
  'route_stops',
  'schedules',
  'dispatch_records',
]

// Configuration
interface RollbackConfig {
  batchSize: number
  dryRun: boolean
  collections: string[]
  overwrite: boolean
}

// Statistics
interface RollbackStats {
  collection: string
  total: number
  rolled: number
  skipped: number
  failed: number
  errors: string[]
}

// Parse command line arguments
function parseArgs(): RollbackConfig {
  const args = process.argv.slice(2)
  const config: RollbackConfig = {
    batchSize: 100,
    dryRun: false,
    collections: [...COLLECTIONS],
    overwrite: false,
  }

  for (const arg of args) {
    if (arg === '--dry-run') {
      config.dryRun = true
    } else if (arg === '--overwrite') {
      config.overwrite = true
    } else if (arg.startsWith('--batch-size=')) {
      config.batchSize = parseInt(arg.split('=')[1], 10)
    } else if (arg.startsWith('--collections=')) {
      config.collections = arg.split('=')[1].split(',')
    }
  }

  return config
}

// Rollback a single collection
async function rollbackCollection(
  collectionName: string,
  config: RollbackConfig
): Promise<RollbackStats> {
  const stats: RollbackStats = {
    collection: collectionName,
    total: 0,
    rolled: 0,
    skipped: 0,
    failed: 0,
    errors: [],
  }

  console.log(`\n  Rolling back: ${collectionName}`)

  try {
    // Get Firestore instance
    const firestoreDb = getFirestoreInstance()
    const collectionRef = firestoreDb.collection(collectionName)

    // Get all documents from Firestore
    const snapshot = await collectionRef.get()

    if (snapshot.empty) {
      console.log(`    No data found in Firestore`)
      return stats
    }

    stats.total = snapshot.docs.length
    console.log(`    Found ${stats.total} documents in Firestore`)

    if (config.dryRun) {
      console.log(`    [DRY RUN] Would rollback ${stats.total} documents`)
      stats.rolled = stats.total
      return stats
    }

    // Process in batches
    const docs = snapshot.docs
    const totalBatches = Math.ceil(docs.length / config.batchSize)

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * config.batchSize
      const endIdx = Math.min(startIdx + config.batchSize, docs.length)
      const batchDocs = docs.slice(startIdx, endIdx)

      for (const doc of batchDocs) {
        try {
          const id = doc.id
          const data = doc.data()

          // Check if document exists in RTDB
          if (!config.overwrite) {
            const existingData = await firebaseDb.get(`${collectionName}/${id}`)
            if (existingData) {
              stats.skipped++
              continue
            }
          }

          // Remove 'id' field from data (it's stored as key in RTDB)
          const { id: _id, ...rtdbData } = data

          // Write to RTDB
          await firebaseDb.set(`${collectionName}/${id}`, rtdbData)
          stats.rolled++
        } catch (err: any) {
          stats.failed++
          stats.errors.push(`${doc.id}: ${err.message}`)
        }
      }

      // Progress update
      const progress = (((batchIndex + 1) / totalBatches) * 100).toFixed(1)
      process.stdout.write(`\r    Progress: ${progress}% (${stats.rolled} rolled back, ${stats.skipped} skipped, ${stats.failed} failed)`)
    }

    console.log() // New line after progress
  } catch (error: any) {
    console.error(`    Error: ${error.message}`)
    stats.errors.push(`Collection error: ${error.message}`)
  }

  return stats
}

// Main rollback function
async function runRollback() {
  const config = parseArgs()

  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  FIRESTORE TO RTDB ROLLBACK')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')
  console.log(`  Mode: ${config.dryRun ? 'DRY RUN (no writes)' : 'LIVE ROLLBACK'}`)
  console.log(`  Overwrite: ${config.overwrite ? 'YES (will overwrite existing RTDB data)' : 'NO (skip existing)'}`)
  console.log(`  Batch size: ${config.batchSize}`)
  console.log(`  Collections: ${config.collections.join(', ')}`)
  console.log('')

  if (!config.dryRun) {
    console.log('  WARNING: This will write data to RTDB!')
    console.log('  Press Ctrl+C within 5 seconds to cancel...')
    await new Promise(resolve => setTimeout(resolve, 5000))
  }

  const startTime = Date.now()
  const allStats: RollbackStats[] = []

  // Rollback each collection
  for (const collection of config.collections) {
    if (!COLLECTIONS.includes(collection)) {
      console.log(`  Skipping unknown collection: ${collection}`)
      continue
    }

    const stats = await rollbackCollection(collection, config)
    allStats.push(stats)
  }

  // Summary
  const duration = ((Date.now() - startTime) / 1000).toFixed(2)
  const totalRolled = allStats.reduce((sum, s) => sum + s.rolled, 0)
  const totalSkipped = allStats.reduce((sum, s) => sum + s.skipped, 0)
  const totalFailed = allStats.reduce((sum, s) => sum + s.failed, 0)

  console.log('')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('  ROLLBACK SUMMARY')
  console.log('═══════════════════════════════════════════════════════════════')
  console.log('')

  // Table header
  console.log('  Collection            | Total | Rolled | Skipped | Failed')
  console.log('  ----------------------|-------|--------|---------|-------')

  // Table rows
  for (const stats of allStats) {
    const name = stats.collection.padEnd(20)
    const total = String(stats.total).padStart(5)
    const rolled = String(stats.rolled).padStart(6)
    const skipped = String(stats.skipped).padStart(7)
    const failed = String(stats.failed).padStart(6)
    console.log(`  ${name} | ${total} | ${rolled} | ${skipped} | ${failed}`)
  }

  console.log('  ----------------------|-------|--------|---------|-------')

  // Totals
  const totalRecords = allStats.reduce((sum, s) => sum + s.total, 0)
  console.log(`  ${'TOTAL'.padEnd(20)} | ${String(totalRecords).padStart(5)} | ${String(totalRolled).padStart(6)} | ${String(totalSkipped).padStart(7)} | ${String(totalFailed).padStart(6)}`)

  console.log('')
  console.log(`  Duration: ${duration}s`)
  console.log('')

  // Errors
  const allErrors = allStats.flatMap(s => s.errors)
  if (allErrors.length > 0) {
    console.log('  ERRORS:')
    allErrors.slice(0, 10).forEach(err => console.log(`    - ${err}`))
    if (allErrors.length > 10) {
      console.log(`    ... and ${allErrors.length - 10} more errors`)
    }
    console.log('')
  }

  if (totalFailed > 0) {
    console.log('  Some documents failed to rollback. Review errors above.')
    process.exit(1)
  } else if (config.dryRun) {
    console.log('  Dry run complete. Run without --dry-run to perform actual rollback.')
  } else {
    console.log('  Rollback completed successfully!')
  }
}

// Run rollback
console.log('')
runRollback()
  .then(() => {
    console.log('')
    console.log('Rollback script finished.')
    process.exit(0)
  })
  .catch((err) => {
    console.error('Unhandled error:', err)
    process.exit(1)
  })
</file>

<file path="server/src/scripts/seed-service-formulas.ts">
import { initializeApp, getApps, cert } from 'firebase-admin/app'
import { getDatabase, Database } from 'firebase-admin/database'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Use RTDB_URL instead of FIREBASE_DATABASE_URL (reserved prefix in Firebase Functions)
const firebaseDatabaseURL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/'

function generateId(): string {
  const timestamp = Date.now().toString(36)
  const randomPart = Math.random().toString(36).substring(2, 15)
  return `${timestamp}-${randomPart}`
}

function now(): string {
  return new Date().toISOString()
}

async function initializeFirebase(): Promise<Database> {
  if (!getApps().length) {
    // Use SERVICE_ACCOUNT_PATH instead of FIREBASE_SERVICE_ACCOUNT_PATH (reserved prefix in Firebase Functions)
    const serviceAccountPath = process.env.SERVICE_ACCOUNT_PATH

    if (serviceAccountPath) {
      const absolutePath = resolve(process.cwd(), serviceAccountPath)
      const serviceAccount = JSON.parse(readFileSync(absolutePath, 'utf-8'))
      initializeApp({
        credential: cert(serviceAccount),
        databaseURL: firebaseDatabaseURL
      })
    } else {
      throw new Error('SERVICE_ACCOUNT_PATH environment variable is required')
    }
  }

  return getDatabase()
}

async function seedServiceFormulas() {
  try {
    console.log('🌱 Bắt đầu seed service formulas...\n')

    const db = await initializeFirebase()
    console.log('✅ Firebase initialized successfully\n')

    // ============================================
    // SERVICE FORMULAS - Biểu thức tính toán
    // ============================================
    console.log('📐 Đang tạo Service Formulas...')

    const serviceFormulas = [
      // Biểu thức tính số lượng (quantity)
      {
        id: generateId(),
        code: 'QTY_SEAT',
        name: 'Số ghế/giường',
        description: 'Tính theo số ghế hoặc số giường của xe',
        formula_type: 'quantity',
        formula_expression: 'vehicle.seatCount',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'QTY_TRIP',
        name: 'Số chuyến',
        description: 'Tính theo số chuyến xe đã thực hiện',
        formula_type: 'quantity',
        formula_expression: 'dispatch.tripCount',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'QTY_PASSENGER',
        name: 'Số khách',
        description: 'Tính theo số lượng hành khách',
        formula_type: 'quantity',
        formula_expression: 'dispatch.passengerCount',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'QTY_TICKET',
        name: 'Số vé',
        description: 'Tính theo số vé đã bán',
        formula_type: 'quantity',
        formula_expression: 'dispatch.ticketCount',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'QTY_FIXED',
        name: 'Cố định = 1',
        description: 'Số lượng cố định bằng 1 (cho phí cố định)',
        formula_type: 'quantity',
        formula_expression: '1',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },

      // Biểu thức tính đơn giá (price)
      {
        id: generateId(),
        code: 'PRICE_ROUTE',
        name: 'Giá theo tuyến',
        description: 'Đơn giá lấy từ cấu hình giá của tuyến đường',
        formula_type: 'price',
        formula_expression: 'route.basePrice',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'PRICE_TICKET',
        name: 'Giá vé',
        description: 'Đơn giá theo giá vé cơ bản',
        formula_type: 'price',
        formula_expression: 'ticket.price',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'PRICE_PARKING',
        name: 'Phí đỗ xe',
        description: 'Phí đỗ xe theo cấu hình bến',
        formula_type: 'price',
        formula_expression: 'station.parkingFee',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'PRICE_SERVICE',
        name: 'Phí dịch vụ',
        description: 'Phí dịch vụ theo cấu hình',
        formula_type: 'price',
        formula_expression: 'service.unitPrice',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'PRICE_COMMISSION',
        name: 'Hoa hồng bán vé',
        description: 'Phần trăm hoa hồng trên doanh thu bán vé',
        formula_type: 'price',
        formula_expression: 'ticket.price * service.commissionRate',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
      {
        id: generateId(),
        code: 'PRICE_PENALTY',
        name: 'Phí phạt',
        description: 'Mức phạt theo quy định',
        formula_type: 'price',
        formula_expression: 'penalty.amount',
        is_active: true,
        created_at: now(),
        updated_at: now(),
      },
    ]

    for (const formula of serviceFormulas) {
      await db.ref(`service_formulas/${formula.id}`).set(formula)
      console.log(`  ✅ Created: ${formula.code} - ${formula.name} (${formula.formula_type})`)
    }

    console.log(`\n✅ Đã tạo ${serviceFormulas.length} service formulas`)
    console.log('\n🎉 Seed service formulas hoàn tất!')

    process.exit(0)

  } catch (error) {
    console.error('❌ Lỗi khi seed service formulas:', error)
    process.exit(1)
  }
}

seedServiceFormulas()
</file>

<file path="server/src/scripts/seed-vehicle-badges.ts">
import { firebaseDb } from '../config/database.js'
import dotenv from 'dotenv'

dotenv.config()

// Helper function to generate ID
function generateId(): string {
  const timestamp = Date.now().toString(36)
  const randomPart = Math.random().toString(36).substring(2, 15)
  return `${timestamp}-${randomPart}`
}

// Helper function to get current timestamp
function now(): string {
  return new Date().toISOString()
}

// Helper function to get date string
function dateString(daysFromNow: number = 0): string {
  const date = new Date()
  date.setDate(date.getDate() + daysFromNow)
  return date.toISOString().split('T')[0]
}

async function seedVehicleBadges() {
  try {
    console.log('🏷️  Đang tạo Vehicle Badges...')

    const vehicleBadges = [
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-001',
        BienSoXe: '51B-123.45',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-180),
        NgayHetHan: dateString(180),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-001',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-002',
        BienSoXe: '51B-678.90',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-120),
        NgayHetHan: dateString(240),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-002',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Vũng Tàu',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-003',
        BienSoXe: '51B-111.22',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Vàng',
        NgayCap: dateString(-90),
        NgayHetHan: dateString(270),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-003',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-TB-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-004',
        BienSoXe: '51B-333.44',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-60),
        NgayHetHan: dateString(25),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-004',
        LoaiCap: 'Gia hạn',
        Ref_GPKD: 'GPKD-KUMHO-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Cần Thơ',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2023-099',
        BienSoXe: '51B-999.88',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Đỏ',
        NgayCap: dateString(-400),
        NgayHetHan: dateString(-30),
        TrangThai: 'Hết hiệu lực',
        MaHoSo: 'HS-099',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
    ]

    // First, clear existing vehicle_badges
    await firebaseDb.remove('vehicle_badges')
    console.log('🗑️  Đã xóa dữ liệu vehicle_badges cũ')

    // Add new badges
    for (const badge of vehicleBadges) {
      await firebaseDb.set(`vehicle_badges/${badge.ID_PhuHieu}`, badge)
    }

    console.log(`✅ Đã tạo ${vehicleBadges.length} vehicle badges thành công!`)
    console.log('\n📋 Danh sách phù hiệu:')
    vehicleBadges.forEach((badge, index) => {
      console.log(`   ${index + 1}. ${badge.SoPhuHieu} - ${badge.BienSoXe} (${badge.TrangThai})`)
    })

    process.exit(0)
  } catch (error: unknown) {
    console.error('❌ Lỗi khi seed vehicle badges:', error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

seedVehicleBadges()
</file>

<file path="server/src/scripts/sync-operators-from-sheets.cjs">
/**
 * Sync Operators from Google Sheets to Firebase
 * Sheet: THONGTINDONVIVANTAI
 * URL: https://docs.google.com/spreadsheets/d/1DCH1-efRqLMSXoIr_jm-5v_C1XpPrnWKultMp7FXn3g
 */

const admin = require('firebase-admin')
const https = require('https')
const path = require('path')

// Initialize Firebase Admin
const serviceAccount = require('../../firebase-service-account.json')

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'
  })
}

const db = admin.database()

// gviz API works fine for this sheet
const SHEET_URL = 'https://docs.google.com/spreadsheets/d/1DCH1-efRqLMSXoIr_jm-5v_C1XpPrnWKultMp7FXn3g/gviz/tq?tqx=out:csv&sheet=THONGTINDONVIVANTAI'

// Parse CSV line handling quoted values
function parseCSVLine(line) {
  const result = []
  let current = ''
  let inQuotes = false
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"'
        i++
      } else {
        inQuotes = !inQuotes
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current)
      current = ''
    } else {
      current += char
    }
  }
  result.push(current)
  
  return result
}

// Fetch CSV from Google Sheets (with redirect support for published URLs)
function fetchCSV(url) {
  return new Promise((resolve, reject) => {
    const http = require('http')
    
    const makeRequest = (reqUrl) => {
      const protocol = reqUrl.startsWith('https') ? https : http
      
      protocol.get(reqUrl, (res) => {
        if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
          makeRequest(res.headers.location)
          return
        }
        
        if (res.statusCode !== 200) {
          reject(new Error(`HTTP ${res.statusCode}`))
          return
        }
        
        let data = ''
        res.on('data', chunk => data += chunk)
        res.on('end', () => resolve(data))
        res.on('error', reject)
      }).on('error', reject)
    }
    makeRequest(url)
  })
}

// Parse CSV to objects
function parseCSV(csv) {
  const lines = csv.split('\n').filter(l => l.trim())
  if (lines.length < 2) return []
  
  const headers = parseCSVLine(lines[0])
  const operators = []
  
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i])
    const obj = {}
    
    headers.forEach((header, idx) => {
      obj[header] = values[idx] || ''
    })
    
    // Skip empty rows and invalid IDs
    // Firebase keys can't contain ".", "#", "$", "/", "[", or "]"
    const id = obj.IDDoanhNghiep
    const name = obj.TenDoanhNghiep
    
    // Validate ID - must be alphanumeric and not contain special prefixes
    const isValidId = id && 
        id.length > 0 &&
        id.length < 50 && 
        !id.includes(',') && 
        !id.includes('.') && 
        !id.includes('#') && 
        !id.includes('$') && 
        !id.includes('/') && 
        !id.includes('[') && 
        !id.includes(']') &&
        !id.includes(':') &&      // Exclude keys like "CQCapDKKD: ..."
        !id.includes('→') &&      // Exclude keys with arrow
        !id.startsWith('•') &&    // Exclude bullet points
        !id.startsWith('DiaChi') &&
        !id.startsWith('SoNha') &&
        !id.startsWith('CQCap')
    
    // Validate name - must have actual content
    const isValidName = name && name.trim().length > 2
    
    if (isValidId && isValidName) {
      operators.push(obj)
    }
  }
  
  return operators
}

// Convert sheet operator to Firebase format
function toFirebaseFormat(op) {
  // Build full address
  const addressParts = [
    op.SoNha_TDP,
    op.XaPhuongThiTran,
    op.QuanHuyen,
    op.TinhThanh
  ].filter(p => p && p.trim())
  
  return {
    id: op.IDDoanhNghiep,
    name: op.TenDoanhNghiep,
    province: op.TinhThanh || '',
    district: op.QuanHuyen || '',
    ward: op.XaPhuongThiTran || '',
    address: op.SoNha_TDP || '',
    full_address: op.DiachiDayDu || addressParts.join(', '),
    phone: op.SoDienThoai || '',
    email: op.Email || '',
    tax_code: op.MaSoThue || '',
    business_license: op.SoDKKD || '',
    business_license_date: op.NgayCap || '',
    business_license_authority: op.CQCapDKKD || '',
    representative_name: op.NguoiDaiDienTheoPhapLuat || '',
    business_type: op.LoaiHinh || '',
    registration_province: op.TinhDangKyHoatDong || '',
    source: 'google_sheets',
    synced_at: new Date().toISOString()
  }
}

async function syncOperators() {
  console.log('=== Syncing Operators from Google Sheets ===\n')
  
  // Fetch CSV
  console.log('Fetching data from Google Sheets...')
  const csv = await fetchCSV(SHEET_URL)
  
  // Parse CSV
  const sheetOperators = parseCSV(csv)
  console.log(`Found ${sheetOperators.length} operators in sheet\n`)
  
  // Analyze data
  const provinceStats = {}
  const bacNinhCount = { inside: 0, outside: 0 }
  
  sheetOperators.forEach(op => {
    const prov = op.TinhThanh || '(empty)'
    provinceStats[prov] = (provinceStats[prov] || 0) + 1
    
    if (op.TinhThanh?.includes('Bắc Ninh')) {
      bacNinhCount.inside++
    } else if (op.TinhThanh) {
      bacNinhCount.outside++
    }
  })
  
  console.log('Province distribution:')
  Object.entries(provinceStats)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .forEach(([prov, count]) => console.log(`  ${count}: ${prov}`))
  
  console.log(`\nBắc Ninh summary:`)
  console.log(`  Inside Bắc Ninh: ${bacNinhCount.inside}`)
  console.log(`  Outside Bắc Ninh: ${bacNinhCount.outside}`)
  
  // Convert to Firebase format
  const firebaseOperators = {}
  sheetOperators.forEach(op => {
    const fbOp = toFirebaseFormat(op)
    firebaseOperators[op.IDDoanhNghiep] = fbOp
  })
  
  // Upload to Firebase
  console.log('\nUploading to Firebase (datasheet/DONVIVANTAI)...')
  await db.ref('datasheet/DONVIVANTAI').set(firebaseOperators)
  
  console.log(`\n✅ Successfully synced ${sheetOperators.length} operators to Firebase!`)
  
  // Show sample
  console.log('\nSample operators:')
  sheetOperators.slice(0, 5).forEach((op, i) => {
    console.log(`${i + 1}. ${op.TenDoanhNghiep.substring(0, 50)}`)
    console.log(`   Province: ${op.TinhThanh}, District: ${op.QuanHuyen}`)
  })
  
  process.exit(0)
}

// Run
syncOperators().catch(err => {
  console.error('Error syncing operators:', err)
  process.exit(1)
})
</file>

<file path="server/src/services/cached-data.service.ts">
/**
 * Cached Data Service
 * Provides cached access to frequently accessed static/semi-static data
 * Reduces Firebase RTDB reads significantly
 */

import { firebase } from '../config/database.js'
import { cache, cacheKeys, cacheTags, MemoryCache } from '../lib/cache.js'

// Type definitions
interface Operator {
  id: string
  name: string
  code: string
  [key: string]: any
}

interface VehicleType {
  id: string
  name: string
  [key: string]: any
}

interface Route {
  id: string
  name: string
  code: string
  [key: string]: any
}

interface Schedule {
  id: string
  route_id: string
  [key: string]: any
}

interface Vehicle {
  id: string
  plate_number: string
  operator_id?: string
  vehicle_type_id?: string
  [key: string]: any
}

interface Driver {
  id: string
  full_name: string
  operator_id?: string
  [key: string]: any
}

/**
 * Cached Data Service - singleton
 */
class CachedDataService {
  // ================== OPERATORS ==================
  async getAllOperators(): Promise<Operator[]> {
    return cache.getOrSet(
      cacheKeys.operators(),
      async () => {
        const { data, error } = await firebase.from('operators').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.OPERATORS] }
    )
  }

  async getOperatorById(id: string): Promise<Operator | null> {
    return cache.getOrSet(
      cacheKeys.operatorById(id),
      async () => {
        const { data, error } = await firebase
          .from('operators')
          .select('*')
          .eq('id', id)
          .single()
        if (error) throw error
        return data || null
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.OPERATORS] }
    )
  }

  async getOperatorsMap(): Promise<Map<string, Operator>> {
    const operators = await this.getAllOperators()
    return new Map(operators.map((op) => [op.id, op]))
  }

  // ================== VEHICLE TYPES ==================
  async getAllVehicleTypes(): Promise<VehicleType[]> {
    return cache.getOrSet(
      cacheKeys.vehicleTypes(),
      async () => {
        const { data, error } = await firebase.from('vehicle_types').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.STATIC, tags: [cacheTags.STATIC] }
    )
  }

  async getVehicleTypesMap(): Promise<Map<string, VehicleType>> {
    const types = await this.getAllVehicleTypes()
    return new Map(types.map((t) => [t.id, t]))
  }

  // ================== ROUTES ==================
  async getAllRoutes(): Promise<Route[]> {
    return cache.getOrSet(
      cacheKeys.routes(),
      async () => {
        const { data, error } = await firebase.from('routes').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.ROUTES] }
    )
  }

  async getRouteById(id: string): Promise<Route | null> {
    return cache.getOrSet(
      cacheKeys.routeById(id),
      async () => {
        const { data, error } = await firebase
          .from('routes')
          .select('*')
          .eq('id', id)
          .single()
        if (error) throw error
        return data || null
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.ROUTES] }
    )
  }

  async getRoutesMap(): Promise<Map<string, Route>> {
    const routes = await this.getAllRoutes()
    return new Map(routes.map((r) => [r.id, r]))
  }

  // ================== SCHEDULES ==================
  async getAllSchedules(): Promise<Schedule[]> {
    return cache.getOrSet(
      cacheKeys.schedules(),
      async () => {
        const { data, error } = await firebase.from('schedules').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.SCHEDULES] }
    )
  }

  async getSchedulesByRoute(routeId: string): Promise<Schedule[]> {
    return cache.getOrSet(
      cacheKeys.schedulesByRoute(routeId),
      async () => {
        const { data, error } = await firebase
          .from('schedules')
          .select('*')
          .eq('route_id', routeId)
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.SCHEDULES] }
    )
  }

  // ================== VEHICLES ==================
  async getAllVehicles(activeOnly = true): Promise<Vehicle[]> {
    const cacheKey = activeOnly ? cacheKeys.vehicles() : `${cacheKeys.vehicles()}:all`
    return cache.getOrSet(
      cacheKey,
      async () => {
        let query = firebase.from('vehicles').select('*').order('created_at', { ascending: false })
        if (activeOnly) {
          query = query.eq('is_active', true)
        }
        const { data, error } = await query
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.MEDIUM, tags: [cacheTags.VEHICLES] }
    )
  }

  async getVehicleById(id: string): Promise<Vehicle | null> {
    return cache.getOrSet(
      cacheKeys.vehicleById(id),
      async () => {
        const { data, error } = await firebase
          .from('vehicles')
          .select('*')
          .eq('id', id)
          .single()
        if (error) throw error
        return data || null
      },
      { ttl: MemoryCache.TTL.MEDIUM, tags: [cacheTags.VEHICLES] }
    )
  }

  async getVehiclesMap(): Promise<Map<string, Vehicle>> {
    const vehicles = await this.getAllVehicles()
    return new Map(vehicles.map((v) => [v.id, v]))
  }

  // ================== DRIVERS ==================
  async getAllDrivers(): Promise<Driver[]> {
    return cache.getOrSet(
      cacheKeys.drivers(),
      async () => {
        const { data, error } = await firebase
          .from('drivers')
          .select('*')
          .order('created_at', { ascending: false })
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.MEDIUM, tags: [cacheTags.DRIVERS] }
    )
  }

  async getDriverById(id: string): Promise<Driver | null> {
    return cache.getOrSet(
      cacheKeys.driverById(id),
      async () => {
        const { data, error } = await firebase
          .from('drivers')
          .select('*')
          .eq('id', id)
          .single()
        if (error) throw error
        return data || null
      },
      { ttl: MemoryCache.TTL.MEDIUM, tags: [cacheTags.DRIVERS] }
    )
  }

  async getDriversMap(): Promise<Map<string, Driver>> {
    const drivers = await this.getAllDrivers()
    return new Map(drivers.map((d) => [d.id, d]))
  }

  // ================== SERVICES ==================
  async getAllServices(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.services(),
      async () => {
        const { data, error } = await firebase.from('services').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.SERVICES] }
    )
  }

  async getAllServiceFormulas(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.serviceFormulas(),
      async () => {
        const { data, error } = await firebase.from('service_formulas').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.SERVICES] }
    )
  }

  // ================== STATIC DATA ==================
  async getAllShifts(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.shifts(),
      async () => {
        const { data, error } = await firebase.from('shifts').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.STATIC, tags: [cacheTags.STATIC] }
    )
  }

  async getAllLocations(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.locations(),
      async () => {
        const { data, error } = await firebase.from('locations').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.STATIC, tags: [cacheTags.STATIC] }
    )
  }

  async getAllProvinces(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.provinces(),
      async () => {
        const { data, error } = await firebase.from('provinces').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.STATIC, tags: [cacheTags.STATIC] }
    )
  }

  async getAllVehicleBadges(): Promise<any[]> {
    return cache.getOrSet(
      cacheKeys.vehicleBadges(),
      async () => {
        const { data, error } = await firebase.from('vehicle_badges').select('*')
        if (error) throw error
        return data || []
      },
      { ttl: MemoryCache.TTL.LONG, tags: [cacheTags.STATIC] }
    )
  }

  // ================== CACHE INVALIDATION ==================
  invalidateVehicles(): void {
    cache.invalidateByTag(cacheTags.VEHICLES)
  }

  invalidateDrivers(): void {
    cache.invalidateByTag(cacheTags.DRIVERS)
  }

  invalidateOperators(): void {
    cache.invalidateByTag(cacheTags.OPERATORS)
  }

  invalidateRoutes(): void {
    cache.invalidateByTag(cacheTags.ROUTES)
  }

  invalidateSchedules(): void {
    cache.invalidateByTag(cacheTags.SCHEDULES)
  }

  invalidateServices(): void {
    cache.invalidateByTag(cacheTags.SERVICES)
  }

  invalidateDispatch(): void {
    cache.invalidateByTag(cacheTags.DISPATCH)
  }

  invalidateAll(): void {
    cache.clear()
  }

  // ================== PRELOAD ==================
  async preloadCommonData(): Promise<void> {
    console.log('[Cache] Preloading common data...')
    const start = Date.now()

    await Promise.all([
      this.getAllOperators(),
      this.getAllVehicleTypes(),
      this.getAllRoutes(),
      this.getAllSchedules(),
      this.getAllVehicles(),
      this.getAllDrivers(),
      this.getAllServices(),
      this.getAllShifts(),
      this.getAllVehicleBadges(),
    ])

    console.log(`[Cache] Preloaded in ${Date.now() - start}ms`)
  }
}

// Singleton export
export const cachedData = new CachedDataService()
</file>

<file path="server/src/services/operator-sync.service.ts">
/**
 * Operator Sync Service
 * Automatically syncs operators from Google Sheets to Firebase
 * Runs every 5 minutes (configurable)
 */

import https from 'https'
import { firebaseDb } from '../config/database.js'
import { invalidateOperatorCache } from '../controllers/operator.controller.js'

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/1DCH1-efRqLMSXoIr_jm-5v_C1XpPrnWKultMp7FXn3g/gviz/tq?tqx=out:csv&sheet=THONGTINDONVIVANTAI'
const SYNC_INTERVAL = 30 * 60 * 1000 // 30 minutes

let syncTimer: NodeJS.Timeout | null = null
let lastSyncTime: Date | null = null
let lastSyncCount: number = 0
let isSyncing = false

// Parse CSV line handling quoted values
function parseCSVLine(line: string): string[] {
  const result: string[] = []
  let current = ''
  let inQuotes = false
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"'
        i++
      } else {
        inQuotes = !inQuotes
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current)
      current = ''
    } else {
      current += char
    }
  }
  result.push(current)
  
  return result
}

// Fetch CSV from Google Sheets
function fetchCSV(url: string): Promise<string> {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      let data = ''
      res.on('data', chunk => data += chunk)
      res.on('end', () => resolve(data))
      res.on('error', reject)
    }).on('error', reject)
  })
}

// Parse CSV to objects
function parseCSV(csv: string): any[] {
  const lines = csv.split('\n').filter(l => l.trim())
  if (lines.length < 2) return []
  
  const headers = parseCSVLine(lines[0])
  const operators: any[] = []
  
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i])
    const obj: any = {}
    
    headers.forEach((header, idx) => {
      obj[header] = values[idx] || ''
    })
    
    // Skip empty rows and invalid IDs
    const id = obj.IDDoanhNghiep
    const name = obj.TenDoanhNghiep
    
    // Validate ID - must be alphanumeric and not contain special prefixes
    const isValidId = id && 
        id.length > 0 &&
        id.length < 50 && 
        !id.includes(',') && 
        !id.includes('.') && 
        !id.includes('#') && 
        !id.includes('$') && 
        !id.includes('/') && 
        !id.includes('[') && 
        !id.includes(']') &&
        !id.includes(':') &&      // Exclude keys like "CQCapDKKD: ..."
        !id.includes('→') &&      // Exclude keys with arrow
        !id.startsWith('•') &&    // Exclude bullet points
        !id.startsWith('DiaChi') &&
        !id.startsWith('SoNha') &&
        !id.startsWith('CQCap')
    
    // Validate name - must have actual content
    const isValidName = name && name.trim().length > 2
    
    if (isValidId && isValidName) {
      operators.push(obj)
    }
  }
  
  return operators
}

// Convert sheet operator to Firebase format
function toFirebaseFormat(op: any) {
  const addressParts = [
    op.SoNha_TDP,
    op.XaPhuongThiTran,
    op.QuanHuyen,
    op.TinhThanh
  ].filter(p => p && p.trim())
  
  return {
    id: op.IDDoanhNghiep,
    name: op.TenDoanhNghiep,
    province: op.TinhThanh || '',
    district: op.QuanHuyen || '',
    ward: op.XaPhuongThiTran || '',
    address: op.SoNha_TDP || '',
    full_address: op.DiachiDayDu || addressParts.join(', '),
    phone: op.SoDienThoai || '',
    email: op.Email || '',
    tax_code: op.MaSoThue || '',
    business_license: op.SoDKKD || '',
    business_license_date: op.NgayCap || '',
    business_license_authority: op.CQCapDKKD || '',
    representative_name: op.NguoiDaiDienTheoPhapLuat || '',
    business_type: op.LoaiHinh || '',
    registration_province: op.TinhDangKyHoatDong || '',
    source: 'google_sheets',
    synced_at: new Date().toISOString()
  }
}

// Main sync function
export async function syncOperatorsFromSheets(): Promise<{ success: boolean; count: number; error?: string }> {
  if (isSyncing) {
    return { success: false, count: 0, error: 'Sync already in progress' }
  }
  
  isSyncing = true
  
  try {
    console.log('[OperatorSync] Starting sync from Google Sheets...')
    
    // Fetch CSV
    const csv = await fetchCSV(SHEET_URL)
    
    // Parse CSV
    const sheetOperators = parseCSV(csv)
    console.log(`[OperatorSync] Found ${sheetOperators.length} operators in sheet`)
    
    // Convert to Firebase format
    const firebaseOperators: Record<string, any> = {}
    sheetOperators.forEach(op => {
      const fbOp = toFirebaseFormat(op)
      firebaseOperators[op.IDDoanhNghiep] = fbOp
    })
    
    // Upload to Firebase
    await firebaseDb.ref('datasheet/DONVIVANTAI').set(firebaseOperators)
    
    // Invalidate operator cache so next API call gets fresh data
    invalidateOperatorCache()
    
    lastSyncTime = new Date()
    lastSyncCount = sheetOperators.length
    
    console.log(`[OperatorSync] ✅ Successfully synced ${sheetOperators.length} operators at ${lastSyncTime.toISOString()}`)
    
    return { success: true, count: sheetOperators.length }
  } catch (error: any) {
    console.error('[OperatorSync] ❌ Error syncing operators:', error.message)
    return { success: false, count: 0, error: error.message }
  } finally {
    isSyncing = false
  }
}

// Start the cron job
export function startOperatorSyncCron(intervalMs: number = SYNC_INTERVAL): void {
  if (syncTimer) {
    console.log('[OperatorSync] Cron already running, skipping start')
    return
  }
  
  console.log(`[OperatorSync] Starting cron job (interval: ${intervalMs / 1000 / 60} minutes)`)
  
  // Run initial sync
  syncOperatorsFromSheets()
  
  // Set up interval
  syncTimer = setInterval(() => {
    syncOperatorsFromSheets()
  }, intervalMs)
  
  console.log('[OperatorSync] Cron job started successfully')
}

// Stop the cron job
export function stopOperatorSyncCron(): void {
  if (syncTimer) {
    clearInterval(syncTimer)
    syncTimer = null
    console.log('[OperatorSync] Cron job stopped')
  }
}

// Get sync status
export function getOperatorSyncStatus(): {
  isRunning: boolean
  isSyncing: boolean
  lastSyncTime: string | null
  lastSyncCount: number
  nextSyncIn: number | null
} {
  return {
    isRunning: syncTimer !== null,
    isSyncing,
    lastSyncTime: lastSyncTime?.toISOString() || null,
    lastSyncCount,
    nextSyncIn: syncTimer ? SYNC_INTERVAL : null
  }
}
</file>

<file path="server/src/shared/database/index.ts">
export * from './base-repository.js'
</file>

<file path="server/src/shared/errors/app-error.ts">
/**
 * Custom Application Error Classes
 * Provides standardized error handling across the application
 */

export enum ErrorCode {
  // Authentication & Authorization
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',

  // Validation
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_INPUT = 'INVALID_INPUT',
  MISSING_REQUIRED_FIELD = 'MISSING_REQUIRED_FIELD',

  // Resource
  NOT_FOUND = 'NOT_FOUND',
  ALREADY_EXISTS = 'ALREADY_EXISTS',
  CONFLICT = 'CONFLICT',

  // Database
  DATABASE_ERROR = 'DATABASE_ERROR',
  CONNECTION_ERROR = 'CONNECTION_ERROR',

  // Business Logic
  BUSINESS_RULE_VIOLATION = 'BUSINESS_RULE_VIOLATION',
  OPERATION_NOT_ALLOWED = 'OPERATION_NOT_ALLOWED',

  // External Services
  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR',

  // Generic
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  BAD_REQUEST = 'BAD_REQUEST',
}

export interface ErrorDetails {
  field?: string
  message?: string
  value?: unknown
}

export class AppError extends Error {
  public readonly code: ErrorCode
  public readonly statusCode: number
  public readonly details?: ErrorDetails[]
  public readonly isOperational: boolean

  constructor(
    message: string,
    code: ErrorCode,
    statusCode: number = 500,
    details?: ErrorDetails[],
    isOperational: boolean = true
  ) {
    super(message)
    this.code = code
    this.statusCode = statusCode
    this.details = details
    this.isOperational = isOperational

    // Maintains proper stack trace
    Error.captureStackTrace(this, this.constructor)
    Object.setPrototypeOf(this, AppError.prototype)
  }

  toJSON() {
    return {
      error: this.message,
      code: this.code,
      details: this.details,
    }
  }
}

// Convenience error classes
export class NotFoundError extends AppError {
  constructor(resource: string, identifier?: string) {
    const message = identifier
      ? `${resource} with identifier '${identifier}' not found`
      : `${resource} not found`
    super(message, ErrorCode.NOT_FOUND, 404)
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: ErrorDetails[]) {
    super(message, ErrorCode.VALIDATION_ERROR, 400, details)
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, ErrorCode.UNAUTHORIZED, 401)
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'Access forbidden') {
    super(message, ErrorCode.FORBIDDEN, 403)
  }
}

export class ConflictError extends AppError {
  constructor(message: string, details?: ErrorDetails[]) {
    super(message, ErrorCode.CONFLICT, 409, details)
  }
}

export class AlreadyExistsError extends AppError {
  constructor(resource: string, field: string, value: string) {
    super(
      `${resource} with ${field} '${value}' already exists`,
      ErrorCode.ALREADY_EXISTS,
      409,
      [{ field, value }]
    )
  }
}

export class DatabaseError extends AppError {
  constructor(message: string = 'Database operation failed') {
    super(message, ErrorCode.DATABASE_ERROR, 500, undefined, false)
  }
}

export class BusinessRuleError extends AppError {
  constructor(message: string, details?: ErrorDetails[]) {
    super(message, ErrorCode.BUSINESS_RULE_VIOLATION, 422, details)
  }
}
</file>

<file path="server/src/shared/errors/error-handler.ts">
/**
 * Global Error Handler Middleware
 * Handles all errors and returns consistent API responses
 */

import { Request, Response, NextFunction } from 'express'
import { ZodError } from 'zod'
import { AppError, ErrorCode } from './app-error.js'

interface ErrorResponse {
  error: string
  code?: string
  details?: unknown
  stack?: string
}

/**
 * Format Zod validation errors into a readable format
 */
function formatZodErrors(error: ZodError): { field: string; message: string }[] {
  return error.errors.map((err) => ({
    field: err.path.join('.'),
    message: err.message,
  }))
}

/**
 * Global error handler middleware
 */
export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  _next: NextFunction
): void {
  // Log error for debugging
  console.error(`[Error] ${req.method} ${req.path}:`, err.message)
  if (process.env.NODE_ENV !== 'production') {
    console.error(err.stack)
  }

  // Handle AppError (our custom errors)
  if (err instanceof AppError) {
    res.status(err.statusCode).json(err.toJSON())
    return
  }

  // Handle Zod validation errors
  if (err instanceof ZodError) {
    res.status(400).json({
      error: 'Validation failed',
      code: ErrorCode.VALIDATION_ERROR,
      details: formatZodErrors(err),
    })
    return
  }

  // Handle Firebase errors
  if (err.name === 'FirebaseError' || (err as any).code?.startsWith?.('auth/')) {
    const firebaseError = err as any
    let statusCode = 500
    let message = firebaseError.message || 'Firebase operation failed'

    if (firebaseError.code === 'auth/id-token-expired') {
      statusCode = 401
      message = 'Token expired'
    } else if (firebaseError.code === 'auth/invalid-id-token') {
      statusCode = 401
      message = 'Invalid token'
    } else if (firebaseError.code === 'PERMISSION_DENIED') {
      statusCode = 403
      message = 'Permission denied'
    }

    res.status(statusCode).json({
      error: message,
      code: firebaseError.code,
    })
    return
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    res.status(401).json({
      error: 'Invalid token',
      code: ErrorCode.UNAUTHORIZED,
    })
    return
  }

  if (err.name === 'TokenExpiredError') {
    res.status(401).json({
      error: 'Token expired',
      code: ErrorCode.TOKEN_EXPIRED,
    })
    return
  }

  // Default to 500 Internal Server Error
  const response: ErrorResponse = {
    error: process.env.NODE_ENV === 'production'
      ? 'Internal server error'
      : err.message,
    code: ErrorCode.INTERNAL_ERROR,
  }

  // Include stack trace in development
  if (process.env.NODE_ENV !== 'production') {
    response.stack = err.stack
  }

  res.status(500).json(response)
}

/**
 * Async handler wrapper to catch errors in async route handlers
 */
export function asyncHandler<T>(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<T>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next)
  }
}

/**
 * Not found handler for undefined routes
 */
export function notFoundHandler(req: Request, res: Response): void {
  res.status(404).json({
    error: `Route ${req.method} ${req.path} not found`,
    code: ErrorCode.NOT_FOUND,
  })
}
</file>

<file path="server/src/shared/errors/index.ts">
export * from './app-error.js'
export * from './error-handler.js'
</file>

<file path="server/src/shared/mappers/case-converter.ts">
/**
 * Case Converter Utilities
 * Converts between snake_case (database) and camelCase (API)
 */

/**
 * Convert snake_case string to camelCase
 */
export function snakeToCamel(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
}

/**
 * Convert camelCase string to snake_case
 */
export function camelToSnake(str: string): string {
  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)
}

/**
 * Convert object keys from snake_case to camelCase (shallow)
 */
export function mapSnakeToCamel<T extends Record<string, any>>(obj: T): Record<string, any> {
  if (!obj || typeof obj !== 'object') return obj

  const result: Record<string, any> = {}
  for (const key of Object.keys(obj)) {
    const camelKey = snakeToCamel(key)
    result[camelKey] = obj[key]
  }
  return result
}

/**
 * Convert object keys from camelCase to snake_case (shallow)
 */
export function mapCamelToSnake<T extends Record<string, any>>(obj: T): Record<string, any> {
  if (!obj || typeof obj !== 'object') return obj

  const result: Record<string, any> = {}
  for (const key of Object.keys(obj)) {
    const snakeKey = camelToSnake(key)
    result[snakeKey] = obj[key]
  }
  return result
}

/**
 * Deep convert object keys from snake_case to camelCase
 */
export function deepMapSnakeToCamel<T>(obj: T): any {
  if (obj === null || obj === undefined) return obj
  if (Array.isArray(obj)) return obj.map(deepMapSnakeToCamel)
  if (typeof obj !== 'object') return obj

  const result: Record<string, any> = {}
  for (const key of Object.keys(obj as Record<string, any>)) {
    const camelKey = snakeToCamel(key)
    result[camelKey] = deepMapSnakeToCamel((obj as Record<string, any>)[key])
  }
  return result
}

/**
 * Deep convert object keys from camelCase to snake_case
 */
export function deepMapCamelToSnake<T>(obj: T): any {
  if (obj === null || obj === undefined) return obj
  if (Array.isArray(obj)) return obj.map(deepMapCamelToSnake)
  if (typeof obj !== 'object') return obj

  const result: Record<string, any> = {}
  for (const key of Object.keys(obj as Record<string, any>)) {
    const snakeKey = camelToSnake(key)
    result[snakeKey] = deepMapCamelToSnake((obj as Record<string, any>)[key])
  }
  return result
}
</file>

<file path="server/src/shared/mappers/entity-mappers.ts">
/**
 * Entity Mappers
 * Maps database records to API response format
 */

// ============================================
// OPERATOR MAPPER
// ============================================
export interface OperatorDB {
  id: string
  name: string
  code: string
  tax_code?: string
  phone?: string
  email?: string
  address?: string
  province?: string
  district?: string
  representative_name?: string
  representative_position?: string
  is_ticket_delegated?: boolean
  is_active: boolean
  created_at?: string
  updated_at?: string
}

export interface OperatorAPI {
  id: string
  name: string
  code: string
  taxCode?: string
  phone?: string
  email?: string
  address?: string
  province?: string
  district?: string
  representativeName?: string
  representativePosition?: string
  isTicketDelegated?: boolean
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export function mapOperator(db: OperatorDB): OperatorAPI {
  return {
    id: db.id,
    name: db.name,
    code: db.code,
    taxCode: db.tax_code,
    phone: db.phone,
    email: db.email,
    address: db.address,
    province: db.province,
    district: db.district,
    representativeName: db.representative_name,
    representativePosition: db.representative_position,
    isTicketDelegated: db.is_ticket_delegated,
    isActive: db.is_active,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  }
}

export function mapOperatorToDB(api: Partial<OperatorAPI>): Partial<OperatorDB> {
  const result: Partial<OperatorDB> = {}
  if (api.name !== undefined) result.name = api.name
  if (api.code !== undefined) result.code = api.code
  if (api.taxCode !== undefined) result.tax_code = api.taxCode
  if (api.phone !== undefined) result.phone = api.phone
  if (api.email !== undefined) result.email = api.email
  if (api.address !== undefined) result.address = api.address
  if (api.province !== undefined) result.province = api.province
  if (api.district !== undefined) result.district = api.district
  if (api.representativeName !== undefined) result.representative_name = api.representativeName
  if (api.representativePosition !== undefined) result.representative_position = api.representativePosition
  if (api.isTicketDelegated !== undefined) result.is_ticket_delegated = api.isTicketDelegated
  if (api.isActive !== undefined) result.is_active = api.isActive
  return result
}

// ============================================
// VEHICLE TYPE MAPPER
// ============================================
export interface VehicleTypeDB {
  id: string
  name: string
  description?: string
  created_at?: string
}

export interface VehicleTypeAPI {
  id: string
  name: string
  description?: string
  createdAt?: string
}

export function mapVehicleType(db: VehicleTypeDB): VehicleTypeAPI {
  return {
    id: db.id,
    name: db.name,
    description: db.description,
    createdAt: db.created_at,
  }
}

// ============================================
// VEHICLE MAPPER
// ============================================
export interface VehicleDB {
  id: string
  plate_number: string
  vehicle_type_id?: string
  operator_id?: string
  seat_capacity: number
  bed_capacity?: number
  chassis_number?: string
  engine_number?: string
  image_url?: string
  insurance_expiry_date?: string
  inspection_expiry_date?: string
  cargo_length?: number
  cargo_width?: number
  cargo_height?: number
  gps_provider?: string
  gps_username?: string
  gps_password?: string
  province?: string
  notes?: string
  is_active: boolean
  created_at?: string
  updated_at?: string
}

export interface VehicleAPI {
  id: string
  plateNumber: string
  vehicleTypeId?: string
  vehicleType?: VehicleTypeAPI
  operatorId?: string
  operator?: OperatorAPI
  seatCapacity: number
  bedCapacity?: number
  chassisNumber?: string
  engineNumber?: string
  imageUrl?: string
  insuranceExpiryDate?: string
  inspectionExpiryDate?: string
  cargoLength?: number
  cargoWidth?: number
  cargoHeight?: number
  gpsProvider?: string
  gpsUsername?: string
  gpsPassword?: string
  province?: string
  notes?: string
  documents?: Record<string, any>
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export function mapVehicle(
  db: VehicleDB,
  vehicleType?: VehicleTypeDB | null,
  operator?: OperatorDB | null,
  documents?: Record<string, any>
): VehicleAPI {
  return {
    id: db.id,
    plateNumber: db.plate_number,
    vehicleTypeId: db.vehicle_type_id,
    vehicleType: vehicleType ? mapVehicleType(vehicleType) : undefined,
    operatorId: db.operator_id,
    operator: operator ? mapOperator(operator) : undefined,
    seatCapacity: db.seat_capacity,
    bedCapacity: db.bed_capacity,
    chassisNumber: db.chassis_number,
    engineNumber: db.engine_number,
    imageUrl: db.image_url,
    insuranceExpiryDate: db.insurance_expiry_date,
    inspectionExpiryDate: db.inspection_expiry_date,
    cargoLength: db.cargo_length,
    cargoWidth: db.cargo_width,
    cargoHeight: db.cargo_height,
    gpsProvider: db.gps_provider,
    gpsUsername: db.gps_username,
    gpsPassword: db.gps_password,
    province: db.province,
    notes: db.notes,
    documents,
    isActive: db.is_active,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  }
}

export function mapVehicleToDB(api: Partial<VehicleAPI>): Partial<VehicleDB> {
  const result: Partial<VehicleDB> = {}
  if (api.plateNumber !== undefined) result.plate_number = api.plateNumber
  if (api.vehicleTypeId !== undefined) result.vehicle_type_id = api.vehicleTypeId
  if (api.operatorId !== undefined) result.operator_id = api.operatorId
  if (api.seatCapacity !== undefined) result.seat_capacity = api.seatCapacity
  if (api.bedCapacity !== undefined) result.bed_capacity = api.bedCapacity
  if (api.chassisNumber !== undefined) result.chassis_number = api.chassisNumber
  if (api.engineNumber !== undefined) result.engine_number = api.engineNumber
  if (api.imageUrl !== undefined) result.image_url = api.imageUrl
  if (api.insuranceExpiryDate !== undefined) result.insurance_expiry_date = api.insuranceExpiryDate
  if (api.inspectionExpiryDate !== undefined) result.inspection_expiry_date = api.inspectionExpiryDate
  if (api.cargoLength !== undefined) result.cargo_length = api.cargoLength
  if (api.cargoWidth !== undefined) result.cargo_width = api.cargoWidth
  if (api.cargoHeight !== undefined) result.cargo_height = api.cargoHeight
  if (api.gpsProvider !== undefined) result.gps_provider = api.gpsProvider
  if (api.gpsUsername !== undefined) result.gps_username = api.gpsUsername
  if (api.gpsPassword !== undefined) result.gps_password = api.gpsPassword
  if (api.province !== undefined) result.province = api.province
  if (api.notes !== undefined) result.notes = api.notes
  if (api.isActive !== undefined) result.is_active = api.isActive
  return result
}

// ============================================
// DRIVER MAPPER
// ============================================
export interface DriverDB {
  id: string
  operator_id?: string
  full_name: string
  id_number: string
  phone?: string
  email?: string
  province?: string
  district?: string
  address?: string
  license_number: string
  license_class: string
  license_issue_date?: string
  license_expiry_date?: string
  image_url?: string
  is_active: boolean
  created_at?: string
  updated_at?: string
}

export interface DriverAPI {
  id: string
  operatorId?: string
  operator?: OperatorAPI
  fullName: string
  idNumber: string
  phone?: string
  email?: string
  province?: string
  district?: string
  address?: string
  licenseNumber: string
  licenseClass: string
  licenseIssueDate?: string
  licenseExpiryDate?: string
  imageUrl?: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export function mapDriver(db: DriverDB, operator?: OperatorDB | null): DriverAPI {
  return {
    id: db.id,
    operatorId: db.operator_id,
    operator: operator ? mapOperator(operator) : undefined,
    fullName: db.full_name,
    idNumber: db.id_number,
    phone: db.phone,
    email: db.email,
    province: db.province,
    district: db.district,
    address: db.address,
    licenseNumber: db.license_number,
    licenseClass: db.license_class,
    licenseIssueDate: db.license_issue_date,
    licenseExpiryDate: db.license_expiry_date,
    imageUrl: db.image_url,
    isActive: db.is_active,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  }
}

export function mapDriverToDB(api: Partial<DriverAPI>): Partial<DriverDB> {
  const result: Partial<DriverDB> = {}
  if (api.operatorId !== undefined) result.operator_id = api.operatorId
  if (api.fullName !== undefined) result.full_name = api.fullName
  if (api.idNumber !== undefined) result.id_number = api.idNumber
  if (api.phone !== undefined) result.phone = api.phone
  if (api.email !== undefined) result.email = api.email
  if (api.province !== undefined) result.province = api.province
  if (api.district !== undefined) result.district = api.district
  if (api.address !== undefined) result.address = api.address
  if (api.licenseNumber !== undefined) result.license_number = api.licenseNumber
  if (api.licenseClass !== undefined) result.license_class = api.licenseClass
  if (api.licenseIssueDate !== undefined) result.license_issue_date = api.licenseIssueDate
  if (api.licenseExpiryDate !== undefined) result.license_expiry_date = api.licenseExpiryDate
  if (api.imageUrl !== undefined) result.image_url = api.imageUrl
  if (api.isActive !== undefined) result.is_active = api.isActive
  return result
}

// ============================================
// LOCATION MAPPER
// ============================================
export interface LocationDB {
  id: string
  name: string
  code: string
  station_type?: string
  province?: string
  district?: string
  address?: string
  phone?: string
  email?: string
  latitude?: number
  longitude?: number
  is_active: boolean
  created_at?: string
}

export interface LocationAPI {
  id: string
  name: string
  code: string
  stationType?: string
  province?: string
  district?: string
  address?: string
  phone?: string
  email?: string
  latitude?: number
  longitude?: number
  isActive: boolean
  createdAt?: string
}

export function mapLocation(db: LocationDB): LocationAPI {
  return {
    id: db.id,
    name: db.name,
    code: db.code,
    stationType: db.station_type,
    province: db.province,
    district: db.district,
    address: db.address,
    phone: db.phone,
    email: db.email,
    latitude: db.latitude,
    longitude: db.longitude,
    isActive: db.is_active,
    createdAt: db.created_at,
  }
}

// ============================================
// ROUTE MAPPER
// ============================================
export interface RouteDB {
  id: string
  route_code: string
  route_name: string
  origin_id: string
  destination_id: string
  distance_km?: number
  estimated_duration_minutes?: number
  route_type?: string
  planned_frequency?: string
  boarding_point?: string
  journey_description?: string
  departure_times_description?: string
  rest_stops?: string
  is_active: boolean
  created_at?: string
  updated_at?: string
}

export interface RouteAPI {
  id: string
  routeCode: string
  routeName: string
  originId: string
  origin?: LocationAPI
  originName?: string
  destinationId: string
  destination?: LocationAPI
  destinationName?: string
  distanceKm?: number
  estimatedDurationMinutes?: number
  routeType?: string
  plannedFrequency?: string
  boardingPoint?: string
  journeyDescription?: string
  departureTimesDescription?: string
  restStops?: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export function mapRoute(
  db: RouteDB,
  origin?: LocationDB | null,
  destination?: LocationDB | null
): RouteAPI {
  return {
    id: db.id,
    routeCode: db.route_code,
    routeName: db.route_name,
    originId: db.origin_id,
    origin: origin ? mapLocation(origin) : undefined,
    originName: origin?.name,
    destinationId: db.destination_id,
    destination: destination ? mapLocation(destination) : undefined,
    destinationName: destination?.name,
    distanceKm: db.distance_km,
    estimatedDurationMinutes: db.estimated_duration_minutes,
    routeType: db.route_type,
    plannedFrequency: db.planned_frequency,
    boardingPoint: db.boarding_point,
    journeyDescription: db.journey_description,
    departureTimesDescription: db.departure_times_description,
    restStops: db.rest_stops,
    isActive: db.is_active,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  }
}

// ============================================
// SHIFT MAPPER
// ============================================
export interface ShiftDB {
  id: string
  name: string
  start_time: string
  end_time: string
  is_active: boolean
  created_at?: string
  updated_at?: string
}

export interface ShiftAPI {
  id: string
  name: string
  startTime: string
  endTime: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export function mapShift(db: ShiftDB): ShiftAPI {
  return {
    id: db.id,
    name: db.name,
    startTime: db.start_time,
    endTime: db.end_time,
    isActive: db.is_active,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  }
}
</file>

<file path="server/src/shared/mappers/index.ts">
export * from './case-converter.js'
export * from './entity-mappers.js'
</file>

<file path="server/src/shared/response/api-response.ts">
/**
 * Standardized API Response Utilities
 * Provides consistent response formats across all endpoints
 */

import { Response } from 'express'

export interface SuccessResponse<T> {
  success: true
  data: T
  message?: string
}

export interface PaginatedResponse<T> {
  success: true
  data: T[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasNext: boolean
    hasPrev: boolean
  }
}

export interface ErrorResponse {
  success: false
  error: string
  code?: string
  details?: unknown
}

/**
 * Send a success response
 */
export function sendSuccess<T>(
  res: Response,
  data: T,
  statusCode: number = 200,
  message?: string
): void {
  const response: SuccessResponse<T> = {
    success: true,
    data,
  }
  if (message) {
    response.message = message
  }
  res.status(statusCode).json(response)
}

/**
 * Send a created response (201)
 */
export function sendCreated<T>(res: Response, data: T, message?: string): void {
  sendSuccess(res, data, 201, message)
}

/**
 * Send a paginated response
 */
export function sendPaginated<T>(
  res: Response,
  data: T[],
  pagination: PaginatedResponse<T>['pagination']
): void {
  const response: PaginatedResponse<T> = {
    success: true,
    data,
    pagination,
  }
  res.status(200).json(response)
}

/**
 * Send a no content response (204)
 */
export function sendNoContent(res: Response): void {
  res.status(204).send()
}

/**
 * Send error response
 */
export function sendError(
  res: Response,
  error: string,
  statusCode: number = 500,
  code?: string,
  details?: unknown
): void {
  const response: ErrorResponse = {
    success: false,
    error,
  }
  if (code) response.code = code
  if (details) response.details = details
  res.status(statusCode).json(response)
}

/**
 * Send validation error (400)
 */
export function sendValidationError(
  res: Response,
  error: string,
  details?: unknown
): void {
  sendError(res, error, 400, 'VALIDATION_ERROR', details)
}

/**
 * Send not found error (404)
 */
export function sendNotFound(res: Response, resource: string): void {
  sendError(res, `${resource} not found`, 404, 'NOT_FOUND')
}

/**
 * Send unauthorized error (401)
 */
export function sendUnauthorized(res: Response, message: string = 'Unauthorized'): void {
  sendError(res, message, 401, 'UNAUTHORIZED')
}

/**
 * Send forbidden error (403)
 */
export function sendForbidden(res: Response, message: string = 'Access forbidden'): void {
  sendError(res, message, 403, 'FORBIDDEN')
}
</file>

<file path="server/src/shared/response/index.ts">
export * from './api-response.js'
</file>

<file path="server/src/shared/services/base-service.ts">
/**
 * Base Service Template
 *
 * Use this pattern for services with complex business logic.
 * Services wrap repositories and add business logic on top.
 *
 * Simple CRUD operations do not need services - use repository directly.
 *
 * @example
 * ```typescript
 * class DispatchService extends BaseService {
 *   constructor(private dispatchRepo: DispatchRepository) {
 *     super('DispatchService');
 *   }
 *
 *   async processWorkflow(id: string, action: WorkflowAction): Promise<DispatchRecord> {
 *     const record = await this.dispatchRepo.findByIdOrFail(id);
 *     // Complex business logic here
 *     return this.dispatchRepo.updateById(id, updates);
 *   }
 * }
 * ```
 */

/**
 * Service interface defining standard operations
 * Repositories handle CRUD, services handle business logic
 */
export interface IService<T> {
  findById(id: string): Promise<T | null>
  findAll(): Promise<T[]>
  create(data: Partial<T>): Promise<T>
  update(id: string, data: Partial<T>): Promise<T>
  delete(id: string): Promise<void>
}

/**
 * Abstract base service providing common functionality
 * Extend this for services with complex business logic
 */
export abstract class BaseService {
  constructor(protected serviceName: string) {}

  /**
   * Standard error handler - logs and re-throws
   * Override in subclass for custom error handling
   */
  protected handleError(operation: string, error: unknown): never {
    console.error(`[${this.serviceName}] ${operation} failed:`, error)
    throw error
  }

  /**
   * Log operation for debugging
   */
  protected log(message: string, data?: unknown): void {
    console.log(`[${this.serviceName}] ${message}`, data ?? '')
  }

  /**
   * Wrap async operations with error handling
   */
  protected async withErrorHandling<R>(
    operation: string,
    fn: () => Promise<R>
  ): Promise<R> {
    try {
      return await fn()
    } catch (error) {
      this.handleError(operation, error)
    }
  }
}

/**
 * Type for workflow actions in dispatch
 */
export type WorkflowAction =
  | 'recordPassengerDrop'
  | 'issuePermit'
  | 'rejectPermit'
  | 'processPayment'
  | 'issueDepartureOrder'
  | 'recordDeparture'
  | 'recordExit'

/**
 * Generic service result type
 */
export interface ServiceResult<T> {
  success: boolean
  data?: T
  error?: string
}

/**
 * Create a success result
 */
export function successResult<T>(data: T): ServiceResult<T> {
  return { success: true, data }
}

/**
 * Create an error result
 */
export function errorResult<T>(error: string): ServiceResult<T> {
  return { success: false, error }
}
</file>

<file path="server/src/shared/services/index.ts">
/**
 * Shared Services Module
 * Export service base classes and utilities
 */

export * from './base-service.js'
</file>

<file path="server/src/shared/validation/dispatch-status.ts">
/**
 * Dispatch Status Management
 *
 * Simple status validation without full state machine complexity.
 * Defines valid status transitions for dispatch workflow.
 *
 * Workflow:
 * entered -> passengers_dropped -> permit_issued -> paid -> departure_ordered -> departed -> exited
 *                                    |
 *                                    v
 *                              permit_rejected -> (retry) passengers_dropped
 */

/**
 * Dispatch status constants
 */
export const DISPATCH_STATUS = {
  ENTERED: 'entered',
  PASSENGERS_DROPPED: 'passengers_dropped',
  PERMIT_ISSUED: 'permit_issued',
  PERMIT_REJECTED: 'permit_rejected',
  PAID: 'paid',
  DEPARTURE_ORDERED: 'departure_ordered',
  DEPARTED: 'departed',
  EXITED: 'exited',
} as const

/**
 * Type for dispatch status values
 */
export type DispatchStatusType = typeof DISPATCH_STATUS[keyof typeof DISPATCH_STATUS]

/**
 * Valid status transitions map
 * Each key maps to array of valid next statuses
 */
export const VALID_TRANSITIONS: Record<DispatchStatusType, DispatchStatusType[]> = {
  [DISPATCH_STATUS.ENTERED]: [DISPATCH_STATUS.PASSENGERS_DROPPED],
  [DISPATCH_STATUS.PASSENGERS_DROPPED]: [DISPATCH_STATUS.PERMIT_ISSUED, DISPATCH_STATUS.PERMIT_REJECTED],
  [DISPATCH_STATUS.PERMIT_ISSUED]: [DISPATCH_STATUS.PAID],
  [DISPATCH_STATUS.PERMIT_REJECTED]: [DISPATCH_STATUS.PASSENGERS_DROPPED], // Can retry
  [DISPATCH_STATUS.PAID]: [DISPATCH_STATUS.DEPARTURE_ORDERED],
  [DISPATCH_STATUS.DEPARTURE_ORDERED]: [DISPATCH_STATUS.DEPARTED],
  [DISPATCH_STATUS.DEPARTED]: [DISPATCH_STATUS.EXITED],
  [DISPATCH_STATUS.EXITED]: [], // Terminal state
}

/**
 * Status display names (Vietnamese)
 */
export const STATUS_DISPLAY_NAMES: Record<DispatchStatusType, string> = {
  [DISPATCH_STATUS.ENTERED]: 'Đã vào bến',
  [DISPATCH_STATUS.PASSENGERS_DROPPED]: 'Đã trả khách',
  [DISPATCH_STATUS.PERMIT_ISSUED]: 'Đã cấp phép',
  [DISPATCH_STATUS.PERMIT_REJECTED]: 'Từ chối cấp phép',
  [DISPATCH_STATUS.PAID]: 'Đã thanh toán',
  [DISPATCH_STATUS.DEPARTURE_ORDERED]: 'Đã điều lệnh',
  [DISPATCH_STATUS.DEPARTED]: 'Đã xuất bến',
  [DISPATCH_STATUS.EXITED]: 'Đã ra khỏi bến',
}

/**
 * Check if a status is a valid dispatch status
 */
export function isValidStatus(status: string): status is DispatchStatusType {
  return Object.values(DISPATCH_STATUS).includes(status as DispatchStatusType)
}

/**
 * Check if transition from one status to another is valid
 */
export function canTransitionStatus(from: DispatchStatusType, to: DispatchStatusType): boolean {
  const validNextStatuses = VALID_TRANSITIONS[from]
  return validNextStatuses?.includes(to) ?? false
}

/**
 * Validate status transition, throw error if invalid
 * @throws Error if transition is not allowed
 */
export function validateStatusTransition(from: string, to: string): void {
  if (!isValidStatus(from)) {
    throw new Error(`Invalid current status: ${from}`)
  }
  if (!isValidStatus(to)) {
    throw new Error(`Invalid target status: ${to}`)
  }
  if (!canTransitionStatus(from, to)) {
    throw new Error(`Invalid status transition: ${from} -> ${to}. Valid transitions from ${from}: ${getNextValidStatuses(from).join(', ') || 'none'}`)
  }
}

/**
 * Get list of valid next statuses for current status
 */
export function getNextValidStatuses(current: DispatchStatusType): DispatchStatusType[] {
  return VALID_TRANSITIONS[current] || []
}

/**
 * Check if status is a terminal state (no further transitions)
 */
export function isTerminalStatus(status: DispatchStatusType): boolean {
  return getNextValidStatuses(status).length === 0
}

/**
 * Get display name for a status
 */
export function getStatusDisplayName(status: DispatchStatusType): string {
  return STATUS_DISPLAY_NAMES[status] || status
}

/**
 * Get all statuses as array (useful for dropdowns)
 */
export function getAllStatuses(): DispatchStatusType[] {
  return Object.values(DISPATCH_STATUS)
}

/**
 * Get all statuses with display names (useful for UI)
 */
export function getStatusOptions(): Array<{ value: DispatchStatusType; label: string }> {
  return getAllStatuses().map(status => ({
    value: status,
    label: getStatusDisplayName(status),
  }))
}
</file>

<file path="server/src/shared/validation/index.ts">
/**
 * Shared Validation Module
 * Export validation utilities and constants
 */

export * from './dispatch-status.js'
</file>

<file path="server/src/types/common.ts">
/**
 * Common Types
 * Shared type definitions used across the application
 */

// ========== Error Types ==========

/**
 * Standard error object structure from various sources
 * (Firebase, Zod, custom errors)
 */
export interface AppError {
  name?: string
  message?: string
  code?: string | number
  errors?: Array<{ message: string; path?: string[] }>
}

/**
 * Type guard to check if an unknown error has an error structure
 */
export function isAppError(error: unknown): error is AppError {
  return (
    typeof error === 'object' &&
    error !== null &&
    ('message' in error || 'code' in error || 'errors' in error)
  )
}

/**
 * Extract error message from unknown error
 */
export function getErrorMessage(error: unknown, defaultMessage = 'An error occurred'): string {
  if (isAppError(error)) {
    // Zod validation error
    if (error.name === 'ZodError' && error.errors?.[0]?.message) {
      return error.errors[0].message
    }
    // Standard error
    if (error.message) {
      return error.message
    }
  }
  // String error
  if (typeof error === 'string') {
    return error
  }
  return defaultMessage
}

/**
 * Check if error is a duplicate key error (PostgreSQL/Firebase)
 */
export function isDuplicateKeyError(error: unknown): boolean {
  if (isAppError(error)) {
    return error.code === '23505' || error.code === 'ALREADY_EXISTS'
  }
  return false
}

/**
 * Check if error is a Zod validation error
 */
export function isValidationError(error: unknown): boolean {
  return isAppError(error) && error.name === 'ZodError'
}

// ========== API Response Types ==========

/**
 * Standard API success response
 */
export interface ApiSuccessResponse<T> {
  success: true
  data: T
}

/**
 * Standard API error response
 */
export interface ApiErrorResponse {
  success: false
  error: string
  code?: string
}

/**
 * Combined API response type
 */
export type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse

// ========== Pagination Types ==========

export interface PaginationParams {
  page?: number
  limit?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}

export interface PaginatedResponse<T> {
  data: T[]
  total: number
  page: number
  limit: number
  totalPages: number
}

// ========== Database Types ==========

/**
 * Base fields present in all database records
 */
export interface BaseDBRecord {
  id: string
  created_at: string
  updated_at: string
}

/**
 * Firebase query result structure
 */
export interface FirebaseQueryResult<T> {
  data: T[] | null
  error: Error | null
}

/**
 * Firebase single record result structure
 */
export interface FirebaseSingleResult<T> {
  data: T | null
  error: Error | null
}

// ========== Relation Types ==========

/**
 * Operator summary for embedded relations
 */
export interface OperatorSummary {
  id: string
  name: string
  code: string
}

/**
 * Vehicle type summary for embedded relations
 */
export interface VehicleTypeSummary {
  id: string
  name: string
}

/**
 * Route summary for embedded relations
 */
export interface RouteSummary {
  id: string
  routeName: string
  routeType?: string | null
}

/**
 * User summary for audit fields
 */
export interface UserSummary {
  id: string
  fullName?: string
  username?: string
}
</file>

<file path="server/src/types/global.d.ts">
// Global type declarations for modules that may not have @types packages available
// This ensures TypeScript can compile even if @types packages are not found

declare module 'express' {
  import { IncomingMessage, ServerResponse } from 'http'
  
  export interface Request extends IncomingMessage {
    body: any
    params: any
    query: any
    headers: any
    [key: string]: any
  }
  
  export interface Response extends ServerResponse {
    json: (body: any) => Response
    status: (code: number) => Response
    send: (body?: any) => Response
    [key: string]: any
  }
  
  export interface NextFunction {
    (err?: any): void
  }
  
  export interface IRouter {
    use: (...handlers: any[]) => IRouter
    get: (path: string, ...handlers: any[]) => IRouter
    post: (path: string, ...handlers: any[]) => IRouter
    put: (path: string, ...handlers: any[]) => IRouter
    delete: (path: string, ...handlers: any[]) => IRouter
    patch: (path: string, ...handlers: any[]) => IRouter
    [key: string]: any
  }
  
  export function Router(): IRouter
  
  export interface Application {
    use: (...handlers: any[]) => Application
    get: (path: string, ...handlers: any[]) => Application
    post: (path: string, ...handlers: any[]) => Application
    put: (path: string, ...handlers: any[]) => Application
    delete: (path: string, ...handlers: any[]) => Application
    patch: (path: string, ...handlers: any[]) => Application
    listen: (port: number | string, callback?: () => void) => any
    [key: string]: any
  }
  
  interface Express {
    (): Application
    json: () => any
    urlencoded: (options?: any) => any
    Router: () => IRouter
  }
  
  const express: Express
  export default express
}

declare module 'cors' {
  import { Request, Response, NextFunction } from 'express'
  
  interface CorsOptions {
    origin?: string | string[] | ((origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => void)
    credentials?: boolean
    [key: string]: any
  }
  
  function cors(options?: CorsOptions): (req: Request, res: Response, next: NextFunction) => void
  export default cors
}

declare module 'jsonwebtoken' {
  export interface JwtPayload {
    [key: string]: any
  }
  
  export interface SignOptions {
    expiresIn?: string | number
    algorithm?: string
    [key: string]: any
  }
  
  export class JsonWebTokenError extends Error {
    name: string
    message: string
  }
  
  export function verify(token: string, secret: string): string | JwtPayload
  export function sign(payload: any, secret: string, options?: SignOptions): string
  export function decode(token: string, options?: any): string | JwtPayload | null
}

declare module 'bcryptjs' {
  export function hash(data: string, saltOrRounds: number | string): Promise<string>
  export function compare(data: string, encrypted: string): Promise<boolean>
  export function hashSync(data: string, saltOrRounds: number | string): string
  export function compareSync(data: string, encrypted: string): boolean
}
</file>

<file path="server/src/utils/denormalization-sync.ts">
/**
 * Denormalization Sync Utilities for Firebase RTDB
 *
 * These functions handle propagating changes from source entities (vehicles, drivers, routes)
 * to the denormalized fields in dispatch_records.
 *
 * When source data changes, we need to update all dispatch_records that reference
 * that entity to keep the denormalized data consistent.
 */

import { firebase, firebaseDb } from '../config/database.js'

/**
 * Sync vehicle changes to all dispatch records that reference this vehicle
 *
 * Call this when:
 * - Vehicle plate number changes
 * - Vehicle operator assignment changes
 *
 * @param vehicleId - The ID of the vehicle that changed
 * @param changes - The fields that changed
 */
export async function syncVehicleChanges(vehicleId: string, changes: {
  plateNumber?: string
  operatorId?: string | null
  operatorName?: string | null
  operatorCode?: string | null
}): Promise<{ updated: number; failed: number }> {
  try {
    // Find all dispatch records for this vehicle
    const { data: records } = await firebase
      .from('dispatch_records')
      .select('id')
      .eq('vehicle_id', vehicleId)

    if (!records || records.length === 0) {
      return { updated: 0, failed: 0 }
    }

    // Build update object
    const updates: Record<string, any> = {}
    if (changes.plateNumber !== undefined) updates.vehicle_plate_number = changes.plateNumber
    if (changes.operatorId !== undefined) updates.vehicle_operator_id = changes.operatorId
    if (changes.operatorName !== undefined) updates.vehicle_operator_name = changes.operatorName
    if (changes.operatorCode !== undefined) updates.vehicle_operator_code = changes.operatorCode

    if (Object.keys(updates).length === 0) {
      return { updated: 0, failed: 0 }
    }

    // Batch update all affected records
    let updated = 0
    let failed = 0

    await Promise.all(records.map(async (r: any) => {
      try {
        await firebaseDb.update(`dispatch_records/${r.id}`, updates)
        updated++
      } catch (err) {
        console.error(`Failed to sync vehicle change to dispatch record ${r.id}:`, err)
        failed++
      }
    }))

    console.log(`[Denorm Sync] Vehicle ${vehicleId}: Updated ${updated} dispatch records (${failed} failed)`)
    return { updated, failed }
  } catch (error) {
    console.error(`[Denorm Sync] Failed to sync vehicle changes for ${vehicleId}:`, error)
    return { updated: 0, failed: 0 }
  }
}

/**
 * Sync driver changes to all dispatch records that reference this driver
 *
 * Call this when:
 * - Driver full name changes
 *
 * @param driverId - The ID of the driver that changed
 * @param fullName - The new full name
 */
export async function syncDriverChanges(driverId: string, fullName: string): Promise<{ updated: number; failed: number }> {
  try {
    // Find all dispatch records for this driver
    const { data: records } = await firebase
      .from('dispatch_records')
      .select('id')
      .eq('driver_id', driverId)

    if (!records || records.length === 0) {
      return { updated: 0, failed: 0 }
    }

    // Batch update all affected records
    let updated = 0
    let failed = 0

    await Promise.all(records.map(async (r: any) => {
      try {
        await firebaseDb.update(`dispatch_records/${r.id}`, { driver_full_name: fullName })
        updated++
      } catch (err) {
        console.error(`Failed to sync driver change to dispatch record ${r.id}:`, err)
        failed++
      }
    }))

    console.log(`[Denorm Sync] Driver ${driverId}: Updated ${updated} dispatch records (${failed} failed)`)
    return { updated, failed }
  } catch (error) {
    console.error(`[Denorm Sync] Failed to sync driver changes for ${driverId}:`, error)
    return { updated: 0, failed: 0 }
  }
}

/**
 * Sync route changes to all dispatch records that reference this route
 *
 * Call this when:
 * - Route name changes
 * - Route type changes
 * - Route destination changes
 *
 * @param routeId - The ID of the route that changed
 * @param changes - The fields that changed
 */
export async function syncRouteChanges(routeId: string, changes: {
  routeName?: string | null
  routeType?: string | null
  destinationId?: string | null
  destinationName?: string | null
  destinationCode?: string | null
}): Promise<{ updated: number; failed: number }> {
  try {
    // Find all dispatch records for this route
    const { data: records } = await firebase
      .from('dispatch_records')
      .select('id')
      .eq('route_id', routeId)

    if (!records || records.length === 0) {
      return { updated: 0, failed: 0 }
    }

    // Build update object
    const updates: Record<string, any> = {}
    if (changes.routeName !== undefined) updates.route_name = changes.routeName
    if (changes.routeType !== undefined) updates.route_type = changes.routeType
    if (changes.destinationId !== undefined) updates.route_destination_id = changes.destinationId
    if (changes.destinationName !== undefined) updates.route_destination_name = changes.destinationName
    if (changes.destinationCode !== undefined) updates.route_destination_code = changes.destinationCode

    if (Object.keys(updates).length === 0) {
      return { updated: 0, failed: 0 }
    }

    // Batch update all affected records
    let updated = 0
    let failed = 0

    await Promise.all(records.map(async (r: any) => {
      try {
        await firebaseDb.update(`dispatch_records/${r.id}`, updates)
        updated++
      } catch (err) {
        console.error(`Failed to sync route change to dispatch record ${r.id}:`, err)
        failed++
      }
    }))

    console.log(`[Denorm Sync] Route ${routeId}: Updated ${updated} dispatch records (${failed} failed)`)
    return { updated, failed }
  } catch (error) {
    console.error(`[Denorm Sync] Failed to sync route changes for ${routeId}:`, error)
    return { updated: 0, failed: 0 }
  }
}

/**
 * Sync operator changes to all vehicles that reference this operator,
 * then cascade to all dispatch records
 *
 * Call this when:
 * - Operator name changes
 * - Operator code changes
 *
 * @param operatorId - The ID of the operator that changed
 * @param changes - The fields that changed
 */
export async function syncOperatorChanges(operatorId: string, changes: {
  name?: string
  code?: string
}): Promise<{ vehiclesUpdated: number; dispatchUpdated: number; failed: number }> {
  try {
    // Find all vehicles with this operator
    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id')
      .eq('operator_id', operatorId)

    if (!vehicles || vehicles.length === 0) {
      return { vehiclesUpdated: 0, dispatchUpdated: 0, failed: 0 }
    }

    let dispatchUpdated = 0
    let failed = 0

    // For each vehicle, sync the operator changes to their dispatch records
    await Promise.all(vehicles.map(async (v: any) => {
      const result = await syncVehicleChanges(v.id, {
        operatorName: changes.name,
        operatorCode: changes.code,
      })
      dispatchUpdated += result.updated
      failed += result.failed
    }))

    console.log(`[Denorm Sync] Operator ${operatorId}: Affected ${vehicles.length} vehicles, ${dispatchUpdated} dispatch records (${failed} failed)`)
    return { vehiclesUpdated: vehicles.length, dispatchUpdated, failed }
  } catch (error) {
    console.error(`[Denorm Sync] Failed to sync operator changes for ${operatorId}:`, error)
    return { vehiclesUpdated: 0, dispatchUpdated: 0, failed: 0 }
  }
}

/**
 * Sync destination (location) changes to all routes that reference this location,
 * then cascade to all dispatch records
 *
 * Call this when:
 * - Location name changes
 * - Location code changes
 *
 * @param locationId - The ID of the location that changed
 * @param changes - The fields that changed
 */
export async function syncDestinationChanges(locationId: string, changes: {
  name?: string
  code?: string
}): Promise<{ routesUpdated: number; dispatchUpdated: number; failed: number }> {
  try {
    // Find all routes with this destination
    const { data: routes } = await firebase
      .from('routes')
      .select('id')
      .eq('destination_id', locationId)

    if (!routes || routes.length === 0) {
      return { routesUpdated: 0, dispatchUpdated: 0, failed: 0 }
    }

    let dispatchUpdated = 0
    let failed = 0

    // For each route, sync the destination changes to their dispatch records
    await Promise.all(routes.map(async (r: any) => {
      const result = await syncRouteChanges(r.id, {
        destinationName: changes.name,
        destinationCode: changes.code,
      })
      dispatchUpdated += result.updated
      failed += result.failed
    }))

    console.log(`[Denorm Sync] Destination ${locationId}: Affected ${routes.length} routes, ${dispatchUpdated} dispatch records (${failed} failed)`)
    return { routesUpdated: routes.length, dispatchUpdated, failed }
  } catch (error) {
    console.error(`[Denorm Sync] Failed to sync destination changes for ${locationId}:`, error)
    return { routesUpdated: 0, dispatchUpdated: 0, failed: 0 }
  }
}
</file>

<file path="server/src/utils/timezone.ts">
/**
 * Timezone utilities for Vietnam (UTC+7)
 * 
 * This module handles timezone conversions to ensure dates are stored
 * and retrieved correctly in Vietnam timezone.
 */

const VIETNAM_TIMEZONE_OFFSET_MS = 7 * 60 * 60 * 1000 // 7 hours in milliseconds

/**
 * Convert UTC ISO string to Vietnam timezone and return as ISO string
 * This ensures the timestamp represents Vietnam time when stored in database
 * 
 * @param utcISOString - UTC ISO date string (e.g., "2024-12-25T07:30:00.000Z")
 * @returns ISO string representing Vietnam time (UTC+7)
 * 
 * @example
 * convertUTCToVietnam("2024-12-25T07:30:00.000Z")
 * // Returns: "2024-12-25T14:30:00.000Z" (VN time represented in UTC)
 */
export function convertUTCToVietnam(utcISOString: string): string {
  const utcDate = new Date(utcISOString)
  
  if (isNaN(utcDate.getTime())) {
    throw new Error(`Invalid UTC date string: ${utcISOString}`)
  }
  
  // Add 7 hours to get Vietnam time
  const vietnamTime = new Date(utcDate.getTime() + VIETNAM_TIMEZONE_OFFSET_MS)
  
  return vietnamTime.toISOString()
}

/**
 * Convert Vietnam time ISO string back to UTC ISO string
 * 
 * @param vietnamISOString - ISO date string representing Vietnam time
 * @returns UTC ISO date string
 * 
 * @example
 * convertVietnamToUTC("2024-12-25T14:30:00.000Z")
 * // Returns: "2024-12-25T07:30:00.000Z" (UTC)
 */
export function convertVietnamToUTC(vietnamISOString: string): string {
  const vietnamDate = new Date(vietnamISOString)
  
  if (isNaN(vietnamDate.getTime())) {
    throw new Error(`Invalid date string: ${vietnamISOString}`)
  }
  
  // Subtract 7 hours to get UTC
  const utcTime = new Date(vietnamDate.getTime() - VIETNAM_TIMEZONE_OFFSET_MS)
  
  return utcTime.toISOString()
}

/**
 * Convert Vietnam time ISO string (with +07:00) to UTC ISO string for database storage.
 * This preserves the Vietnam time value by storing it as UTC with +7 hours offset.
 * 
 * @param vietnamISOString - ISO string with +07:00 (e.g., "2024-12-25T14:30:00+07:00")
 * @returns UTC ISO string representing the same moment (e.g., "2024-12-25T07:30:00.000Z")
 * 
 * @example
 * convertVietnamISOToUTCForStorage("2024-12-25T14:30:00+07:00")
 * // Returns: "2024-12-25T14:30:00.000Z" (stored as UTC but represents VN time)
 */
export function convertVietnamISOToUTCForStorage(vietnamISOString: string): string {
  // Parse the Vietnam time string
  const date = new Date(vietnamISOString)
  
  // Get the UTC components (which represent Vietnam time after parsing)
  // When we parse "2024-12-25T14:30:00+07:00", JavaScript converts to UTC
  // So we need to add 7 hours back to preserve the Vietnam time value
  const vietnamTimeMs = date.getTime() + VIETNAM_TIMEZONE_OFFSET_MS
  const preservedDate = new Date(vietnamTimeMs)
  
  // Return as UTC ISO string (this represents Vietnam time stored as UTC+7)
  return preservedDate.toISOString()
}

/**
 * Get current time in Vietnam timezone as ISO string with +07:00 offset
 * 
 * @returns ISO string with +07:00 offset representing current Vietnam time
 * 
 * @example
 * getCurrentVietnamTime()
 * // Returns: "2024-12-25T14:30:00+07:00" (current Vietnam time)
 */
export function getCurrentVietnamTime(): string {
  const now = new Date()
  // Get current UTC time and add 7 hours
  const vietnamTimeMs = now.getTime() + VIETNAM_TIMEZONE_OFFSET_MS
  const vietnamDate = new Date(vietnamTimeMs)
  
  // Format as ISO string with +07:00 offset
  const year = vietnamDate.getUTCFullYear()
  const month = String(vietnamDate.getUTCMonth() + 1).padStart(2, '0')
  const day = String(vietnamDate.getUTCDate()).padStart(2, '0')
  const hours = String(vietnamDate.getUTCHours()).padStart(2, '0')
  const minutes = String(vietnamDate.getUTCMinutes()).padStart(2, '0')
  const seconds = String(vietnamDate.getUTCSeconds()).padStart(2, '0')
  
  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+07:00`
}
</file>

<file path="server/src/utils/validation.ts">
import { z } from 'zod'

export const loginSchema = z.object({
  usernameOrEmail: z.string().min(1, 'Username or email is required'),
  password: z.string().min(1, 'Password is required'),
})

export const registerSchema = z.object({
  username: z.string().min(3, 'Username must be at least 3 characters').max(50, 'Username must be at most 50 characters'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  fullName: z.string().min(1, 'Full name is required').max(100, 'Full name must be at most 100 characters'),
  email: z.string().email('Invalid email address').optional().or(z.literal('')),
  phone: z.string().max(20, 'Phone number must be at most 20 characters').optional().or(z.literal('')),
  role: z.enum(['admin', 'dispatcher', 'accountant', 'reporter']).optional(),
})

export const driverSchema = z.object({
  fullName: z.string().min(1, 'Full name is required'),
  phoneNumber: z.string().min(1, 'Phone number is required'),
  email: z.string().email().optional().or(z.literal('')),
  licenseNumber: z.string().min(1, 'License number is required'),
  licenseExpiry: z.string().min(1, 'License expiry is required'),
  contractExpiry: z.string().optional(),
  imageUrl: z.string().url().optional().or(z.literal('')),
})

export const vehicleSchema = z.object({
  plateNumber: z.string().min(1, 'Plate number is required'),
  vehicleType: z.string().min(1, 'Vehicle type is required'),
  seatCapacity: z.number().int().positive('Seat capacity must be positive'),
  operatorId: z.string().min(1, 'Operator ID is required'),
  operatorName: z.string().optional(),
  documents: z.object({
    registration: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      isValid: z.boolean(),
      imageUrl: z.string().optional(),
    }),
    inspection: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      isValid: z.boolean(),
      imageUrl: z.string().optional(),
    }),
    permit: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      isValid: z.boolean(),
      imageUrl: z.string().optional(),
    }),
    insurance: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      isValid: z.boolean(),
      imageUrl: z.string().optional(),
    }),
  }),
})

export const dispatchSchema = z.object({
  vehicleId: z.string().min(1, 'Invalid vehicle ID'),
  driverId: z.string().min(1, 'Invalid driver ID'),
  route: z.string().min(1, 'Route is required'),
  entryTime: z.string().datetime('Invalid entry time'),
  passengerCount: z.number().int().nonnegative().optional(),
})
</file>

<file path="server/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "exclude": ["node_modules", "dist", "src/**/__tests__/**", "src/**/*.test.ts"]
}
</file>

<file path="server/uploads/.gitkeep">

</file>

<file path="client/index.html">
<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hệ Thống Quản Lý Bến Xe</title>
    <!-- Elegant Serif Display Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/src/components/dashboard/DocumentWarningsTable.tsx">
import { useState } from "react"
import { format, differenceInDays } from "date-fns"
import { AlertTriangle, Edit, ChevronLeft, ChevronRight, History } from "lucide-react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { iconStyles } from "@/lib/icon-theme"
import type { Warning } from "@/services/dashboard.service"

interface DocumentWarningsTableProps {
  warnings: Warning[]
  isLoading: boolean
  onEditDocument: (warning: Warning) => void
  onViewHistory: (warning: Warning) => void
}

const ITEMS_PER_PAGE = 10

export function DocumentWarningsTable({
  warnings,
  isLoading,
  onEditDocument,
  onViewHistory
}: DocumentWarningsTableProps) {
  const [currentPage, setCurrentPage] = useState(1)

  const totalPages = Math.ceil(warnings.length / ITEMS_PER_PAGE)
  const startIndex = (currentPage - 1) * ITEMS_PER_PAGE
  const endIndex = startIndex + ITEMS_PER_PAGE
  const currentWarnings = warnings.slice(startIndex, endIndex)

  const getDaysRemaining = (expiryDate: string | Date) => {
    const today = new Date()
    const expiry = new Date(expiryDate)
    return differenceInDays(expiry, today)
  }

  const getDaysRemainingBadge = (daysRemaining: number) => {
    if (daysRemaining < 0) {
      return <Badge variant="danger">Đã hết hạn {Math.abs(daysRemaining)} ngày</Badge>
    } else if (daysRemaining === 0) {
      return <Badge variant="danger">Hết hạn hôm nay</Badge>
    } else if (daysRemaining <= 7) {
      return <Badge variant="danger">Còn {daysRemaining} ngày</Badge>
    } else if (daysRemaining <= 30) {
      return <Badge variant="warning">Còn {daysRemaining} ngày</Badge>
    } else {
      return <Badge variant="secondary">Còn {daysRemaining} ngày</Badge>
    }
  }

  const getRowClassName = (daysRemaining: number) => {
    if (daysRemaining < 0) {
      return "bg-red-50 border-red-200"
    } else if (daysRemaining <= 7) {
      return "bg-red-50 border-red-100"
    } else if (daysRemaining <= 30) {
      return "bg-yellow-50 border-yellow-100"
    }
    return ""
  }

  return (
    <Card className="border border-stone-200 shadow-sm bg-white rounded-2xl overflow-hidden">
      <CardHeader className="border-b border-stone-100">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="p-2.5 rounded-xl bg-rose-500">
              <AlertTriangle className="w-5 h-5 text-white" />
            </div>
            <CardTitle className="text-lg font-bold text-stone-800">
              Cảnh báo giấy tờ sắp hết hạn
            </CardTitle>
          </div>
          <div className="text-sm text-stone-500 font-medium">
            {warnings.length > 0 && `${warnings.length} cảnh báo`}
          </div>
        </div>
      </CardHeader>
      <CardContent className="pt-4">
        {isLoading ? (
          <div className="text-center text-stone-500 py-8">Đang tải...</div>
        ) : warnings.length === 0 ? (
          <div className="text-center text-stone-500 py-8">
            <div className="w-16 h-16 rounded-2xl bg-stone-100 flex items-center justify-center mx-auto mb-4">
              <AlertTriangle className="h-8 w-8 text-stone-300" />
            </div>
            <p className="font-medium">Không có cảnh báo giấy tờ sắp hết hạn</p>
          </div>
        ) : (
          <>
            <div className="overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Loại</TableHead>
                    <TableHead>Thông tin</TableHead>
                    <TableHead>Giấy tờ</TableHead>
                    <TableHead>Ngày hết hạn</TableHead>
                    <TableHead>Còn lại</TableHead>
                    <TableHead className="text-center">Thao tác</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {currentWarnings.map((warning, index) => {
                    const daysRemaining = getDaysRemaining(warning.expiryDate)
                    return (
                      <TableRow
                        key={`${warning.type}-${warning.plateNumber || warning.name}-${index}`}
                        className={`hover:bg-stone-50 ${getRowClassName(daysRemaining)}`}
                      >
                        <TableCell>
                          <Badge variant={warning.type === "vehicle" ? "default" : "secondary"}>
                            {warning.type === "vehicle" ? "Xe" : "Lái xe"}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <div className="font-medium">
                            {warning.type === "vehicle"
                              ? warning.plateNumber
                              : warning.name}
                          </div>
                        </TableCell>
                        <TableCell>
                          <span className="text-sm font-medium">
                            {warning.document}
                          </span>
                        </TableCell>
                        <TableCell>
                          <span className="text-sm">
                            {format(new Date(warning.expiryDate), "dd/MM/yyyy")}
                          </span>
                        </TableCell>
                        <TableCell>
                          {getDaysRemainingBadge(daysRemaining)}
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center justify-center gap-1">
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => onEditDocument(warning)}
                              className="h-8 w-8 p-0"
                              title="Chỉnh sửa giấy tờ"
                            >
                              <Edit className={iconStyles.editButton} />
                            </Button>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => onViewHistory(warning)}
                              className="h-8 w-8 p-0"
                              title="Xem lịch sử"
                            >
                              <History className={iconStyles.historyButton} />
                            </Button>
                          </div>
                        </TableCell>
                      </TableRow>
                    )
                  })}
                </TableBody>
              </Table>
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between mt-4 pt-4 border-t border-stone-100">
                <div className="text-sm text-stone-500">
                  Hiển thị {startIndex + 1}-{Math.min(endIndex, warnings.length)} của {warnings.length} cảnh báo
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                    disabled={currentPage === 1}
                    className="gap-1 rounded-lg border-stone-200 hover:bg-stone-50"
                  >
                    <ChevronLeft className={iconStyles.navigationIcon} />
                    Trước
                  </Button>

                  <div className="flex items-center gap-1">
                    {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
                      <Button
                        key={page}
                        size="sm"
                        variant={currentPage === page ? "default" : "outline"}
                        onClick={() => setCurrentPage(page)}
                        className="w-8 h-8 p-0 rounded-lg"
                      >
                        {page}
                      </Button>
                    ))}
                  </div>

                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                    disabled={currentPage === totalPages}
                    className="gap-1 rounded-lg border-stone-200 hover:bg-stone-50"
                  >
                    Sau
                    <ChevronRight className={iconStyles.navigationIcon} />
                  </Button>
                </div>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  )
}
</file>

<file path="client/src/components/dashboard/stats/HeatMapCalendar.tsx">
import { useMemo } from "react";
import { format, startOfMonth, endOfMonth, eachDayOfInterval, isSameDay, isToday } from "date-fns";
import { cn } from "@/lib/utils";
import type { ChartDataPoint } from "@/services/dashboard.service";

interface HeatMapCalendarProps {
  data: ChartDataPoint[];
  selectedDate: Date;
  onSelectDate: (date: Date) => void;
}

export function HeatMapCalendar({ data, selectedDate, onSelectDate }: HeatMapCalendarProps) {
  const today = new Date();
  const monthStart = startOfMonth(today);
  const monthEnd = endOfMonth(today);
  const days = eachDayOfInterval({ start: monthStart, end: monthEnd });

  const dataByDate = useMemo(() => {
    const map = new Map<string, number>();
    data.forEach((d) => {
      const dateKey = format(today, "yyyy-MM-dd");
      map.set(dateKey, (map.get(dateKey) || 0) + d.count);
    });
    return map;
  }, [data]);

  const getHeatLevel = (count: number): string => {
    if (count === 0) return "bg-stone-100";
    if (count <= 5) return "bg-emerald-200";
    if (count <= 15) return "bg-emerald-400";
    if (count <= 30) return "bg-emerald-500";
    return "bg-emerald-600";
  };

  const weekDays = ["CN", "T2", "T3", "T4", "T5", "T6", "T7"];
  const firstDayOfWeek = monthStart.getDay();

  return (
    <div className="space-y-4">
      {/* Week Headers */}
      <div className="grid grid-cols-7 gap-1">
        {weekDays.map((day) => (
          <div
            key={day}
            className="text-center text-xs font-medium text-stone-400 py-1"
          >
            {day}
          </div>
        ))}
      </div>

      {/* Calendar Grid */}
      <div className="grid grid-cols-7 gap-1">
        {/* Empty cells for alignment */}
        {Array.from({ length: firstDayOfWeek }).map((_, i) => (
          <div key={`empty-${i}`} className="aspect-square" />
        ))}

        {/* Day cells */}
        {days.map((day) => {
          const dateKey = format(day, "yyyy-MM-dd");
          const count = dataByDate.get(dateKey) || 0;
          const isSelected = isSameDay(day, selectedDate);
          const isTodayDate = isToday(day);
          const hasActivity = count > 0;

          return (
            <button
              key={dateKey}
              onClick={() => onSelectDate(day)}
              className={cn(
                "aspect-square rounded-lg flex flex-col items-center justify-center text-xs transition-all relative",
                "hover:ring-2 hover:ring-emerald-400 hover:ring-offset-1",
                hasActivity ? getHeatLevel(count) : "bg-stone-50",
                isSelected && "ring-2 ring-amber-400 ring-offset-2",
                isTodayDate && "ring-2 ring-emerald-500 ring-offset-1"
              )}
              title={`${format(day, "dd/MM")}: ${count} chuyến`}
            >
              <span
                className={cn(
                  "font-medium",
                  hasActivity && count > 2 ? "text-white" : "text-stone-600"
                )}
              >
                {format(day, "d")}
              </span>
              {hasActivity && (
                <span className="text-[10px] font-bold text-white drop-shadow-sm">
                  {count}
                </span>
              )}
            </button>
          );
        })}
      </div>

      {/* Legend */}
      <div className="flex items-center justify-between pt-2 border-t border-stone-100">
        <span className="text-xs text-stone-400">Ít</span>
        <div className="flex items-center gap-1">
          {[
            "bg-stone-100",
            "bg-emerald-200",
            "bg-emerald-400",
            "bg-emerald-500",
            "bg-emerald-600",
          ].map((bg, i) => (
            <div key={i} className={cn("w-4 h-4 rounded", bg)} />
          ))}
        </div>
        <span className="text-xs text-stone-400">Nhiều</span>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/stats/HeroStatsCard.tsx">
import { Bus, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAnimatedCounter } from "@/hooks/useAnimatedCounter";
import { LiveBeacon } from "./LiveBeacon";

interface HeroStatsCardProps {
  total: number;
  inStation: number;
  departed: number;
  label: string;
  isLoading: boolean;
  onViewDetails: () => void;
}

export function HeroStatsCard({
  total,
  inStation,
  departed,
  label,
  isLoading,
  onViewDetails,
}: HeroStatsCardProps) {
  const animatedTotal = useAnimatedCounter(isLoading ? 0 : total, 2000);
  const animatedInStation = useAnimatedCounter(isLoading ? 0 : inStation, 2000);
  const animatedDeparted = useAnimatedCounter(isLoading ? 0 : departed, 2000);

  return (
    <div className="relative overflow-hidden rounded-2xl bg-stone-800 p-6 shadow-xl shadow-stone-800/20">
      {/* Subtle Background Pattern */}
      <div className="absolute inset-0 opacity-5">
        <div
          className="absolute inset-0"
          style={{
            backgroundImage: `radial-gradient(circle at 2px 2px, white 1px, transparent 0)`,
            backgroundSize: "24px 24px",
          }}
        />
      </div>

      {/* Subtle Glow */}
      <div className="absolute top-0 right-0 w-64 h-64 bg-emerald-500/10 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2" />

      <div className="relative">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center gap-4">
            <div className="p-3 rounded-xl bg-emerald-500">
              <Bus className="w-6 h-6 text-white" />
            </div>
            <div>
              <h2 className="text-base font-semibold text-stone-300 uppercase tracking-wide">{label}</h2>
              <div className="flex items-center gap-2 mt-1">
                <LiveBeacon size="small" />
                <span className="text-sm text-emerald-400 font-medium">
                  Đang hoạt động
                </span>
              </div>
            </div>
          </div>
          <div className="text-right">
            <p className="font-display text-5xl font-bold text-white tracking-tight">
              {animatedTotal}
            </p>
            <p className="text-sm text-stone-400 mt-1">lượt xe</p>
          </div>
        </div>

        {/* Stats Row */}
        <div className="flex items-center justify-between pt-5 border-t border-stone-700">
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-3">
              <div className="w-2.5 h-2.5 rounded-full bg-blue-400" />
              <div>
                <p className="text-stone-400 text-xs font-medium">Trong bến</p>
                <p className="text-2xl font-bold text-white mt-0.5">
                  {animatedInStation}
                </p>
              </div>
            </div>
            <div className="h-10 w-px bg-stone-700" />
            <div className="flex items-center gap-3">
              <div className="w-2.5 h-2.5 rounded-full bg-emerald-400" />
              <div>
                <p className="text-stone-400 text-xs font-medium">Đã xuất bến</p>
                <p className="text-2xl font-bold text-emerald-400 mt-0.5">
                  {animatedDeparted}
                </p>
              </div>
            </div>
          </div>
          <Button
            variant="ghost"
            className="text-stone-300 hover:text-white hover:bg-stone-700 gap-1.5 text-sm rounded-xl px-4"
            onClick={onViewDetails}
          >
            Xem chi tiết
            <ChevronRight className="w-4 h-4" />
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/stats/index.ts">
export { LiveBeacon } from "./LiveBeacon";
export { HeroStatsCard } from "./HeroStatsCard";
export { MetricCard, metricVariants, type MetricCardProps } from "./MetricCard";
export { TrendStatCard, type TrendStatCardProps } from "./TrendStatCard";
export { HeatMapCalendar } from "./HeatMapCalendar";
export { LiveActivityFeed } from "./LiveActivityFeed";
export { QuickStatCard } from "./QuickStatCard";
</file>

<file path="client/src/components/dashboard/stats/MetricCard.tsx">
import { memo } from "react";
import { TrendingUp, TrendingDown } from "lucide-react";
import { cn } from "@/lib/utils";
import { useAnimatedCounter } from "@/hooks/useAnimatedCounter";
import { LiveBeacon } from "./LiveBeacon";

export interface MetricCardProps {
  title: string;
  value: number;
  icon: React.ElementType;
  trend?: { value: number; isPositive: boolean };
  variant: "blue" | "emerald" | "amber" | "rose";
  subtitle?: string;
  isLoading?: boolean;
  isPulsing?: boolean;
}

export const metricVariants = {
  blue: {
    bg: "bg-blue-500",
    light: "bg-blue-50",
    border: "border-stone-200",
    text: "text-stone-800",
    iconBg: "bg-blue-500",
    accent: "text-blue-600",
  },
  emerald: {
    bg: "bg-emerald-500",
    light: "bg-emerald-50",
    border: "border-stone-200",
    text: "text-stone-800",
    iconBg: "bg-emerald-500",
    accent: "text-emerald-600",
  },
  amber: {
    bg: "bg-amber-500",
    light: "bg-amber-50",
    border: "border-stone-200",
    text: "text-stone-800",
    iconBg: "bg-amber-500",
    accent: "text-amber-600",
  },
  rose: {
    bg: "bg-rose-500",
    light: "bg-rose-50",
    border: "border-stone-200",
    text: "text-stone-800",
    iconBg: "bg-rose-500",
    accent: "text-rose-600",
  },
};

export const MetricCard = memo(function MetricCard({
  title,
  value,
  icon: Icon,
  trend,
  variant,
  subtitle,
  isLoading,
  isPulsing,
}: MetricCardProps) {
  const styles = metricVariants[variant];
  const animatedValue = useAnimatedCounter(isLoading ? 0 : value, 1200);

  return (
    <div
      className={cn(
        "group relative overflow-hidden rounded-2xl transition-all duration-300",
        "hover:-translate-y-0.5 hover:shadow-md",
        isPulsing && "animate-pulse-subtle"
      )}
    >
      {/* Card Content */}
      <div
        className={cn(
          "relative p-5 bg-white border rounded-2xl",
          "shadow-sm transition-shadow",
          styles.border
        )}
      >
        {/* Header: Icon + Badge */}
        <div className="flex items-center justify-between mb-3">
          <div
            className={cn(
              "p-2.5 rounded-xl",
              styles.iconBg
            )}
          >
            <Icon className="w-5 h-5 text-white" />
          </div>
          {isPulsing && (
            <div className="flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-rose-50 border border-rose-100">
              <LiveBeacon size="small" />
              <span className="text-xs font-semibold text-rose-600">
                Cần xử lý
              </span>
            </div>
          )}
        </div>

        {/* Title */}
        <p className="text-sm font-medium text-stone-500 mb-1">{title}</p>

        {/* Value */}
        <p
          className={cn(
            "text-3xl font-bold tracking-tight leading-tight",
            styles.text
          )}
        >
          {animatedValue.toLocaleString("vi-VN")}
        </p>

        {/* Subtitle */}
        {subtitle && (
          <p className="text-xs text-stone-400 mt-1">{subtitle}</p>
        )}

        {/* Trend - compact */}
        {trend && (
          <div className="flex items-center gap-1.5 mt-3 pt-3 border-t border-stone-100">
            <span
              className={cn(
                "inline-flex items-center gap-0.5 px-2 py-0.5 rounded-full text-xs font-semibold",
                trend.isPositive
                  ? "bg-emerald-50 text-emerald-600"
                  : "bg-rose-50 text-rose-600"
              )}
            >
              {trend.isPositive ? (
                <TrendingUp className="w-3 h-3" />
              ) : (
                <TrendingDown className="w-3 h-3" />
              )}
              {trend.isPositive ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-stone-400">vs hôm qua</span>
          </div>
        )}

        {/* Hover Accent Line */}
        <div
          className={cn(
            "absolute bottom-0 left-0 right-0 h-0.5 opacity-0 group-hover:opacity-100 transition-opacity",
            styles.bg
          )}
        />
      </div>
    </div>
  );
});
</file>

<file path="client/src/components/dashboard/stats/QuickStatCard.tsx">
import { cn } from "@/lib/utils";

interface QuickStatCardProps {
  label: string;
  value: number | string;
  icon: React.ElementType;
  color: "blue" | "emerald" | "amber" | "rose";
}

const colorStyles = {
  blue: "bg-blue-500",
  emerald: "bg-emerald-500",
  amber: "bg-amber-500",
  rose: "bg-rose-500",
};

export function QuickStatCard({ label, value, icon: Icon, color }: QuickStatCardProps) {
  return (
    <div className="flex items-center gap-3 p-4 rounded-xl bg-stone-50 border border-stone-100 hover:border-stone-200 transition-colors">
      <div
        className={cn(
          "p-2.5 rounded-xl text-white",
          colorStyles[color]
        )}
      >
        <Icon className="w-5 h-5" />
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-xs text-stone-500 font-medium mb-0.5">{label}</p>
        <p className="text-xl font-bold text-stone-800">{value}</p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/CapPhepDialogRedesign.tsx">
import { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { 
  FileText, X, Truck, Plus, Camera, Shield, 
  CheckCircle, Clock, AlertCircle, ChevronDown, ChevronUp,
  Calendar, Upload, Loader2, ImageIcon, Globe, Construction, Trash2
} from "lucide-react";
import { format } from "date-fns";
import { toast } from "react-toastify";
import { formatVietnamTime } from "@/utils/timezone";
import { useCapPhepDialog } from "@/hooks/useCapPhepDialog";
import { Button } from "@/components/ui/button";
import { Autocomplete } from "@/components/ui/autocomplete";
import { DatePicker } from "@/components/DatePicker";
import { 
  ServiceChargesSection,
  ZeroAmountWarningDialog,
} from "./sections";
import { KiemTraGiayToDialog } from "./KiemTraGiayToDialog";
import { LyDoKhongDuDieuKienDialog } from "./LyDoKhongDuDieuKienDialog";
import { ThemDichVuDialog } from "./ThemDichVuDialog";
import { ThemTaiXeDialog } from "./ThemTaiXeDialog";
import api from "@/lib/api";
import type { DispatchRecord } from "@/types";

interface CapPhepDialogProps {
  record: DispatchRecord;
  onClose: () => void;
  onSuccess?: () => void;
  open?: boolean;
  readOnly?: boolean;
}

export function CapPhepDialogRedesign({
  record,
  onClose,
  onSuccess,
  open = true,
  readOnly = false,
}: CapPhepDialogProps) {
  const [isAnimating, setIsAnimating] = useState(false);
  const [documentDialogOpen, setDocumentDialogOpen] = useState(false);
  const [notEligibleDialogOpen, setNotEligibleDialogOpen] = useState(false);
  const [addServiceDialogOpen, setAddServiceDialogOpen] = useState(false);
  const [addDriverDialogOpen, setAddDriverDialogOpen] = useState(false);
  const [calendarExpanded, setCalendarExpanded] = useState(true);
  
  // Image upload state
  const [isUploading, setIsUploading] = useState(false);
  const [entryImageUrl, setEntryImageUrl] = useState(record.entryImageUrl || null);
  const [activeImageTab, setActiveImageTab] = useState<"entry" | "vehicle">("entry");

  const hook = useCapPhepDialog(record, onClose, onSuccess);

  useEffect(() => {
    if (open) {
      setIsAnimating(true);
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }
    return () => { document.body.style.overflow = "unset"; };
  }, [open]);

  const handleClose = () => {
    setIsAnimating(false);
    setTimeout(onClose, 300);
  };

  const handleNotEligibleConfirm = async (
    selectedReasons: string[],
    options: { createOrder: boolean; signAndTransmit: boolean; printDisplay: boolean }
  ) => {
    await hook.handleNotEligibleConfirm(selectedReasons, options);
    setNotEligibleDialogOpen(false);
  };

  // Image upload handler
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (!file.type.startsWith("image/")) {
      toast.error("Vui lòng chọn file ảnh");
      return;
    }
    if (file.size > 5 * 1024 * 1024) {
      toast.error("Kích thước ảnh không được vượt quá 5MB");
      return;
    }

    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const uploadResponse = await api.post<{ url: string }>("/upload", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });
      const imageUrl = uploadResponse.data.url;
      await api.patch(`/dispatch/${record.id}/entry-image`, { entryImageUrl: imageUrl });
      setEntryImageUrl(imageUrl);
      toast.success("Đã cập nhật ảnh xe vào bến");
    } catch {
      toast.error("Không thể upload ảnh. Vui lòng thử lại.");
    } finally {
      setIsUploading(false);
    }
  };

  // Xóa ảnh entry
  const handleRemoveEntryImage = async () => {
    try {
      await api.patch(`/dispatch/${record.id}/entry-image`, { entryImageUrl: null });
      setEntryImageUrl(null);
      toast.success("Đã xóa ảnh xe vào bến");
    } catch {
      toast.error("Không thể xóa ảnh. Vui lòng thử lại.");
    }
  };

  if (!open) return null;

  const overallStatus = hook.getOverallStatus();
  const documents = hook.getDocumentsCheckResults();

  return createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Background */}
      <div 
        className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm"
        onClick={handleClose}
      />

      {/* Main Dialog - Full Screen */}
      <div
        className={`relative w-full h-full bg-white overflow-hidden transition-all duration-300 ${
          isAnimating ? "scale-100 opacity-100" : "scale-95 opacity-0"
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="sticky top-0 z-10 bg-white border-b border-slate-200 px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="p-2.5 rounded-xl bg-gradient-to-br from-blue-500 to-blue-600 shadow-lg shadow-blue-500/30">
                <FileText className="h-5 w-5 text-white" />
              </div>
              <div>
                <h1 className="text-xl font-bold text-slate-800">
                  {readOnly ? "Xem cấp phép" : "Cấp phép lên nốt"}
                </h1>
                <p className="text-sm text-slate-500">
                  <span className="font-semibold text-slate-700">{record.vehiclePlateNumber}</span>
                  {record.entryTime && (
                    <span className="ml-2">• Vào bến {formatVietnamTime(record.entryTime, "HH:mm dd/MM")}</span>
                  )}
                </p>
              </div>
            </div>
            
            {/* Action Buttons */}
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                onClick={handleClose}
                className="h-9 px-4 rounded-lg border-slate-300 text-slate-600 hover:bg-slate-50"
              >
                Hủy
              </Button>
              {!readOnly && (
                <>
                  <Button
                    onClick={() => setNotEligibleDialogOpen(true)}
                    disabled={hook.isLoading}
                    className="h-9 px-4 rounded-lg bg-rose-500 hover:bg-rose-600 text-white"
                  >
                    Không đủ ĐK
                  </Button>
                  <Button
                    onClick={hook.handleEligible}
                    disabled={hook.isLoading}
                    className="h-9 px-4 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white"
                  >
                    {hook.isLoading ? "Đang xử lý..." : "Đủ điều kiện"}
                  </Button>
                </>
              )}
              <Button
                variant="ghost"
                onClick={handleClose}
                className="h-9 w-9 p-0 rounded-lg text-slate-400 hover:text-slate-600 hover:bg-slate-100"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
          </div>
        </div>

        {/* Content */}
        <div className="overflow-y-auto h-[calc(100vh-80px)]">
          {hook.isInitialLoading ? (
            <div className="flex items-center justify-center h-96">
              <div className="text-center">
                <Loader2 className="h-10 w-10 text-blue-500 animate-spin mx-auto mb-3" />
                <p className="text-slate-500">Đang tải dữ liệu...</p>
              </div>
            </div>
          ) : (
            <div className="p-6">
              {/* 2-Column Layout - 65% : 35% */}
              <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
                
                {/* LEFT COLUMN - 2/3 */}
                <div className="lg:col-span-2 space-y-5 order-1">
                  
                  {/* Section 1: Thông tin xe & Tài xế */}
                  <div className="bg-slate-50 rounded-xl border border-slate-200 p-5">
                    <div className="flex items-center gap-2 mb-4">
                      <Truck className="h-5 w-5 text-blue-600" />
                      <h3 className="text-base font-semibold text-slate-800">Thông tin xe & Tài xế</h3>
                    </div>
                    
                    {/* Row 1: Biển số, Đơn vị VT, Giờ vào */}
                    <div className="grid grid-cols-3 gap-4 mb-4">
                      {/* Biển số đăng ký */}
                      <div>
                        <label className="text-sm font-medium text-slate-500 mb-1.5 block">Biển số ĐK</label>
                        <div className="h-11 px-4 flex items-center bg-white rounded-lg border border-slate-200 text-base font-semibold text-slate-700">
                          {hook.registeredPlateNumber || record.vehiclePlateNumber || "---"}
                        </div>
                      </div>
                      
                      {/* Đơn vị vận tải */}
                      <div>
                        <label className="text-sm font-medium text-slate-500 mb-1.5 block">Đơn vị VT</label>
                        <div className="h-11 px-4 flex items-center bg-white rounded-lg border border-slate-200 text-base text-slate-700 truncate" title={hook.operatorNameFromVehicle || ""}>
                          {hook.operatorNameFromVehicle || "---"}
                        </div>
                      </div>
                      
                      {/* Giờ vào bến */}
                      <div>
                        <label className="text-sm font-medium text-slate-500 mb-1.5 block">Giờ vào bến</label>
                        <div className="h-11 px-4 flex items-center bg-white rounded-lg border border-slate-200 text-base text-slate-700">
                          {formatVietnamTime(record.entryTime, "HH:mm dd/MM")}
                        </div>
                      </div>
                    </div>
                    
                    {/* Row 2: Tài xế (full width) */}
                    <div>
                      <label className="text-sm font-medium text-slate-500 mb-1.5 block">Tài xế</label>
                      <div className="h-11 px-4 flex items-center justify-between bg-white rounded-lg border border-slate-200">
                        {hook.drivers.length > 0 ? (
                          <div className="flex items-center gap-2">
                            <div className="w-7 h-7 rounded-full bg-blue-500 flex items-center justify-center flex-shrink-0">
                              <span className="text-sm font-bold text-white">
                                {hook.drivers[0].fullName.charAt(0)}
                              </span>
                            </div>
                            <span className="text-base text-slate-700">
                              {hook.drivers[0].fullName}
                            </span>
                          </div>
                        ) : (
                          <span className="text-base text-slate-400">Chưa có</span>
                        )}
                        {!readOnly && (
                          <button
                            onClick={() => setAddDriverDialogOpen(true)}
                            className="text-blue-500 hover:text-blue-600 flex-shrink-0 ml-2"
                          >
                            <Plus className="h-5 w-5" />
                          </button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Section 2: Lệnh vận chuyển (Main Form) */}
                  <div className="bg-white rounded-xl border-2 border-blue-200 p-6 shadow-sm">
                    <div className="flex items-center gap-2 mb-5">
                      <FileText className="h-5 w-5 text-blue-600" />
                      <h3 className="text-base font-semibold text-slate-800">Lệnh vận chuyển</h3>
                      <span className="text-sm text-rose-500">* Bắt buộc</span>
                    </div>

                    <div className="space-y-5">
                      {/* Row 1: Mã lệnh + Tuyến */}
                      <div className="grid grid-cols-2 gap-5">
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">
                            Mã lệnh vận chuyển <span className="text-rose-500">*</span>
                          </label>
                          <input
                            type="text"
                            value={hook.transportOrderCode}
                            onChange={(e) => hook.setTransportOrderCode(e.target.value)}
                            placeholder="Nhập mã lệnh vận chuyển"
                            readOnly={readOnly}
                            className={`w-full h-11 px-4 rounded-lg border text-base transition-colors ${
                              hook.validationErrors.transportOrderCode 
                                ? "border-rose-400 focus:border-rose-500 focus:ring-2 focus:ring-rose-500/20" 
                                : "border-slate-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20"
                            }`}
                          />
                          {hook.validationErrors.transportOrderCode && (
                            <p className="text-sm text-rose-500 mt-1">{hook.validationErrors.transportOrderCode}</p>
                          )}
                        </div>
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">
                            Tuyến vận chuyển <span className="text-rose-500">*</span>
                          </label>
                          <Autocomplete
                            value={hook.routeId}
                            onChange={(value) => hook.setRouteId(value)}
                            options={hook.routes.map((r) => ({
                              value: r.id,
                              label: `${r.routeName}${r.routeCode ? ` (${r.routeCode})` : ""}`,
                            }))}
                            placeholder="Gõ để tìm tuyến..."
                            disabled={readOnly}
                            className={hook.validationErrors.routeId ? "[&_input]:border-rose-400 [&_input]:h-11 [&_input]:text-base" : "[&_input]:h-11 [&_input]:text-base"}
                          />
                        </div>
                      </div>

                      {/* Row 2: Giờ xuất + Ngày xuất */}
                      <div className="grid grid-cols-2 gap-5">
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">
                            Giờ xuất bến <span className="text-rose-500">*</span>
                          </label>
                          <input
                            type="time"
                            value={hook.departureTime}
                            onChange={(e) => hook.setDepartureTime(e.target.value)}
                            readOnly={readOnly}
                            className={`w-full h-11 px-4 rounded-lg border text-base ${
                              hook.validationErrors.departureTime 
                                ? "border-rose-400" 
                                : "border-slate-300 focus:border-blue-500"
                            }`}
                          />
                        </div>
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">
                            Ngày xuất bến <span className="text-rose-500">*</span>
                          </label>
                          <DatePicker
                            date={hook.departureDate ? new Date(hook.departureDate) : null}
                            onDateChange={(date) => hook.setDepartureDate(date ? format(date, "yyyy-MM-dd") : "")}
                            placeholder="Chọn ngày"
                            disabled={readOnly}
                          />
                        </div>
                      </div>

                      {/* Row 3: Số ghế, Số giường */}
                      <div className="grid grid-cols-4 gap-4">
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">
                            Số ghế <span className="text-rose-500">*</span>
                          </label>
                          <input
                            type="number"
                            value={hook.seatCount}
                            onChange={(e) => hook.setSeatCount(e.target.value)}
                            min="1"
                            readOnly={readOnly}
                            className={`w-full h-11 px-4 rounded-lg border text-base text-center font-semibold ${
                              hook.validationErrors.seatCount 
                                ? "border-rose-400" 
                                : "border-slate-300 focus:border-blue-500"
                            }`}
                          />
                        </div>
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">Số giường</label>
                          <input
                            type="number"
                            value={hook.bedCount}
                            onChange={(e) => hook.setBedCount(e.target.value)}
                            min="0"
                            readOnly={readOnly}
                            className="w-full h-11 px-4 rounded-lg border border-slate-300 text-base text-center font-semibold focus:border-blue-500"
                          />
                        </div>
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">Số vé HH</label>
                          <input
                            type="number"
                            value={hook.hhTicketCount}
                            onChange={(e) => hook.setHhTicketCount(e.target.value)}
                            min="0"
                            readOnly={readOnly}
                            className="w-full h-11 px-4 rounded-lg border border-slate-300 text-base text-center font-semibold focus:border-blue-500"
                          />
                        </div>
                        <div>
                          <label className="text-sm font-medium text-slate-600 mb-2 block">% HH</label>
                          <input
                            type="number"
                            value={hook.hhPercentage}
                            onChange={(e) => hook.setHhPercentage(e.target.value)}
                            min="0"
                            max="100"
                            readOnly={readOnly}
                            className="w-full h-11 px-4 rounded-lg border border-slate-300 text-base text-center font-semibold focus:border-blue-500"
                          />
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Section 3: Dịch vụ & Thanh toán */}
                  <ServiceChargesSection
                    readOnly={readOnly}
                    serviceCharges={hook.serviceCharges}
                    totalAmount={hook.totalAmount}
                    serviceDetailsExpanded={hook.serviceDetailsExpanded}
                    setServiceDetailsExpanded={hook.setServiceDetailsExpanded}
                    onAddService={() => setAddServiceDialogOpen(true)}
                    recordId={record.id}
                  />
                </div>

                {/* RIGHT COLUMN - 1/3 */}
                <div className="lg:col-span-1 space-y-5 order-2">
                  
                  {/* Ảnh xe vào bến */}
                  <div className="bg-white rounded-xl border border-slate-200 overflow-hidden">
                    <div className="flex items-center justify-between px-5 py-4 border-b border-slate-100">
                      <div className="flex items-center gap-2">
                        <Camera className="h-5 w-5 text-blue-600" />
                        <h3 className="font-semibold text-slate-800 text-base">Ảnh xe</h3>
                      </div>
                      <div className="flex gap-1">
                        <button
                          onClick={() => setActiveImageTab("entry")}
                          className={`px-4 py-1.5 text-sm font-medium rounded-md transition-colors ${
                            activeImageTab === "entry"
                              ? "bg-blue-500 text-white"
                              : "bg-slate-100 text-slate-600 hover:bg-slate-200"
                          }`}
                        >
                          Vào bến
                        </button>
                        <button
                          onClick={() => setActiveImageTab("vehicle")}
                          className={`px-4 py-1.5 text-sm font-medium rounded-md transition-colors ${
                            activeImageTab === "vehicle"
                              ? "bg-blue-500 text-white"
                              : "bg-slate-100 text-slate-600 hover:bg-slate-200"
                          }`}
                        >
                          Đăng ký
                        </button>
                      </div>
                    </div>
                    <div className="p-5">
                      <div className="aspect-video rounded-lg bg-slate-50 border-2 border-dashed border-slate-200 overflow-hidden relative">
                        {isUploading ? (
                          <div className="absolute inset-0 flex flex-col items-center justify-center">
                            <Loader2 className="h-10 w-10 text-blue-500 animate-spin mb-2" />
                            <p className="text-base text-slate-500">Đang tải...</p>
                          </div>
                        ) : (activeImageTab === "entry" ? entryImageUrl : hook.selectedVehicle?.imageUrl) ? (
                          <img
                            src={activeImageTab === "entry" ? entryImageUrl! : hook.selectedVehicle?.imageUrl!}
                            alt="Ảnh xe"
                            className="w-full h-full object-cover"
                          />
                        ) : (
                          <div className="absolute inset-0 flex flex-col items-center justify-center">
                            <ImageIcon className="h-12 w-12 text-slate-300 mb-2" />
                            <p className="text-base text-slate-400">
                              {activeImageTab === "entry" ? "Chưa có ảnh vào bến" : "Chưa có ảnh đăng ký"}
                            </p>
                          </div>
                        )}
                      </div>
                      {activeImageTab === "entry" && !readOnly && (
                        <div className="flex gap-2 mt-4">
                          <label className="flex-1 flex items-center justify-center gap-2 h-11 px-4 rounded-lg bg-blue-50 text-blue-600 text-base font-medium cursor-pointer hover:bg-blue-100 border border-blue-200 transition-colors">
                            <Upload className="h-5 w-5" />
                            {entryImageUrl ? "Thay đổi ảnh" : "Tải ảnh lên"}
                            <input
                              type="file"
                              accept="image/*"
                              onChange={handleImageUpload}
                              className="hidden"
                            />
                          </label>
                          {entryImageUrl && (
                            <button
                              onClick={handleRemoveEntryImage}
                              className="h-11 px-4 rounded-lg bg-rose-50 text-rose-600 text-base font-medium hover:bg-rose-100 border border-rose-200 transition-colors flex items-center gap-2"
                            >
                              <Trash2 className="h-5 w-5" />
                              Xóa
                            </button>
                          )}
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Kiểm tra giấy tờ */}
                  <div className="bg-white rounded-xl border border-slate-200 overflow-hidden">
                    <div className="flex items-center justify-between px-5 py-4 border-b border-slate-100">
                      <div className="flex items-center gap-2">
                        <Shield className="h-5 w-5 text-blue-600" />
                        <h3 className="font-semibold text-slate-800 text-base">Kiểm tra giấy tờ</h3>
                      </div>
                      <span className={`text-sm px-3 py-1.5 rounded-full font-bold ${
                        overallStatus.isValid
                          ? "bg-emerald-100 text-emerald-700"
                          : "bg-rose-100 text-rose-700"
                      }`}>
                        {overallStatus.validCount}/{overallStatus.totalCount} OK
                      </span>
                    </div>
                    <div className="p-5">
                      <div className="grid grid-cols-2 gap-3">
                        {documents.map((doc, idx) => {
                          const isOk = doc.status === "valid" || doc.status === "expiring_soon";
                          return (
                            <div
                              key={idx}
                              className={`flex items-center gap-2 p-3 rounded-lg border ${
                                isOk 
                                  ? "bg-emerald-50 border-emerald-200" 
                                  : "bg-rose-50 border-rose-200"
                              }`}
                            >
                              {isOk ? (
                                <CheckCircle className="h-5 w-5 text-emerald-500 flex-shrink-0" />
                              ) : doc.status === "expiring_soon" ? (
                                <Clock className="h-5 w-5 text-amber-500 flex-shrink-0" />
                              ) : (
                                <AlertCircle className="h-5 w-5 text-rose-500 flex-shrink-0" />
                              )}
                              <span className={`text-sm font-medium truncate ${
                                isOk ? "text-emerald-700" : "text-rose-700"
                              }`}>
                                {doc.name}
                              </span>
                            </div>
                          );
                        })}
                      </div>
                      <button
                        onClick={() => setDocumentDialogOpen(true)}
                        className="w-full mt-4 h-10 text-sm font-medium text-blue-600 hover:text-blue-700 hover:bg-blue-50 rounded-lg transition-colors"
                      >
                        Xem chi tiết & Chỉnh sửa
                      </button>
                    </div>
                  </div>

                  {/* Lịch tháng (Collapsible) */}
                  <div className="bg-white rounded-xl border border-slate-200 overflow-hidden">
                    <button
                      onClick={() => setCalendarExpanded(!calendarExpanded)}
                      className="w-full flex items-center justify-between px-5 py-4 hover:bg-slate-50 transition-colors"
                    >
                      <div className="flex items-center gap-2">
                        <Calendar className="h-5 w-5 text-blue-600" />
                        <h3 className="font-semibold text-slate-800 text-base">Lịch hoạt động tháng</h3>
                      </div>
                      {calendarExpanded ? (
                        <ChevronUp className="h-5 w-5 text-slate-400" />
                      ) : (
                        <ChevronDown className="h-5 w-5 text-slate-400" />
                      )}
                    </button>
                    {calendarExpanded && (
                      <div className="px-5 pb-5">
                        <MiniCalendar 
                          departureDate={hook.departureDate}
                          dailyTripCounts={hook.dailyTripCounts}
                        />
                      </div>
                    )}
                  </div>

                  {/* Kiểm tra GSHT (Đang phát triển) */}
                  <div className="bg-slate-50 rounded-xl border border-slate-200 overflow-hidden opacity-60">
                    <div className="flex items-center justify-between px-5 py-4 border-b border-slate-100">
                      <div className="flex items-center gap-2">
                        <Globe className="h-5 w-5 text-slate-400" />
                        <h3 className="font-semibold text-slate-500 text-base">Kiểm tra GSHT</h3>
                      </div>
                      <span className="flex items-center gap-1 text-sm px-3 py-1.5 rounded-full bg-amber-100 text-amber-700 font-medium">
                        <Construction className="h-4 w-4" />
                        Đang phát triển
                      </span>
                    </div>
                    <div className="p-5">
                      <div className="text-center py-4">
                        <Globe className="h-10 w-10 text-slate-300 mx-auto mb-2" />
                        <p className="text-sm text-slate-400">
                          Tính năng kiểm tra Giám sát hành trình sẽ được tích hợp trong phiên bản tiếp theo
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Ghi chú */}
                  <div className="bg-white rounded-xl border border-slate-200 p-5">
                    <label className="text-sm font-medium text-slate-600 mb-2 block">Ghi chú</label>
                    <textarea
                      placeholder="Nhập ghi chú (nếu có)..."
                      readOnly={readOnly}
                      className="w-full h-24 px-4 py-3 rounded-lg border border-slate-200 text-base resize-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20"
                    />
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Dialogs */}
        {record.vehicleId && (
          <KiemTraGiayToDialog
            vehicleId={record.vehicleId}
            open={documentDialogOpen}
            onClose={() => setDocumentDialogOpen(false)}
            onSuccess={hook.handleDocumentDialogSuccess}
          />
        )}
        <LyDoKhongDuDieuKienDialog
          open={notEligibleDialogOpen}
          onClose={() => setNotEligibleDialogOpen(false)}
          onConfirm={handleNotEligibleConfirm}
        />
        {record.id && (
          <ThemDichVuDialog
            dispatchRecordId={record.id}
            open={addServiceDialogOpen}
            onClose={() => setAddServiceDialogOpen(false)}
            onSuccess={hook.handleAddServiceSuccess}
          />
        )}
        <ThemTaiXeDialog
          operatorId={hook.selectedOperatorId || undefined}
          open={addDriverDialogOpen}
          onClose={() => setAddDriverDialogOpen(false)}
          onSuccess={hook.handleAddDriverSuccess}
        />
        <ZeroAmountWarningDialog
          open={hook.showZeroAmountConfirm}
          onClose={() => hook.setShowZeroAmountConfirm(false)}
          onConfirm={() => {
            hook.setShowZeroAmountConfirm(false);
            hook.submitPermit();
          }}
        />
      </div>
    </div>,
    document.body
  );
}

// Mini Calendar Component
function MiniCalendar({ 
  departureDate, 
  dailyTripCounts 
}: { 
  departureDate: string; 
  dailyTripCounts: Record<number, number>;
}) {
  const today = new Date();
  const currentDay = today.getDate();
  const selectedDate = departureDate ? new Date(departureDate) : new Date();
  const firstDayOfMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
  const startDay = firstDayOfMonth.getDay();
  const daysInMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0).getDate();
  const isCurrentMonth = selectedDate.getMonth() === today.getMonth() && selectedDate.getFullYear() === today.getFullYear();

  const getBgColor = (count: number) => {
    if (count === 0) return "bg-slate-100";
    if (count <= 2) return "bg-emerald-200";
    if (count <= 5) return "bg-emerald-400 text-white";
    return "bg-emerald-600 text-white";
  };

  return (
    <div className="space-y-2">
      <div className="grid grid-cols-7 gap-1">
        {["CN", "T2", "T3", "T4", "T5", "T6", "T7"].map((d) => (
          <div key={d} className="text-center text-[10px] font-medium text-slate-400">
            {d}
          </div>
        ))}
      </div>
      <div className="grid grid-cols-7 gap-1">
        {Array.from({ length: startDay }, (_, i) => (
          <div key={`empty-${i}`} className="aspect-square" />
        ))}
        {Array.from({ length: daysInMonth }, (_, i) => {
          const day = i + 1;
          const count = dailyTripCounts[day] || 0;
          const isToday = isCurrentMonth && day === currentDay;
          const isSelected = departureDate && new Date(departureDate).getDate() === day;

          return (
            <div
              key={day}
              className={`
                aspect-square rounded flex items-center justify-center text-xs font-medium
                ${getBgColor(count)}
                ${isToday ? "ring-2 ring-blue-500" : ""}
                ${isSelected ? "ring-2 ring-orange-500" : ""}
              `}
              title={`Ngày ${day}: ${count} xe`}
            >
              {day}
            </div>
          );
        })}
      </div>
      <div className="flex items-center justify-between text-xs text-slate-500 pt-2 border-t border-slate-100">
        <span>Tổng: <strong className="text-emerald-600">{Object.values(dailyTripCounts).reduce((a, b) => a + b, 0)}</strong> chuyến</span>
        <span>Max/ngày: <strong>{Math.max(...Object.values(dailyTripCounts), 0)}</strong></span>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/common/VehicleCard.tsx">
import { Bus, MapPin, User, Users, FileCheck, RefreshCw, Zap, XCircle, Timer, ArrowRightLeft } from "lucide-react";
import { cn } from "@/lib/utils";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { columnConfig, type DisplayStatus } from "./column-config";
import { StatusRibbon } from "./StatusRibbon";
import { BusPlusIcon, FileExclamationIcon } from "@/components/dispatch/icons";
import type { DispatchRecord } from "@/types";

interface VehicleCardProps {
  record: DispatchRecord;
  status: DisplayStatus;
  index: number;
  vehicleStatus: 'eligible' | 'ineligible' | 'returned' | 'irregular' | null;
  onClick: () => void;
  actionButtons: React.ReactNode;
}

export function VehicleCard({ record, status, index, vehicleStatus, onClick, actionButtons }: VehicleCardProps) {
  const config = columnConfig[status];
  const iconBg = getVehicleIconBg(record, status);

  return (
    <div
      className={cn(
        "group relative rounded-2xl cursor-pointer transition-all duration-300",
        "bg-white/90 backdrop-blur-sm border-2 shadow-md",
        "hover:shadow-xl hover:scale-[1.02] hover:-translate-y-1",
        config.borderColor,
        config.glowColor
      )}
      style={{ animation: `slideUp 0.4s ease-out ${index * 0.05}s backwards` }}
      onClick={onClick}
    >
      {vehicleStatus && <StatusRibbon type={vehicleStatus} />}

      <div className="p-4">
        {/* Header */}
        <div className="flex items-center gap-3 mb-4">
          <div className={cn("p-3 rounded-xl bg-gradient-to-br shadow-lg", iconBg)}>
            {renderVehicleIcon(record, status)}
          </div>
          <div className="flex-1 min-w-0">
            <h3 className="font-black text-slate-900 text-lg tracking-wide">{record.vehiclePlateNumber}</h3>
            <div className="flex items-center gap-2 text-xs text-slate-500 mt-0.5">
              <Timer className="h-3 w-3" />
              <span className="font-mono font-semibold">{formatVietnamDateTime(record.entryTime, "HH:mm")}</span>
            </div>
          </div>
        </div>

        {/* Info */}
        <div className="space-y-2 mb-4">
          {(record.seatCount || record.passengersArrived) && (
            <div className="flex items-center justify-between text-sm">
              <div className="flex items-center gap-2 text-slate-600">
                <Users className="h-4 w-4 text-slate-400" />
                <span className="font-medium">{record.seatCount || record.passengersArrived} chỗ</span>
              </div>
              {record.boardingPermitTime && (
                <div className="flex items-center gap-1.5 text-xs text-emerald-600 bg-emerald-50 px-2 py-1 rounded-lg">
                  <FileCheck className="h-3 w-3" />
                  <span className="font-semibold">{formatVietnamDateTime(record.boardingPermitTime, "HH:mm")}</span>
                </div>
              )}
            </div>
          )}

          {renderElectronicOrderInfo(record, status)}

          {record.driverName && (
            <div className="flex items-center gap-2 text-sm text-slate-600">
              <User className="h-4 w-4 text-slate-400" />
              <span className="font-medium truncate">{record.driverName}</span>
            </div>
          )}

          {record.routeName && (
            <div className="flex items-center gap-2 text-sm text-slate-600">
              <MapPin className="h-4 w-4 text-slate-400" />
              <span className="font-medium truncate">{record.routeName}</span>
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-end gap-2 pt-3 border-t border-slate-100">
          {actionButtons}
        </div>
      </div>

      {/* Bottom accent line */}
      <div className={cn(
        "absolute bottom-0 left-4 right-4 h-1 rounded-full bg-gradient-to-r opacity-0 group-hover:opacity-100 transition-opacity",
        config.headerGradient
      )} />
    </div>
  );
}

function getVehicleIconBg(record: DispatchRecord, status: DisplayStatus) {
  if (record.metadata?.type === "irregular") return "from-amber-500 to-orange-600";
  if (record.currentStatus === "passengers_dropped") return "from-sky-500 to-blue-600";
  if (record.permitStatus === "rejected" || (status === "paid" && !record.permitStatus)) return "from-rose-500 to-red-600";
  if (record.permitStatus === "approved") return "from-emerald-500 to-teal-600";
  return columnConfig[status].iconBg.replace('bg-gradient-to-br ', '');
}

function renderVehicleIcon(record: DispatchRecord, status: DisplayStatus) {
  const type = record.metadata?.type;
  if (type === "augmented") return <BusPlusIcon className="h-5 w-5 text-white" />;
  if (type === "replacement") return <ArrowRightLeft className="h-5 w-5 text-white" />;
  if (!record.scheduleId && type !== "irregular" && status === "in-station") {
    return <FileExclamationIcon className="h-5 w-5 text-white" />;
  }
  return <Bus className="h-5 w-5 text-white" />;
}

function renderElectronicOrderInfo(record: DispatchRecord, status: DisplayStatus) {
  if (status !== "in-station") return null;

  const metadata = (record.metadata || {}) as Record<string, unknown>;
  const electronicStatus = metadata.electronicOrderStatus as string | undefined;
  const electronicCode = String(metadata.electronicOrderCode || record.transportOrderCode || "");
  const electronicUrl = metadata.electronicOrderUrl as string | undefined;

  if (electronicStatus === "loading") {
    return (
      <div className="flex items-center gap-2 text-xs text-sky-600 bg-sky-50 px-2 py-1 rounded-lg">
        <RefreshCw className="h-3 w-3 animate-spin" />
        <span>Đang tải lệnh...</span>
      </div>
    );
  }

  if (electronicCode) {
    return (
      <div className="flex items-center gap-2 text-xs font-semibold text-sky-600 bg-sky-50 px-2 py-1 rounded-lg">
        <Zap className="h-3 w-3" />
        {electronicUrl ? (
          <a href={electronicUrl} target="_blank" rel="noreferrer"
            className="hover:underline" onClick={(e) => e.stopPropagation()}>
            {electronicCode}
          </a>
        ) : (
          <span>{electronicCode}</span>
        )}
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2 text-xs text-rose-500 bg-rose-50 px-2 py-1 rounded-lg">
      <XCircle className="h-3 w-3" />
      <span>Chưa có lệnh</span>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/KiemTraGiayToDialog.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { X, CheckCircle, History } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { DatePicker } from "@/components/DatePicker"
import { vehicleService } from "@/services/vehicle.service"
import { DocumentHistoryDialog } from "./DocumentHistoryDialog"
import type { Vehicle, VehicleDocuments } from "@/types"
import { format } from "date-fns"

interface KiemTraGiayToDialogProps {
  vehicleId: string
  open: boolean
  onClose: () => void
  onSuccess?: () => void
}

export function KiemTraGiayToDialog({
  vehicleId,
  open,
  onClose,
  onSuccess
}: KiemTraGiayToDialogProps) {
  const [vehicle, setVehicle] = useState<Vehicle | null>(null)
  const [documents, setDocuments] = useState<VehicleDocuments>({})
  const [isLoading, setIsLoading] = useState(false)
  const [historyDialogOpen, setHistoryDialogOpen] = useState(false)

  useEffect(() => {
    if (open && vehicleId) {
      loadVehicle()
    }
  }, [open, vehicleId])

  const loadVehicle = async () => {
    try {
      const data = await vehicleService.getById(vehicleId)
      setVehicle(data)
      setDocuments(data.documents || {})
    } catch (error) {
      console.error("Failed to load vehicle:", error)
    }
  }

  const handleSave = async () => {
    if (!vehicle) return

    // Validate required fields - chỉ kiểm tra expiryDate vì đây là dialog sửa hiệu lực
    const requiredDocs = ['registration', 'operation_permit', 'inspection', 'insurance'] as const
    for (const docType of requiredDocs) {
      const doc = documents[docType]
      if (!doc || !doc.expiryDate) {
        toast.warning(`Vui lòng nhập ngày hết hạn cho ${getDocumentLabel(docType)}`)
        return
      }
    }

    setIsLoading(true)
    try {
      // Update vehicle documents - đảm bảo gửi đầy đủ thông tin
      // Lấy thông tin hiện có từ vehicle, chỉ cập nhật expiryDate
      const documentsToUpdate: VehicleDocuments = {}
      for (const docType of requiredDocs) {
        const doc = documents[docType]
        if (doc && doc.expiryDate) {
          const existingDoc = vehicle.documents?.[docType]
          
          // Đảm bảo tất cả trường bắt buộc là string, không được null/undefined
          const number = existingDoc?.number || `AUTO-${docType}-${vehicle.plateNumber}`
          const issueDate = existingDoc?.issueDate || new Date().toISOString().split('T')[0]
          const expiryDate = doc.expiryDate
          
          // Nếu document đã tồn tại, giữ nguyên thông tin cũ, chỉ cập nhật expiryDate
          if (existingDoc) {
            documentsToUpdate[docType] = {
              number: number,
              issueDate: issueDate,
              expiryDate: expiryDate,
              isValid: checkDocumentValidity(expiryDate),
              // Chỉ thêm các trường optional nếu chúng có giá trị (không phải null/undefined)
              ...(existingDoc.issuingAuthority && { issuingAuthority: existingDoc.issuingAuthority }),
              ...(existingDoc.documentUrl && { documentUrl: existingDoc.documentUrl }),
              ...(existingDoc.notes && { notes: existingDoc.notes }),
            }
          } else {
            // Nếu document chưa tồn tại, tạo mới với thông tin tối thiểu
            documentsToUpdate[docType] = {
              number: number,
              issueDate: issueDate,
              expiryDate: expiryDate,
              isValid: checkDocumentValidity(expiryDate),
            }
          }
        }
      }

      await vehicleService.update(vehicle.id, {
        documents: documentsToUpdate
      })

      toast.success("Cập nhật hiệu lực giấy tờ thành công!")
      
      // Reload vehicle data to get updated documents
      await loadVehicle()
      
      if (onSuccess) {
        onSuccess()
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to update documents:", error)
      console.error("Error response:", error?.response?.data)
      
      // Hiển thị thông báo lỗi chi tiết hơn
      let errorMessage = "Không thể cập nhật hiệu lực giấy tờ. Vui lòng thử lại sau."
      if (error?.response?.data?.error) {
        errorMessage = error.response.data.error
      } else if (error?.response?.data?.errors) {
        // Nếu có nhiều lỗi validation
        const errors = error.response.data.errors
        errorMessage = Array.isArray(errors) 
          ? errors.map((e: any) => e.message || e).join('\n')
          : JSON.stringify(errors)
      } else if (error?.message) {
        errorMessage = error.message
      }
      
      toast.error(errorMessage)
    } finally {
      setIsLoading(false)
    }
  }

  const getDocumentLabel = (docType: keyof VehicleDocuments): string => {
    const labels: Record<string, string> = {
      registration: 'Đăng ký xe',
      operation_permit: 'Phù hiệu',
      inspection: 'Đăng kiểm',
      insurance: 'Bảo hiểm'
    }
    return labels[docType] || docType
  }

  const updateDocumentDate = (docType: keyof VehicleDocuments, date: Date | undefined) => {
    const value = date ? format(date, "yyyy-MM-dd") : ""
    setDocuments(prev => {
      const updated = { ...prev }
      if (!updated[docType]) {
        // Nếu document chưa tồn tại, tạo mới với thông tin từ vehicle hiện tại hoặc giá trị mặc định
        const existingDoc = vehicle?.documents?.[docType]
        updated[docType] = {
          number: existingDoc?.number || '',
          issueDate: existingDoc?.issueDate || new Date().toISOString().split('T')[0],
          expiryDate: value,
          isValid: checkDocumentValidity(value)
        }
      } else {
        updated[docType] = {
          ...updated[docType]!,
          expiryDate: value,
          isValid: checkDocumentValidity(value)
        }
      }
      return updated
    })
  }

  const checkDocumentValidity = (expiryDate: string): boolean => {
    if (!expiryDate) return false
    const expiry = new Date(expiryDate)
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    return expiry >= today
  }

  const getDocumentStatus = (expiryDate?: string): { isValid: boolean; icon: JSX.Element } => {
    if (!expiryDate) {
      return {
        isValid: false,
        icon: <X className="h-5 w-5 text-red-500" />
      }
    }
    const isValid = checkDocumentValidity(expiryDate)
    return {
      isValid,
      icon: isValid 
        ? <CheckCircle className="h-5 w-5 text-green-500" />
        : <X className="h-5 w-5 text-red-500" />
    }
  }

  const registrationExpiry = documents.registration?.expiryDate || ''
  const permitExpiry = documents.operation_permit?.expiryDate || ''
  const inspectionExpiry = documents.inspection?.expiryDate || ''
  const insuranceExpiry = documents.insurance?.expiryDate || ''

  const registrationStatus = getDocumentStatus(registrationExpiry)
  const permitStatus = getDocumentStatus(permitExpiry)
  const inspectionStatus = getDocumentStatus(inspectionExpiry)
  const insuranceStatus = getDocumentStatus(insuranceExpiry)

  return (
    <Dialog open={open} onOpenChange={onClose} className="w-full flex justify-center">
      <DialogContent className="max-w-md">
        <DialogHeader>
          <div className="flex items-center justify-between gap-8">
            <DialogTitle>Sửa hiệu lực giấy tờ</DialogTitle>
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => setHistoryDialogOpen(true)}
              className="flex items-center gap-2"
            >
              <History className="h-4 w-4" />
              Lịch sử
            </Button>
          </div>
        </DialogHeader>

        <div className="space-y-4">
          {/* Đăng ký xe */}
          <div>
            <Label htmlFor="registrationExpiry">
              Đăng ký xe <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1 flex items-center gap-2">
              <div className="flex-1">
                <DatePicker
                  date={registrationExpiry ? new Date(registrationExpiry) : null}
                  onDateChange={(date) => updateDocumentDate('registration', date)}
                  placeholder="Chọn ngày hết hạn"
                />
              </div>
              <div>
                {registrationStatus.icon}
              </div>
            </div>
          </div>

          {/* Hạn phù hiệu */}
          <div>
            <Label htmlFor="permitExpiry">
              Hạn phù hiệu <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1 flex items-center gap-2">
              <div className="flex-1">
                <DatePicker
                  date={permitExpiry ? new Date(permitExpiry) : null}
                  onDateChange={(date) => updateDocumentDate('operation_permit', date)}
                  placeholder="Chọn ngày hết hạn"
                />
              </div>
              <div>
                {permitStatus.icon}
              </div>
            </div>
          </div>

          {/* Hạn đăng kiểm */}
          <div>
            <Label htmlFor="inspectionExpiry">
              Hạn đăng kiểm <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1 flex items-center gap-2">
              <div className="flex-1">
                <DatePicker
                  date={inspectionExpiry ? new Date(inspectionExpiry) : null}
                  onDateChange={(date) => updateDocumentDate('inspection', date)}
                  placeholder="Chọn ngày hết hạn"
                />
              </div>
              <div>
                {inspectionStatus.icon}
              </div>
            </div>
          </div>

          {/* Hạn bảo hiểm */}
          <div>
            <Label htmlFor="insuranceExpiry">
              Hạn bảo hiểm <span className="text-red-500">(*)</span>
            </Label>
            <div className="relative mt-1 flex items-center gap-2">
              <div className="flex-1">
                <DatePicker
                  date={insuranceExpiry ? new Date(insuranceExpiry) : null}
                  onDateChange={(date) => updateDocumentDate('insurance', date)}
                  placeholder="Chọn ngày hết hạn"
                />
              </div>
              <div>
                {insuranceStatus.icon}
              </div>
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-2 pt-4 border-t mt-6">
          <Button 
            type="button" 
            variant="outline" 
            onClick={onClose}
            disabled={isLoading}
          >
            HỦY
          </Button>
          <Button 
            type="button"
            onClick={handleSave}
            disabled={isLoading}
          >
            {isLoading ? "Đang lưu..." : "LƯU"}
          </Button>
        </div>
      </DialogContent>

      {/* Document History Dialog */}
      <DocumentHistoryDialog
        vehicleId={vehicleId}
        open={historyDialogOpen}
        onClose={() => setHistoryDialogOpen(false)}
      />
    </Dialog>
  )
}
</file>

<file path="client/src/components/dispatch/sections/DocumentCheckCards.tsx">
import { CheckCircle, Clock, AlertCircle, FileX, Shield, Settings } from "lucide-react";
import { GlassCard, SectionHeader } from "@/components/shared/styled-components";

type DocumentStatus = 'valid' | 'expired' | 'expiring_soon' | 'missing';

interface DocumentCheckResult {
  name: string;
  status: DocumentStatus;
  expiryDate?: string;
  daysRemaining?: number;
}

interface DocumentCheckCardsProps {
  documents: DocumentCheckResult[];
  isValid: boolean;
  validCount: number;
  totalCount: number;
  onEdit: () => void;
}

export function DocumentCheckCards({ documents, isValid, validCount, totalCount, onEdit }: DocumentCheckCardsProps) {
  return (
    <GlassCard>
      <SectionHeader
        icon={Shield}
        title="Kiểm tra điều kiện"
        badge={
          <span className={`text-xs px-2 py-1 rounded font-bold ${
            isValid ? 'bg-emerald-100 text-emerald-700' : 'bg-rose-100 text-rose-700'
          }`}>
            {validCount}/{totalCount}
          </span>
        }
        action={
          <button
            type="button"
            onClick={onEdit}
            className="h-7 w-7 rounded-lg bg-gray-100 text-gray-500 hover:bg-blue-50 hover:text-blue-600 transition-colors flex items-center justify-center"
          >
            <Settings className="h-3.5 w-3.5" />
          </button>
        }
      />

      {/* Compact Document List */}
      <div className="p-3 space-y-2">
        {documents.map((doc, index) => {
          const statusConfig = {
            valid: { icon: CheckCircle, color: 'text-emerald-600', bg: 'bg-emerald-50', label: doc.daysRemaining && doc.daysRemaining < 999 ? `${doc.daysRemaining}d` : 'OK' },
            expiring_soon: { icon: Clock, color: 'text-amber-600', bg: 'bg-amber-50', label: doc.daysRemaining === 0 ? 'Hôm nay!' : `${doc.daysRemaining}d` },
            expired: { icon: AlertCircle, color: 'text-rose-600', bg: 'bg-rose-50', label: 'Hết hạn' },
            missing: { icon: FileX, color: 'text-gray-500', bg: 'bg-gray-50', label: 'Thiếu' }
          };
          const config = statusConfig[doc.status];
          const Icon = config.icon;

          return (
            <div
              key={index}
              className={`flex items-center justify-between p-2.5 rounded-lg ${config.bg} border border-transparent hover:border-gray-200 transition-colors`}
            >
              <div className="flex items-center gap-2">
                <Icon className={`h-4 w-4 ${config.color}`} />
                <span className="text-sm font-medium text-gray-700">{doc.name}</span>
              </div>
              <span className={`text-xs font-bold ${config.color}`}>{config.label}</span>
            </div>
          );
        })}
      </div>

      {/* Compact Status Footer */}
      <div className={`px-3 py-2 border-t text-center ${
        isValid ? 'bg-emerald-50 border-emerald-100' : 'bg-rose-50 border-rose-100'
      }`}>
        <span className={`text-xs font-bold ${isValid ? 'text-emerald-700' : 'text-rose-700'}`}>
          {isValid ? '✓ Đủ điều kiện cấp phép' : '✗ Chưa đủ điều kiện'}
        </span>
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/DriverSection.tsx">
import { Users, Plus, Phone, CreditCard } from "lucide-react";
import { GlassCard, SectionHeader, EmptyState } from "@/components/shared/styled-components";
import type { Driver } from "@/types";

interface DriverSectionProps {
  drivers: Driver[];
  readOnly: boolean;
  onAddDriver: () => void;
}

export function DriverSection({ drivers, readOnly, onAddDriver }: DriverSectionProps) {
  return (
    <GlassCard>
      <SectionHeader
        icon={Users}
        title="Lái xe"
        action={
          <button
            type="button"
            onClick={onAddDriver}
            disabled={readOnly}
            className="
              inline-flex items-center gap-2 h-11 px-5 rounded-xl
              bg-gradient-to-r from-blue-600 to-blue-500 text-white
              font-semibold text-sm
              shadow-lg shadow-blue-500/25
              hover:shadow-xl hover:shadow-blue-500/30 hover:from-blue-700 hover:to-blue-600
              active:scale-[0.98]
              transition-all duration-200
              disabled:opacity-50 disabled:cursor-not-allowed
            "
          >
            <Plus className="h-5 w-5" />
            Thêm lái xe
          </button>
        }
      />
      <div className="p-6">
        {drivers.length === 0 ? (
          <EmptyState 
            icon={Users} 
            message="Chưa có lái xe" 
            action={
              <button
                onClick={onAddDriver}
                disabled={readOnly}
                className="text-blue-600 font-semibold text-sm hover:text-blue-700 transition-colors"
              >
                + Thêm lái xe đầu tiên
              </button>
            }
          />
        ) : (
          <div className="space-y-4">
            {drivers.map((driver) => (
              <div
                key={driver.id}
                className="
                  flex items-center justify-between p-5 rounded-2xl 
                  bg-gradient-to-r from-gray-50 to-white
                  border-2 border-gray-100
                  hover:border-blue-200 hover:shadow-lg hover:shadow-blue-500/10
                  transition-all duration-300
                "
              >
                <div className="flex items-center gap-4">
                  <div className="w-14 h-14 rounded-2xl bg-gradient-to-br from-blue-600 to-cyan-500 flex items-center justify-center shadow-lg shadow-blue-500/30">
                    <span className="text-xl font-bold text-white">
                      {driver.fullName.charAt(0)}
                    </span>
                  </div>
                  <div>
                    <p className="text-lg font-bold text-gray-900">{driver.fullName}</p>
                    <div className="flex items-center gap-2 mt-1">
                      <Phone className="h-4 w-4 text-gray-400" />
                      <p className="text-sm text-gray-500 font-medium">{driver.phone || "Chưa có SĐT"}</p>
                    </div>
                  </div>
                </div>
                <div className="flex items-center gap-2 px-4 py-2 rounded-xl bg-blue-50 text-blue-700">
                  <CreditCard className="h-4 w-4" />
                  <span className="font-bold text-sm">{driver.licenseClass}</span>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/MonthlyCalendarHeatmap.tsx">
import { Label } from "@/components/ui/label";

interface MonthlyCalendarHeatmapProps {
  departureDate: string;
  dailyTripCounts: Record<number, number>;
}

export function MonthlyCalendarHeatmap({ departureDate, dailyTripCounts }: MonthlyCalendarHeatmapProps) {
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <Label className="text-base font-semibold text-gray-800">
          Lịch hoạt động tháng {departureDate ? new Date(departureDate).toLocaleDateString('vi-VN', { month: 'long', year: 'numeric' }) : ''}
        </Label>
        <div className="flex items-center gap-3 text-sm text-gray-600">
          <span className="flex items-center gap-1.5">
            <span className="w-3.5 h-3.5 rounded-sm bg-gray-100 border border-gray-200"></span>
            0
          </span>
          <span className="flex items-center gap-1.5">
            <span className="w-3.5 h-3.5 rounded-sm bg-emerald-200"></span>
            1-2
          </span>
          <span className="flex items-center gap-1.5">
            <span className="w-3.5 h-3.5 rounded-sm bg-emerald-400"></span>
            3-5
          </span>
          <span className="flex items-center gap-1.5">
            <span className="w-3.5 h-3.5 rounded-sm bg-emerald-600"></span>
            6+
          </span>
        </div>
      </div>

      <div className="bg-gradient-to-br from-slate-50 to-gray-100 rounded-xl p-4 border border-gray-200/60 shadow-sm">
        {/* Week day headers */}
        <div className="grid grid-cols-7 gap-1.5 mb-2">
          {['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'].map((d) => (
            <div key={d} className="text-center text-xs font-semibold text-gray-500 uppercase tracking-wide py-1">
              {d}
            </div>
          ))}
        </div>

        {/* Calendar grid */}
        <div className="grid grid-cols-7 gap-1.5">
          {(() => {
            const today = new Date();
            const currentDay = today.getDate();
            const selectedDate = departureDate ? new Date(departureDate) : new Date();
            const firstDayOfMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
            const startDay = firstDayOfMonth.getDay();
            const daysInMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0).getDate();
            const isCurrentMonth = selectedDate.getMonth() === today.getMonth() && selectedDate.getFullYear() === today.getFullYear();

            const emptyCells = Array.from({ length: startDay }, (_, i) => (
              <div key={`empty-${i}`} className="aspect-square" />
            ));

            const dayCells = Array.from({ length: daysInMonth }, (_, i) => {
              const day = i + 1;
              const count = dailyTripCounts[day] || 0;
              const isToday = isCurrentMonth && day === currentDay;
              const isSelected = departureDate && new Date(departureDate).getDate() === day;

              const getBgColor = (c: number) => {
                if (c === 0) return 'bg-gray-100 border-gray-200';
                if (c <= 2) return 'bg-emerald-200 border-emerald-300';
                if (c <= 5) return 'bg-emerald-400 border-emerald-500 text-white';
                return 'bg-emerald-600 border-emerald-700 text-white';
              };

              return (
                <div
                  key={day}
                  className={`
                    relative aspect-square rounded-md border flex flex-col items-center justify-center
                    transition-all duration-200 cursor-default group
                    ${getBgColor(count)}
                    ${isToday ? 'ring-2 ring-blue-500 ring-offset-1' : ''}
                    ${isSelected ? 'ring-2 ring-amber-500 ring-offset-1' : ''}
                    hover:scale-110 hover:shadow-md hover:z-10
                  `}
                  title={`Ngày ${day}: ${count} xe`}
                >
                  <span className={`text-sm font-semibold ${count > 2 ? '' : 'text-gray-700'}`}>
                    {day}
                  </span>
                  {count > 0 && (
                    <span className={`text-xs font-bold ${count > 2 ? '' : 'text-emerald-700'}`}>
                      {count}
                    </span>
                  )}
                  <div className="absolute -top-9 left-1/2 -translate-x-1/2 px-2.5 py-1 bg-gray-900 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-20 shadow-lg">
                    {count} chuyến
                  </div>
                </div>
              );
            });

            return [...emptyCells, ...dayCells];
          })()}
        </div>

        {/* Summary footer */}
        <div className="mt-4 pt-3 border-t border-gray-200/60 flex items-center justify-between text-sm">
          <div className="flex items-center gap-2 text-gray-700">
            <span className="font-medium">Tổng tháng:</span>
            <span className="px-2.5 py-1 bg-emerald-100 text-emerald-700 rounded-full font-bold">
              {Object.values(dailyTripCounts).reduce((a, b) => a + b, 0)} chuyến
            </span>
          </div>
          <div className="text-gray-500">
            Ngày cao nhất: <span className="font-semibold text-gray-700">{Math.max(...Object.values(dailyTripCounts), 0)}</span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/sections/PermitActions.tsx">
import { X, XCircle, CheckCircle } from "lucide-react";

interface PermitActionsProps {
  readOnly: boolean;
  isLoading: boolean;
  onClose: () => void;
  onNotEligible: () => void;
  onEligible: () => void;
}

export function PermitActions({
  readOnly,
  isLoading,
  onClose,
  onNotEligible,
  onEligible,
}: PermitActionsProps) {
  return (
    <div className="flex items-center gap-4">
      {/* Cancel/Close button - Ghost style */}
      <button
        type="button"
        onClick={onClose}
        disabled={isLoading}
        className="
          inline-flex items-center gap-2 h-12 px-6 rounded-xl
          bg-white border-2 border-gray-200 text-gray-600
          font-semibold text-base
          hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800
          active:scale-[0.98]
          transition-all duration-200
          disabled:opacity-50 disabled:cursor-not-allowed
        "
      >
        <X className="h-5 w-5" />
        {readOnly ? "Đóng" : "Hủy"}
      </button>

      {!readOnly && (
        <>
          {/* Not Eligible button - Danger style */}
          <button
            type="button"
            onClick={onNotEligible}
            disabled={isLoading}
            className="
              inline-flex items-center gap-2 h-12 px-6 rounded-xl
              bg-gradient-to-r from-rose-500 to-red-500 text-white
              font-bold text-base
              shadow-xl shadow-rose-500/30
              hover:shadow-2xl hover:shadow-rose-500/40 hover:from-rose-600 hover:to-red-600
              active:scale-[0.98]
              transition-all duration-200
              disabled:opacity-50 disabled:cursor-not-allowed
            "
          >
            <XCircle className="h-5 w-5" />
            Không đủ điều kiện
          </button>

          {/* Eligible button - Success style with emphasis */}
          <button
            type="button"
            onClick={onEligible}
            disabled={isLoading}
            className="
              inline-flex items-center gap-2 h-14 px-8 rounded-xl
              bg-gradient-to-r from-emerald-500 to-green-500 text-white
              font-bold text-lg
              shadow-xl shadow-emerald-500/40
              hover:shadow-2xl hover:shadow-emerald-500/50 hover:from-emerald-600 hover:to-green-600
              active:scale-[0.98]
              transition-all duration-200
              disabled:opacity-50 disabled:cursor-not-allowed
              ring-4 ring-emerald-500/20
            "
          >
            <CheckCircle className="h-6 w-6" />
            Đủ điều kiện
          </button>
        </>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/sections/ServiceChargesSection.tsx">
import { CreditCard, ChevronRight, Plus, Wallet } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { GlassCard, SectionHeader } from "@/components/shared/styled-components";
import type { ServiceCharge } from "@/types";

interface ServiceChargesSectionProps {
  readOnly: boolean;
  serviceCharges: ServiceCharge[];
  totalAmount: number;
  serviceDetailsExpanded: boolean;
  setServiceDetailsExpanded: (value: boolean) => void;
  onAddService: () => void;
  recordId?: string;
}

export function ServiceChargesSection({
  readOnly,
  serviceCharges,
  totalAmount,
  serviceDetailsExpanded,
  setServiceDetailsExpanded,
  onAddService,
  recordId,
}: ServiceChargesSectionProps) {
  return (
    <GlassCard>
      <SectionHeader
        icon={CreditCard}
        title="Giá dịch vụ"
        action={
          <button
            type="button"
            onClick={onAddService}
            disabled={!recordId || readOnly}
            className="
              inline-flex items-center gap-2 h-11 px-5 rounded-xl
              bg-gradient-to-r from-blue-600 to-blue-500 text-white
              font-semibold text-sm
              shadow-lg shadow-blue-500/25
              hover:shadow-xl hover:shadow-blue-500/30 hover:from-blue-700 hover:to-blue-600
              active:scale-[0.98]
              transition-all duration-200
              disabled:opacity-50 disabled:cursor-not-allowed
            "
          >
            <Plus className="h-5 w-5" />
            Thêm dịch vụ
          </button>
        }
      />
      <div className="divide-y divide-gray-100">
        {/* Service list header */}
        <div
          className="flex items-center justify-between px-6 py-5 cursor-pointer hover:bg-gray-50 transition-colors"
          onClick={() => setServiceDetailsExpanded(!serviceDetailsExpanded)}
        >
          <div className="flex items-center gap-4">
            <Checkbox
              checked={true}
              onChange={() => {}}
              onClick={(e) => e.stopPropagation()}
              disabled={readOnly}
            />
            <ChevronRight
              className={`h-5 w-5 text-gray-400 transition-transform duration-300 ${
                serviceDetailsExpanded ? "rotate-90" : ""
              }`}
            />
            <span className="text-base font-medium text-gray-800">Dịch vụ chuyến đi</span>
          </div>
          <span className="text-lg font-bold text-gray-900">
            {totalAmount.toLocaleString("vi-VN")} ₫
          </span>
        </div>

        {/* Service details */}
        {serviceDetailsExpanded && (
          <div className="bg-gradient-to-b from-gray-50 to-white">
            {serviceCharges.length === 0 ? (
              <div className="px-6 py-10 text-center">
                <div className="p-4 rounded-2xl bg-gray-100 w-fit mx-auto mb-4">
                  <Wallet className="h-12 w-12 text-gray-400" />
                </div>
                <p className="text-gray-500 font-semibold text-lg mb-1">Chưa có dịch vụ</p>
                <p className="text-gray-400 text-sm">Nhấn "Thêm dịch vụ" để bắt đầu</p>
              </div>
            ) : (
              <div className="divide-y divide-gray-100">
                {serviceCharges.map((charge) => (
                  <div key={charge.id} className="flex items-center justify-between px-6 py-4 hover:bg-gray-50 transition-colors">
                    <span className="text-base font-medium text-gray-700">
                      {charge.serviceType?.name || "Dịch vụ"}
                    </span>
                    <span className="text-base text-gray-900 font-semibold">
                      {charge.totalAmount.toLocaleString("vi-VN")} ₫
                    </span>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Total - Much more prominent */}
        <div className="relative overflow-hidden">
          {/* Background pattern */}
          <div className="absolute inset-0 bg-gradient-to-r from-blue-600 to-cyan-500" />
          <div className="absolute inset-0 opacity-10">
            <div className="absolute inset-0" style={{
              backgroundImage: `radial-gradient(circle at 2px 2px, white 1px, transparent 0)`,
              backgroundSize: '20px 20px'
            }} />
          </div>
          
          <div className="relative flex items-center justify-between px-6 py-6">
            <div className="flex items-center gap-3">
              <div className="p-2.5 rounded-xl bg-white/20 backdrop-blur">
                <Wallet className="h-6 w-6 text-white" />
              </div>
              <span className="text-lg font-bold text-white">TỔNG TIỀN</span>
            </div>
            <span className="text-3xl font-extrabold text-white tracking-tight">
              {totalAmount.toLocaleString("vi-VN")} ₫
            </span>
          </div>
        </div>
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/TransportOrderSection.tsx">
import { FileText, Hash, MapPin, Clock } from "lucide-react";
import { format } from "date-fns";
import { Autocomplete } from "@/components/ui/autocomplete";
import { DatePicker } from "@/components/DatePicker";
import { GlassCard, SectionHeader, FormField, StyledInput } from "@/components/shared/styled-components";
import type { Route } from "@/types";

interface TransportOrderSectionProps {
  readOnly: boolean;
  transportOrderCode: string;
  setTransportOrderCode: (value: string) => void;
  seatCount: string;
  setSeatCount: (value: string) => void;
  bedCount: string;
  setBedCount: (value: string) => void;
  hhTicketCount: string;
  setHhTicketCount: (value: string) => void;
  hhPercentage: string;
  setHhPercentage: (value: string) => void;
  routeId: string;
  setRouteId: (value: string) => void;
  routes: Route[];
  departureTime: string;
  setDepartureTime: (value: string) => void;
  departureDate: string;
  setDepartureDate: (value: string) => void;
  scheduleId: string;
  validationErrors?: Record<string, string>;
}

export function TransportOrderSection({
  readOnly,
  transportOrderCode,
  setTransportOrderCode,
  seatCount,
  setSeatCount,
  bedCount,
  setBedCount,
  hhTicketCount,
  setHhTicketCount,
  hhPercentage,
  setHhPercentage,
  routeId,
  setRouteId,
  routes,
  departureTime,
  setDepartureTime,
  departureDate,
  setDepartureDate,
  scheduleId,
  validationErrors = {},
}: TransportOrderSectionProps) {
  return (
    <GlassCard>
      <SectionHeader icon={FileText} title="Lệnh vận chuyển" />
      <div className="p-6 space-y-5">
        {/* Transport Order Code - Prominent input */}
        <FormField label="Mã lệnh vận chuyển" required error={validationErrors.transportOrderCode}>
          <div className="relative">
            <div className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400">
              <Hash className="h-5 w-5" />
            </div>
            <StyledInput
              value={transportOrderCode}
              onChange={(e) => setTransportOrderCode(e.target.value)}
              placeholder="Nhập mã lệnh vận chuyển"
              autoComplete="off"
              readOnly={readOnly}
              className={`pl-12 ${validationErrors.transportOrderCode ? "border-rose-400 focus:border-rose-500 focus:ring-rose-500/30" : ""}`}
            />
          </div>
        </FormField>

        {/* Capacity Grid */}
        <div className="grid grid-cols-4 gap-4">
          <FormField label="Số ghế" required error={validationErrors.seatCount}>
            <StyledInput
              type="number"
              value={seatCount}
              onChange={(e) => setSeatCount(e.target.value)}
              min="1"
              readOnly={readOnly}
              className={`text-center ${validationErrors.seatCount ? "!border-rose-400 focus:border-rose-500 focus:ring-rose-500/30" : ""}`}
            />
          </FormField>
          <FormField label="Số giường">
            <StyledInput
              type="number"
              value={bedCount}
              onChange={(e) => setBedCount(e.target.value)}
              min="0"
              readOnly={readOnly}
              className="text-center"
            />
          </FormField>
          <FormField label="Số vé HH">
            <StyledInput
              type="number"
              value={hhTicketCount}
              onChange={(e) => setHhTicketCount(e.target.value)}
              min="0"
              readOnly={readOnly}
              className="text-center"
            />
          </FormField>
          <FormField label="% HH">
            <StyledInput
              type="number"
              value={hhPercentage}
              onChange={(e) => setHhPercentage(e.target.value)}
              min="0"
              max="100"
              readOnly={readOnly}
              className="text-center"
            />
          </FormField>
        </div>

        {/* Route Selection */}
        <FormField label="Tuyến vận chuyển" required error={validationErrors.routeId}>
          <div className="relative">
            <div className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 z-10 pointer-events-none">
              <MapPin className="h-5 w-5" />
            </div>
            <Autocomplete
              value={routeId}
              onChange={(value) => setRouteId(value)}
              options={routes.map((r) => ({
                value: r.id,
                label: `${r.routeName} (${r.routeCode})${r.distanceKm ? ` - ${r.distanceKm} Km` : ""}`,
              }))}
              placeholder="Gõ để tìm tuyến..."
              disabled={readOnly}
              className={`w-full [&_input]:pl-12 ${validationErrors.routeId ? "[&_input]:border-rose-400" : ""}`}
            />
          </div>
        </FormField>

        {/* Time & Date - Side by side with icons */}
        <div className="grid grid-cols-2 gap-5">
          <FormField label="Giờ xuất bến khác" required={!scheduleId} error={validationErrors.departureTime}>
            <div className="relative">
              <div className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400">
                <Clock className="h-5 w-5" />
              </div>
              <StyledInput
                type="time"
                value={departureTime}
                onChange={(e) => setDepartureTime(e.target.value)}
                readOnly={readOnly}
                className={`pl-12 font-bold ${validationErrors.departureTime ? "border-rose-400 focus:border-rose-500 focus:ring-rose-500/30" : ""}`}
              />
            </div>
          </FormField>
          <FormField label="Ngày xuất bến" required error={validationErrors.departureDate}>
            <div className={`relative ${validationErrors.departureDate ? "[&_button]:border-rose-400" : ""}`}>
              <DatePicker
                date={departureDate ? new Date(departureDate) : null}
                onDateChange={(date) => setDepartureDate(date ? format(date, "yyyy-MM-dd") : "")}
                placeholder="Chọn ngày"
                disabled={readOnly}
              />
            </div>
          </FormField>
        </div>
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/sections/VehicleImageSection.tsx">
import { useState, useRef } from "react";
import { Camera, Upload, Car, X, Loader2, Image } from "lucide-react";
import { toast } from "react-toastify";
import { GlassCard, SectionHeader } from "@/components/shared/styled-components";
import api from "@/lib/api";

interface VehicleImageSectionProps {
  vehicleImageUrl?: string | null;
  entryImageUrl?: string | null;
  dispatchId: string;
  onEntryImageUpdated?: (newUrl: string) => void;
}

export function VehicleImageSection({
  vehicleImageUrl,
  entryImageUrl,
  dispatchId,
  onEntryImageUpdated,
}: VehicleImageSectionProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(entryImageUrl || null);
  const [activeTab, setActiveTab] = useState<"entry" | "vehicle">("entry");
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
      toast.error("Vui lòng chọn file ảnh");
      return;
    }

    if (file.size > 5 * 1024 * 1024) {
      toast.error("Kích thước ảnh không được vượt quá 5MB");
      return;
    }

    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);

      const uploadResponse = await api.post<{ url: string }>("/upload", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });

      const imageUrl = uploadResponse.data.url;

      await api.patch(`/dispatch/${dispatchId}/entry-image`, {
        entryImageUrl: imageUrl,
      });

      setPreviewUrl(imageUrl);
      onEntryImageUpdated?.(imageUrl);
      toast.success("Đã cập nhật ảnh xe vào bến");
    } catch (error) {
      console.error("Upload failed:", error);
      toast.error("Không thể upload ảnh. Vui lòng thử lại.");
    } finally {
      setIsUploading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  const handleRemoveEntryImage = async () => {
    if (!previewUrl) return;
    
    try {
      await api.patch(`/dispatch/${dispatchId}/entry-image`, {
        entryImageUrl: "",
      });
      setPreviewUrl(null);
      onEntryImageUpdated?.("");
      toast.success("Đã xóa ảnh xe vào bến");
    } catch (error) {
      console.error("Remove failed:", error);
      toast.error("Không thể xóa ảnh. Vui lòng thử lại.");
    }
  };

  const currentImage = activeTab === "entry" ? previewUrl : vehicleImageUrl;

  return (
    <GlassCard>
      <SectionHeader icon={Camera} title="Ảnh xe" />
      <div className="p-6">
        {/* Tab buttons - More prominent */}
        <div className="flex gap-3 mb-5">
          <button
            onClick={() => setActiveTab("entry")}
            className={`
              flex-1 px-5 py-3.5 rounded-xl font-bold text-base
              transition-all duration-200 flex items-center justify-center gap-3
              ${activeTab === "entry"
                ? "bg-gradient-to-r from-blue-600 to-blue-500 text-white shadow-lg shadow-blue-500/30"
                : "bg-gray-100 text-gray-600 hover:bg-gray-200 hover:text-gray-800 border-2 border-transparent"
              }
            `}
          >
            <Camera className="h-5 w-5" />
            Vào bến
          </button>
          <button
            onClick={() => setActiveTab("vehicle")}
            className={`
              flex-1 px-5 py-3.5 rounded-xl font-bold text-base
              transition-all duration-200 flex items-center justify-center gap-3
              ${activeTab === "vehicle"
                ? "bg-gradient-to-r from-blue-600 to-blue-500 text-white shadow-lg shadow-blue-500/30"
                : "bg-gray-100 text-gray-600 hover:bg-gray-200 hover:text-gray-800 border-2 border-transparent"
              }
            `}
          >
            <Car className="h-5 w-5" />
            Đăng ký
          </button>
        </div>

        {/* Image display area - Enhanced */}
        <div className="relative aspect-video rounded-2xl bg-gradient-to-b from-gray-50 to-gray-100 border-2 border-dashed border-gray-300 overflow-hidden">
          {isUploading ? (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm">
              <div className="p-4 rounded-2xl bg-blue-50 mb-4">
                <Loader2 className="h-10 w-10 text-blue-600 animate-spin" />
              </div>
              <p className="text-gray-700 font-semibold text-lg">Đang tải ảnh...</p>
            </div>
          ) : currentImage ? (
            <>
              <img
                src={currentImage}
                alt={activeTab === "entry" ? "Ảnh xe vào bến" : "Ảnh đăng ký xe"}
                className="w-full h-full object-cover"
              />
              {activeTab === "entry" && previewUrl && (
                <button
                  onClick={handleRemoveEntryImage}
                  className="
                    absolute top-3 right-3 p-2.5 
                    bg-gradient-to-r from-rose-500 to-red-500 text-white 
                    rounded-xl hover:from-rose-600 hover:to-red-600 
                    transition-all duration-200 shadow-xl shadow-rose-500/30
                    active:scale-95
                  "
                  title="Xóa ảnh"
                >
                  <X className="h-5 w-5" />
                </button>
              )}
            </>
          ) : (
            <div className="absolute inset-0 flex flex-col items-center justify-center">
              <div className="p-5 rounded-2xl bg-gray-200/50 mb-4">
                <Image className="h-14 w-14 text-gray-400" />
              </div>
              <p className="text-gray-500 font-semibold text-lg mb-2">
                {activeTab === "entry" ? "Chưa có ảnh vào bến" : "Chưa có ảnh đăng ký"}
              </p>
              <p className="text-gray-400 text-sm">
                {activeTab === "entry" ? "Tải ảnh lên để xác nhận xe vào bến" : "Ảnh đăng ký của xe"}
              </p>
            </div>
          )}
        </div>

        {/* Upload button (only for entry tab) - More prominent */}
        {activeTab === "entry" && (
          <div className="mt-5">
            <input
              ref={fileInputRef}
              type="file"
              accept="image/*"
              onChange={handleFileSelect}
              className="hidden"
              id="entry-image-upload"
            />
            <label
              htmlFor="entry-image-upload"
              className={`
                flex items-center justify-center gap-3 w-full px-6 py-4 rounded-xl 
                text-lg font-bold cursor-pointer transition-all duration-200
                ${isUploading
                  ? "bg-gray-100 text-gray-400 cursor-not-allowed"
                  : previewUrl
                    ? "bg-gray-100 text-gray-700 hover:bg-gray-200 border-2 border-gray-200"
                    : "bg-gradient-to-r from-blue-600 to-cyan-500 text-white shadow-lg shadow-blue-500/30 hover:shadow-xl hover:shadow-blue-500/40"
                }
              `}
            >
              <Upload className="h-6 w-6" />
              {previewUrl ? "Thay đổi ảnh" : "Tải ảnh lên"}
            </label>
          </div>
        )}
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/layout/PublicFooter.tsx">
import { Link } from "react-router-dom"
import { Facebook, Youtube, Linkedin, Instagram, Mail, Phone, MapPin, Bus, ArrowRight } from "lucide-react"

export function PublicFooter() {
  return (
    <footer className="bg-stone-900 text-stone-400">
      {/* Newsletter Section */}
      <div className="border-b border-stone-800">
        <div className="container mx-auto px-4 lg:px-8 py-12">
          <div className="flex flex-col lg:flex-row items-center justify-between gap-6">
            <div>
              <h3 className="text-xl font-semibold text-white mb-2">Cập nhật tin tức mới nhất</h3>
              <p className="text-stone-500">Đăng ký nhận bản tin về giải pháp và ưu đãi từ ABC C&T</p>
            </div>
            <div className="flex gap-3 w-full lg:w-auto">
              <input
                type="email"
                placeholder="Email của bạn"
                className="flex-1 lg:w-72 bg-stone-800 border border-stone-700 rounded-xl px-4 py-3 text-white placeholder:text-stone-500 focus:outline-none focus:border-emerald-500 transition-colors"
              />
              <button className="bg-emerald-500 hover:bg-emerald-600 text-white px-6 py-3 rounded-xl font-medium transition-colors flex items-center gap-2">
                Đăng ký
                <ArrowRight className="w-4 h-4" />
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Main Footer Content */}
      <div className="container mx-auto px-4 lg:px-8 py-16">
        <div className="grid md:grid-cols-2 lg:grid-cols-5 gap-12">
          {/* Brand Column */}
          <div className="lg:col-span-2">
            <Link to="/" className="inline-flex items-center gap-3 mb-6">
              <div className="w-10 h-10 bg-gradient-to-br from-emerald-500 to-teal-500 rounded-xl flex items-center justify-center">
                <Bus className="w-5 h-5 text-white" />
              </div>
              <span className="font-display text-2xl text-white">ABC C&T</span>
            </Link>
            <p className="text-stone-500 leading-relaxed mb-6 max-w-sm">
              Giải pháp công nghệ toàn diện cho bến xe và doanh nghiệp vận tải.
              Đồng hành cùng ngành vận tải Việt Nam trong kỷ nguyên số.
            </p>
            <div className="flex gap-3">
              {[
                { icon: Facebook, href: 'https://facebook.com' },
                { icon: Youtube, href: 'https://youtube.com' },
                { icon: Linkedin, href: 'https://linkedin.com' },
                { icon: Instagram, href: 'https://instagram.com' }
              ].map((social, i) => (
                <a
                  key={i}
                  href={social.href}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="w-10 h-10 bg-stone-800 hover:bg-emerald-500 rounded-xl flex items-center justify-center text-stone-400 hover:text-white transition-all duration-300"
                >
                  <social.icon className="w-4 h-4" />
                </a>
              ))}
            </div>
          </div>

          {/* Khám phá */}
          <div>
            <h4 className="text-white font-semibold mb-5">Khám phá</h4>
            <ul className="space-y-3 text-sm">
              {[
                { label: 'Trang chủ', to: '/home' },
                { label: 'Về chúng tôi', to: '/about' },
                { label: 'Case study', to: '/case-study' },
                { label: 'Blog', to: '/blog' },
                { label: 'Tuyển dụng', to: '/careers' }
              ].map((link, i) => (
                <li key={i}>
                  <Link
                    to={link.to}
                    className="text-stone-500 hover:text-emerald-400 transition-colors"
                  >
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </div>

          {/* Giải pháp */}
          <div>
            <h4 className="text-white font-semibold mb-5">Giải pháp</h4>
            <ul className="space-y-3 text-sm">
              {[
                { label: 'Lệnh điện tử', to: '/products' },
                { label: 'Vé xe điện tử', to: '/products' },
                { label: 'Chữ ký số HSM', to: '/products' },
                { label: 'Bán vé ủy thác', to: '/products' },
                { label: 'Bảng giá', to: '/pricing' }
              ].map((link, i) => (
                <li key={i}>
                  <Link
                    to={link.to}
                    className="text-stone-500 hover:text-emerald-400 transition-colors"
                  >
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </div>

          {/* Liên hệ */}
          <div>
            <h4 className="text-white font-semibold mb-5">Liên hệ</h4>
            <ul className="space-y-4 text-sm">
              <li>
                <a
                  href="mailto:abctn@gmail.com"
                  className="flex items-center gap-3 text-stone-500 hover:text-emerald-400 transition-colors"
                >
                  <div className="w-8 h-8 bg-stone-800 rounded-lg flex items-center justify-center">
                    <Mail className="w-4 h-4" />
                  </div>
                  abctn@gmail.com
                </a>
              </li>
              <li>
                <a
                  href="tel:19004751"
                  className="flex items-center gap-3 text-stone-500 hover:text-emerald-400 transition-colors"
                >
                  <div className="w-8 h-8 bg-stone-800 rounded-lg flex items-center justify-center">
                    <Phone className="w-4 h-4" />
                  </div>
                  1900.4751
                </a>
              </li>
              <li className="flex items-start gap-3 text-stone-500">
                <div className="w-8 h-8 bg-stone-800 rounded-lg flex items-center justify-center flex-shrink-0 mt-0.5">
                  <MapPin className="w-4 h-4" />
                </div>
                <span>Trụ sở chính: ABC</span>
              </li>
            </ul>
          </div>
        </div>
      </div>

      {/* Bottom Bar */}
      <div className="border-t border-stone-800">
        <div className="container mx-auto px-4 lg:px-8 py-6">
          <div className="flex flex-col md:flex-row items-center justify-between gap-4 text-sm">
            <p className="text-stone-600">
              © {new Date().getFullYear()} ABC C&T. Tất cả quyền được bảo lưu.
            </p>
            <div className="flex items-center gap-6">
              <Link to="/privacy" className="text-stone-500 hover:text-emerald-400 transition-colors">
                Chính sách bảo mật
              </Link>
              <Link to="/terms" className="text-stone-500 hover:text-emerald-400 transition-colors">
                Điều khoản sử dụng
              </Link>
            </div>
          </div>
        </div>
      </div>
    </footer>
  )
}
</file>

<file path="client/src/components/layout/PublicHeader.tsx">
import { useState, useEffect } from "react"
import { Link, useLocation } from "react-router-dom"
import { Menu, X, ChevronDown } from "lucide-react"
import { Button } from "@/components/ui/button"
import { useAuthStore } from "@/store/auth.store"
import { UserDropdown } from "./UserDropdown"
import logo from "@/assets/logo.png"

interface NavItem {
  label: string
  path: string
  hasDropdown?: boolean
  dropdownItems?: { label: string; path: string }[]
  dropdownCategories?: {
    title: string
    path: string
    items: { label: string; path: string }[]
    underlineColor: "gray" | "teal" | "purple" | "amber"
  }[]
}

const navItems: NavItem[] = [
  { label: "Trang chủ", path: "/" },
  {
    label: "Sản phẩm",
    path: "/products",
    hasDropdown: true,
    dropdownCategories: [
      {
        title: "CỔNG VÀO RA TỰ ĐỘNG",
        path: "/products/gate",
        underlineColor: "gray",
        items: [
          { label: "Phần mềm quản lý vào - ra", path: "/products/gate/management" },
          { label: "Vé điện tử tại vào ra cổng", path: "/products/gate/electronic-ticket" },
          { label: "Thiết bị điều khiển cổng vào ra", path: "/products/gate/equipment" },
        ],
      },
      {
        title: "BẾN XE KHÁCH",
        path: "/products/bus-station",
        underlineColor: "teal",
        items: [
          { label: "Phần mềm quản lý bến xe", path: "/products/bus-station/management" },
          { label: "Ký số & Lệnh vận chuyển điện tử", path: "/products/bus-station/digital-signature" },
          { label: "Phần mềm bán vé tại bến", path: "/products/bus-station/ticket-sales" },
          { label: "Giải pháp thanh toán điện tử", path: "/products/bus-station/payment" },
        ],
      },
      {
        title: "DOANH NGHIỆP VẬN TẢI",
        path: "/products/transport",
        underlineColor: "teal",
        items: [
          { label: "Vé xe khách điện tử", path: "/products/transport/electronic-ticket" },
          { label: "Phần mềm bán vé điện tử", path: "/products/transport/ticket-software" },
          { label: "Lệnh vận chuyển điện tử", path: "/products/transport/dispatch-order" },
          { label: "Phần mềm quản lý chuyến xe", path: "/products/transport/trip-management" },
          { label: "Moblie app Lái Xe", path: "/products/transport/driver-app" },
        ],
      },
      {
        title: "ĐỐI TÁC ABC",
        path: "/products/partner",
        underlineColor: "gray",
        items: [
          { label: "Hóa đơn điện tử - Hilo Invoice", path: "/products/partner/hilo-invoice" },
          { label: "Hợp đồng điện tử - Hilo Contract", path: "/products/partner/hilo-contract" },
          { label: "Chữ ký số - Hilo CA", path: "/products/partner/hilo-ca" },
          { label: "Kiosk bán vé tự phục vụ", path: "/products/partner/kiosk" },
        ],
      },
    ],
  },
  {
    label: "Bảng giá",
    path: "/pricing",
    hasDropdown: true,
    dropdownItems: [
      { label: "Bảng giá vé xe khách điện tử", path: "/pricing/electronic-ticket" },
      { label: "Bảng giá lệnh vận chuyển điện tử", path: "/pricing/dispatch-order" },
      { label: "Bảng giá chữ ký số ICORP", path: "/pricing/icorp-signature" },
      { label: "Bảng giá HĐĐT - ICORP", path: "/pricing/icorp-invoice" },
    ],
  },
  {
    label: "Hướng dẫn sử dụng",
    path: "/guide",
    hasDropdown: true,
    dropdownCategories: [
      {
        title: "DÀNH CHO BẾN XE KHÁCH",
        path: "/guide/bus-station",
        underlineColor: "teal",
        items: [
          { label: "Bán vé ủy thác", path: "/guide/bus-station/consignment" },
          { label: "Điều độ", path: "/guide/bus-station/dispatch" },
          { label: "Thanh toán", path: "/guide/bus-station/payment" },
          { label: "Báo cáo - thống kê", path: "/guide/bus-station/reports" },
        ],
      },
      {
        title: "DÀNH CHO DOANH NGHIỆP VẬN TẢI",
        path: "/guide/transport",
        underlineColor: "purple",
        items: [
          { label: "Lệnh điện tử", path: "/guide/transport/electronic-order" },
          { label: "Bán vé điện tử", path: "/guide/transport/electronic-ticket" },
          { label: "Khởi tạo thông tin", path: "/guide/transport/init-data" },
          { label: "Thiết lập kế hoạch hoạt động", path: "/guide/transport/activity-plan" },
          { label: "Báo cáo - thống kê", path: "/guide/transport/reports" },
        ],
      },
      {
        title: "DÀNH CHO LÁI XE",
        path: "/guide/driver",
        underlineColor: "amber",
        items: [
          { label: "Lệnh vận chuyển điện tử", path: "/guide/driver/dispatch-order" },
          { label: "Bán vé điện tử trên xe", path: "/guide/driver/onboard-ticket" },
          { label: "Cài đặt app SLaiXe", path: "/guide/driver/slaixe-app" },
        ],
      },
    ],
  },
  { label: "Trợ giúp", path: "/help" },
]

export function PublicHeader() {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const [openDropdown, setOpenDropdown] = useState<string | null>(null)
  const [scrolled, setScrolled] = useState(false)
  const location = useLocation()
  const { isAuthenticated } = useAuthStore()

  // Track scroll for header styling
  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 20)
    }
    window.addEventListener("scroll", handleScroll)
    return () => window.removeEventListener("scroll", handleScroll)
  }, [])

  const isActive = (path: string) => {
    if (path === "/") {
      return location.pathname === "/"
    }
    return location.pathname.startsWith(path)
  }

  const handleDropdownToggle = (label: string) => {
    setOpenDropdown(openDropdown === label ? null : label)
  }

  return (
    <header
      className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
        scrolled
          ? "bg-white/95 backdrop-blur-md shadow-sm border-b border-stone-200/50"
          : "bg-white border-b border-stone-100"
      }`}
    >
      <div className="container mx-auto px-4 lg:px-8">
        <div className="flex h-16 lg:h-18 items-center justify-between">
          {/* Logo - Elegant Typography */}
          <Link to="/" className="flex items-center gap-3 group">
            <img
              src={logo}
              alt="ABC C&T"
              className="h-10 lg:h-11 w-auto transition-transform group-hover:scale-105"
            />
            <span className="font-display text-xl lg:text-2xl font-semibold text-stone-800 tracking-tight">
              ABC C&T
            </span>
          </Link>

          {/* Desktop Navigation - Centered */}
          <nav className="hidden lg:flex items-center">
            {navItems.map((item) => (
              <div key={item.label} className="relative group">
                <Link
                  to={item.path}
                  className={`relative flex items-center gap-1.5 px-4 py-2 text-sm font-medium transition-colors ${
                    isActive(item.path)
                      ? "text-emerald-600"
                      : "text-stone-600 hover:text-stone-900"
                  }`}
                  onClick={() => !item.hasDropdown && setOpenDropdown(null)}
                  onMouseEnter={() => item.hasDropdown && setOpenDropdown(item.label)}
                >
                  {item.label}
                  {item.hasDropdown && (
                    <ChevronDown className={`h-3.5 w-3.5 transition-transform duration-200 ${
                      openDropdown === item.label ? "rotate-180" : ""
                    }`} />
                  )}
                  {/* Active indicator */}
                  {isActive(item.path) && (
                    <span className="absolute bottom-0 left-4 right-4 h-0.5 bg-emerald-500 rounded-full" />
                  )}
                </Link>

                {/* Mega Menu Dropdown */}
                {item.hasDropdown && item.dropdownCategories && (
                  <div
                    className={`absolute top-full left-1/2 -translate-x-1/2 mt-2 bg-white rounded-2xl shadow-xl shadow-stone-200/50 border border-stone-100 py-6 transition-all duration-200 ${
                      openDropdown === item.label
                        ? "opacity-100 visible translate-y-0"
                        : "opacity-0 invisible -translate-y-2"
                    }`}
                    style={{ width: "max-content", minWidth: "720px" }}
                    onMouseEnter={() => setOpenDropdown(item.label)}
                    onMouseLeave={() => setOpenDropdown(null)}
                  >
                    <div className="grid grid-cols-4 gap-8 px-8">
                      {item.dropdownCategories.map((category) => (
                        <div key={category.path} className="min-w-[160px]">
                          <Link
                            to={category.path}
                            className={`block mb-3 pb-2 text-xs font-bold tracking-wide text-stone-400 uppercase border-b-2 transition-colors hover:text-stone-600 ${
                              category.underlineColor === "teal"
                                ? "border-emerald-400"
                                : category.underlineColor === "purple"
                                ? "border-violet-400"
                                : category.underlineColor === "amber"
                                ? "border-amber-400"
                                : "border-stone-300"
                            }`}
                            onClick={() => setOpenDropdown(null)}
                          >
                            {category.title}
                          </Link>
                          <ul className="space-y-2">
                            {category.items.map((subItem) => (
                              <li key={subItem.path}>
                                <Link
                                  to={subItem.path}
                                  className="block text-sm text-stone-600 hover:text-emerald-600 transition-colors"
                                  onClick={() => setOpenDropdown(null)}
                                >
                                  {subItem.label}
                                </Link>
                              </li>
                            ))}
                          </ul>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Simple Dropdown */}
                {item.hasDropdown && item.dropdownItems && !item.dropdownCategories && (
                  <div
                    className={`absolute top-full left-0 mt-2 w-72 bg-white rounded-xl shadow-xl shadow-stone-200/50 border border-stone-100 py-2 transition-all duration-200 ${
                      openDropdown === item.label
                        ? "opacity-100 visible translate-y-0"
                        : "opacity-0 invisible -translate-y-2"
                    }`}
                    onMouseEnter={() => setOpenDropdown(item.label)}
                    onMouseLeave={() => setOpenDropdown(null)}
                  >
                    {item.dropdownItems.map((dropdownItem) => (
                      <Link
                        key={dropdownItem.path}
                        to={dropdownItem.path}
                        className="block px-4 py-2.5 text-sm text-stone-600 hover:bg-stone-50 hover:text-emerald-600 transition-colors"
                        onClick={() => setOpenDropdown(null)}
                      >
                        {dropdownItem.label}
                      </Link>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </nav>

          {/* Right side actions */}
          <div className="hidden lg:flex items-center gap-3">
            {isAuthenticated ? (
              <UserDropdown variant="desktop" />
            ) : (
              <>
                <Link to="/login">
                  <Button
                    variant="ghost"
                    className="text-stone-600 hover:text-stone-900 hover:bg-stone-100 font-medium"
                  >
                    Đăng nhập
                  </Button>
                </Link>
                <Link to="/lien-he">
                  <Button className="bg-emerald-600 hover:bg-emerald-700 text-white font-medium px-6 rounded-full shadow-sm shadow-emerald-500/20">
                    Liên hệ
                  </Button>
                </Link>
              </>
            )}
          </div>

          {/* Mobile menu button */}
          <Button
            variant="ghost"
            size="icon"
            className="lg:hidden text-stone-700"
            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
            aria-label="Toggle menu"
          >
            {mobileMenuOpen ? (
              <X className="h-6 w-6" />
            ) : (
              <Menu className="h-6 w-6" />
            )}
          </Button>
        </div>

        {/* Mobile Navigation */}
        {mobileMenuOpen && (
          <div className="lg:hidden border-t border-stone-100 py-4 bg-white">
            <nav className="flex flex-col gap-1">
              {navItems.map((item) => (
                <div key={item.label}>
                  <Link
                    to={item.path}
                    className={`flex items-center justify-between px-4 py-3 rounded-lg text-sm font-medium transition-colors ${
                      isActive(item.path)
                        ? "text-emerald-600 bg-emerald-50"
                        : "text-stone-700 hover:bg-stone-50"
                    }`}
                    onClick={() => {
                      if (item.hasDropdown) {
                        handleDropdownToggle(item.label)
                      } else {
                        setMobileMenuOpen(false)
                      }
                    }}
                  >
                    {item.label}
                    {item.hasDropdown && (
                      <ChevronDown
                        className={`h-4 w-4 transition-transform ${
                          openDropdown === item.label ? "rotate-180" : ""
                        }`}
                      />
                    )}
                  </Link>
                  {item.hasDropdown &&
                    item.dropdownCategories &&
                    openDropdown === item.label && (
                      <div className="mt-1 ml-4 space-y-4 py-2">
                        {item.dropdownCategories.map((category) => (
                          <div key={category.path}>
                            <Link
                              to={category.path}
                              className={`block mb-2 pb-1 font-semibold text-xs tracking-wide text-stone-400 uppercase border-b ${
                                category.underlineColor === "teal"
                                  ? "border-emerald-300"
                                  : "border-stone-200"
                              }`}
                              onClick={() => setMobileMenuOpen(false)}
                            >
                              {category.title}
                            </Link>
                            <ul className="ml-2 space-y-1">
                              {category.items.map((subItem) => (
                                <li key={subItem.path}>
                                  <Link
                                    to={subItem.path}
                                    className="block px-2 py-1.5 text-sm text-stone-600 rounded-md hover:bg-stone-50"
                                    onClick={() => setMobileMenuOpen(false)}
                                  >
                                    {subItem.label}
                                  </Link>
                                </li>
                              ))}
                            </ul>
                          </div>
                        ))}
                      </div>
                    )}
                  {item.hasDropdown &&
                    item.dropdownItems &&
                    !item.dropdownCategories &&
                    openDropdown === item.label && (
                      <div className="mt-1 ml-4 space-y-1 py-2">
                        {item.dropdownItems.map((dropdownItem) => (
                          <Link
                            key={dropdownItem.path}
                            to={dropdownItem.path}
                            className="block px-4 py-2 text-sm text-stone-600 rounded-lg hover:bg-stone-50"
                            onClick={() => setMobileMenuOpen(false)}
                          >
                            {dropdownItem.label}
                          </Link>
                        ))}
                      </div>
                    )}
                </div>
              ))}
              <div className="mt-4 pt-4 border-t border-stone-100 flex flex-col gap-2 px-4">
                {isAuthenticated ? (
                  <UserDropdown
                    variant="mobile"
                    onMenuClose={() => setMobileMenuOpen(false)}
                  />
                ) : (
                  <>
                    <Link to="/login" onClick={() => setMobileMenuOpen(false)}>
                      <Button variant="outline" className="w-full rounded-lg border-stone-200">
                        Đăng nhập
                      </Button>
                    </Link>
                    <Link to="/lien-he" onClick={() => setMobileMenuOpen(false)}>
                      <Button className="w-full rounded-lg bg-emerald-600 hover:bg-emerald-700">
                        Liên hệ
                      </Button>
                    </Link>
                  </>
                )}
              </div>
            </nav>
          </div>
        )}
      </div>
    </header>
  )
}
</file>

<file path="client/src/components/layout/Sidebar.tsx">
import { Link, useLocation } from "react-router-dom";
import { useState } from "react";
import {
  Home,
  LayoutDashboard,
  Bus,
  Users,
  Route,
  BarChart3,
  CreditCard,
  Building2,
  LogOut,
  ChevronDown,
  ChevronRight,
  MapPin,
  Plus,
  CarFront,
  Package,
  Calculator,
  Clock,
  Wallet,
  Database,
  Send,
  CircleOff,
  ArrowRightFromLine,
  ArrowLeftFromLine,
  FileSpreadsheet,
  ClipboardList,
  Receipt,
  ShieldCheck,
  CalendarCheck,
  History,
  Award,
  TrendingUp,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { useAuthStore } from "@/store/auth.store";
import logo from "@/assets/logo.png";

// Main navigation items
const navigation = [
  { name: "Trang chủ", href: "/", icon: Home },
  { name: "Tổng quan", href: "/dashboard", icon: LayoutDashboard },
  { name: "Điều độ xe", href: "/dieu-do", icon: ClipboardList },
  { name: "Thanh toán", href: "/thanh-toan", icon: Wallet },
];

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

export function Sidebar({ isOpen, onClose }: SidebarProps) {
  const location = useLocation();
  const logout = useAuthStore((state) => state.logout);
  const [isTruyenTaiOpen, setIsTruyenTaiOpen] = useState(false);
  const [isBaoCaoOpen, setIsBaoCaoOpen] = useState(false);
  const [isQuanLyOpen, setIsQuanLyOpen] = useState(false);

  const handleLogout = () => {
    logout();
    window.location.href = "/login";
  };

  const truyenTaiSubmenu = [
    { name: "Xe xuất bến", href: "/truyen-tai/xe-xuat-ben", icon: ArrowRightFromLine },
    { name: "Xe không đủ điều kiện", href: "/truyen-tai/xe-khong-du-dieu-kien", icon: CircleOff },
    { name: "Xe trả khách", href: "/truyen-tai/xe-tra-khach", icon: ArrowLeftFromLine },
  ];

  const baoCaoSubmenu = [
    { name: "Lập báo cáo", href: "/bao-cao/lap-bao-cao", icon: FileSpreadsheet },
    { name: "Bảng kê hóa đơn", href: "/bao-cao/bang-ke-hoa-don", icon: Receipt },
    { name: "Xe trả khách", href: "/bao-cao/xe-tra-khach", icon: ArrowLeftFromLine },
    { name: "Theo dõi lệnh xuất bến", href: "/bao-cao/theo-doi-lenh-xuat-ben", icon: ClipboardList },
    { name: "Theo dõi lệnh trả khách", href: "/bao-cao/theo-doi-lenh-tra-khach", icon: ClipboardList },
    { name: "Nhật trình xe", href: "/bao-cao/nhat-trinh-xe", icon: Clock },
    { name: "Xe đi thay", href: "/bao-cao/xe-di-thay", icon: Bus },
    { name: "Xe không đủ điều kiện", href: "/bao-cao/xe-khong-du-dieu-kien", icon: CircleOff },
    { name: "Xe ra vào bến", href: "/bao-cao/xe-ra-vao-ben", icon: Bus },
    { name: "Xe tăng cường", href: "/bao-cao/xe-tang-cuong", icon: BusPlusIcon },
    { name: "Báo cáo tổng hợp tuyến", href: "/bao-cao/tong-hop-tuyen", icon: Route },
    { name: "Báo cáo tổng hợp", href: "/bao-cao/tong-hop", icon: TrendingUp },
    { name: "Doanh thu bến bán vé", href: "/bao-cao/doanh-thu-ben-ban-ve", icon: CreditCard },
    { name: "Cấp phép ra bến", href: "/bao-cao/cap-phep-ra-ben", icon: ShieldCheck },
    { name: "Chấm công đăng tài", href: "/bao-cao/cham-cong-dang-tai", icon: CalendarCheck },
    { name: "Lịch sử giấy tờ", href: "/bao-cao/lich-su-giay-to", icon: History },
  ];

  const quanLySubmenu = [
    { name: "Quản lý xe", href: "/quan-ly-xe", icon: Bus },
    { name: "Quản lý lái xe", href: "/quan-ly-lai-xe", icon: Users },
    { name: "Đơn vị vận tải", href: "/quan-ly-don-vi-van-tai", icon: Building2 },
    { name: "Quản lý tuyến", href: "/quan-ly-tuyen", icon: Route },
    { name: "Bến đến", href: "/quan-ly-ben-den", icon: MapPin },
    { name: "Quản lý dịch vụ", href: "/quan-ly-dich-vu", icon: Package },
    { name: "Biểu thức", href: "/quan-ly-bieu-thuc", icon: Calculator },
    { name: "Phù hiệu xe", href: "/quan-ly-phu-hieu-xe", icon: Award },
    { name: "Danh sách ca trực", href: "/danh-sach-ca-truc", icon: Clock },
  ];

  // Check if any submenu item is active
  const isQuanLyActive = quanLySubmenu.some((item) => location.pathname === item.href);
  const isTruyenTaiActive = truyenTaiSubmenu.some((item) => location.pathname === item.href);
  const isBaoCaoActive = baoCaoSubmenu.some((item) => location.pathname === item.href);

  return (
    <>
      {/* Mobile overlay */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black/50 z-40 lg:hidden"
          onClick={onClose}
        />
      )}

      {/* Sidebar */}
      <aside
        className={cn(
          "fixed top-0 left-0 z-50 h-full w-64 bg-white border-r border-stone-200 transform transition-transform duration-300 ease-in-out lg:translate-x-0",
          isOpen ? "translate-x-0" : "-translate-x-full"
        )}
      >
        <div className="flex h-full flex-col">
          {/* Logo */}
          <div className="flex items-center justify-center border-b border-stone-100 px-6 py-4">
            <img
              src={logo}
              alt="Quản Lý Bến Xe"
              className="h-24 w-auto object-contain"
            />
          </div>

          {/* Navigation */}
          <nav className="flex-1 px-3 py-4 overflow-y-auto">
            {/* Main Navigation */}
            <div className="space-y-1">
              {navigation.map((item) => {
                const isActive = location.pathname === item.href;
                return (
                  <Link
                    key={item.name}
                    to={item.href}
                    onClick={onClose}
                    className={cn(
                      "flex items-center gap-3 rounded-lg px-3 py-2.5 text-sm font-medium transition-colors",
                      isActive
                        ? "bg-stone-100 text-stone-900 border-l-2 border-orange-500 -ml-[2px] pl-[14px]"
                        : "text-stone-600 hover:bg-stone-50 hover:text-stone-900"
                    )}
                  >
                    <item.icon className={cn("h-5 w-5", isActive ? "text-orange-500" : "text-stone-400")} />
                    {item.name}
                  </Link>
                );
              })}
            </div>

            {/* Quản lý thông tin Section */}
            <div className="mt-6">
              <button
                onClick={() => setIsQuanLyOpen(!isQuanLyOpen)}
                className={cn(
                  "w-full flex items-center justify-between gap-3 rounded-lg px-3 py-2.5 text-sm font-medium transition-colors",
                  isQuanLyActive
                    ? "bg-stone-100 text-stone-900"
                    : "text-stone-600 hover:bg-stone-50 hover:text-stone-900"
                )}
              >
                <div className="flex items-center gap-3">
                  <Database className={cn("h-5 w-5", isQuanLyActive ? "text-orange-500" : "text-stone-400")} />
                  <span>Quản lý thông tin</span>
                </div>
                {isQuanLyOpen ? (
                  <ChevronDown className="h-4 w-4 text-stone-400" />
                ) : (
                  <ChevronRight className="h-4 w-4 text-stone-400" />
                )}
              </button>

              {/* Submenu */}
              {isQuanLyOpen && (
                <div className="mt-1 ml-4 space-y-0.5 border-l border-stone-200 pl-3">
                  {quanLySubmenu.map((subItem) => {
                    const isSubActive = location.pathname === subItem.href;
                    return (
                      <Link
                        key={subItem.name}
                        to={subItem.href}
                        onClick={onClose}
                        className={cn(
                          "flex items-center gap-2.5 rounded-md px-2.5 py-2 text-sm transition-colors",
                          isSubActive
                            ? "bg-orange-50 text-orange-600 font-medium"
                            : "text-stone-500 hover:bg-stone-50 hover:text-stone-700"
                        )}
                      >
                        <subItem.icon className={cn("h-4 w-4", isSubActive ? "text-orange-500" : "text-stone-400")} />
                        {subItem.name}
                      </Link>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Truyền tải Section */}
            <div className="mt-2">
              <button
                onClick={() => setIsTruyenTaiOpen(!isTruyenTaiOpen)}
                className={cn(
                  "w-full flex items-center justify-between gap-3 rounded-lg px-3 py-2.5 text-sm font-medium transition-colors",
                  isTruyenTaiActive
                    ? "bg-stone-100 text-stone-900"
                    : "text-stone-600 hover:bg-stone-50 hover:text-stone-900"
                )}
              >
                <div className="flex items-center gap-3">
                  <Send className={cn("h-5 w-5", isTruyenTaiActive ? "text-orange-500" : "text-stone-400")} />
                  <span>Truyền tải</span>
                </div>
                {isTruyenTaiOpen ? (
                  <ChevronDown className="h-4 w-4 text-stone-400" />
                ) : (
                  <ChevronRight className="h-4 w-4 text-stone-400" />
                )}
              </button>

              {/* Submenu */}
              {isTruyenTaiOpen && (
                <div className="mt-1 ml-4 space-y-0.5 border-l border-stone-200 pl-3">
                  {truyenTaiSubmenu.map((subItem) => {
                    const isSubActive = location.pathname === subItem.href;
                    return (
                      <Link
                        key={subItem.name}
                        to={subItem.href}
                        onClick={onClose}
                        className={cn(
                          "flex items-center gap-2.5 rounded-md px-2.5 py-2 text-sm transition-colors",
                          isSubActive
                            ? "bg-orange-50 text-orange-600 font-medium"
                            : "text-stone-500 hover:bg-stone-50 hover:text-stone-700"
                        )}
                      >
                        <subItem.icon className={cn("h-4 w-4", isSubActive ? "text-orange-500" : "text-stone-400")} />
                        {subItem.name}
                      </Link>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Báo cáo Section */}
            <div className="mt-2">
              <button
                onClick={() => setIsBaoCaoOpen(!isBaoCaoOpen)}
                className={cn(
                  "w-full flex items-center justify-between gap-3 rounded-lg px-3 py-2.5 text-sm font-medium transition-colors",
                  isBaoCaoActive
                    ? "bg-stone-100 text-stone-900"
                    : "text-stone-600 hover:bg-stone-50 hover:text-stone-900"
                )}
              >
                <div className="flex items-center gap-3">
                  <BarChart3 className={cn("h-5 w-5", isBaoCaoActive ? "text-orange-500" : "text-stone-400")} />
                  <span>Báo cáo</span>
                </div>
                {isBaoCaoOpen ? (
                  <ChevronDown className="h-4 w-4 text-stone-400" />
                ) : (
                  <ChevronRight className="h-4 w-4 text-stone-400" />
                )}
              </button>

              {/* Submenu */}
              {isBaoCaoOpen && (
                <div className="mt-1 ml-4 space-y-0.5 border-l border-stone-200 pl-3">
                  {baoCaoSubmenu.map((subItem) => {
                    const isSubActive = location.pathname === subItem.href;
                    const IconComponent = subItem.icon;
                    return (
                      <Link
                        key={subItem.name}
                        to={subItem.href}
                        onClick={onClose}
                        className={cn(
                          "flex items-center gap-2.5 rounded-md px-2.5 py-2 text-sm transition-colors",
                          isSubActive
                            ? "bg-orange-50 text-orange-600 font-medium"
                            : "text-stone-500 hover:bg-stone-50 hover:text-stone-700"
                        )}
                      >
                        <IconComponent className={cn("h-4 w-4", isSubActive ? "text-orange-500" : "text-stone-400")} />
                        {subItem.name}
                      </Link>
                    );
                  })}
                </div>
              )}
            </div>
          </nav>

          {/* Logout button */}
          <div className="border-t border-stone-100 p-3">
            <button
              onClick={handleLogout}
              className="w-full flex items-center gap-3 rounded-lg px-3 py-2.5 text-sm font-medium text-stone-600 hover:bg-red-50 hover:text-red-600 transition-colors"
            >
              <LogOut className="h-5 w-5" />
              <span>Đăng xuất</span>
            </button>
          </div>
        </div>
      </aside>
    </>
  );
}

function BusPlusIcon({ className = "" }: { className?: string }) {
  return (
    <div className={`relative inline-flex ${className}`}>
      <CarFront className="h-4 w-4" />
      <div className="absolute -bottom-0.5 -right-0.5 bg-white rounded-full">
        <Plus className="h-2 w-2" strokeWidth={3} />
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/operator/common/OperatorGridCard.tsx">
import { Building2, Phone, User, Ticket, Eye, Edit, Trash2 } from "lucide-react";
import type { Operator } from "@/types";

interface OperatorWithSource extends Operator {
  source?: "database" | "legacy" | "google_sheets";
}

interface OperatorGridCardProps {
  operator: OperatorWithSource;
  index: number;
  onRowClick: (operator: Operator) => void;
  onView: (operator: Operator) => void;
  onEdit: (operator: OperatorWithSource) => void;
  onDelete: (operator: OperatorWithSource) => void;
}

export function OperatorGridCard({
  operator,
  index,
  onRowClick,
  onView,
  onEdit,
  onDelete,
}: OperatorGridCardProps) {
  const isReadOnly = operator.source === "legacy" || operator.source === "google_sheets";

  return (
    <div
      className="bg-white rounded-2xl border border-slate-200 p-5 hover:shadow-lg hover:border-orange-200 transition-all group hover:-translate-y-1 cursor-pointer"
      onClick={() => onRowClick(operator)}
      style={{
        animation: "fadeInUp 0.3s ease forwards",
        animationDelay: `${index * 50}ms`,
        opacity: 0,
      }}
    >
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-orange-100 to-amber-100 flex items-center justify-center group-hover:from-orange-500 group-hover:to-amber-500 transition-colors">
            <Building2 className="h-6 w-6 text-orange-600 group-hover:text-white transition-colors" />
          </div>
          <div>
            <h3 className="font-bold text-slate-800 line-clamp-1">
              {operator.name}
            </h3>
            <p className="text-sm text-slate-500 font-mono">
              {operator.code || operator.id?.substring(0, 8) || "-"}
            </p>
          </div>
        </div>
        <span
          className={`inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-semibold ${
            operator.isActive
              ? "bg-emerald-100 text-emerald-700"
              : "bg-slate-100 text-slate-600"
          }`}
        >
          <span
            className={`w-1.5 h-1.5 rounded-full ${
              operator.isActive ? "bg-emerald-500" : "bg-slate-400"
            }`}
          />
          {operator.isActive ? "Hoạt động" : "Ngừng"}
        </span>
      </div>

      <div className="space-y-2 mb-4">
        <div className="flex items-center gap-2 text-sm">
          <Phone className="h-4 w-4 text-slate-400" />
          <span className="text-slate-600">{operator.phone || "-"}</span>
        </div>
        <div className="flex items-center gap-2 text-sm">
          <User className="h-4 w-4 text-slate-400" />
          <span className="text-slate-600 truncate">
            {operator.representativeName || "-"}
          </span>
        </div>
        <div className="flex items-center gap-2 text-sm">
          <Ticket className="h-4 w-4 text-slate-400" />
          <span className="text-slate-600">
            {operator.isTicketDelegated ? "Có ủy thác vé" : "Không ủy thác"}
          </span>
        </div>
      </div>

      <div
        className="relative z-10 flex items-center justify-end gap-1 pt-4 border-t border-slate-100"
        onClick={(e) => e.stopPropagation()}
      >
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            onView(operator);
          }}
          className="p-2 rounded-lg text-slate-400 hover:text-orange-600 hover:bg-orange-50 transition-all cursor-pointer"
        >
          <Eye className="h-4 w-4" />
        </button>
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            onEdit(operator);
          }}
          className={`p-2 rounded-lg transition-all cursor-pointer ${
            isReadOnly
              ? "text-slate-300 cursor-not-allowed pointer-events-none"
              : "text-slate-400 hover:text-amber-600 hover:bg-amber-50"
          }`}
          disabled={isReadOnly}
        >
          <Edit className="h-4 w-4" />
        </button>
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            onDelete(operator);
          }}
          className={`p-2 rounded-lg transition-all cursor-pointer ${
            isReadOnly
              ? "text-slate-300 cursor-not-allowed pointer-events-none"
              : "text-slate-400 hover:text-rose-600 hover:bg-rose-50"
          }`}
          disabled={isReadOnly}
        >
          <Trash2 className="h-4 w-4" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/operator/common/OperatorTableRow.tsx">
import { memo } from "react";
import { Building2, Phone, User, CheckCircle, Eye, Edit, Trash2 } from "lucide-react";
import type { Operator } from "@/types";

interface OperatorWithSource extends Operator {
  source?: "database" | "legacy" | "google_sheets";
}

interface OperatorTableRowProps {
  operator: OperatorWithSource;
  index: number;
  onRowClick: (operator: Operator) => void;
  onView: (operator: Operator) => void;
  onEdit: (operator: OperatorWithSource) => void;
  onDelete: (operator: OperatorWithSource) => void;
}

export const OperatorTableRow = memo(function OperatorTableRow({
  operator,
  index,
  onRowClick,
  onView,
  onEdit,
  onDelete,
}: OperatorTableRowProps) {
  // Google Sheets data is read-only (managed externally)
  const isReadOnly = operator.source === "legacy" || operator.source === "google_sheets";

  return (
    <tr
      className="group hover:bg-orange-50/50 transition-colors cursor-pointer"
      onClick={() => onRowClick(operator)}
      style={{
        animation: "fadeInUp 0.3s ease forwards",
        animationDelay: `${index * 30}ms`,
        opacity: 0,
      }}
    >
      <td className="px-6 py-4">
        <span className="font-mono text-sm font-medium bg-slate-100 text-slate-700 px-3 py-1.5 rounded-lg">
          {operator.code || operator.id?.substring(0, 8) || "-"}
        </span>
      </td>
      <td className="px-6 py-4">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-orange-100 to-amber-100 flex items-center justify-center group-hover:from-orange-500 group-hover:to-amber-500 transition-colors">
            <Building2 className="h-5 w-5 text-orange-600 group-hover:text-white transition-colors" />
          </div>
          <span className="font-semibold text-slate-800 max-w-[300px] truncate">
            {operator.name}
          </span>
        </div>
      </td>
      <td className="px-6 py-4 text-center">
        <div className="flex items-center justify-center gap-2">
          <Phone className="h-4 w-4 text-slate-400" />
          <span className="text-slate-600">{operator.phone || "-"}</span>
        </div>
      </td>
      <td className="px-6 py-4 text-center">
        <div className="flex items-center justify-center gap-2">
          <User className="h-4 w-4 text-slate-400" />
          <span className="text-slate-600">
            {operator.representativeName || "-"}
          </span>
        </div>
      </td>
      <td className="px-6 py-4 text-center">
        {operator.isTicketDelegated ? (
          <span className="inline-flex items-center gap-1.5 px-3 py-1 rounded-full bg-violet-100 text-violet-700 text-xs font-medium">
            <CheckCircle className="h-3 w-3" />
            Có
          </span>
        ) : (
          <span className="text-slate-400">-</span>
        )}
      </td>
      <td className="px-6 py-4 text-center">
        <span
          className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold ${
            operator.isActive
              ? "bg-emerald-100 text-emerald-700"
              : "bg-slate-100 text-slate-600"
          }`}
        >
          <span
            className={`w-2 h-2 rounded-full ${
              operator.isActive ? "bg-emerald-500 animate-pulse" : "bg-slate-400"
            }`}
          />
          {operator.isActive ? "Hoạt động" : "Ngừng"}
        </span>
      </td>
      <td
        className="px-6 py-4 relative z-10"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-center gap-1 opacity-100 transition-opacity">
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              onView(operator);
            }}
            className="p-2 rounded-lg text-slate-500 hover:text-orange-600 hover:bg-orange-50 transition-all cursor-pointer"
            title="Xem chi tiết"
          >
            <Eye className="h-4 w-4" />
          </button>
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              onEdit(operator);
            }}
            className={`p-2 rounded-lg transition-all cursor-pointer ${
              isReadOnly
                ? "text-slate-300 cursor-not-allowed pointer-events-none"
                : "text-slate-500 hover:text-amber-600 hover:bg-amber-50"
            }`}
            title={isReadOnly ? "Dữ liệu được quản lý từ Google Sheets" : "Chỉnh sửa"}
            disabled={isReadOnly}
          >
            <Edit className="h-4 w-4" />
          </button>
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              onDelete(operator);
            }}
            className={`p-2 rounded-lg transition-all cursor-pointer ${
              isReadOnly
                ? "text-slate-300 cursor-not-allowed pointer-events-none"
                : "text-slate-500 hover:text-rose-600 hover:bg-rose-50"
            }`}
            title={isReadOnly ? "Dữ liệu được quản lý từ Google Sheets" : "Xóa"}
            disabled={isReadOnly}
          >
            <Trash2 className="h-4 w-4" />
          </button>
        </div>
      </td>
    </tr>
  );
});
</file>

<file path="client/src/components/payment/VehicleInfoCard.tsx">
import { Bus } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { formatVietnamTime } from "@/utils/timezone";
import type { DispatchRecord } from "@/types";

interface VehicleInfoCardProps {
  record: DispatchRecord;
}

export function VehicleInfoCard({ record }: VehicleInfoCardProps) {
  return (
    <Card className="border-0 shadow-sm overflow-hidden">
      <div className="bg-gradient-to-r from-blue-500 to-indigo-600 p-6 text-white">
        <div className="flex items-center gap-4">
          <div className="w-16 h-16 bg-white/20 backdrop-blur rounded-xl flex items-center justify-center">
            <Bus className="w-8 h-8" />
          </div>
          <div>
            <p className="text-white/80 text-sm">Biển kiểm soát</p>
            <p className="text-3xl font-bold">{record.vehiclePlateNumber}</p>
          </div>
        </div>
      </div>
      <CardContent className="p-6">
        <div className="grid grid-cols-2 lg:grid-cols-4 gap-6">
          <div>
            <p className="text-sm text-gray-500 mb-1">Tuyến vận chuyển</p>
            <p className="font-semibold text-gray-900">{record.routeName || 'Chưa có'}</p>
          </div>
          <div>
            <p className="text-sm text-gray-500 mb-1">Giờ vào bến</p>
            <p className="font-semibold text-gray-900">
              {formatVietnamTime(record.entryTime, "HH:mm dd/MM/yyyy")}
            </p>
          </div>
          <div>
            <p className="text-sm text-gray-500 mb-1">Giờ xuất bến KH</p>
            <p className="font-semibold text-gray-900">
              {record.plannedDepartureTime
                ? formatVietnamTime(record.plannedDepartureTime, "HH:mm dd/MM/yyyy")
                : 'Chưa có'}
            </p>
          </div>
          <div>
            <p className="text-sm text-gray-500 mb-1">Số ghế</p>
            <p className="font-semibold text-gray-900">{record.seatCount || 'N/A'}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/service/ServiceDialog.tsx">
import { useEffect, useState } from "react"
import { toast } from "react-toastify"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
// Tạm thời comment - dùng cho right column
// import {
//   Table,
//   TableBody,
//   TableCell,
//   TableHead,
//   TableHeader,
//   TableRow,
// } from "@/components/ui/table"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { serviceService } from "@/services/service.service"
import { serviceFormulaService } from "@/services/service-formula.service"
import type { Service, ServiceInput, ServiceFormula } from "@/types"

const serviceSchema = z.object({
  code: z.string().min(1, "Mã dịch vụ là bắt buộc"),
  name: z.string().min(1, "Tên dịch vụ là bắt buộc"),
  unit: z.string().min(1, "Đơn vị tính là bắt buộc"),
  taxPercentage: z.union([
    z.number().min(0).max(100),
    z.string(),
  ]).refine(
    (val) => {
      if (typeof val === "number") return val >= 0 && val <= 100;
      if (typeof val === "string") {
        return val === "KCT" || val === "KKKNT" || (!isNaN(Number(val)) && Number(val) >= 0 && Number(val) <= 100);
      }
      return false;
    },
    { message: "Phần trăm thuế không hợp lệ" }
  ),
  materialType: z.string().min(1, "Loại vật tư/hàng hóa là bắt buộc"),
  useQuantityFormula: z.boolean().default(false),
  usePriceFormula: z.boolean().default(false),
  displayOrder: z.number().min(0, "Thứ tự hiển thị phải >= 0"),
  isDefault: z.boolean().default(false),
  autoCalculateQuantity: z.boolean().default(false),
  isActive: z.boolean().default(true),
  quantityFormulaExpression: z.string().optional(),
  priceFormulaExpression: z.string().optional(),
  formulaDescription: z.string().optional(),
})

type ServiceFormData = z.infer<typeof serviceSchema>

const MATERIAL_TYPES = ["Khác", "Hoa hồng bán vé", "Đỗ chờ", "Phí dịch vụ", "Phạt ra muộn", "Truy thu"]

const UNITS = ["Giường", "Chuyến", "Cái", "Ghế", "Người", "Khách", "Vé", "Xe"]

const TAX_PERCENTAGES = [
  { value: "20", label: "20%" },
  { value: "10", label: "10%" },
  { value: "8", label: "8%" },
  { value: "5", label: "5%" },
  { value: "0", label: "0%" },
  { value: "KCT", label: "KCT" },
  { value: "KKKNT", label: "KKKNT" },
]

// Biểu thức sẽ được load từ database

interface ServiceDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  viewMode: "create" | "edit" | "view"
  selectedService: Service | null
  onSuccess: () => void
}

export function ServiceDialog({
  open,
  onOpenChange,
  viewMode,
  selectedService,
  onSuccess,
}: ServiceDialogProps) {
  const [quantityFormulas, setQuantityFormulas] = useState<ServiceFormula[]>([])
  const [priceFormulas, setPriceFormulas] = useState<ServiceFormula[]>([])
  const [isLoadingFormulas, setIsLoadingFormulas] = useState(false)

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<ServiceFormData>({
    resolver: zodResolver(serviceSchema),
    defaultValues: {
      useQuantityFormula: false,
      usePriceFormula: false,
      displayOrder: 0,
      isDefault: false,
      autoCalculateQuantity: false,
      isActive: true,
      taxPercentage: 0,
      quantityFormulaExpression: "",
      priceFormulaExpression: "",
      formulaDescription: "",
    },
  })

  // Tạm thời comment - dùng cho right column
  // const handleCheckFormula = () => {
  //   // TODO: Implement formula checking logic
  //   toast.info("Chức năng kiểm tra công thức đang được phát triển")
  // }

  // Load formulas from database
  useEffect(() => {
    if (open) {
      const loadFormulas = async () => {
        setIsLoadingFormulas(true)
        try {
          const [quantityData, priceData] = await Promise.all([
            serviceFormulaService.getAll('quantity', true), // Chỉ lấy active
            serviceFormulaService.getAll('price', true), // Chỉ lấy active
          ])
          setQuantityFormulas(quantityData)
          setPriceFormulas(priceData)
        } catch (error) {
          console.error("Failed to load formulas:", error)
          toast.error("Không thể tải danh sách biểu thức. Vui lòng thử lại sau.")
        } finally {
          setIsLoadingFormulas(false)
        }
      }
      loadFormulas()
    }
  }, [open])

  useEffect(() => {
    if (selectedService && (viewMode === "edit" || viewMode === "view")) {
      reset({
        code: selectedService.code,
        name: selectedService.name,
        unit: selectedService.unit,
        taxPercentage: selectedService.taxPercentage,
        materialType: selectedService.materialType,
        useQuantityFormula: selectedService.useQuantityFormula,
        usePriceFormula: selectedService.usePriceFormula,
        displayOrder: selectedService.displayOrder,
        isDefault: selectedService.isDefault,
        autoCalculateQuantity: selectedService.autoCalculateQuantity,
        isActive: selectedService.isActive,
        quantityFormulaExpression: selectedService.quantityFormulaExpression || "",
        priceFormulaExpression: selectedService.priceFormulaExpression || "",
        formulaDescription: "",
      })
    } else {
      reset({
        code: "",
        name: "",
        unit: "",
        taxPercentage: 0,
        materialType: "",
        useQuantityFormula: false,
        usePriceFormula: false,
        displayOrder: 0,
        isDefault: false,
        autoCalculateQuantity: false,
        isActive: true,
        quantityFormulaExpression: "",
        priceFormulaExpression: "",
        formulaDescription: "",
      })
    }
  }, [selectedService, viewMode, reset])

  const onSubmit = async (data: ServiceFormData) => {
    try {
      // Convert taxPercentage to number if it's a numeric string, otherwise keep as string
      const taxPercentage = typeof data.taxPercentage === "string" && !isNaN(Number(data.taxPercentage))
        ? Number(data.taxPercentage)
        : data.taxPercentage

      const serviceData: ServiceInput & { 
        isActive?: boolean
        quantityFormulaExpression?: string
        priceFormulaExpression?: string
      } = {
        code: data.code,
        name: data.name,
        unit: data.unit,
        taxPercentage: taxPercentage as any,
        materialType: data.materialType,
        useQuantityFormula: data.useQuantityFormula,
        usePriceFormula: data.usePriceFormula,
        displayOrder: data.displayOrder,
        isDefault: data.isDefault,
        autoCalculateQuantity: data.autoCalculateQuantity,
        // Gửi biểu thức nếu có chọn (không phải empty string)
        quantityFormulaExpression: data.quantityFormulaExpression && data.quantityFormulaExpression.trim() !== "" 
          ? data.quantityFormulaExpression 
          : undefined,
        priceFormulaExpression: data.priceFormulaExpression && data.priceFormulaExpression.trim() !== "" 
          ? data.priceFormulaExpression 
          : undefined,
      }

      if (viewMode === "create") {
        await serviceService.create({ ...serviceData, isActive: data.isActive } as any)
        toast.success("Thêm dịch vụ thành công")
      } else if (viewMode === "edit" && selectedService) {
        await serviceService.update(selectedService.id, { ...serviceData, isActive: data.isActive } as any)
        toast.success("Cập nhật dịch vụ thành công")
      }
      onOpenChange(false)
      onSuccess()
    } catch (error: any) {
      console.error("Failed to save service:", error)
      toast.error(
        error.response?.data?.message ||
          `Không thể ${viewMode === "create" ? "thêm" : "cập nhật"} dịch vụ. Vui lòng thử lại.`
      )
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[95vw] sm:w-[90vw] md:w-[85vw] lg:w-[1400px] max-w-7xl max-h-[95vh] sm:max-h-[90vh] overflow-y-auto p-4 sm:p-6">
        <DialogHeader>
          <DialogTitle className="text-xl sm:text-2xl">
            {viewMode === "create" && "Thêm dịch vụ mới"}
            {viewMode === "edit" && "Sửa thông tin dịch vụ"}
            {viewMode === "view" && "Chi tiết dịch vụ"}
          </DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit(onSubmit)} className="mt-4">
          <div className="grid grid-cols-1 gap-6">
            {/* Left Column - Thông tin chính */}
            <div className="space-y-4">
              {/* Header với checkboxes */}
              <div className="space-y-3 sm:space-y-4">
                <div className="flex items-center justify-between border-b pb-2">
                  <h3 className="text-base sm:text-lg font-semibold text-gray-800">
                    Thông tin chính
                  </h3>
                  <div className="flex items-center gap-4">
                    <div className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        id="isDefault"
                        {...register("isDefault")}
                        disabled={viewMode === "view"}
                        className="h-4 w-4"
                      />
                      <Label htmlFor="isDefault" className="cursor-pointer text-sm">
                        Mặc định chọn
                      </Label>
                    </div>
                    <div className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        id="autoCalculateQuantity"
                        {...register("autoCalculateQuantity")}
                        disabled={viewMode === "view"}
                        className="h-4 w-4"
                      />
                      <Label htmlFor="autoCalculateQuantity" className="cursor-pointer text-sm">
                        Tự động tính số lượng
                      </Label>
                    </div>
                  </div>
                </div>
                
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="name">
                      Tên dịch vụ <span className="text-red-500">(*)</span>
                    </Label>
                    <Input
                      id="name"
                      placeholder="Tên dịch vụ"
                      {...register("name")}
                      disabled={viewMode === "view"}
                      className={errors.name ? "border-red-500" : ""}
                    />
                    {errors.name && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.name.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="code">
                      Mã dịch vụ <span className="text-red-500">(*)</span>
                    </Label>
                    <Input
                      id="code"
                      placeholder="Mã dịch vụ"
                      {...register("code")}
                      disabled={viewMode === "view"}
                      className={errors.code ? "border-red-500" : ""}
                    />
                    {errors.code && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.code.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="displayOrder">
                      Thứ tự hiển thị <span className="text-red-500">(*)</span>
                    </Label>
                    <Input
                      id="displayOrder"
                      type="number"
                      min="0"
                      placeholder="0"
                      {...register("displayOrder", { valueAsNumber: true })}
                      disabled={viewMode === "view"}
                      className={errors.displayOrder ? "border-red-500" : ""}
                    />
                    {errors.displayOrder && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.displayOrder.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="materialType">
                      Loại vật tư/hàng hóa <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="materialType"
                      {...register("materialType")}
                      disabled={viewMode === "view"}
                      className={errors.materialType ? "border-red-500" : ""}
                    >
                      <option value="">Chọn loại</option>
                      {MATERIAL_TYPES.map((type) => (
                        <option key={type} value={type}>
                          {type}
                        </option>
                      ))}
                    </Select>
                    {errors.materialType && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.materialType.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="unit">
                      Đơn vị tính <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="unit"
                      {...register("unit")}
                      disabled={viewMode === "view"}
                      className={errors.unit ? "border-red-500" : ""}
                    >
                      <option value="">Chọn đơn vị</option>
                      {UNITS.map((unit) => (
                        <option key={unit} value={unit}>
                          {unit}
                        </option>
                      ))}
                    </Select>
                    {errors.unit && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.unit.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="taxPercentage">
                      Phần trăm thuế <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="taxPercentage"
                      {...register("taxPercentage")}
                      disabled={viewMode === "view"}
                      className={errors.taxPercentage ? "border-red-500" : ""}
                    >
                      <option value="">Chọn phần trăm thuế</option>
                      {TAX_PERCENTAGES.map((tax) => (
                        <option key={tax.value} value={tax.value}>
                          {tax.label}
                        </option>
                      ))}
                    </Select>
                    {errors.taxPercentage && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.taxPercentage.message}
                      </p>
                    )}
                  </div>

                  <div className="sm:col-span-2">
                    <Label htmlFor="quantityFormulaExpression">
                      Biểu thức tính số lượng <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="quantityFormulaExpression"
                      {...register("quantityFormulaExpression")}
                      disabled={viewMode === "view" || isLoadingFormulas}
                    >
                      <option value="">Chọn biểu thức</option>
                      {quantityFormulas.map((formula) => (
                        <option key={formula.id} value={formula.id}>
                          {formula.name}
                        </option>
                      ))}
                    </Select>
                    {isLoadingFormulas && (
                      <p className="text-sm text-gray-500 mt-1">Đang tải danh sách biểu thức...</p>
                    )}
                  </div>

                  <div className="sm:col-span-2">
                    <Label htmlFor="priceFormulaExpression">
                      Biểu thức tính đơn giá <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="priceFormulaExpression"
                      {...register("priceFormulaExpression")}
                      disabled={viewMode === "view" || isLoadingFormulas}
                    >
                      <option value="">Chọn biểu thức</option>
                      {priceFormulas.map((formula) => (
                        <option key={formula.id} value={formula.id}>
                          {formula.name}
                        </option>
                      ))}
                    </Select>
                    {isLoadingFormulas && (
                      <p className="text-sm text-gray-500 mt-1">Đang tải danh sách biểu thức...</p>
                    )}
                  </div>

                  <div className="sm:col-span-2">
                    <Label htmlFor="formulaDescription">
                      Mô tả biểu thức
                    </Label>
                    <textarea
                      id="formulaDescription"
                      {...register("formulaDescription")}
                      disabled={viewMode === "view"}
                      rows={4}
                      className="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                      placeholder="Nhập mô tả biểu thức..."
                    />
                  </div>
                </div>
              </div>

            </div>

            {/* Right Column - Kiểm tra công thức và Kết quả */}
            {/* Tạm thời ẩn right column */}
            {/* <div className="space-y-4">
              {/* Kiểm tra công thức */}
              {/* <div className="space-y-3">
                <h3 className="text-base sm:text-lg font-semibold text-gray-800 border-b pb-2">
                  Kiểm tra công thức
                </h3>
                <div className="space-y-3">
                  <div className="border border-gray-200 rounded-lg overflow-hidden">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead className="text-center">Tham số</TableHead>
                          <TableHead className="text-center">Giá trị</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {formulaParameters.length === 0 ? (
                          <TableRow>
                            <TableCell colSpan={2} className="text-center py-8 text-gray-500 text-sm">
                              Không có dữ liệu
                            </TableCell>
                          </TableRow>
                        ) : (
                          formulaParameters.map((param, index) => (
                            <TableRow key={index}>
                              <TableCell className="text-center">{param.name}</TableCell>
                              <TableCell className="text-center">{param.value}</TableCell>
                            </TableRow>
                          ))
                        )}
                      </TableBody>
                    </Table>
                  </div>
                  <div className="flex justify-end">
                    <Button
                      type="button"
                      onClick={handleCheckFormula}
                      className="bg-blue-600 hover:bg-blue-700"
                    >
                      KIỂM TRA
                    </Button>
                  </div>
                </div>
              </div>

              {/* Kết quả */}
              {/* <div className="space-y-3">
                <h3 className="text-base sm:text-lg font-semibold text-gray-800 border-b pb-2">
                  Kết quả
                </h3>
                <div className="border border-gray-200 rounded-lg overflow-hidden">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="text-center w-16">STT</TableHead>
                        <TableHead className="text-center">Tên biểu thức</TableHead>
                        <TableHead className="text-center">Kết quả</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {formulaResults.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={3} className="text-center py-8 text-gray-500 text-sm">
                            Không có dữ liệu
                          </TableCell>
                        </TableRow>
                      ) : (
                        formulaResults.map((result) => (
                          <TableRow key={result.stt}>
                            <TableCell className="text-center">{result.stt}</TableCell>
                            <TableCell className="text-center">{result.name}</TableCell>
                            <TableCell className="text-center">{result.result}</TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </div>
              </div>

              {/* Status (for view mode) */}
              {/* {viewMode === "view" && selectedService && (
                <div>
                  <Label>Trạng thái</Label>
                  <div className="mt-2">
                    <StatusBadge
                      status={selectedService.isActive ? "active" : "inactive"}
                    />
                  </div>
                </div>
              )}
            </div> */}
            
            {/* Status (for view mode) - Moved here temporarily */}
            {viewMode === "view" && selectedService && (
              <div>
                <Label>Trạng thái</Label>
                <div className="mt-2">
                  <StatusBadge
                    status={selectedService.isActive ? "active" : "inactive"}
                  />
                </div>
              </div>
            )}
          </div>

          {/* Footer buttons */}
          <div className="flex flex-col-reverse sm:flex-row justify-end gap-2 sm:gap-2 pt-4 border-t mt-6">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="w-full sm:w-auto"
            >
              {viewMode === "view" ? "Đóng" : "Hủy"}
            </Button>
            {viewMode !== "view" && (
              <Button type="submit" className="w-full sm:w-auto">
                {viewMode === "create" ? "Thêm" : "Cập nhật"}
              </Button>
            )}
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="client/src/components/shared/styled-components.tsx">
import React from "react";

// Reusable styled components - Professional Light Theme with bold visual changes
// Based on Gemini AI analysis for modern SaaS UI

export const GlassCard = ({ children, className = "" }: { children: React.ReactNode; className?: string }) => (
  <div className={`
    relative overflow-hidden rounded-xl
    bg-white border border-gray-200
    shadow-sm
    transition-all duration-200
    ${className}
  `}>
    {children}
  </div>
);

export const SectionHeader = ({ icon: Icon, title, badge, action }: {
  icon: React.ElementType;
  title: string;
  badge?: React.ReactNode;
  action?: React.ReactNode;
}) => (
  <div className="flex items-center justify-between px-4 py-3 border-b border-gray-100 bg-gray-50/50">
    <div className="flex items-center gap-3">
      <div className="p-2 rounded-lg bg-blue-600 text-white">
        <Icon className="h-4 w-4" />
      </div>
      <h3 className="text-base font-semibold text-gray-900">{title}</h3>
      {badge}
    </div>
    {action}
  </div>
);

export const FormField = ({ label, required, error, children, className = "" }: {
  label: string;
  required?: boolean;
  error?: string;
  children: React.ReactNode;
  className?: string;
}) => (
  <div className={`mb-3 ${className}`}>
    <label className="block text-xs font-medium text-gray-600 mb-1">
      {label}
      {required && <span className="text-rose-500 ml-0.5">*</span>}
    </label>
    {children}
    {error && (
      <p className="mt-1 text-xs text-rose-600 flex items-center gap-1">
        <svg className="w-3 h-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
        </svg>
        {error}
      </p>
    )}
  </div>
);

export const StyledInput = ({ className = "", ...props }: React.InputHTMLAttributes<HTMLInputElement>) => (
  <input
    className={`
      w-full h-9 px-3 py-2 rounded-lg
      bg-white border border-gray-300
      text-sm text-gray-900 placeholder-gray-400
      hover:border-gray-400
      focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500
      transition-all duration-150
      disabled:opacity-60 disabled:cursor-not-allowed disabled:bg-gray-50
      ${className}
    `}
    {...props}
  />
);

export const StyledSelect = ({ className = "", children, ...props }: React.SelectHTMLAttributes<HTMLSelectElement>) => (
  <select
    className={`
      w-full h-9 px-3 py-2 rounded-lg
      bg-white border border-gray-300
      text-sm text-gray-900
      hover:border-gray-400
      focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500
      transition-all duration-150
      disabled:opacity-60 disabled:cursor-not-allowed disabled:bg-gray-50
      cursor-pointer
      ${className}
    `}
    {...props}
  >
    {children}
  </select>
);

// Empty state placeholder component with improved visual
export const EmptyState = ({ icon: Icon, message, action }: { 
  icon: React.ElementType; 
  message: string;
  action?: React.ReactNode;
}) => (
  <div className="flex flex-col items-center justify-center min-h-[160px] py-8 bg-gradient-to-b from-gray-50 to-white rounded-xl border-2 border-dashed border-gray-200">
    <div className="p-4 rounded-2xl bg-gray-100 mb-4">
      <Icon className="w-10 h-10 text-gray-400" />
    </div>
    <p className="text-base font-medium text-gray-500 mb-3">{message}</p>
    {action}
  </div>
);

// Action Button styles
export const ActionButton = ({ 
  children, 
  variant = "primary", 
  size = "md",
  className = "", 
  ...props 
}: React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: "primary" | "secondary" | "danger" | "ghost";
  size?: "sm" | "md" | "lg";
}) => {
  const variants = {
    primary: "bg-gradient-to-r from-blue-600 to-blue-500 text-white shadow-lg shadow-blue-500/30 hover:shadow-xl hover:shadow-blue-500/40 hover:from-blue-700 hover:to-blue-600",
    secondary: "bg-white border-2 border-gray-200 text-gray-700 hover:border-gray-300 hover:bg-gray-50 shadow-sm",
    danger: "bg-gradient-to-r from-rose-500 to-red-500 text-white shadow-lg shadow-rose-500/30 hover:shadow-xl hover:shadow-rose-500/40 hover:from-rose-600 hover:to-red-600",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100 hover:text-gray-900"
  };
  
  const sizes = {
    sm: "h-9 px-4 text-sm",
    md: "h-11 px-5 text-base",
    lg: "h-12 px-6 text-lg"
  };

  return (
    <button
      className={`
        inline-flex items-center justify-center gap-2 rounded-xl font-semibold
        transition-all duration-200 ease-out
        disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none
        active:scale-[0.98]
        ${variants[variant]}
        ${sizes[size]}
        ${className}
      `}
      {...props}
    >
      {children}
    </button>
  );
};

// Badge component
export const Badge = ({ 
  children, 
  variant = "default",
  size = "md",
  className = "" 
}: { 
  children: React.ReactNode; 
  variant?: "default" | "success" | "warning" | "danger" | "info";
  size?: "sm" | "md" | "lg";
  className?: string;
}) => {
  const variants = {
    default: "bg-gray-100 text-gray-700",
    success: "bg-emerald-100 text-emerald-700",
    warning: "bg-amber-100 text-amber-700",
    danger: "bg-rose-100 text-rose-700",
    info: "bg-blue-100 text-blue-700"
  };
  
  const sizes = {
    sm: "px-2 py-0.5 text-xs",
    md: "px-3 py-1 text-sm",
    lg: "px-4 py-1.5 text-base"
  };

  return (
    <span className={`
      inline-flex items-center font-semibold rounded-full
      ${variants[variant]}
      ${sizes[size]}
      ${className}
    `}>
      {children}
    </span>
  );
};
</file>

<file path="client/src/components/ui/dialog.tsx">
import * as React from "react"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "./button"

interface DialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  children: React.ReactNode
  className?: string
}

interface DialogContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode
}

const Dialog: React.FC<DialogProps> = ({ open, onOpenChange, children, className }) => {
  if (!open) return null

  return (
    <div
      className="fixed inset-0 z-[100] flex items-center justify-center p-4"
      onClick={() => onOpenChange(false)}
    >
      <div className="fixed inset-0 bg-black/60 backdrop-blur-sm" />
      <div onClick={(e) => e.stopPropagation()} className={cn("relative z-[101] max-w-[95vw]", className)}>
        {children}
      </div>
    </div>
  )
}

const DialogContent = React.forwardRef<HTMLDivElement, DialogContentProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          "relative z-50 bg-white rounded-lg shadow-lg p-4 sm:p-6",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }
)
DialogContent.displayName = "DialogContent"

const DialogHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col space-y-1.5 text-center sm:text-left mb-4", className)}
    {...props}
  />
)

const DialogTitle = React.forwardRef<
  HTMLHeadingElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h2
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
DialogTitle.displayName = "DialogTitle"

const DialogDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
))
DialogDescription.displayName = "DialogDescription"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogClose: React.FC<{ onClose: () => void }> = ({ onClose }) => (
  <Button
    variant="ghost"
    size="icon"
    className="absolute right-4 top-4"
    onClick={onClose}
    aria-label="Close"
  >
    <X className="h-4 w-4" />
  </Button>
)

export {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
}
</file>

<file path="client/src/constants/vietnam-locations.ts">
// ============================================================
// DANH SÁCH 63 TỈNH THÀNH VIỆT NAM TRƯỚC SÁP NHẬP (V1)
// ============================================================
export const PROVINCES_V1 = [
  "An Giang", "Bà Rịa - Vũng Tàu", "Bạc Liêu", "Bắc Giang", "Bắc Kạn",
  "Bắc Ninh", "Bến Tre", "Bình Dương", "Bình Định", "Bình Phước",
  "Bình Thuận", "Cà Mau", "Cao Bằng", "Cần Thơ", "Đà Nẵng",
  "Đắk Lắk", "Đắk Nông", "Điện Biên", "Đồng Nai", "Đồng Tháp",
  "Gia Lai", "Hà Giang", "Hà Nam", "Hà Nội", "Hà Tĩnh",
  "Hải Dương", "Hải Phòng", "Hậu Giang", "Hòa Bình", "Hưng Yên",
  "Khánh Hòa", "Kiên Giang", "Kon Tum", "Lai Châu", "Lâm Đồng",
  "Lạng Sơn", "Lào Cai", "Long An", "Nam Định", "Nghệ An",
  "Ninh Bình", "Ninh Thuận", "Phú Thọ", "Phú Yên", "Quảng Bình",
  "Quảng Nam", "Quảng Ngãi", "Quảng Ninh", "Quảng Trị", "Sóc Trăng",
  "Sơn La", "Tây Ninh", "Thái Bình", "Thái Nguyên", "Thanh Hóa",
  "Thừa Thiên Huế", "Tiền Giang", "Trà Vinh", "Tuyên Quang", "Vĩnh Long",
  "Vĩnh Phúc", "Yên Bái",
]

// Quận huyện theo tỉnh thành TRƯỚC sáp nhập (V1)
export const DISTRICTS_BY_PROVINCE_V1: Record<string, string[]> = {
  "An Giang": [
    "TP. Long Xuyên", "TP. Châu Đốc", "TX. Tân Châu",
    "H. An Phú", "H. Tịnh Biên", "H. Tri Tôn", "H. Châu Phú",
    "H. Chợ Mới", "H. Phú Tân", "H. Thoại Sơn", "H. Châu Thành",
  ],
  "Bà Rịa - Vũng Tàu": [
    "TP. Vũng Tàu", "TP. Bà Rịa", "TX. Phú Mỹ",
    "H. Châu Đức", "H. Xuyên Mộc", "H. Long Điền", "H. Đất Đỏ", "H. Côn Đảo",
  ],
  "Bạc Liêu": [
    "TP. Bạc Liêu", "TX. Giá Rai",
    "H. Vĩnh Lợi", "H. Hồng Dân", "H. Phước Long", "H. Hòa Bình", "H. Đông Hải",
  ],
  "Bắc Giang": [
    "TP. Bắc Giang",
    "H. Yên Thế", "H. Tân Yên", "H. Lạng Giang", "H. Lục Nam",
    "H. Lục Ngạn", "H. Sơn Động", "H. Yên Dũng", "H. Việt Yên", "H. Hiệp Hòa",
  ],
  "Bắc Kạn": [
    "TP. Bắc Kạn",
    "H. Pác Nặm", "H. Ba Bể", "H. Ngân Sơn", "H. Bạch Thông",
    "H. Chợ Đồn", "H. Chợ Mới", "H. Na Rì",
  ],
  "Bắc Ninh": [
    "TP. Bắc Ninh", "TX. Từ Sơn",
    "H. Yên Phong", "H. Quế Võ", "H. Tiên Du", "H. Thuận Thành",
    "H. Gia Bình", "H. Lương Tài",
  ],
  "Bến Tre": [
    "TP. Bến Tre",
    "H. Châu Thành", "H. Chợ Lách", "H. Mỏ Cày Nam", "H. Giồng Trôm",
    "H. Bình Đại", "H. Ba Tri", "H. Thạnh Phú", "H. Mỏ Cày Bắc",
  ],
  "Bình Dương": [
    "TP. Thủ Dầu Một", "TP. Thuận An", "TP. Dĩ An", "TP. Tân Uyên",
    "TX. Bến Cát", "H. Bàu Bàng", "H. Dầu Tiếng", "H. Phú Giáo", "H. Bắc Tân Uyên",
  ],
  "Bình Định": [
    "TP. Quy Nhơn", "TX. An Nhơn", "TX. Hoài Nhơn",
    "H. An Lão", "H. Hoài Ân", "H. Phù Mỹ", "H. Vĩnh Thạnh",
    "H. Tây Sơn", "H. Phù Cát", "H. Vân Canh", "H. Tuy Phước",
  ],
  "Bình Phước": [
    "TP. Đồng Xoài", "TX. Bình Long", "TX. Phước Long", "TX. Chơn Thành",
    "H. Bù Gia Mập", "H. Lộc Ninh", "H. Bù Đốp", "H. Hớn Quản",
    "H. Đồng Phú", "H. Bù Đăng", "H. Phú Riềng",
  ],
  "Bình Thuận": [
    "TP. Phan Thiết", "TX. La Gi",
    "H. Tuy Phong", "H. Bắc Bình", "H. Hàm Thuận Bắc", "H. Hàm Thuận Nam",
    "H. Tánh Linh", "H. Hàm Tân", "H. Đức Linh", "H. Phú Quý",
  ],
  "Cà Mau": [
    "TP. Cà Mau",
    "H. U Minh", "H. Thới Bình", "H. Trần Văn Thời", "H. Cái Nước",
    "H. Đầm Dơi", "H. Năm Căn", "H. Phú Tân", "H. Ngọc Hiển",
  ],
  "Cao Bằng": [
    "TP. Cao Bằng",
    "H. Bảo Lâm", "H. Bảo Lạc", "H. Hà Quảng", "H. Trùng Khánh",
    "H. Hạ Lang", "H. Quảng Hòa", "H. Hoà An", "H. Nguyên Bình", "H. Thạch An",
  ],
  "Cần Thơ": [
    "Q. Ninh Kiều", "Q. Ô Môn", "Q. Bình Thủy", "Q. Cái Răng", "Q. Thốt Nốt",
    "H. Vĩnh Thạnh", "H. Cờ Đỏ", "H. Phong Điền", "H. Thới Lai",
  ],
  "Đà Nẵng": [
    "Q. Hải Châu", "Q. Thanh Khê", "Q. Sơn Trà", "Q. Ngũ Hành Sơn",
    "Q. Liên Chiểu", "Q. Cẩm Lệ", "H. Hòa Vang", "H. Hoàng Sa",
  ],
  "Đắk Lắk": [
    "TP. Buôn Ma Thuột", "TX. Buôn Hồ",
    "H. Ea H'leo", "H. Ea Súp", "H. Buôn Đôn", "H. Cư M'gar",
    "H. Krông Búk", "H. Krông Năng", "H. Ea Kar", "H. M'Đrắk",
    "H. Krông Bông", "H. Krông Pắc", "H. Krông A Na", "H. Lắk", "H. Cư Kuin",
  ],
  "Đắk Nông": [
    "TP. Gia Nghĩa",
    "H. Đắk Glong", "H. Cư Jút", "H. Đắk Mil", "H. Krông Nô",
    "H. Đắk Song", "H. Đắk R'Lấp", "H. Tuy Đức",
  ],
  "Điện Biên": [
    "TP. Điện Biên Phủ", "TX. Mường Lay",
    "H. Mường Nhé", "H. Mường Chà", "H. Tủa Chùa", "H. Tuần Giáo",
    "H. Điện Biên", "H. Điện Biên Đông", "H. Mường Ảng", "H. Nậm Pồ",
  ],
  "Đồng Nai": [
    "TP. Biên Hòa", "TP. Long Khánh",
    "H. Tân Phú", "H. Vĩnh Cửu", "H. Định Quán", "H. Trảng Bom",
    "H. Thống Nhất", "H. Cẩm Mỹ", "H. Long Thành", "H. Xuân Lộc", "H. Nhơn Trạch",
  ],
  "Đồng Tháp": [
    "TP. Cao Lãnh", "TP. Sa Đéc", "TX. Hồng Ngự",
    "H. Tân Hồng", "H. Hồng Ngự", "H. Tam Nông", "H. Tháp Mười",
    "H. Cao Lãnh", "H. Thanh Bình", "H. Lấp Vò", "H. Lai Vung", "H. Châu Thành",
  ],
  "Gia Lai": [
    "TP. Pleiku", "TX. An Khê", "TX. Ayun Pa",
    "H. Kbang", "H. Đăk Đoa", "H. Chư Păh", "H. Ia Grai",
    "H. Mang Yang", "H. Kông Chro", "H. Đức Cơ", "H. Chư Prông",
    "H. Chư Sê", "H. Đăk Pơ", "H. Ia Pa", "H. Krông Pa", "H. Phú Thiện", "H. Chư Pưh",
  ],
  "Hà Giang": [
    "TP. Hà Giang",
    "H. Đồng Văn", "H. Mèo Vạc", "H. Yên Minh", "H. Quản Bạ",
    "H. Vị Xuyên", "H. Bắc Mê", "H. Hoàng Su Phì", "H. Xín Mần",
    "H. Bắc Quang", "H. Quang Bình",
  ],
  "Hà Nam": [
    "TP. Phủ Lý",
    "H. Duy Tiên", "H. Kim Bảng", "H. Thanh Liêm", "H. Bình Lục", "H. Lý Nhân",
  ],
  "Hà Nội": [
    "Q. Ba Đình", "Q. Hoàn Kiếm", "Q. Tây Hồ", "Q. Long Biên", "Q. Cầu Giấy",
    "Q. Đống Đa", "Q. Hai Bà Trưng", "Q. Hoàng Mai", "Q. Thanh Xuân",
    "Q. Nam Từ Liêm", "Q. Bắc Từ Liêm", "Q. Hà Đông",
    "TX. Sơn Tây",
    "H. Sóc Sơn", "H. Đông Anh", "H. Gia Lâm", "H. Mê Linh", "H. Ba Vì",
    "H. Phúc Thọ", "H. Đan Phượng", "H. Hoài Đức", "H. Quốc Oai",
    "H. Thạch Thất", "H. Chương Mỹ", "H. Thanh Oai", "H. Thường Tín",
    "H. Phú Xuyên", "H. Ứng Hòa", "H. Mỹ Đức", "H. Thanh Trì",
  ],
  "Hà Tĩnh": [
    "TP. Hà Tĩnh", "TX. Hồng Lĩnh", "TX. Kỳ Anh",
    "H. Hương Sơn", "H. Đức Thọ", "H. Vũ Quang", "H. Nghi Xuân",
    "H. Can Lộc", "H. Hương Khê", "H. Thạch Hà", "H. Cẩm Xuyên",
    "H. Kỳ Anh", "H. Lộc Hà",
  ],
  "Hải Dương": [
    "TP. Hải Dương", "TX. Chí Linh", "TX. Kinh Môn",
    "H. Nam Sách", "H. Thanh Hà", "H. Kim Thành", "H. Gia Lộc",
    "H. Tứ Kỳ", "H. Ninh Giang", "H. Thanh Miện", "H. Cẩm Giàng", "H. Bình Giang",
  ],
  "Hải Phòng": [
    "Q. Hồng Bàng", "Q. Ngô Quyền", "Q. Lê Chân", "Q. Hải An", "Q. Kiến An",
    "Q. Đồ Sơn", "Q. Dương Kinh",
    "H. Thuỷ Nguyên", "H. An Dương", "H. An Lão", "H. Kiến Thuỵ",
    "H. Tiên Lãng", "H. Vĩnh Bảo", "H. Cát Hải", "H. Bạch Long Vĩ",
  ],
  "Hậu Giang": [
    "TP. Vị Thanh", "TX. Ngã Bảy", "TX. Long Mỹ",
    "H. Châu Thành A", "H. Châu Thành", "H. Phụng Hiệp", "H. Vị Thủy",
  ],
  "Hòa Bình": [
    "TP. Hòa Bình",
    "H. Đà Bắc", "H. Lương Sơn", "H. Kim Bôi", "H. Cao Phong",
    "H. Tân Lạc", "H. Mai Châu", "H. Lạc Sơn", "H. Yên Thủy", "H. Lạc Thủy",
  ],
  "Hưng Yên": [
    "TP. Hưng Yên",
    "H. Văn Lâm", "H. Văn Giang", "H. Yên Mỹ", "H. Mỹ Hào",
    "H. Ân Thi", "H. Khoái Châu", "H. Kim Động", "H. Tiên Lữ", "H. Phù Cừ",
  ],
  "Khánh Hòa": [
    "TP. Nha Trang", "TP. Cam Ranh", "TX. Ninh Hòa",
    "H. Vạn Ninh", "H. Khánh Vĩnh", "H. Diên Khánh", "H. Khánh Sơn",
    "H. Trường Sa", "H. Cam Lâm",
  ],
  "Kiên Giang": [
    "TP. Rạch Giá", "TP. Hà Tiên", "TX. Kiên Lương",
    "H. Kiên Hải", "H. Châu Thành", "H. Giồng Riềng", "H. Gò Quao",
    "H. An Biên", "H. An Minh", "H. Vĩnh Thuận", "H. Phú Quốc",
    "H. Tân Hiệp", "H. Hòn Đất", "H. Giang Thành", "H. U Minh Thượng",
  ],
  "Kon Tum": [
    "TP. Kon Tum",
    "H. Đắk Glei", "H. Ngọc Hồi", "H. Đắk Tô", "H. Kon Plông",
    "H. Kon Rẫy", "H. Đắk Hà", "H. Sa Thầy", "H. Tu Mơ Rông", "H. Ia H'Drai",
  ],
  "Lai Châu": [
    "TP. Lai Châu",
    "H. Tam Đường", "H. Mường Tè", "H. Sìn Hồ", "H. Phong Thổ",
    "H. Than Uyên", "H. Tân Uyên", "H. Nậm Nhùn",
  ],
  "Lâm Đồng": [
    "TP. Đà Lạt", "TP. Bảo Lộc",
    "H. Đức Trọng", "H. Lạc Dương", "H. Đơn Dương", "H. Đạ Huoai",
    "H. Đạ Tẻh", "H. Cát Tiên", "H. Đam Rông", "H. Lâm Hà", "H. Bảo Lâm",
  ],
  "Lạng Sơn": [
    "TP. Lạng Sơn",
    "H. Tràng Định", "H. Bình Gia", "H. Văn Lãng", "H. Cao Lộc",
    "H. Văn Quan", "H. Bắc Sơn", "H. Hữu Lũng", "H. Chi Lăng",
    "H. Lộc Bình", "H. Đình Lập",
  ],
  "Lào Cai": [
    "TP. Lào Cai", "TX. Sa Pa",
    "H. Bát Xát", "H. Mường Khương", "H. Si Ma Cai", "H. Bắc Hà",
    "H. Bảo Thắng", "H. Bảo Yên", "H. Văn Bàn",
  ],
  "Long An": [
    "TP. Tân An", "TX. Kiến Tường",
    "H. Tân Hưng", "H. Vĩnh Hưng", "H. Mộc Hóa", "H. Tân Thạnh",
    "H. Thạnh Hóa", "H. Đức Huệ", "H. Đức Hòa", "H. Bến Lức",
    "H. Thủ Thừa", "H. Tân Trụ", "H. Cần Đước", "H. Cần Giuộc", "H. Châu Thành",
  ],
  "Nam Định": [
    "TP. Nam Định",
    "H. Mỹ Lộc", "H. Vụ Bản", "H. Ý Yên", "H. Nghĩa Hưng", "H. Nam Trực",
    "H. Trực Ninh", "H. Xuân Trường", "H. Giao Thủy", "H. Hải Hậu",
  ],
  "Nghệ An": [
    "TP. Vinh", "TX. Cửa Lò", "TX. Thái Hòa", "TX. Hoàng Mai",
    "H. Quế Phong", "H. Quỳ Châu", "H. Kỳ Sơn", "H. Tương Dương",
    "H. Nghĩa Đàn", "H. Quỳ Hợp", "H. Quỳnh Lưu", "H. Con Cuông",
    "H. Tân Kỳ", "H. Anh Sơn", "H. Diễn Châu", "H. Yên Thành",
    "H. Đô Lương", "H. Thanh Chương", "H. Nghi Lộc", "H. Nam Đàn", "H. Hưng Nguyên",
  ],
  "Ninh Bình": [
    "TP. Ninh Bình", "TP. Tam Điệp",
    "H. Nho Quan", "H. Gia Viễn", "H. Hoa Lư", "H. Yên Khánh",
    "H. Kim Sơn", "H. Yên Mô",
  ],
  "Ninh Thuận": [
    "TP. Phan Rang-Tháp Chàm",
    "H. Bác Ái", "H. Ninh Sơn", "H. Ninh Hải", "H. Ninh Phước",
    "H. Thuận Bắc", "H. Thuận Nam",
  ],
  "Phú Thọ": [
    "TP. Việt Trì", "TX. Phú Thọ",
    "H. Đoan Hùng", "H. Hạ Hoà", "H. Thanh Ba", "H. Phù Ninh",
    "H. Yên Lập", "H. Cẩm Khê", "H. Tam Nông", "H. Lâm Thao",
    "H. Thanh Sơn", "H. Thanh Thuỷ", "H. Tân Sơn",
  ],
  "Phú Yên": [
    "TP. Tuy Hòa", "TX. Sông Cầu",
    "H. Đồng Xuân", "H. Tuy An", "H. Sơn Hòa", "H. Sông Hinh",
    "H. Tây Hòa", "H. Phú Hòa", "H. Đông Hòa",
  ],
  "Quảng Bình": [
    "TP. Đồng Hới", "TX. Ba Đồn",
    "H. Minh Hóa", "H. Tuyên Hóa", "H. Quảng Trạch", "H. Bố Trạch",
    "H. Quảng Ninh", "H. Lệ Thủy",
  ],
  "Quảng Nam": [
    "TP. Tam Kỳ", "TP. Hội An", "TX. Điện Bàn",
    "H. Đại Lộc", "H. Duy Xuyên", "H. Quế Sơn", "H. Nam Giang",
    "H. Phước Sơn", "H. Hiệp Đức", "H. Thăng Bình", "H. Tiên Phước",
    "H. Bắc Trà My", "H. Nam Trà My", "H. Núi Thành", "H. Phú Ninh",
    "H. Nông Sơn", "H. Đông Giang", "H. Tây Giang",
  ],
  "Quảng Ngãi": [
    "TP. Quảng Ngãi",
    "H. Bình Sơn", "H. Trà Bồng", "H. Sơn Tịnh", "H. Tư Nghĩa",
    "H. Sơn Hà", "H. Sơn Tây", "H. Minh Long", "H. Nghĩa Hành",
    "H. Mộ Đức", "H. Đức Phổ", "H. Ba Tơ", "H. Lý Sơn",
  ],
  "Quảng Ninh": [
    "TP. Hạ Long", "TP. Móng Cái", "TP. Cẩm Phả", "TP. Uông Bí",
    "TX. Quảng Yên", "TX. Đông Triều",
    "H. Bình Liêu", "H. Tiên Yên", "H. Đầm Hà", "H. Hải Hà",
    "H. Ba Chẽ", "H. Vân Đồn", "H. Cô Tô",
  ],
  "Quảng Trị": [
    "TP. Đông Hà", "TX. Quảng Trị",
    "H. Vĩnh Linh", "H. Hướng Hóa", "H. Gio Linh", "H. Đa Krông",
    "H. Cam Lộ", "H. Triệu Phong", "H. Hải Lăng", "H. Cồn Cỏ",
  ],
  "Sóc Trăng": [
    "TP. Sóc Trăng", "TX. Vĩnh Châu", "TX. Ngã Năm",
    "H. Kế Sách", "H. Mỹ Tú", "H. Cù Lao Dung", "H. Long Phú",
    "H. Mỹ Xuyên", "H. Thạnh Trị", "H. Châu Thành", "H. Trần Đề",
  ],
  "Sơn La": [
    "TP. Sơn La",
    "H. Quỳnh Nhai", "H. Thuận Châu", "H. Mường La", "H. Bắc Yên",
    "H. Phù Yên", "H. Mộc Châu", "H. Yên Châu", "H. Mai Sơn",
    "H. Sông Mã", "H. Sốp Cộp", "H. Vân Hồ",
  ],
  "Tây Ninh": [
    "TP. Tây Ninh",
    "H. Tân Biên", "H. Tân Châu", "H. Dương Minh Châu", "H. Châu Thành",
    "H. Hòa Thành", "H. Gò Dầu", "H. Bến Cầu", "H. Trảng Bàng",
  ],
  "Thái Bình": [
    "TP. Thái Bình",
    "H. Quỳnh Phụ", "H. Hưng Hà", "H. Đông Hưng", "H. Thái Thụy",
    "H. Tiền Hải", "H. Kiến Xương", "H. Vũ Thư",
  ],
  "Thái Nguyên": [
    "TP. Thái Nguyên", "TP. Sông Công", "TX. Phổ Yên",
    "H. Định Hóa", "H. Phú Lương", "H. Đồng Hỷ", "H. Võ Nhai",
    "H. Đại Từ", "H. Phú Bình",
  ],
  "Thanh Hóa": [
    "TP. Thanh Hóa", "TX. Bỉm Sơn", "TX. Sầm Sơn", "TX. Nghi Sơn",
    "H. Mường Lát", "H. Quan Hóa", "H. Bá Thước", "H. Quan Sơn",
    "H. Lang Chánh", "H. Ngọc Lặc", "H. Cẩm Thủy", "H. Thạch Thành",
    "H. Hà Trung", "H. Vĩnh Lộc", "H. Yên Định", "H. Thọ Xuân",
    "H. Thường Xuân", "H. Triệu Sơn", "H. Thiệu Hóa", "H. Hoằng Hóa",
    "H. Hậu Lộc", "H. Nga Sơn", "H. Như Xuân", "H. Như Thanh",
    "H. Nông Cống", "H. Đông Sơn", "H. Quảng Xương",
  ],
  "Thừa Thiên Huế": [
    "TP. Huế", "TX. Hương Thuỷ", "TX. Hương Trà",
    "H. Phong Điền", "H. Quảng Điền", "H. Phú Vang", "H. Phú Lộc",
    "H. A Lưới", "H. Nam Đông",
  ],
  "Tiền Giang": [
    "TP. Mỹ Tho", "TX. Gò Công", "TX. Cai Lậy",
    "H. Tân Phước", "H. Cái Bè", "H. Cai Lậy", "H. Châu Thành",
    "H. Chợ Gạo", "H. Gò Công Tây", "H. Gò Công Đông", "H. Tân Phú Đông",
  ],
  "Trà Vinh": [
    "TP. Trà Vinh", "TX. Duyên Hải",
    "H. Càng Long", "H. Cầu Kè", "H. Tiểu Cần", "H. Châu Thành",
    "H. Cầu Ngang", "H. Trà Cú", "H. Duyên Hải",
  ],
  "Tuyên Quang": [
    "TP. Tuyên Quang",
    "H. Lâm Bình", "H. Na Hang", "H. Chiêm Hóa", "H. Hàm Yên",
    "H. Yên Sơn", "H. Sơn Dương",
  ],
  "Vĩnh Long": [
    "TP. Vĩnh Long", "TX. Bình Minh",
    "H. Long Hồ", "H. Mang Thít", "H. Vũng Liêm", "H. Tam Bình",
    "H. Bình Tân", "H. Trà Ôn",
  ],
  "Vĩnh Phúc": [
    "TP. Vĩnh Yên", "TX. Phúc Yên",
    "H. Lập Thạch", "H. Tam Dương", "H. Tam Đảo", "H. Bình Xuyên",
    "H. Yên Lạc", "H. Vĩnh Tường", "H. Sông Lô",
  ],
  "Yên Bái": [
    "TP. Yên Bái", "TX. Nghĩa Lộ",
    "H. Lục Yên", "H. Văn Yên", "H. Mù Cang Chải", "H. Trấn Yên",
    "H. Trạm Tấu", "H. Văn Chấn", "H. Yên Bình",
  ],
}

// ============================================================
// DANH SÁCH 34 TỈNH THÀNH VIỆT NAM SAU SÁP NHẬP 2025 (V2)
// Theo Nghị quyết của Quốc hội ngày 12/6/2025, có hiệu lực từ 01/07/2025
// Nguồn: https://xaydungchinhsach.chinhphu.vn/chi-tiet-34-don-vi-hanh-chinh-cap-tinh-tu-12-6-2025
// ============================================================
export const PROVINCES_V2 = [
  // 28 tỉnh + 6 thành phố trực thuộc TW = 34 đơn vị hành chính cấp tỉnh
  "An Giang",
  "Bắc Ninh",
  "Cà Mau",
  "Cao Bằng",
  "Đắk Lắk",
  "Điện Biên",
  "Đồng Nai",
  "Đồng Tháp",
  "Gia Lai",
  "Hà Tĩnh",
  "Hưng Yên",
  "Khánh Hòa",
  "Lai Châu",
  "Lâm Đồng",
  "Lạng Sơn",
  "Lào Cai",
  "Nghệ An",
  "Ninh Bình",
  "Phú Thọ",
  "Quảng Ngãi",
  "Quảng Ninh",
  "Quảng Trị",
  "Sơn La",
  "Tây Ninh",
  "Thái Nguyên",
  "Thanh Hóa",
  "Tuyên Quang",
  "Vĩnh Long",
  // 6 thành phố trực thuộc TW
  "TP. Cần Thơ",
  "TP. Đà Nẵng",
  "TP. Hà Nội",
  "TP. Hải Phòng",
  "TP. Hồ Chí Minh",
  "TP. Huế",
]

// Backward compatibility - export PROVINCES as V1 by default (before merger)
export const PROVINCES = PROVINCES_V1

export const STATION_TYPES = [
  "Loại 1",
  "Loại 2",
  "Loại 3",
  "Loại 4",
  "Loại 5",
  "Loại 6",
]

// Mapping chi tiết tỉnh thành sáp nhập (cho mục đích tra cứu tỉnh cũ)
export const PROVINCE_MERGE_MAP: Record<string, string[]> = {
  // Các tỉnh hợp nhất từ nhiều tỉnh cũ
  "An Giang": ["An Giang", "Kiên Giang"],
  "Bắc Ninh": ["Bắc Giang", "Bắc Ninh", "Hải Dương"],
  "Cà Mau": ["Bạc Liêu", "Cà Mau"],
  "Đắk Lắk": ["Đắk Lắk", "Phú Yên"],
  "Đồng Nai": ["Bình Phước", "Đồng Nai"],
  "Đồng Tháp": ["Bến Tre", "Đồng Tháp", "Tiền Giang", "Trà Vinh"],
  "Gia Lai": ["Bình Định", "Gia Lai"],
  "Hưng Yên": ["Hà Nam", "Hưng Yên", "Nam Định", "Thái Bình"],
  "Khánh Hòa": ["Khánh Hòa", "Ninh Thuận"],
  "Lâm Đồng": ["Bình Thuận", "Đắk Nông", "Lâm Đồng"],
  "Lào Cai": ["Lào Cai", "Yên Bái"],
  "Phú Thọ": ["Hòa Bình", "Phú Thọ", "Vĩnh Phúc"],
  "Quảng Ngãi": ["Kon Tum", "Quảng Ngãi"],
  "Quảng Trị": ["Quảng Bình", "Quảng Trị"],
  "Tây Ninh": ["Long An", "Tây Ninh"],
  "Thái Nguyên": ["Bắc Kạn", "Thái Nguyên"],
  "Tuyên Quang": ["Hà Giang", "Tuyên Quang"],
  "TP. Cần Thơ": ["Cần Thơ", "Hậu Giang", "Sóc Trăng"],
  "TP. Đà Nẵng": ["Đà Nẵng", "Quảng Nam"],
  "TP. Hồ Chí Minh": ["Bà Rịa - Vũng Tàu", "Bình Dương", "TP. Hồ Chí Minh"],
  // Các tỉnh không sáp nhập
  "Cao Bằng": ["Cao Bằng"],
  "Điện Biên": ["Điện Biên"],
  "Hà Tĩnh": ["Hà Tĩnh"],
  "Lai Châu": ["Lai Châu"],
  "Lạng Sơn": ["Lạng Sơn"],
  "Nghệ An": ["Nghệ An"],
  "Ninh Bình": ["Ninh Bình"],
  "Quảng Ninh": ["Quảng Ninh"],
  "Sơn La": ["Sơn La"],
  "Thanh Hóa": ["Thanh Hóa"],
  "Vĩnh Long": ["Vĩnh Long"],
  "TP. Hà Nội": ["Hà Nội"],
  "TP. Hải Phòng": ["Hải Phòng"],
  "TP. Huế": ["Thừa Thiên Huế"],
}

// ============================================================
// PHƯỜNG XÃ THEO TỈNH THÀNH SAU SÁP NHẬP 2025 (V2)
// Sau sáp nhập chỉ còn 2 cấp: Tỉnh/TP → Phường/Xã (không còn Quận/Huyện)
// ============================================================
export const WARDS_BY_PROVINCE_V2: Record<string, string[]> = {
  // ===== 6 THÀNH PHỐ TRỰC THUỘC TRUNG ƯƠNG =====
  "TP. Hồ Chí Minh": [
    // Các quận/huyện cũ của TP.HCM
    "Q. 1", "Q. 3", "Q. 4", "Q. 5", "Q. 6", "Q. 7", "Q. 8",
    "Q. 10", "Q. 11", "Q. 12", "Q. Bình Thạnh", "Q. Bình Tân",
    "Q. Gò Vấp", "Q. Phú Nhuận", "Q. Tân Bình", "Q. Tân Phú",
    "TP. Thủ Đức",
    "H. Bình Chánh", "H. Cần Giờ", "H. Củ Chi", "H. Hóc Môn", "H. Nhà Bè",
    // Các quận/huyện từ Bình Dương
    "TP. Thủ Dầu Một", "TP. Thuận An", "TP. Dĩ An", "TP. Tân Uyên",
    "TX. Bến Cát", "H. Bàu Bàng", "H. Dầu Tiếng", "H. Phú Giáo", "H. Bắc Tân Uyên",
    // Các quận/huyện từ Bà Rịa - Vũng Tàu
    "TP. Vũng Tàu", "TP. Bà Rịa", "TX. Phú Mỹ",
    "H. Châu Đức", "H. Xuyên Mộc", "H. Long Điền", "H. Đất Đỏ", "H. Côn Đảo",
  ],
  "TP. Hà Nội": [
    "Q. Ba Đình", "Q. Hoàn Kiếm", "Q. Tây Hồ", "Q. Long Biên", "Q. Cầu Giấy",
    "Q. Đống Đa", "Q. Hai Bà Trưng", "Q. Hoàng Mai", "Q. Thanh Xuân",
    "Q. Nam Từ Liêm", "Q. Bắc Từ Liêm", "Q. Hà Đông",
    "TX. Sơn Tây",
    "H. Sóc Sơn", "H. Đông Anh", "H. Gia Lâm", "H. Mê Linh", "H. Ba Vì",
    "H. Phúc Thọ", "H. Đan Phượng", "H. Hoài Đức", "H. Quốc Oai",
    "H. Thạch Thất", "H. Chương Mỹ", "H. Thanh Oai", "H. Thường Tín",
    "H. Phú Xuyên", "H. Ứng Hòa", "H. Mỹ Đức", "H. Thanh Trì",
  ],
  "TP. Đà Nẵng": [
    // Các quận cũ của Đà Nẵng
    "Q. Hải Châu", "Q. Thanh Khê", "Q. Sơn Trà", "Q. Ngũ Hành Sơn",
    "Q. Liên Chiểu", "Q. Cẩm Lệ", "H. Hòa Vang", "H. Hoàng Sa",
    // Các huyện từ Quảng Nam
    "TP. Tam Kỳ", "TP. Hội An", "TX. Điện Bàn",
    "H. Đại Lộc", "H. Duy Xuyên", "H. Quế Sơn", "H. Nam Giang",
    "H. Phước Sơn", "H. Hiệp Đức", "H. Thăng Bình", "H. Tiên Phước",
    "H. Bắc Trà My", "H. Nam Trà My", "H. Núi Thành", "H. Phú Ninh",
    "H. Nông Sơn", "H. Đông Giang", "H. Tây Giang",
  ],
  "TP. Cần Thơ": [
    // Các quận cũ của Cần Thơ
    "Q. Ninh Kiều", "Q. Ô Môn", "Q. Bình Thủy", "Q. Cái Răng", "Q. Thốt Nốt",
    "H. Vĩnh Thạnh", "H. Cờ Đỏ", "H. Phong Điền", "H. Thới Lai",
    // Các huyện từ Hậu Giang
    "TP. Vị Thanh", "TX. Ngã Bảy", "TX. Long Mỹ",
    "H. Châu Thành A", "H. Châu Thành", "H. Phụng Hiệp", "H. Vị Thủy",
    // Các huyện từ Sóc Trăng
    "TP. Sóc Trăng", "TX. Vĩnh Châu", "TX. Ngã Năm",
    "H. Kế Sách", "H. Mỹ Tú", "H. Cù Lao Dung", "H. Long Phú",
    "H. Mỹ Xuyên", "H. Thạnh Trị", "H. Châu Thành (ST)", "H. Trần Đề",
  ],
  "TP. Hải Phòng": [
    "Q. Hồng Bàng", "Q. Ngô Quyền", "Q. Lê Chân", "Q. Hải An", "Q. Kiến An",
    "Q. Đồ Sơn", "Q. Dương Kinh",
    "H. Thuỷ Nguyên", "H. An Dương", "H. An Lão", "H. Kiến Thuỵ",
    "H. Tiên Lãng", "H. Vĩnh Bảo", "H. Cát Hải", "H. Bạch Long Vĩ",
  ],
  "TP. Huế": [
    "Q. Thuận Hoà", "Q. Phú Xuân", "Q. Vĩnh Ninh",
    "TX. Hương Thuỷ", "TX. Hương Trà",
    "H. Phong Điền (TT)", "H. Quảng Điền", "H. Phú Vang", "H. Phú Lộc",
    "H. A Lưới", "H. Nam Đông",
  ],

  // ===== 28 TỈNH =====
  "An Giang": [
    // An Giang cũ
    "TP. Long Xuyên", "TP. Châu Đốc", "TX. Tân Châu",
    "H. An Phú", "H. Tịnh Biên", "H. Tri Tôn", "H. Châu Phú",
    "H. Chợ Mới", "H. Phú Tân", "H. Thoại Sơn", "H. Châu Thành (AG)",
    // Từ Kiên Giang
    "TP. Rạch Giá", "TP. Hà Tiên", "TX. Kiên Lương",
    "H. Kiên Hải", "H. Châu Thành (KG)", "H. Giồng Riềng", "H. Gò Quao",
    "H. An Biên", "H. An Minh", "H. Vĩnh Thuận", "H. Phú Quốc",
    "H. Tân Hiệp", "H. Hòn Đất", "H. Giang Thành", "H. U Minh Thượng",
  ],
  "Bắc Ninh": [
    // Bắc Ninh cũ
    "TP. Bắc Ninh", "TX. Từ Sơn",
    "H. Yên Phong", "H. Quế Võ", "H. Tiên Du", "H. Thuận Thành",
    "H. Gia Bình", "H. Lương Tài",
    // Từ Bắc Giang
    "TP. Bắc Giang",
    "H. Yên Thế", "H. Tân Yên", "H. Lạng Giang", "H. Lục Nam",
    "H. Lục Ngạn", "H. Sơn Động", "H. Yên Dũng", "H. Việt Yên", "H. Hiệp Hòa",
    // Từ Hải Dương
    "TP. Hải Dương", "TX. Chí Linh", "TX. Kinh Môn",
    "H. Nam Sách", "H. Thanh Hà", "H. Kim Thành", "H. Gia Lộc",
    "H. Tứ Kỳ", "H. Ninh Giang", "H. Thanh Miện", "H. Cẩm Giàng", "H. Bình Giang",
  ],
  "Cà Mau": [
    // Cà Mau cũ
    "TP. Cà Mau",
    "H. U Minh", "H. Thới Bình", "H. Trần Văn Thời", "H. Cái Nước",
    "H. Đầm Dơi", "H. Năm Căn", "H. Phú Tân (CM)", "H. Ngọc Hiển",
    // Từ Bạc Liêu
    "TP. Bạc Liêu", "TX. Giá Rai",
    "H. Vĩnh Lợi", "H. Hồng Dân", "H. Phước Long", "H. Hòa Bình", "H. Đông Hải",
  ],
  "Cao Bằng": [
    "TP. Cao Bằng",
    "H. Bảo Lâm", "H. Bảo Lạc", "H. Hà Quảng", "H. Trùng Khánh",
    "H. Hạ Lang", "H. Quảng Hòa", "H. Hoà An", "H. Nguyên Bình",
    "H. Thạch An",
  ],
  "Đắk Lắk": [
    // Đắk Lắk cũ
    "TP. Buôn Ma Thuột", "TX. Buôn Hồ",
    "H. Ea H'leo", "H. Ea Súp", "H. Buôn Đôn", "H. Cư M'gar",
    "H. Krông Búk", "H. Krông Năng", "H. Ea Kar", "H. M'Đrắk",
    "H. Krông Bông", "H. Krông Pắc", "H. Krông A Na", "H. Lắk", "H. Cư Kuin",
    // Từ Phú Yên
    "TP. Tuy Hòa", "TX. Sông Cầu",
    "H. Đồng Xuân", "H. Tuy An", "H. Sơn Hòa", "H. Sông Hinh",
    "H. Tây Hòa", "H. Phú Hòa", "H. Đông Hòa",
  ],
  "Điện Biên": [
    "TP. Điện Biên Phủ", "TX. Mường Lay",
    "H. Mường Nhé", "H. Mường Chà", "H. Tủa Chùa", "H. Tuần Giáo",
    "H. Điện Biên", "H. Điện Biên Đông", "H. Mường Ảng", "H. Nậm Pồ",
  ],
  "Đồng Nai": [
    // Đồng Nai cũ
    "TP. Biên Hòa", "TP. Long Khánh",
    "H. Tân Phú", "H. Vĩnh Cửu", "H. Định Quán", "H. Trảng Bom",
    "H. Thống Nhất", "H. Cẩm Mỹ", "H. Long Thành", "H. Xuân Lộc", "H. Nhơn Trạch",
    // Từ Bình Phước
    "TP. Đồng Xoài", "TX. Bình Long", "TX. Phước Long", "TX. Chơn Thành",
    "H. Bù Gia Mập", "H. Lộc Ninh", "H. Bù Đốp", "H. Hớn Quản",
    "H. Đồng Phú", "H. Bù Đăng", "H. Phú Riềng",
  ],
  "Đồng Tháp": [
    // Đồng Tháp cũ
    "TP. Cao Lãnh", "TP. Sa Đéc", "TX. Hồng Ngự",
    "H. Tân Hồng", "H. Hồng Ngự", "H. Tam Nông", "H. Tháp Mười",
    "H. Cao Lãnh", "H. Thanh Bình", "H. Lấp Vò", "H. Lai Vung", "H. Châu Thành (ĐT)",
    // Từ Bến Tre
    "TP. Bến Tre",
    "H. Châu Thành (BT)", "H. Chợ Lách", "H. Mỏ Cày Nam", "H. Giồng Trôm",
    "H. Bình Đại", "H. Ba Tri", "H. Thạnh Phú", "H. Mỏ Cày Bắc",
    // Từ Tiền Giang
    "TP. Mỹ Tho", "TX. Gò Công", "TX. Cai Lậy",
    "H. Tân Phước", "H. Cái Bè", "H. Cai Lậy", "H. Châu Thành (TG)",
    "H. Chợ Gạo", "H. Gò Công Tây", "H. Gò Công Đông", "H. Tân Phú Đông",
    // Từ Trà Vinh
    "TP. Trà Vinh", "TX. Duyên Hải",
    "H. Càng Long", "H. Cầu Kè", "H. Tiểu Cần", "H. Châu Thành (TV)",
    "H. Cầu Ngang", "H. Trà Cú", "H. Duyên Hải",
  ],
  "Gia Lai": [
    // Gia Lai cũ
    "TP. Pleiku", "TX. An Khê", "TX. Ayun Pa",
    "H. Kbang", "H. Đăk Đoa", "H. Chư Păh", "H. Ia Grai",
    "H. Mang Yang", "H. Kông Chro", "H. Đức Cơ", "H. Chư Prông",
    "H. Chư Sê", "H. Đăk Pơ", "H. Ia Pa", "H. Krông Pa",
    "H. Phú Thiện", "H. Chư Pưh",
    // Từ Bình Định
    "TP. Quy Nhơn", "TX. An Nhơn", "TX. Hoài Nhơn",
    "H. An Lão", "H. Hoài Ân", "H. Phù Mỹ", "H. Vĩnh Thạnh",
    "H. Tây Sơn", "H. Phù Cát", "H. Vân Canh", "H. Tuy Phước",
  ],
  "Hà Tĩnh": [
    "TP. Hà Tĩnh", "TX. Hồng Lĩnh", "TX. Kỳ Anh",
    "H. Hương Sơn", "H. Đức Thọ", "H. Vũ Quang", "H. Nghi Xuân",
    "H. Can Lộc", "H. Hương Khê", "H. Thạch Hà", "H. Cẩm Xuyên",
    "H. Kỳ Anh", "H. Lộc Hà",
  ],
  "Hưng Yên": [
    // Hưng Yên cũ
    "TP. Hưng Yên",
    "H. Văn Lâm", "H. Văn Giang", "H. Yên Mỹ", "H. Mỹ Hào",
    "H. Ân Thi", "H. Khoái Châu", "H. Kim Động", "H. Tiên Lữ", "H. Phù Cừ",
    // Từ Hà Nam
    "TP. Phủ Lý",
    "H. Duy Tiên", "H. Kim Bảng", "H. Thanh Liêm", "H. Bình Lục", "H. Lý Nhân",
    // Từ Nam Định
    "TP. Nam Định",
    "H. Mỹ Lộc", "H. Vụ Bản", "H. Ý Yên", "H. Nghĩa Hưng", "H. Nam Trực",
    "H. Trực Ninh", "H. Xuân Trường", "H. Giao Thủy", "H. Hải Hậu",
    // Từ Thái Bình
    "TP. Thái Bình",
    "H. Quỳnh Phụ", "H. Hưng Hà", "H. Đông Hưng", "H. Thái Thụy",
    "H. Tiền Hải", "H. Kiến Xương", "H. Vũ Thư",
  ],
  "Khánh Hòa": [
    // Khánh Hòa cũ
    "TP. Nha Trang", "TP. Cam Ranh",
    "TX. Ninh Hòa",
    "H. Vạn Ninh", "H. Khánh Vĩnh", "H. Diên Khánh", "H. Khánh Sơn",
    "H. Trường Sa", "H. Cam Lâm",
    // Từ Ninh Thuận
    "TP. Phan Rang-Tháp Chàm",
    "H. Bác Ái", "H. Ninh Sơn", "H. Ninh Hải", "H. Ninh Phước", "H. Thuận Bắc", "H. Thuận Nam",
  ],
  "Lai Châu": [
    "TP. Lai Châu",
    "H. Tam Đường", "H. Mường Tè", "H. Sìn Hồ", "H. Phong Thổ",
    "H. Than Uyên", "H. Tân Uyên", "H. Nậm Nhùn",
  ],
  "Lâm Đồng": [
    // Lâm Đồng cũ
    "TP. Đà Lạt", "TP. Bảo Lộc",
    "H. Đức Trọng", "H. Lạc Dương", "H. Đơn Dương", "H. Đạ Huoai",
    "H. Đạ Tẻh", "H. Cát Tiên", "H. Đam Rông", "H. Lâm Hà", "H. Bảo Lâm",
    // Từ Đắk Nông
    "TP. Gia Nghĩa", "H. Đắk Glong", "H. Cư Jút", "H. Đắk Mil",
    "H. Krông Nô", "H. Đắk Song", "H. Đắk R'Lấp", "H. Tuy Đức",
    // Từ Bình Thuận
    "TP. Phan Thiết", "TX. La Gi",
    "H. Tuy Phong", "H. Bắc Bình", "H. Hàm Thuận Bắc", "H. Hàm Thuận Nam",
    "H. Tánh Linh", "H. Hàm Tân", "H. Đức Linh", "H. Phú Quý",
  ],
  "Lạng Sơn": [
    "TP. Lạng Sơn",
    "H. Tràng Định", "H. Bình Gia", "H. Văn Lãng", "H. Cao Lộc",
    "H. Văn Quan", "H. Bắc Sơn", "H. Hữu Lũng", "H. Chi Lăng",
    "H. Lộc Bình", "H. Đình Lập",
  ],
  "Lào Cai": [
    // Lào Cai cũ
    "TP. Lào Cai", "TX. Sa Pa",
    "H. Bát Xát", "H. Mường Khương", "H. Si Ma Cai", "H. Bắc Hà",
    "H. Bảo Thắng", "H. Bảo Yên", "H. Văn Bàn",
    // Từ Yên Bái
    "TP. Yên Bái", "TX. Nghĩa Lộ",
    "H. Lục Yên", "H. Văn Yên", "H. Mù Cang Chải", "H. Trấn Yên",
    "H. Trạm Tấu", "H. Văn Chấn", "H. Yên Bình",
  ],
  "Nghệ An": [
    "TP. Vinh", "TX. Cửa Lò", "TX. Thái Hòa", "TX. Hoàng Mai",
    "H. Quế Phong", "H. Quỳ Châu", "H. Kỳ Sơn", "H. Tương Dương",
    "H. Nghĩa Đàn", "H. Quỳ Hợp", "H. Quỳnh Lưu", "H. Con Cuông",
    "H. Tân Kỳ", "H. Anh Sơn", "H. Diễn Châu", "H. Yên Thành",
    "H. Đô Lương", "H. Thanh Chương", "H. Nghi Lộc", "H. Nam Đàn", "H. Hưng Nguyên",
  ],
  "Ninh Bình": [
    "TP. Ninh Bình", "TP. Tam Điệp",
    "H. Nho Quan", "H. Gia Viễn", "H. Hoa Lư", "H. Yên Khánh",
    "H. Kim Sơn", "H. Yên Mô",
  ],
  "Phú Thọ": [
    // Phú Thọ cũ
    "TP. Việt Trì", "TX. Phú Thọ",
    "H. Đoan Hùng", "H. Hạ Hoà", "H. Thanh Ba", "H. Phù Ninh",
    "H. Yên Lập", "H. Cẩm Khê", "H. Tam Nông (PT)", "H. Lâm Thao",
    "H. Thanh Sơn", "H. Thanh Thuỷ", "H. Tân Sơn",
    // Từ Hòa Bình
    "TP. Hòa Bình",
    "H. Đà Bắc", "H. Lương Sơn", "H. Kim Bôi", "H. Cao Phong",
    "H. Tân Lạc", "H. Mai Châu", "H. Lạc Sơn", "H. Yên Thủy", "H. Lạc Thủy",
    // Từ Vĩnh Phúc
    "TP. Vĩnh Yên", "TX. Phúc Yên",
    "H. Lập Thạch", "H. Tam Dương", "H. Tam Đảo", "H. Bình Xuyên",
    "H. Yên Lạc", "H. Vĩnh Tường", "H. Sông Lô",
  ],
  "Quảng Ngãi": [
    // Quảng Ngãi cũ
    "TP. Quảng Ngãi",
    "H. Bình Sơn", "H. Trà Bồng", "H. Sơn Tịnh", "H. Tư Nghĩa",
    "H. Sơn Hà", "H. Sơn Tây", "H. Minh Long", "H. Nghĩa Hành",
    "H. Mộ Đức", "H. Đức Phổ", "H. Ba Tơ", "H. Lý Sơn",
    // Từ Kon Tum
    "TP. Kon Tum",
    "H. Đắk Glei", "H. Ngọc Hồi", "H. Đắk Tô", "H. Kon Plông",
    "H. Kon Rẫy", "H. Đắk Hà", "H. Sa Thầy", "H. Tu Mơ Rông", "H. Ia H'Drai",
  ],
  "Quảng Ninh": [
    "TP. Hạ Long", "TP. Móng Cái", "TP. Cẩm Phả", "TP. Uông Bí",
    "TX. Quảng Yên", "TX. Đông Triều",
    "H. Bình Liêu", "H. Tiên Yên", "H. Đầm Hà", "H. Hải Hà",
    "H. Ba Chẽ", "H. Vân Đồn", "H. Cô Tô",
  ],
  "Quảng Trị": [
    // Quảng Trị cũ
    "TP. Đông Hà", "TX. Quảng Trị",
    "H. Vĩnh Linh", "H. Hướng Hóa", "H. Gio Linh", "H. Đa Krông",
    "H. Cam Lộ", "H. Triệu Phong", "H. Hải Lăng", "H. Cồn Cỏ",
    // Từ Quảng Bình
    "TP. Đồng Hới", "TX. Ba Đồn",
    "H. Minh Hóa", "H. Tuyên Hóa", "H. Quảng Trạch", "H. Bố Trạch",
    "H. Quảng Ninh (QB)", "H. Lệ Thủy",
  ],
  "Sơn La": [
    "TP. Sơn La",
    "H. Quỳnh Nhai", "H. Thuận Châu", "H. Mường La", "H. Bắc Yên",
    "H. Phù Yên", "H. Mộc Châu", "H. Yên Châu", "H. Mai Sơn",
    "H. Sông Mã", "H. Sốp Cộp", "H. Vân Hồ",
  ],
  "Tây Ninh": [
    // Tây Ninh cũ
    "TP. Tây Ninh",
    "H. Tân Biên", "H. Tân Châu (TN)", "H. Dương Minh Châu", "H. Châu Thành (TN)",
    "H. Hòa Thành", "H. Gò Dầu", "H. Bến Cầu", "H. Trảng Bàng",
    // Từ Long An
    "TP. Tân An", "TX. Kiến Tường",
    "H. Tân Hưng", "H. Vĩnh Hưng", "H. Mộc Hóa", "H. Tân Thạnh",
    "H. Thạnh Hóa", "H. Đức Huệ", "H. Đức Hòa", "H. Bến Lức",
    "H. Thủ Thừa", "H. Tân Trụ", "H. Cần Đước", "H. Cần Giuộc", "H. Châu Thành (LA)",
  ],
  "Thái Nguyên": [
    // Thái Nguyên cũ
    "TP. Thái Nguyên", "TP. Sông Công", "TX. Phổ Yên",
    "H. Định Hóa", "H. Phú Lương", "H. Đồng Hỷ", "H. Võ Nhai",
    "H. Đại Từ", "H. Phú Bình",
    // Từ Bắc Kạn
    "TP. Bắc Kạn",
    "H. Pác Nặm", "H. Ba Bể", "H. Ngân Sơn", "H. Bạch Thông",
    "H. Chợ Đồn", "H. Chợ Mới (BK)", "H. Na Rì",
  ],
  "Thanh Hóa": [
    "TP. Thanh Hóa", "TX. Bỉm Sơn", "TX. Sầm Sơn", "TX. Nghi Sơn",
    "H. Mường Lát", "H. Quan Hóa", "H. Bá Thước", "H. Quan Sơn",
    "H. Lang Chánh", "H. Ngọc Lặc", "H. Cẩm Thủy", "H. Thạch Thành",
    "H. Hà Trung", "H. Vĩnh Lộc", "H. Yên Định", "H. Thọ Xuân",
    "H. Thường Xuân", "H. Triệu Sơn", "H. Thiệu Hóa", "H. Hoằng Hóa",
    "H. Hậu Lộc", "H. Nga Sơn", "H. Như Xuân", "H. Như Thanh",
    "H. Nông Cống", "H. Đông Sơn", "H. Quảng Xương",
  ],
  "Tuyên Quang": [
    // Tuyên Quang cũ
    "TP. Tuyên Quang",
    "H. Lâm Bình", "H. Na Hang", "H. Chiêm Hóa", "H. Hàm Yên",
    "H. Yên Sơn", "H. Sơn Dương",
    // Từ Hà Giang
    "TP. Hà Giang",
    "H. Đồng Văn", "H. Mèo Vạc", "H. Yên Minh", "H. Quản Bạ",
    "H. Vị Xuyên", "H. Bắc Mê", "H. Hoàng Su Phì", "H. Xín Mần",
    "H. Bắc Quang", "H. Quang Bình",
  ],
  "Vĩnh Long": [
    "TP. Vĩnh Long", "TX. Bình Minh",
    "H. Long Hồ", "H. Mang Thít", "H. Vũng Liêm", "H. Tam Bình",
    "H. Bình Tân (VL)", "H. Trà Ôn",
  ],
}

// Backward compatibility - export DISTRICTS_BY_PROVINCE as V1 by default (before merger)
export const DISTRICTS_BY_PROVINCE = DISTRICTS_BY_PROVINCE_V1

// Hàm lấy danh sách quận huyện theo tỉnh thành (V1 - trước sáp nhập)
export function getDistrictsByProvince(province: string): string[] {
  return DISTRICTS_BY_PROVINCE_V1[province] || []
}

// Hàm lấy danh sách phường xã theo tỉnh thành (V2 - sau sáp nhập 2025)
// Sau sáp nhập chỉ còn 2 cấp: Tỉnh/TP → Phường/Xã
export function getWardsByProvinceV2(province: string): string[] {
  return WARDS_BY_PROVINCE_V2[province] || []
}

// Hàm tìm tỉnh mới từ tỉnh cũ
export function getNewProvinceFromOld(oldProvince: string): string | null {
  for (const [newProv, oldProvs] of Object.entries(PROVINCE_MERGE_MAP)) {
    if (oldProvs.includes(oldProvince)) {
      return newProv
    }
  }
  return null
}

// Hàm lấy danh sách tỉnh cũ từ tỉnh mới
export function getOldProvincesFromNew(newProvince: string): string[] {
  return PROVINCE_MERGE_MAP[newProvince] || []
}
</file>

<file path="client/src/features/chat/components/ChatInput.tsx">
import { useState, KeyboardEvent } from 'react'
import { Send } from 'lucide-react'
import { Button } from '@/components/ui/button'

interface ChatInputProps {
  onSend: (message: string) => void
  disabled?: boolean
}

export function ChatInput({ onSend, disabled }: ChatInputProps) {
  const [input, setInput] = useState('')

  const handleSend = () => {
    if (input.trim() && !disabled) {
      onSend(input.trim())
      setInput('')
    }
  }

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  return (
    <div className="flex gap-2 p-3 border-t border-stone-100 bg-white">
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Nhập câu hỏi... (VD: xe 98H07480)"
        disabled={disabled}
        autoComplete="off"
        className="flex-1 bg-stone-50 border border-stone-200 rounded-xl px-4 py-2.5 text-sm text-stone-800 placeholder:text-stone-400 focus:outline-none focus:border-emerald-400 focus:ring-1 focus:ring-emerald-400 transition-colors"
      />
      <Button
        onClick={handleSend}
        disabled={disabled || !input.trim()}
        size="icon"
        className="bg-emerald-500 hover:bg-emerald-600 rounded-xl h-10 w-10 shadow-sm"
      >
        <Send className="w-4 h-4" />
      </Button>
    </div>
  )
}
</file>

<file path="client/src/features/chat/components/ChatMessage.tsx">
import { cn } from '@/lib/utils'
import type { ChatMessage as ChatMessageType } from '../types'
import { Bus, User } from 'lucide-react'

interface ChatMessageProps {
  message: ChatMessageType
}

export function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user'

  return (
    <div className={cn(
      'flex gap-3 p-4',
      isUser ? 'flex-row-reverse' : ''
    )}>
      {/* Avatar */}
      <div className={cn(
        'w-8 h-8 rounded-xl flex items-center justify-center flex-shrink-0',
        isUser
          ? 'bg-stone-800'
          : 'bg-gradient-to-br from-emerald-100 to-teal-100'
      )}>
        {isUser ? (
          <User className="w-4 h-4 text-white" />
        ) : (
          <Bus className="w-4 h-4 text-emerald-600" />
        )}
      </div>

      {/* Message Bubble */}
      <div className={cn(
        'max-w-[80%] rounded-2xl px-4 py-3',
        isUser
          ? 'bg-stone-800 text-white'
          : 'bg-white text-stone-800 border border-stone-100 shadow-sm',
        message.type === 'error' && 'bg-red-50 text-red-700 border-red-100'
      )}>
        <div className="whitespace-pre-wrap text-sm leading-relaxed">
          {message.content}
        </div>
        {message.metadata?.processingTime && (
          <div className={cn(
            'text-[11px] mt-2 font-medium',
            isUser ? 'text-stone-400' : 'text-stone-400'
          )}>
            {message.metadata.processingTime}ms
            {message.metadata.queryType && message.metadata.queryType !== 'GENERAL_QUESTION' && (
              <span className="ml-2 text-emerald-500">• {message.metadata.queryType}</span>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="client/src/features/fleet/vehicles/index.ts">
// Vehicles Domain Public API

// API Services
export { vehicleApi, vehicleService } from './api'
export { vehicleTypeApi, vehicleTypeService } from './api'

// Components
export { VehicleForm, VehicleView } from './components'

// Types
export type {
  Vehicle,
  VehicleInput,
  VehicleDocuments,
  DocumentInfo,
  VehicleType,
  VehicleTypeInput,
  VehicleFilters,
  VehicleFormMode,
} from './types'
</file>

<file path="client/src/hooks/useChoXeVaoBenForm.ts">
import { useState, useEffect } from "react";
import { toast } from "react-toastify";
import { vehicleService } from "@/services/vehicle.service";
import { routeService } from "@/services/route.service";
import { scheduleService } from "@/services/schedule.service";
import { dispatchService } from "@/services/dispatch.service";
import { driverService } from "@/services/driver.service";
import { useUIStore } from "@/store/ui.store";
import type { Route, Schedule, Driver, DispatchInput, DispatchRecord } from "@/types";
import type { Shift } from "@/services/shift.service";

interface UseChoXeVaoBenFormProps {
  open: boolean;
  editRecord: DispatchRecord | null;
  onSuccess?: () => void;
  onClose: () => void;
}

export function useChoXeVaoBenForm({
  open,
  editRecord,
  onSuccess,
  onClose,
}: UseChoXeVaoBenFormProps) {
  const isEditMode = !!editRecord;
  const [vehicleId, setVehicleId] = useState("");
  const [entryDateTime, setEntryDateTime] = useState<Date | undefined>(new Date());
  const [performPermitAfterEntry, setPerformPermitAfterEntry] = useState(false);
  const [confirmPassengerDrop, setConfirmPassengerDrop] = useState(false);
  const [scheduleId, setScheduleId] = useState("");
  const [passengersArrived, setPassengersArrived] = useState("");
  const [routeId, setRouteId] = useState("");
  const [transportOrderCode, setTransportOrderCode] = useState("");
  const [signAndTransmit, setSignAndTransmit] = useState(true);
  const [printDisplay, setPrintDisplay] = useState(false);
  const [routes, setRoutes] = useState<Route[]>([]);
  const [schedules, setSchedules] = useState<Schedule[]>([]);
  const [selectedDriver, setSelectedDriver] = useState<Driver | null>(null);
  const [transportOrderDisplay] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  const [showPermitDialog, setShowPermitDialog] = useState(false);
  const [permitDispatchRecord, setPermitDispatchRecord] = useState<DispatchRecord | null>(null);
  const { currentShift } = useUIStore();

  const getShiftIdFromCurrentShift = (): string | undefined => {
    if (!currentShift || currentShift === "<Trống>") {
      return undefined;
    }
    const currentShifts = useUIStore.getState().shifts;
    if (currentShifts.length === 0) {
      return undefined;
    }
    const match = currentShift.match(/^(.+?)\s*\(/);
    if (!match) {
      return undefined;
    }
    const shiftName = match[1].trim();
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName);
    return foundShift?.id;
  };

  useEffect(() => {
    if (open) {
      setIsAnimating(true);
      document.body.style.overflow = "hidden";
      if (!isEditMode) {
        resetForm();
      }
    } else {
      document.body.style.overflow = "unset";
    }
    return () => {
      document.body.style.overflow = "unset";
    };
  }, [open, isEditMode]);

  useEffect(() => {
    loadRoutes();
    const { shifts: currentShifts, loadShifts } = useUIStore.getState();
    if (currentShifts.length === 0) {
      loadShifts();
    }
  }, []);

  useEffect(() => {
    if (vehicleId) {
      loadVehicleDetails(vehicleId);
    } else {
      setSelectedDriver(null);
    }
  }, [vehicleId]);

  useEffect(() => {
    if (routeId) {
      loadSchedules(routeId);
    } else {
      setSchedules([]);
    }
  }, [routeId]);

  useEffect(() => {
    if (isEditMode && editRecord) {
      // Set vehicleId - editRecord.vehicleId may not match current vehicle options
      // Keep the original vehicleId for now, Autocomplete will show plateNumber from label
      setVehicleId(editRecord.vehicleId);
      setRouteId(editRecord.routeId || "");
      if (editRecord.entryTime) {
        setEntryDateTime(new Date(editRecord.entryTime));
      }
      if (editRecord.driverId) {
        driverService
          .getById(editRecord.driverId)
          .then((driver) => setSelectedDriver(driver))
          .catch(console.error);
      }
    }
  }, [isEditMode, editRecord]);

  const resetForm = () => {
    setVehicleId("");
    setRouteId("");
    setScheduleId("");
    setEntryDateTime(new Date());
    setPassengersArrived("");
    setTransportOrderCode("");
    setConfirmPassengerDrop(false);
    setPerformPermitAfterEntry(false);
    setSelectedDriver(null);
  };

  const loadRoutes = async () => {
    try {
      const data = await routeService.getAll(undefined, undefined, true);
      setRoutes(data);
    } catch (error) {
      console.error("Failed to load routes:", error);
    }
  };

  const loadVehicleDetails = async (id: string) => {
    const isLegacyOrBadge = id.startsWith("legacy_") || id.startsWith("badge_");
    try {
      const vehicle = await vehicleService.getById(id);
      if (vehicle.operatorId) {
        try {
          const drivers = await driverService.getAll(vehicle.operatorId, true);
          if (drivers.length > 0) {
            setSelectedDriver(drivers[0]);
          } else {
            console.warn("No active drivers found for this operator");
            setSelectedDriver(null);
          }
        } catch (error) {
          console.error("Failed to load driver:", error);
          setSelectedDriver(null);
        }
      } else {
        console.warn("Vehicle does not have an operator");
        setSelectedDriver(null);
      }
    } catch (error) {
      console.error("Failed to load vehicle details:", error);
      if (isLegacyOrBadge) {
        console.warn("Không tìm thấy thông tin lái xe cho xe này - cho phép tiếp tục");
      }
      setSelectedDriver(null);
    }
  };

  const loadSchedules = async (routeId: string) => {
    try {
      const data = await scheduleService.getAll(routeId, undefined, true);
      setSchedules(data);
    } catch (error) {
      console.error("Failed to load schedules:", error);
    }
  };

  const handleVehicleSelect = (id: string) => {
    setVehicleId(id);
  };

  const handleRefreshTransportOrder = () => {
    toast.info("Chức năng làm mới lệnh vận chuyển đang được phát triển");
  };

  const handleConfirmPassengerDropChange = (checked: boolean) => {
    setConfirmPassengerDrop(checked);
    if (!checked) {
      setScheduleId("");
      setPassengersArrived("");
      setRouteId("");
      setTransportOrderCode("");
    }
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!vehicleId) {
      toast.warning("Vui lòng chọn biển kiểm soát");
      return;
    }
    if (!entryDateTime) {
      toast.warning("Vui lòng nhập thời gian vào");
      return;
    }
    if (!selectedDriver) {
      console.warn("Không tìm thấy thông tin lái xe cho xe này - cho phép tiếp tục");
    }
    if (confirmPassengerDrop) {
      if (!routeId) {
        toast.warning("Vui lòng chọn tuyến vận chuyển khi xác nhận trả khách");
        return;
      }
      if (!passengersArrived || passengersArrived.trim() === "") {
        toast.warning("Vui lòng nhập số khách đến bến");
        return;
      }
      if (!transportOrderCode || transportOrderCode.trim() === "") {
        toast.warning("Vui lòng chọn lệnh vận chuyển");
        return;
      }
    }

    const entryTimeISO = entryDateTime.toISOString();
    setIsLoading(true);

    try {
      const entryShiftId = getShiftIdFromCurrentShift();

      if (isEditMode && editRecord) {
        await dispatchService.update(editRecord.id, {
          vehicleId,
          driverId: selectedDriver?.id || undefined,
          routeId: routeId || undefined,
          entryTime: entryTimeISO,
        });
        toast.success("Cập nhật thông tin thành công!");
        onSuccess?.();
        onClose();
        return;
      }

      const dispatchData: DispatchInput = {
        vehicleId,
        driverId: selectedDriver?.id || undefined,
        routeId: routeId || undefined,
        scheduleId: confirmPassengerDrop ? scheduleId || undefined : undefined,
        entryTime: entryTimeISO,
        entryShiftId,
      };

      const result = await dispatchService.create(dispatchData);
      let updatedRecord = result;

      if (confirmPassengerDrop && passengersArrived) {
        updatedRecord = await dispatchService.recordPassengerDrop(
          result.id,
          parseInt(passengersArrived),
          routeId || undefined
        );
      }

      toast.success("Cho xe vào bến thành công!");

      if (performPermitAfterEntry) {
        try {
          const fullRecord = await dispatchService.getById(updatedRecord.id);
          setPermitDispatchRecord(fullRecord);
          setShowPermitDialog(true);
        } catch (error) {
          console.error("Failed to load dispatch record for permit:", error);
          toast.error("Không thể tải dữ liệu để cấp phép. Vui lòng thử lại sau.");
          onSuccess?.();
          onClose();
        }
      } else {
        onSuccess?.();
        onClose();
      }
    } catch (error) {
      console.error("Failed to create dispatch record:", error);
      toast.error("Không thể tạo bản ghi điều độ. Vui lòng thử lại sau.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () => {
    if (showPermitDialog) {
      return;
    }
    setIsAnimating(false);
    setTimeout(() => {
      onClose();
    }, 300);
  };

  const handlePermitDialogClose = () => {
    setShowPermitDialog(false);
    setPermitDispatchRecord(null);
    onSuccess?.();
    onClose();
  };

  return {
    isEditMode,
    vehicleId,
    entryDateTime,
    setEntryDateTime,
    performPermitAfterEntry,
    setPerformPermitAfterEntry,
    confirmPassengerDrop,
    scheduleId,
    setScheduleId,
    passengersArrived,
    setPassengersArrived,
    routeId,
    setRouteId,
    transportOrderCode,
    setTransportOrderCode,
    signAndTransmit,
    setSignAndTransmit,
    printDisplay,
    setPrintDisplay,
    routes,
    schedules,
    transportOrderDisplay,
    isLoading,
    isAnimating,
    showPermitDialog,
    permitDispatchRecord,
    handleVehicleSelect,
    handleRefreshTransportOrder,
    handleConfirmPassengerDropChange,
    handleSubmit,
    handleClose,
    handlePermitDialogClose,
  };
}
</file>

<file path="client/src/lib/firebase.ts">
/**
 * @deprecated This file is deprecated as of Backend-first Migration (2024-12-19)
 *
 * REASON: All frontend services now use Backend API instead of direct Firebase access.
 * This improves security (Firebase will be locked) and centralizes business logic in Backend.
 *
 * MIGRATION: Use `import api from '@/lib/api'` instead of `firebaseClient`
 *
 * Example migration:
 * BEFORE: const data = await firebaseClient.getAsArray('vehicles')
 * AFTER:  const response = await api.get('/vehicles'); return response.data
 *
 * This file will be DELETED after Phase 2 (Lock Firebase Security) is complete.
 * DO NOT USE THIS FILE FOR NEW CODE.
 */

console.warn(
  '[DEPRECATED] firebase.ts is deprecated. Use api.ts instead. ' +
  'See Backend-first Migration plan for details.'
)

const FIREBASE_URL = 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app'

/**
 * @deprecated Use api.ts instead
 */
export const firebaseClient = {
  /** @deprecated Use api.get() instead */
  get: async <T>(path: string): Promise<T | null> => {
    console.warn(`[DEPRECATED] firebaseClient.get('${path}') - Use api.get() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`)
      if (!response.ok) {
        throw new Error(`Firebase error: ${response.status}`)
      }
      return await response.json()
    } catch (error) {
      console.error(`Firebase GET ${path} error:`, error)
      return null
    }
  },

  /** @deprecated Use api.get() instead */
  getAsArray: async <T>(path: string): Promise<T[]> => {
    console.warn(`[DEPRECATED] firebaseClient.getAsArray('${path}') - Use api.get() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`)
      if (!response.ok) {
        throw new Error(`Firebase error: ${response.status}`)
      }
      const data = await response.json()
      if (!data) return []

      return Object.keys(data).map(key => ({
        id: key,
        ...data[key]
      })) as T[]
    } catch (error) {
      console.error(`Firebase GET ${path} error:`, error)
      return []
    }
  },

  /** @deprecated Use api.post() instead */
  set: async <T>(path: string, data: T): Promise<boolean> => {
    console.warn(`[DEPRECATED] firebaseClient.set('${path}') - Use api.post() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      return response.ok
    } catch (error) {
      console.error(`Firebase SET ${path} error:`, error)
      return false
    }
  },

  /** @deprecated Use api.put() or api.patch() instead */
  update: async <T>(path: string, data: Partial<T>): Promise<boolean> => {
    console.warn(`[DEPRECATED] firebaseClient.update('${path}') - Use api.put() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      return response.ok
    } catch (error) {
      console.error(`Firebase UPDATE ${path} error:`, error)
      return false
    }
  },

  /** @deprecated Use api.post() instead */
  push: async <T>(path: string, data: T): Promise<string | null> => {
    console.warn(`[DEPRECATED] firebaseClient.push('${path}') - Use api.post() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      if (!response.ok) return null
      const result = await response.json()
      return result.name
    } catch (error) {
      console.error(`Firebase PUSH ${path} error:`, error)
      return null
    }
  },

  /** @deprecated Use api.delete() instead */
  delete: async (path: string): Promise<boolean> => {
    console.warn(`[DEPRECATED] firebaseClient.delete('${path}') - Use api.delete() instead`)
    try {
      const response = await fetch(`${FIREBASE_URL}/${path}.json`, {
        method: 'DELETE'
      })
      return response.ok
    } catch (error) {
      console.error(`Firebase DELETE ${path} error:`, error)
      return false
    }
  },

  /** @deprecated ID generation moved to Backend */
  generateId: (): string => {
    console.warn('[DEPRECATED] firebaseClient.generateId() - Backend generates IDs now')
    const timestamp = Date.now().toString(36)
    const randomPart = Math.random().toString(36).substring(2, 15)
    return `${timestamp}-${randomPart}`
  }
}
</file>

<file path="client/src/lib/vietnam-time.ts">
/**
 * Vietnam Timezone Utility Module
 * 
 * Centralized module for handling Vietnam timezone (UTC+7) conversions.
 * This module provides clean, type-safe utilities for:
 * - Parsing user input in Vietnam time format
 * - Formatting dates for display in Vietnam time
 * - Converting between UTC (database) and Vietnam time
 * 
 * @module vietnam-time
 */

import { format } from "date-fns"

/**
 * Vietnam timezone offset in hours (UTC+7)
 */
export const VIETNAM_TIMEZONE_OFFSET_HOURS = 7

/**
 * Vietnam timezone identifier
 */
export const VIETNAM_TIMEZONE = "Asia/Ho_Chi_Minh"

/**
 * Default date format used throughout the application
 */
export const DEFAULT_DATE_FORMAT = "HH:mm dd/MM/yyyy"

/**
 * Parse a date string in "HH:mm dd/MM/yyyy" format and convert to ISO string.
 * Treats the input as Vietnam time (UTC+7) and stores it as UTC+7 in database.
 * 
 * @param dateTimeString - Date string in format "HH:mm dd/MM/yyyy"
 * @returns ISO string with UTC+7 offset for database storage
 * 
 * @example
 * parseVietnamDateTime("14:30 25/12/2024")
 * // Returns: "2024-12-25T14:30:00+07:00" (Vietnam time stored as UTC+7)
 */
export function parseVietnamDateTime(dateTimeString: string): string {
  try {
    const parts = dateTimeString.trim().split(" ")
    if (parts.length < 2) {
      throw new Error("Invalid date format")
    }

    const timePart = parts[0]
    const datePart = parts.slice(1).join(" ")
    
    const [hours, minutes] = timePart.split(":").map(Number)
    const [day, month, year] = datePart.split("/").map(Number)

    if (
      isNaN(hours) || isNaN(minutes) ||
      isNaN(day) || isNaN(month) || isNaN(year) ||
      hours < 0 || hours >= 24 ||
      minutes < 0 || minutes >= 60 ||
      day < 1 || day > 31 ||
      month < 1 || month > 12 ||
      year < 1900
    ) {
      throw new Error("Invalid date/time values")
    }

    // Create ISO string with Vietnam timezone offset (+07:00)
    // This will be stored as-is in database, representing Vietnam time
    const isoString = `${year.toString().padStart(4, '0')}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}T${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00+07:00`
    
    // Verify it's a valid date
    const dateObj = new Date(isoString)
    if (isNaN(dateObj.getTime())) {
      throw new Error("Invalid date")
    }

    // Return ISO string with +07:00 offset (representing Vietnam time)
    return isoString
  } catch (error) {
    console.error("Error parsing Vietnam date time:", error, dateTimeString)
    throw new Error(`Failed to parse date: ${dateTimeString}`)
  }
}

/**
 * Format date string from database for display.
 * Database stores time as UTC+7, so we format it directly.
 * 
 * @param dateString - ISO date string from database (can be with or without timezone)
 * @param formatString - Format string (default: "HH:mm dd/MM/yyyy")
 * @returns Formatted date string in Vietnam time, or "-" if invalid
 * 
 * @example
 * formatVietnamDateTime("2024-12-25T14:30:00+07:00")
 * // Returns: "14:30 25/12/2024"
 */
export function formatVietnamDateTime(
  dateString: string | undefined | null,
  formatString: string = DEFAULT_DATE_FORMAT
): string {
  if (!dateString) return "-"

  try {
    // Strategy: Extract time components directly from ISO string
    // Database stores Vietnam time, we just need to display it as-is
    
    // Try to match ISO format: YYYY-MM-DDTHH:mm:ss (with optional timezone)
    const match = dateString.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/)
    
    if (match) {
      const [, year, month, day, hours, minutes, seconds] = match
      // Create date with extracted values (treating them as Vietnam time)
      const vnDate = new Date(
        parseInt(year), 
        parseInt(month) - 1, 
        parseInt(day), 
        parseInt(hours), 
        parseInt(minutes), 
        parseInt(seconds)
      )
      
      if (!isNaN(vnDate.getTime())) {
        return format(vnDate, formatString)
      }
    }
    
    // Fallback: If dateString ends with Z (UTC), convert to Vietnam time
    if (dateString.endsWith('Z')) {
      const utcDate = new Date(dateString)
      if (!isNaN(utcDate.getTime())) {
        // Add 7 hours to convert UTC to Vietnam time
        const vnTimeMs = utcDate.getTime() + VIETNAM_TIMEZONE_OFFSET_HOURS * 60 * 60 * 1000
        const tempDate = new Date(vnTimeMs)
        // Create new date with the Vietnam time values
        const vnDate = new Date(
          tempDate.getUTCFullYear(), 
          tempDate.getUTCMonth(), 
          tempDate.getUTCDate(),
          tempDate.getUTCHours(), 
          tempDate.getUTCMinutes(), 
          tempDate.getUTCSeconds()
        )
        return format(vnDate, formatString)
      }
    }
    
    // Last fallback: try parsing directly
    const dateObj = new Date(dateString)
    if (!isNaN(dateObj.getTime())) {
      return format(dateObj, formatString)
    }
    
    console.warn("Could not parse date string:", dateString)
    return "-"
  } catch (error) {
    console.error("Error formatting Vietnam date time:", error, dateString)
    return "-"
  }
}

/**
 * Get current time in Vietnam timezone as ISO string with +07:00 offset
 * 
 * @returns ISO string with +07:00 offset representing current Vietnam time
 */
export function getCurrentVietnamTime(): string {
  const now = new Date()
  // Add 7 hours to get Vietnam time
  const vietnamTimeMs = now.getTime() + VIETNAM_TIMEZONE_OFFSET_HOURS * 60 * 60 * 1000
  const vietnamDate = new Date(vietnamTimeMs)
  
  // Format as ISO string with +07:00 offset
  const year = vietnamDate.getUTCFullYear()
  const month = String(vietnamDate.getUTCMonth() + 1).padStart(2, '0')
  const day = String(vietnamDate.getUTCDate()).padStart(2, '0')
  const hours = String(vietnamDate.getUTCHours()).padStart(2, '0')
  const minutes = String(vietnamDate.getUTCMinutes()).padStart(2, '0')
  const seconds = String(vietnamDate.getUTCSeconds()).padStart(2, '0')
  
  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+07:00`
}

/**
 * Get current time in Vietnam timezone formatted for display
 * 
 * @param formatString - Format string (default: "HH:mm dd/MM/yyyy")
 * @returns Formatted current time in Vietnam timezone
 */
export function getCurrentVietnamTimeFormatted(formatString: string = DEFAULT_DATE_FORMAT): string {
  return formatVietnamDateTime(getCurrentVietnamTime(), formatString)
}

/**
 * Convert a Date object to Vietnam timezone ISO string
 * 
 * @param date - Date object
 * @returns ISO string in UTC
 */
export function toVietnamISO(date: Date): string {
  return date.toISOString()
}

/**
 * Type guard to check if a string is a valid ISO date string
 */
export function isValidISODateString(dateString: string): boolean {
  try {
    const date = new Date(dateString)
    return !isNaN(date.getTime()) && dateString.includes('T')
  } catch {
    return false
  }
}
</file>

<file path="client/src/pages/BangKeDoanhThu.tsx">
import { useEffect, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { Printer, ArrowLeft } from "lucide-react";
import { format } from "date-fns";
import { toast } from "react-toastify";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";

interface RevenueRowData {
  routeName: string;
  vehicle: string;
  // Quantity - Load capacity
  loadCapacitySeats: number;
  loadCapacityBeds: number;
  // Quantity - Passengers
  passengersSeats: number;
  passengersBeds: number;
  // Unit Price - Vehicle entry/exit service
  unitPriceEntryExitSeats: number;
  unitPriceEntryExitBeds: number;
  // Unit Price - Ticket sales service
  unitPriceTicketSeats: number;
  unitPriceTicketBeds: number;
  // Amount (with VAT)
  amountEntryExit: number; // Column 12: = 4 * 8 + 5 * 9
  amountTicketSales: number; // Column 13: = 4 * 10 + 5 * 11
  amountHalfDayParking: number; // Column 14
  amountFullDayParking: number; // Column 15
  // Total (with VAT)
  totalWithVAT: number; // Column 16: = 12 + 13 + 14 + 15
  // Revenue (without VAT)
  revenueWithoutVAT: number; // Column 17: = 16 / 1.1
  // VAT Tax
  vatTax: number; // Column 18: = 17 * 10%
}

export default function BangKeDoanhThu() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const setTitle = useUIStore((state) => state.setTitle);
  const [isLoading, setIsLoading] = useState(true);
  const [reportDate, setReportDate] = useState<Date>(new Date());
  const [data, setData] = useState<RevenueRowData[]>([]);
  const [totals, setTotals] = useState<RevenueRowData | null>(null);

  useEffect(() => {
    setTitle("Báo cáo > Bảng kê doanh thu");
    
    // Get date from URL params
    const dateParam = searchParams.get("date");
    
    if (dateParam) {
      const parsedDate = new Date(dateParam);
      if (!isNaN(parsedDate.getTime())) {
        setReportDate(parsedDate);
      }
    }
  }, [setTitle, searchParams]);

  useEffect(() => {
    if (reportDate) {
      loadData();
    }
  }, [reportDate]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Get start and end of the report date
      const startDate = new Date(reportDate);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(reportDate);
      endDate.setHours(23, 59, 59, 999);

      // Load all dispatch records for the date
      const dispatchRecords = await dispatchService.getAll();

      // Filter records by date range
      const filteredRecords = dispatchRecords.filter((record) => {
        if (!record.entryTime) return false;
        const recordDate = new Date(record.entryTime);
        return recordDate >= startDate && recordDate <= endDate;
      });

      // Group by route and vehicle
      const grouped = new Map<string, RevenueRowData>();

      filteredRecords.forEach((record) => {
        const routeName = record.routeName || "-";
        const vehiclePlate = record.vehiclePlateNumber || "-";
        const key = `${routeName}|${vehiclePlate}`;

        if (!grouped.has(key)) {
          grouped.set(key, {
            routeName,
            vehicle: vehiclePlate,
            loadCapacitySeats: 0,
            loadCapacityBeds: 0,
            passengersSeats: 0,
            passengersBeds: 0,
            unitPriceEntryExitSeats: 0,
            unitPriceEntryExitBeds: 0,
            unitPriceTicketSeats: 0,
            unitPriceTicketBeds: 0,
            amountEntryExit: 0,
            amountTicketSales: 0,
            amountHalfDayParking: 0,
            amountFullDayParking: 0,
            totalWithVAT: 0,
            revenueWithoutVAT: 0,
            vatTax: 0,
          });
        }

        const item = grouped.get(key)!;

        // Get vehicle type from metadata or vehicle info
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const seatCount = Number(metadata.seatCount) || record.seatCount || 0;
        const vehicleType = String(metadata.vehicleType || "seat"); // "seat" or "bed"

        // Set load capacity based on vehicle type
        if (vehicleType === "bed") {
          item.loadCapacityBeds = seatCount;
        } else {
          item.loadCapacitySeats = seatCount;
        }

        // Set passengers based on departing passengers
        const passengers = record.passengersDeparting || 0;
        if (vehicleType === "bed") {
          item.passengersBeds += passengers;
        } else {
          item.passengersSeats += passengers;
        }

        // Unit prices (these would typically come from pricing configuration)
        // For now, using default values - in production, fetch from service charges
        item.unitPriceEntryExitSeats = item.unitPriceEntryExitSeats || 50000; // Default price
        item.unitPriceEntryExitBeds = item.unitPriceEntryExitBeds || 70000;
        item.unitPriceTicketSeats = item.unitPriceTicketSeats || 10000;
        item.unitPriceTicketBeds = item.unitPriceTicketBeds || 15000;

        // Calculate amounts
        // Column 12: Amount Entry/Exit = Load Seats * Unit Price Entry/Exit Seats + Load Beds * Unit Price Entry/Exit Beds
        item.amountEntryExit =
          item.loadCapacitySeats * item.unitPriceEntryExitSeats +
          item.loadCapacityBeds * item.unitPriceEntryExitBeds;

        // Column 13: Amount Ticket Sales = Load Seats * Unit Price Ticket Seats + Load Beds * Unit Price Ticket Beds
        item.amountTicketSales =
          item.loadCapacitySeats * item.unitPriceTicketSeats +
          item.loadCapacityBeds * item.unitPriceTicketBeds;

        // Parking fees (if applicable) - would need additional data
        // For now, defaulting to 0
        item.amountHalfDayParking = 0;
        item.amountFullDayParking = 0;

        // Column 16: Total (with VAT) = 12 + 13 + 14 + 15
        item.totalWithVAT =
          item.amountEntryExit +
          item.amountTicketSales +
          item.amountHalfDayParking +
          item.amountFullDayParking;

        // Column 17: Revenue (without VAT) = 16 / 1.1
        item.revenueWithoutVAT = item.totalWithVAT / 1.1;

        // Column 18: VAT Tax = 17 * 10%
        item.vatTax = item.revenueWithoutVAT * 0.1;
      });

      // Convert to array and sort
      const result = Array.from(grouped.values()).sort((a, b) => {
        const routeCompare = a.routeName.localeCompare(b.routeName, "vi");
        if (routeCompare !== 0) return routeCompare;
        return a.vehicle.localeCompare(b.vehicle, "vi");
      });

      setData(result);

      // Calculate totals
      const total = result.reduce(
        (acc, row) => ({
          routeName: "",
          vehicle: "",
          loadCapacitySeats: acc.loadCapacitySeats + row.loadCapacitySeats,
          loadCapacityBeds: acc.loadCapacityBeds + row.loadCapacityBeds,
          passengersSeats: acc.passengersSeats + row.passengersSeats,
          passengersBeds: acc.passengersBeds + row.passengersBeds,
          unitPriceEntryExitSeats: 0,
          unitPriceEntryExitBeds: 0,
          unitPriceTicketSeats: 0,
          unitPriceTicketBeds: 0,
          amountEntryExit: acc.amountEntryExit + row.amountEntryExit,
          amountTicketSales: acc.amountTicketSales + row.amountTicketSales,
          amountHalfDayParking: acc.amountHalfDayParking + row.amountHalfDayParking,
          amountFullDayParking: acc.amountFullDayParking + row.amountFullDayParking,
          totalWithVAT: acc.totalWithVAT + row.totalWithVAT,
          revenueWithoutVAT: acc.revenueWithoutVAT + row.revenueWithoutVAT,
          vatTax: acc.vatTax + row.vatTax,
        }),
        {
          routeName: "",
          vehicle: "",
          loadCapacitySeats: 0,
          loadCapacityBeds: 0,
          passengersSeats: 0,
          passengersBeds: 0,
          unitPriceEntryExitSeats: 0,
          unitPriceEntryExitBeds: 0,
          unitPriceTicketSeats: 0,
          unitPriceTicketBeds: 0,
          amountEntryExit: 0,
          amountTicketSales: 0,
          amountHalfDayParking: 0,
          amountFullDayParking: 0,
          totalWithVAT: 0,
          revenueWithoutVAT: 0,
          vatTax: 0,
        }
      );

      setTotals(total);
    } catch (error) {
      console.error("Failed to load report data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePrint = () => {
    window.print();
  };

  const formatNumber = (num: number): string => {
    if (num === 0) return "";
    return Math.round(num).toLocaleString("vi-VN");
  };

  const formatCurrency = (num: number): string => {
    if (num === 0) return "";
    return Math.round(num).toLocaleString("vi-VN");
  };

  const dateStr = format(reportDate, "dd/MM/yyyy");
  const dateRangeStr = `(Từ 00:00:00 ngày ${dateStr} đến 23:59:59 ngày ${dateStr})`;

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="h-8 w-8 border-4 border-gray-300 border-t-blue-600 rounded-full animate-spin mx-auto mb-4" />
          <p className="text-gray-600">Đang tải dữ liệu...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white">
      {/* Print controls - hidden when printing */}
      <div className="no-print p-4 bg-gray-50 border-b sticky top-0 z-10">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <Button variant="outline" onClick={() => navigate(-1)}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Quay lại
          </Button>
          <Button onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            In báo cáo
          </Button>
        </div>
      </div>

      {/* Report Content */}
      <div className="report-content w-full mx-auto bg-white p-[15mm] print:p-[10mm]">
        {/* Header */}
        <div className="mb-6">
          <div className="text-center mb-2">
            <p className="font-semibold text-sm">Công ty CP</p>
            <p className="font-semibold text-sm">Bố Hạ</p>
          </div>
          <h1 className="text-center font-bold text-base uppercase mb-2">
            BẢNG KÊ DOANH THU XE KHÁCH NGÀY {format(reportDate, "dd").toUpperCase()} THÁNG{" "}
            {format(reportDate, "MM").toUpperCase()} NĂM {format(reportDate, "yyyy").toUpperCase()}
          </h1>
          <p className="text-center text-sm mb-6">{dateRangeStr}</p>
        </div>

        {/* Table */}
        <div className="overflow-x-auto">
          <table className="w-full border-collapse border border-black text-sm" style={{ minWidth: "100%" }}>
            <thead>
              <tr>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  STT
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tên tuyến
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Xe
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Số lượng
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Đơn giá
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Thành tiền (có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tổng cộng (có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Doanh thu (chưa có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Thuế GTGT
                </th>
              </tr>
              <tr>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tải trọng
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Hành khách
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV xe ra vào bến
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV bán vé
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV xe ra vào bến
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV bán vé
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Lưu đậu 1/2 ngày
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Lưu đậu ngày
                </th>
              </tr>
              <tr>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
              </tr>
              <tr>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">1</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">2</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">3</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">4</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">5</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">6</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">7</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">8</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">9</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">10</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">11</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">12=4*8+5*9</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">13=4*10+5*11</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">14</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">15</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">16=12+13+14+15</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">17=16/1,1</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">18=17*10%</th>
              </tr>
            </thead>
            <tbody>
              {data.map((row, index) => (
                <tr key={index}>
                  <td className="border border-black p-1 text-center">{index + 1}</td>
                  <td className="border border-black p-1">{row.routeName}</td>
                  <td className="border border-black p-1">{row.vehicle}</td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.loadCapacitySeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.loadCapacityBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.passengersSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.passengersBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceEntryExitSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceEntryExitBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceTicketSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceTicketBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountEntryExit)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountTicketSales)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountHalfDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountFullDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.totalWithVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.revenueWithoutVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.vatTax)}
                  </td>
                </tr>
              ))}
              {/* Total Row */}
              {totals && (
                <tr className="font-semibold bg-gray-50">
                  <td colSpan={2} className="border border-black p-1 text-center">
                    TỔNG CỘNG
                  </td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.loadCapacitySeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.loadCapacityBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.passengersSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.passengersBeds)}
                  </td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountEntryExit)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountTicketSales)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountHalfDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountFullDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.totalWithVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.revenueWithoutVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.vatTax)}
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>

        {/* Footer - Signatures */}
        <div className="mt-8 flex justify-around items-end">
          <div className="text-center">
            <p className="font-semibold mb-12">BẢO VỆ</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">ĐIỀU HÀNH</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">THU NGÂN</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">GIÁM ĐỐC</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
        </div>
      </div>

      {/* Print Styles */}
      <style>{`
        @media print {
          @page {
            size: A4 landscape;
            margin: 0;
          }
          
          * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
          }
          
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            background: white !important;
          }
          
          body * {
            visibility: hidden;
          }
          
          .report-content,
          .report-content * {
            visibility: visible !important;
          }
          
          .no-print {
            display: none !important;
            visibility: hidden !important;
          }
          
          .report-content {
            position: absolute !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 10mm !important;
            background: white !important;
            page-break-inside: avoid;
            font-size: 10px !important;
          }
          
          .report-content h1 {
            font-size: 12px !important;
            line-height: 1.3 !important;
          }
          
          .report-content p {
            font-size: 10px !important;
            line-height: 1.3 !important;
          }
          
          table {
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: collapse !important;
            font-size: 9px !important;
          }
          
          th, td {
            white-space: normal !important;
            border: 1px solid black !important;
            padding: 2px 3px !important;
            font-size: 9px !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            line-height: 1.2 !important;
          }
          
          .report-content > * {
            page-break-inside: avoid;
          }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="client/src/pages/BangKeDoanhThu02.tsx">
import { useEffect, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { Printer, ArrowLeft } from "lucide-react";
import { format } from "date-fns";
import { toast } from "react-toastify";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";

interface RevenueRowData {
  routeName: string;
  vehicle: string;
  // Quantity - Load capacity
  loadCapacitySeats: number;
  loadCapacityBeds: number;
  // Quantity - Passengers
  passengersSeats: number;
  passengersBeds: number;
  // Unit Price - Vehicle entry/exit service
  unitPriceEntryExitSeats: number;
  unitPriceEntryExitBeds: number;
  // Unit Price - Ticket sales service
  unitPriceTicketSeats: number;
  unitPriceTicketBeds: number;
  // Amount (with VAT)
  amountEntryExit: number; // Column 12: = 4 * 8 + 5 * 9
  amountTicketSales: number; // Column 13: = 4 * 10 + 5 * 11
  amountHalfDayParking: number; // Column 14
  amountFullDayParking: number; // Column 15
  // Total (with VAT)
  totalWithVAT: number; // Column 16: = 12 + 13 + 14 + 15
  // Revenue (without VAT)
  revenueWithoutVAT: number; // Column 17: = 16 / 1.1
  // VAT Tax
  vatTax: number; // Column 18: = 17 * 10%
}

export default function BangKeDoanhThu02() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const setTitle = useUIStore((state) => state.setTitle);
  const [isLoading, setIsLoading] = useState(true);
  const [reportDate, setReportDate] = useState<Date>(new Date());
  const [data, setData] = useState<RevenueRowData[]>([]);
  const [totals, setTotals] = useState<RevenueRowData | null>(null);

  useEffect(() => {
    setTitle("Báo cáo > Bảng kê doanh thu");
    
    // Get date from URL params
    const dateParam = searchParams.get("date");
    
    if (dateParam) {
      const parsedDate = new Date(dateParam);
      if (!isNaN(parsedDate.getTime())) {
        setReportDate(parsedDate);
      }
    }
  }, [setTitle, searchParams]);

  useEffect(() => {
    if (reportDate) {
      loadData();
    }
  }, [reportDate]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Get start and end of the report date
      const startDate = new Date(reportDate);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(reportDate);
      endDate.setHours(23, 59, 59, 999);

      // Load all dispatch records for the date
      const dispatchRecords = await dispatchService.getAll();

      // Filter records by date range
      const filteredRecords = dispatchRecords.filter((record) => {
        if (!record.entryTime) return false;
        const recordDate = new Date(record.entryTime);
        return recordDate >= startDate && recordDate <= endDate;
      });

      // Group by route and vehicle
      const grouped = new Map<string, RevenueRowData>();

      filteredRecords.forEach((record) => {
        const routeName = record.routeName || "-";
        const vehiclePlate = record.vehiclePlateNumber || "-";
        const key = `${routeName}|${vehiclePlate}`;

        if (!grouped.has(key)) {
          grouped.set(key, {
            routeName,
            vehicle: vehiclePlate,
            loadCapacitySeats: 0,
            loadCapacityBeds: 0,
            passengersSeats: 0,
            passengersBeds: 0,
            unitPriceEntryExitSeats: 0,
            unitPriceEntryExitBeds: 0,
            unitPriceTicketSeats: 0,
            unitPriceTicketBeds: 0,
            amountEntryExit: 0,
            amountTicketSales: 0,
            amountHalfDayParking: 0,
            amountFullDayParking: 0,
            totalWithVAT: 0,
            revenueWithoutVAT: 0,
            vatTax: 0,
          });
        }

        const item = grouped.get(key)!;

        // Get vehicle type from metadata or vehicle info
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const seatCount = Number(metadata.seatCount) || record.seatCount || 0;
        const vehicleType = String(metadata.vehicleType || "seat"); // "seat" or "bed"

        // Set load capacity based on vehicle type
        if (vehicleType === "bed") {
          item.loadCapacityBeds = seatCount;
        } else {
          item.loadCapacitySeats = seatCount;
        }

        // Set passengers based on departing passengers
        const passengers = record.passengersDeparting || 0;
        if (vehicleType === "bed") {
          item.passengersBeds += passengers;
        } else {
          item.passengersSeats += passengers;
        }

        // Unit prices (these would typically come from pricing configuration)
        // For now, using default values - in production, fetch from service charges
        item.unitPriceEntryExitSeats = item.unitPriceEntryExitSeats || 50000; // Default price
        item.unitPriceEntryExitBeds = item.unitPriceEntryExitBeds || 70000;
        item.unitPriceTicketSeats = item.unitPriceTicketSeats || 10000;
        item.unitPriceTicketBeds = item.unitPriceTicketBeds || 15000;

        // Calculate amounts
        // Column 12: Amount Entry/Exit = Load Seats * Unit Price Entry/Exit Seats + Load Beds * Unit Price Entry/Exit Beds
        item.amountEntryExit =
          item.loadCapacitySeats * item.unitPriceEntryExitSeats +
          item.loadCapacityBeds * item.unitPriceEntryExitBeds;

        // Column 13: Amount Ticket Sales = Load Seats * Unit Price Ticket Seats + Load Beds * Unit Price Ticket Beds
        item.amountTicketSales =
          item.loadCapacitySeats * item.unitPriceTicketSeats +
          item.loadCapacityBeds * item.unitPriceTicketBeds;

        // Parking fees (if applicable) - would need additional data
        // For now, defaulting to 0
        item.amountHalfDayParking = 0;
        item.amountFullDayParking = 0;

        // Column 16: Total (with VAT) = 12 + 13 + 14 + 15
        item.totalWithVAT =
          item.amountEntryExit +
          item.amountTicketSales +
          item.amountHalfDayParking +
          item.amountFullDayParking;

        // Column 17: Revenue (without VAT) = 16 / 1.1
        item.revenueWithoutVAT = item.totalWithVAT / 1.1;

        // Column 18: VAT Tax = 17 * 10%
        item.vatTax = item.revenueWithoutVAT * 0.1;
      });

      // Convert to array and sort
      const result = Array.from(grouped.values()).sort((a, b) => {
        const routeCompare = a.routeName.localeCompare(b.routeName, "vi");
        if (routeCompare !== 0) return routeCompare;
        return a.vehicle.localeCompare(b.vehicle, "vi");
      });

      setData(result);

      // Calculate totals
      const total = result.reduce(
        (acc, row) => ({
          routeName: "",
          vehicle: "",
          loadCapacitySeats: acc.loadCapacitySeats + row.loadCapacitySeats,
          loadCapacityBeds: acc.loadCapacityBeds + row.loadCapacityBeds,
          passengersSeats: acc.passengersSeats + row.passengersSeats,
          passengersBeds: acc.passengersBeds + row.passengersBeds,
          unitPriceEntryExitSeats: 0,
          unitPriceEntryExitBeds: 0,
          unitPriceTicketSeats: 0,
          unitPriceTicketBeds: 0,
          amountEntryExit: acc.amountEntryExit + row.amountEntryExit,
          amountTicketSales: acc.amountTicketSales + row.amountTicketSales,
          amountHalfDayParking: acc.amountHalfDayParking + row.amountHalfDayParking,
          amountFullDayParking: acc.amountFullDayParking + row.amountFullDayParking,
          totalWithVAT: acc.totalWithVAT + row.totalWithVAT,
          revenueWithoutVAT: acc.revenueWithoutVAT + row.revenueWithoutVAT,
          vatTax: acc.vatTax + row.vatTax,
        }),
        {
          routeName: "",
          vehicle: "",
          loadCapacitySeats: 0,
          loadCapacityBeds: 0,
          passengersSeats: 0,
          passengersBeds: 0,
          unitPriceEntryExitSeats: 0,
          unitPriceEntryExitBeds: 0,
          unitPriceTicketSeats: 0,
          unitPriceTicketBeds: 0,
          amountEntryExit: 0,
          amountTicketSales: 0,
          amountHalfDayParking: 0,
          amountFullDayParking: 0,
          totalWithVAT: 0,
          revenueWithoutVAT: 0,
          vatTax: 0,
        }
      );

      setTotals(total);
    } catch (error) {
      console.error("Failed to load report data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePrint = () => {
    window.print();
  };

  const formatNumber = (num: number): string => {
    if (num === 0) return "";
    return Math.round(num).toLocaleString("vi-VN");
  };

  const formatCurrency = (num: number): string => {
    if (num === 0) return "";
    return Math.round(num).toLocaleString("vi-VN");
  };

  const dateStr = format(reportDate, "dd/MM/yyyy");
  const dateRangeStr = `(Từ 00:00:00 ngày ${dateStr} đến 23:59:59 ngày ${dateStr})`;

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="h-8 w-8 border-4 border-gray-300 border-t-blue-600 rounded-full animate-spin mx-auto mb-4" />
          <p className="text-gray-600">Đang tải dữ liệu...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white">
      {/* Print controls - hidden when printing */}
      <div className="no-print p-4 bg-gray-50 border-b sticky top-0 z-10">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <Button variant="outline" onClick={() => navigate(-1)}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Quay lại
          </Button>
          <Button onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            In báo cáo
          </Button>
        </div>
      </div>

      {/* Report Content */}
      <div className="report-content w-full mx-auto bg-white p-[15mm] print:p-[10mm]">
        {/* Header */}
        <div className="mb-6">
          <div className="text-center mb-2">
            <p className="font-semibold text-sm">Công ty CP</p>
            <p className="font-semibold text-sm">Bố Hạ</p>
          </div>
          <h1 className="text-center font-bold text-base uppercase mb-2">
            BẢNG KÊ DOANH THU XE KHÁCH NGÀY {format(reportDate, "dd").toUpperCase()} THÁNG{" "}
            {format(reportDate, "MM").toUpperCase()} NĂM {format(reportDate, "yyyy").toUpperCase()}
          </h1>
          <p className="text-center text-sm mb-6">{dateRangeStr}</p>
        </div>

        {/* Table */}
        <div className="overflow-x-auto">
          <table className="w-full border-collapse border border-black text-sm" style={{ minWidth: "100%" }}>
            <thead>
              <tr>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  STT
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tên tuyến
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Xe
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Số lượng
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Đơn giá
                </th>
                <th colSpan={4} className="border border-black p-1 bg-gray-100 font-semibold">
                  Thành tiền (có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tổng cộng (có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Doanh thu (chưa có VAT)
                </th>
                <th rowSpan={3} className="border border-black p-1 bg-gray-100 font-semibold">
                  Thuế GTGT
                </th>
              </tr>
              <tr>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Tải trọng
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Hành khách
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV xe ra vào bến
                </th>
                <th colSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV bán vé
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV xe ra vào bến
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  DV bán vé
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Lưu đậu 1/2 ngày
                </th>
                <th rowSpan={2} className="border border-black p-1 bg-gray-100 font-semibold">
                  Lưu đậu ngày
                </th>
              </tr>
              <tr>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Ghế</th>
                <th className="border border-black p-1 bg-gray-100 font-semibold">Giường</th>
              </tr>
              <tr>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">1</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">2</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">3</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">4</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">5</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">6</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">7</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">8</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">9</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">10</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">11</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">12=4*8+5*9</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">13=4*10+5*11</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">14</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">15</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">16=12+13+14+15</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">17=16/1,1</th>
                <th className="border border-black p-1 text-center bg-gray-50 italic text-xs">18=17*10%</th>
              </tr>
            </thead>
            <tbody>
              {data.map((row, index) => (
                <tr key={index}>
                  <td className="border border-black p-1 text-center">{index + 1}</td>
                  <td className="border border-black p-1">{row.routeName}</td>
                  <td className="border border-black p-1">{row.vehicle}</td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.loadCapacitySeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.loadCapacityBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.passengersSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(row.passengersBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceEntryExitSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceEntryExitBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceTicketSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.unitPriceTicketBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountEntryExit)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountTicketSales)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountHalfDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.amountFullDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.totalWithVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.revenueWithoutVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(row.vatTax)}
                  </td>
                </tr>
              ))}
              {/* Total Row */}
              {totals && (
                <tr className="font-semibold bg-gray-50">
                  <td colSpan={2} className="border border-black p-1 text-center">
                    TỔNG CỘNG
                  </td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.loadCapacitySeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.loadCapacityBeds)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.passengersSeats)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatNumber(totals.passengersBeds)}
                  </td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1"></td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountEntryExit)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountTicketSales)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountHalfDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.amountFullDayParking)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.totalWithVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.revenueWithoutVAT)}
                  </td>
                  <td className="border border-black p-1 text-right">
                    {formatCurrency(totals.vatTax)}
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>

        {/* Footer - Signatures */}
        <div className="mt-8 flex justify-around items-end">
          <div className="text-center">
            <p className="font-semibold mb-12">BẢO VỆ</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">ĐIỀU HÀNH</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">THU NGÂN</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
          <div className="text-center">
            <p className="font-semibold mb-12">GIÁM ĐỐC</p>
            <p className="text-xs italic">(Ký, ghi rõ họ tên)</p>
          </div>
        </div>
      </div>

      {/* Print Styles */}
      <style>{`
        @media print {
          @page {
            size: A4 landscape;
            margin: 0;
          }
          
          * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
          }
          
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            background: white !important;
          }
          
          body * {
            visibility: hidden;
          }
          
          .report-content,
          .report-content * {
            visibility: visible !important;
          }
          
          .no-print {
            display: none !important;
            visibility: hidden !important;
          }
          
          .report-content {
            position: absolute !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 10mm !important;
            background: white !important;
            page-break-inside: avoid;
            font-size: 10px !important;
          }
          
          .report-content h1 {
            font-size: 12px !important;
            line-height: 1.3 !important;
          }
          
          .report-content p {
            font-size: 10px !important;
            line-height: 1.3 !important;
          }
          
          table {
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: collapse !important;
            font-size: 9px !important;
          }
          
          th, td {
            white-space: normal !important;
            border: 1px solid black !important;
            padding: 2px 3px !important;
            font-size: 9px !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            line-height: 1.2 !important;
          }
          
          .report-content > * {
            page-break-inside: avoid;
          }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="client/src/pages/BangKeHoaDon.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
} from "@/components/ui/sticky-table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { invoiceService } from "@/services/invoice.service";
import { dispatchService } from "@/services/dispatch.service";

interface InvoiceData {
  transactionCode: string;
  plateNumber: string;
  taxPercentage: number;
  invoiceNumber: string;
  orderCode: string;
  vehicleType: string;
  transportUnit: string;
  transportRoute: string;
  goodsServiceName: string;
  valueWithoutTax: number;
  discount: number;
  vatAmount: number;
  paymentMethod: string;
  transactionTime: string;
  payer: string;
  shift: string;
  paymentType: string;
  valueWithTax: number;
}

export default function BangKeHoaDon() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<InvoiceData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  useEffect(() => {
    setTitle("Báo cáo > Bảng kê hóa đơn");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Prepare date range for API
      let startDate: string | undefined;
      let endDate: string | undefined;
      
      if (dateRange?.from && dateRange?.to) {
        startDate = format(dateRange.from, "yyyy-MM-dd");
        endDate = format(dateRange.to, "yyyy-MM-dd");
      }

      // Fetch invoices and dispatch records in parallel
      const [invoices, dispatchRecords] = await Promise.all([
        invoiceService.getAll(undefined, undefined, startDate, endDate),
        dispatchService.getAll(),
      ]);

      // Create a map of dispatch records by ID for quick lookup
      const dispatchMap = new Map(
        dispatchRecords.map((record) => [record.id, record])
      );

      // Map invoices to InvoiceData format
      const result: InvoiceData[] = invoices
        .filter((invoice) => invoice.dispatchRecordId) // Only invoices with dispatch records
        .map((invoice) => {
          const dispatch = invoice.dispatchRecordId
            ? dispatchMap.get(invoice.dispatchRecordId)
            : null;

          // Calculate tax percentage
          const taxPercentage =
            invoice.subtotal > 0
              ? Math.round((invoice.taxAmount / invoice.subtotal) * 100)
              : 10;

          // Get shift from metadata or default
          const metadata = (dispatch?.metadata || {}) as Record<string, unknown>;
          const shift = String(metadata.shift || metadata.paymentShift || "-");

          // Map payment method
          const paymentMethodMap: Record<string, string> = {
            cash: "Tiền mặt",
            bank_transfer: "Chuyển khoản",
            card: "Thẻ",
          };

          return {
            transactionCode: invoice.id.substring(0, 8).toUpperCase(),
            plateNumber: dispatch?.vehiclePlateNumber || "-",
            taxPercentage,
            invoiceNumber: invoice.invoiceNumber,
            orderCode: dispatch?.transportOrderCode || "-",
            vehicleType:
              dispatch?.vehicle?.vehicleType?.name ||
              dispatch?.route?.routeType ||
              "-",
            transportUnit: invoice.operator?.name || "-",
            transportRoute: dispatch?.routeName || "-",
            goodsServiceName: "Dịch vụ vận chuyển",
            valueWithoutTax: invoice.subtotal,
            discount: 0, // TODO: Get discount from invoice if available
            vatAmount: invoice.taxAmount,
            paymentMethod:
              dispatch?.paymentMethod
                ? paymentMethodMap[dispatch.paymentMethod] || dispatch.paymentMethod
                : "-",
            transactionTime: invoice.issueDate || invoice.createdAt || "-",
            payer: dispatch?.paymentBy || "-",
            shift,
            paymentType: "Thanh toán trực tiếp", // TODO: Get from invoice or dispatch
            valueWithTax: invoice.totalAmount,
          };
        });

      setData(result);
    } catch (error) {
      console.error("Failed to load invoice data:", error);
      toast.error("Không thể tải dữ liệu. Vui lòng thử lại sau.");
      setData([]);
    } finally {
      setIsLoading(false);
    }
  };

  const filteredData = useMemo(() => {
    if (!searchQuery.trim()) return data;
    
    const query = searchQuery.toLowerCase();
    return data.filter((item) =>
      item.transactionCode.toLowerCase().includes(query) ||
      item.plateNumber.toLowerCase().includes(query) ||
      item.invoiceNumber.toLowerCase().includes(query) ||
      item.orderCode.toLowerCase().includes(query) ||
      item.transportUnit.toLowerCase().includes(query) ||
      item.transportRoute.toLowerCase().includes(query) ||
      item.payer.toLowerCase().includes(query)
    );
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Mã giao dịch": item.transactionCode,
        "Biển kiểm soát": item.plateNumber,
        "Phần trăm thuế": `${item.taxPercentage}%`,
        "Số hóa đơn": item.invoiceNumber,
        "Mã đơn hàng": item.orderCode,
        "Loại xe": item.vehicleType,
        "Đơn vị vận tải": item.transportUnit,
        "Tuyến vận chuyển": item.transportRoute,
        "Tên hàng hóa, dịch vụ": item.goodsServiceName,
        "Giá trị DV chưa có thuế GTGT (đ)": item.valueWithoutTax,
        "Chiết khấu": item.discount,
        "Thuế GTGT (đ)": item.vatAmount,
        "Hình thức thanh toán": item.paymentMethod,
        "Thời gian giao dịch": item.transactionTime !== "-" ? format(new Date(item.transactionTime), "dd/MM/yyyy HH:mm") : "-",
        "Người thanh toán": item.payer,
        "Ca trực": item.shift,
        "Loại thanh toán": item.paymentType,
        "Giá trị thanh toán đã có thuế GTGT (đ)": item.valueWithTax,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Bảng kê hóa đơn");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Mã giao dịch
        { wch: 15 },  // Biển kiểm soát
        { wch: 12 },  // Phần trăm thuế
        { wch: 15 },  // Số hóa đơn
        { wch: 15 },  // Mã đơn hàng
        { wch: 15 },  // Loại xe
        { wch: 25 },  // Đơn vị vận tải
        { wch: 25 },  // Tuyến vận chuyển
        { wch: 30 },  // Tên hàng hóa, dịch vụ
        { wch: 20 },  // Giá trị DV chưa có thuế GTGT (đ)
        { wch: 15 },  // Chiết khấu
        { wch: 15 },  // Thuế GTGT (đ)
        { wch: 20 },  // Hình thức thanh toán
        { wch: 20 },  // Thời gian giao dịch
        { wch: 20 },  // Người thanh toán
        { wch: 12 },  // Ca trực
        { wch: 20 },  // Loại thanh toán
        { wch: 25 },  // Giá trị thanh toán đã có thuế GTGT (đ)
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bang-ke-hoa-don_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat("vi-VN").format(amount);
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  // Sticky column positions (in pixels)
  const STICKY_COLUMN_WIDTH = 150;
  const NON_STICKY_COLUMN_WIDTH = 160; // Average width for non-sticky columns
  
  // Calculate positions: 2 sticky columns on left + 15 non-sticky columns + 1 sticky column on right
  const stickyPositions = {
    transactionCode: 0,
    plateNumber: STICKY_COLUMN_WIDTH,
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm mã giao dịch, biển số, hóa đơn, đơn hàng..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <StickyTable style={{ tableLayout: "fixed", width: "max-content" }}>
              <colgroup>
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
              </colgroup>
              <StickyTableHeader>
                <StickyTableRow className="bg-gray-100">
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.transactionCode}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Mã giao dịch
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.plateNumber}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Biển kiểm soát
                  </StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Phần trăm thuế</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Số hóa đơn</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Mã đơn hàng</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Loại xe</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Đơn vị vận tải</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Tuyến vận chuyển</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Tên hàng hóa, dịch vụ</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giá trị DV chưa có thuế GTGT (đ)</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Chiết khấu</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thuế GTGT (đ)</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Hình thức thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian giao dịch</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Loại thanh toán</StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyRight={0}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Giá trị thanh toán đã có thuế GTGT (đ)
                  </StickyTableHead>
                </StickyTableRow>
              </StickyTableHeader>
              <StickyTableBody>
                {isLoading ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={18} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </StickyTableCell>
                  </StickyTableRow>
                ) : filteredData.length === 0 ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={18} className="text-center text-gray-500">
                      Không có dữ liệu
                    </StickyTableCell>
                  </StickyTableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <StickyTableRow key={`${item.transactionCode}-${index}`}>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.transactionCode}
                        className="text-center font-semibold"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.transactionCode}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.plateNumber}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.plateNumber}
                      </StickyTableCell>
                      <StickyTableCell className="text-center">{item.taxPercentage}%</StickyTableCell>
                      <StickyTableCell className="text-center">{item.invoiceNumber}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.orderCode}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.vehicleType}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.transportUnit}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.transportRoute}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.goodsServiceName}</StickyTableCell>
                      <StickyTableCell className="text-right">{formatCurrency(item.valueWithoutTax)}</StickyTableCell>
                      <StickyTableCell className="text-right">{formatCurrency(item.discount)}</StickyTableCell>
                      <StickyTableCell className="text-right">{formatCurrency(item.vatAmount)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.paymentMethod}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.transactionTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.payer}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.shift}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.paymentType}</StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyRight={0}
                        className="text-right font-semibold"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {formatCurrency(item.valueWithTax)}
                      </StickyTableCell>
                    </StickyTableRow>
                  ))
                )}
              </StickyTableBody>
            </StickyTable>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoDoanhThuBenBanVe.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";

interface RevenueDetailData {
  operatorName: string;
  routeName: string;
  routeCode: string;
  vehicleCount: number; // Lượt xe
  // Chi tiết thu
  raVaoBen: number;
  hoaHongVe: number;
  dauDem: number;
  veSinhTaxi: number;
  luuBen: number;
  veSinhXeHD: number;
  truyThuChuyen: number;
  truyThuThang: number;
  hhTruyThuThang: number;
  noCu: number;
  phuThu: number;
  doanhThu: number; // Tổng doanh thu
}

export default function BaoCaoDoanhThuBenBanVe() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<RevenueDetailData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  useEffect(() => {
    setTitle("Báo cáo > Doanh thu bến bán vé");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          const recordDate = new Date(record.entryTime);
          return recordDate >= fromDate && recordDate <= toDate;
        });
      }

      // Only count records that have been paid
      const paidRecords = filteredRecords.filter(
        (record) => record.paymentAmount && record.paymentAmount > 0
      );

      // Group by operator and route
      const grouped = new Map<string, RevenueDetailData>();
      
      paidRecords.forEach((record) => {
        const key = `${record.vehicle?.operatorId || 'unknown'}-${record.routeId}`;
        const operatorName = record.vehicle?.operator?.name || "-";
        const routeName = record.routeName || "-";
        const routeCode = record.route?.routeCode || "-";
        
        if (!grouped.has(key)) {
          grouped.set(key, {
            operatorName,
            routeName,
            routeCode,
            vehicleCount: 0,
            raVaoBen: 0,
            hoaHongVe: 0,
            dauDem: 0,
            veSinhTaxi: 0,
            luuBen: 0,
            veSinhXeHD: 0,
            truyThuChuyen: 0,
            truyThuThang: 0,
            hhTruyThuThang: 0,
            noCu: 0,
            phuThu: 0,
            doanhThu: 0,
          });
        }
        
        const item = grouped.get(key)!;
        
        // Count vehicles
        item.vehicleCount += 1;

        // Extract fee details from metadata or use payment amount as base
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const fees = (metadata.fees || {}) as Record<string, unknown>;

        // Ra vào bến - base fee for entry/exit
        item.raVaoBen += Number(fees.raVaoBen) || 0;

        // Hoa hồng vé - commission from ticket sales
        item.hoaHongVe += Number(fees.hoaHongVe) || 0;

        // Đậu dêm - overnight parking fee
        item.dauDem += Number(fees.dauDem) || 0;

        // Vệ sinh taxi - taxi cleaning fee
        item.veSinhTaxi += Number(fees.veSinhTaxi) || 0;

        // Lưu bến - station storage fee
        item.luuBen += Number(fees.luuBen) || 0;

        // Vệ sinh xe HD - HD vehicle cleaning fee
        item.veSinhXeHD += Number(fees.veSinhXeHD) || 0;

        // Truy thu chuyến - retroactive charge per trip
        item.truyThuChuyen += Number(fees.truyThuChuyen) || 0;

        // Truy thu tháng - retroactive monthly charge
        item.truyThuThang += Number(fees.truyThuThang) || 0;

        // HH Truy thu tháng - commission on retroactive monthly charge
        item.hhTruyThuThang += Number(fees.hhTruyThuThang) || 0;

        // Nợ cũ - old debt
        item.noCu += Number(fees.noCu) || 0;

        // Phụ thu - additional charges
        item.phuThu += Number(fees.phuThu) || 0;

        // If no detailed fees in metadata, use payment amount as raVaoBen
        if (!metadata.fees && record.paymentAmount) {
          item.raVaoBen += record.paymentAmount;
        }
        
        // Calculate total revenue
        item.doanhThu = 
          item.raVaoBen +
          item.hoaHongVe +
          item.dauDem +
          item.veSinhTaxi +
          item.luuBen +
          item.veSinhXeHD +
          item.truyThuChuyen +
          item.truyThuThang +
          item.hhTruyThuThang +
          item.noCu +
          item.phuThu;
      });
      
      // Convert to array and sort by operator name and route code
      const result = Array.from(grouped.values()).sort((a, b) => {
        const operatorCompare = a.operatorName.localeCompare(b.operatorName);
        if (operatorCompare !== 0) return operatorCompare;
        return a.routeCode.localeCompare(b.routeCode);
      });
      
      setData(result);
    } catch (error) {
      console.error("Failed to load revenue detail data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.operatorName.toLowerCase().includes(query) ||
          item.routeCode.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Doanh nghiệp": item.operatorName,
        "Tên tuyến": item.routeName,
        "Mã tuyến": item.routeCode,
        "Lượt xe": item.vehicleCount,
        "Ra vào bến": item.raVaoBen,
        "Hoa hồng vé": item.hoaHongVe,
        "Đậu dêm": item.dauDem,
        "Vệ sinh taxi": item.veSinhTaxi,
        "Lưu bến": item.luuBen,
        "Vệ sinh xe HD": item.veSinhXeHD,
        "Truy thu chuyến": item.truyThuChuyen,
        "Truy thu tháng": item.truyThuThang,
        "HH Truy thu tháng": item.hhTruyThuThang,
        "Nợ cũ": item.noCu,
        "Phụ thu": item.phuThu,
        "Doanh thu": item.doanhThu,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Doanh thu bến bán vé");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 25 },  // Doanh nghiệp
        { wch: 25 },  // Tên tuyến
        { wch: 15 },  // Mã tuyến
        { wch: 12 },  // Lượt xe
        { wch: 15 },  // Ra vào bến
        { wch: 15 },  // Hoa hồng vé
        { wch: 12 },  // Đậu dêm
        { wch: 15 },  // Vệ sinh taxi
        { wch: 12 },  // Lưu bến
        { wch: 15 },  // Vệ sinh xe HD
        { wch: 15 },  // Truy thu chuyến
        { wch: 15 },  // Truy thu tháng
        { wch: 18 },  // HH Truy thu tháng
        { wch: 12 },  // Nợ cũ
        { wch: 12 },  // Phụ thu
        { wch: 15 },  // Doanh thu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-doanh-thu-ben-ban-ve_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  // Calculate totals
  const totals = useMemo(() => {
    return filteredData.reduce(
      (acc, item) => ({
        vehicleCount: acc.vehicleCount + item.vehicleCount,
        raVaoBen: acc.raVaoBen + item.raVaoBen,
        hoaHongVe: acc.hoaHongVe + item.hoaHongVe,
        dauDem: acc.dauDem + item.dauDem,
        veSinhTaxi: acc.veSinhTaxi + item.veSinhTaxi,
        luuBen: acc.luuBen + item.luuBen,
        veSinhXeHD: acc.veSinhXeHD + item.veSinhXeHD,
        truyThuChuyen: acc.truyThuChuyen + item.truyThuChuyen,
        truyThuThang: acc.truyThuThang + item.truyThuThang,
        hhTruyThuThang: acc.hhTruyThuThang + item.hhTruyThuThang,
        noCu: acc.noCu + item.noCu,
        phuThu: acc.phuThu + item.phuThu,
        doanhThu: acc.doanhThu + item.doanhThu,
      }),
      {
        vehicleCount: 0,
        raVaoBen: 0,
        hoaHongVe: 0,
        dauDem: 0,
        veSinhTaxi: 0,
        luuBen: 0,
        veSinhXeHD: 0,
        truyThuChuyen: 0,
        truyThuThang: 0,
        hhTruyThuThang: 0,
        noCu: 0,
        phuThu: 0,
        doanhThu: 0,
      }
    );
  }, [filteredData]);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND",
    }).format(amount);
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm doanh nghiệp, mã tuyến, tên tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                {/* Main header row */}
                <TableRow className="bg-gray-100">
                  <TableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle"
                  >
                    STT
                  </TableHead>
                  <TableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle"
                  >
                    Doanh nghiệp
                  </TableHead>
                  <TableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle"
                  >
                    Tên tuyến
                  </TableHead>
                  <TableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle"
                  >
                    Mã tuyến
                  </TableHead>
                  <TableHead
                    rowSpan={2}
                    className="text-center font-semibold border-r border-gray-300 align-middle"
                  >
                    Lượt xe
                  </TableHead>
                  <TableHead
                    colSpan={12}
                    className="text-center font-semibold"
                  >
                    Chi tiết thu
                  </TableHead>
                </TableRow>
                {/* Sub-header row */}
                <TableRow className="bg-gray-50">
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Ra vào bến
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Hoa hồng vé
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Đậu dêm
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Vệ sinh taxi
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Lưu bến
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Vệ sinh xe HD
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Truy thu chuyến
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Truy thu tháng
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    HH Truy thu tháng
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Nợ cũ
                  </TableHead>
                  <TableHead className="text-center font-medium border-r border-gray-200">
                    Phụ thu
                  </TableHead>
                  <TableHead className="text-center font-medium">
                    Doanh thu
                  </TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={17} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={17} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredData.map((item, index) => (
                      <TableRow key={`${item.operatorName}-${item.routeCode}-${index}`}>
                        <TableCell className="text-center border-r border-gray-200">
                          {index + 1}
                        </TableCell>
                        <TableCell className="border-r border-gray-200">
                          {item.operatorName}
                        </TableCell>
                        <TableCell className="border-r border-gray-200">
                          {item.routeName}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200 font-semibold">
                          {item.routeCode}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {item.vehicleCount}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.raVaoBen)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.hoaHongVe)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.dauDem)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.veSinhTaxi)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.luuBen)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.veSinhXeHD)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.truyThuChuyen)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.truyThuThang)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.hhTruyThuThang)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.noCu)}
                        </TableCell>
                        <TableCell className="text-center border-r border-gray-200">
                          {formatCurrency(item.phuThu)}
                        </TableCell>
                        <TableCell className="text-center font-semibold">
                          {formatCurrency(item.doanhThu)}
                        </TableCell>
                      </TableRow>
                    ))}
                    {/* Total row */}
                    <TableRow className="bg-gradient-to-r from-blue-100 to-blue-50 font-bold text-blue-900 border-t-2 border-blue-300 sticky bottom-0">
                      <TableCell colSpan={4} className="text-center border-r border-blue-300 bg-blue-200 shadow-sm">
                        <div className="flex items-center justify-center gap-2">
                          <span className="text-lg"></span>
                          <span className="text-base font-bold">TỔNG CỘNG</span>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-lg font-bold">{totals.vehicleCount}</div>
                          <div className="text-xs text-blue-600">lượt xe</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.raVaoBen)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.hoaHongVe)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.dauDem)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.veSinhTaxi)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.luuBen)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.veSinhXeHD)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.truyThuChuyen)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.truyThuThang)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.hhTruyThuThang)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.noCu)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center border-r border-blue-300 bg-blue-100 font-bold text-blue-800">
                        <div className="py-1">
                          <div className="text-sm font-bold">{formatCurrency(totals.phuThu)}</div>
                        </div>
                      </TableCell>
                      <TableCell className="text-center bg-gradient-to-r from-green-200 to-green-100 border-2 border-green-400 shadow-lg">
                        <div className="py-2 px-1">
                          <div className="text-lg font-bold text-green-800">{formatCurrency(totals.doanhThu)}</div>
                          <div className="text-xs text-green-600 font-medium">VNĐ</div>
                        </div>
                      </TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoLichSuGiayTo.tsx">
import { useEffect, useMemo, useState } from "react"
import { format } from "date-fns"
import { toast } from "react-toastify"
import * as XLSX from "xlsx"
import {
  RefreshCw,
  Search,
  FileSpreadsheet,
  History,
  User,
  Calendar,
  FileText,
  ChevronLeft,
  ChevronRight,
} from "lucide-react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select } from "@/components/ui/select"
import { Badge } from "@/components/ui/badge"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { DatePickerRange } from "@/components/DatePickerRange"
import { useUIStore } from "@/store/ui.store"
import { vehicleService } from "@/services/vehicle.service"
import { iconStyles } from "@/lib/icon-theme"
import { type DateRange } from "react-day-picker"

interface AuditLogEntry {
  id: string
  userId: string
  userName: string
  action: string
  recordId: string
  oldValues: any
  newValues: any
  createdAt: string
  vehiclePlateNumber?: string
}

const ITEMS_PER_PAGE = 20

const getDocumentTypeLabel = (docType: string): string => {
  const labels: Record<string, string> = {
    registration: "Đăng ký xe",
    inspection: "Đăng kiểm",
    insurance: "Bảo hiểm",
    operation_permit: "Phù hiệu",
    emblem: "Biển hiệu",
  }
  return labels[docType] || docType
}

const getActionLabel = (action: string): string => {
  const labels: Record<string, string> = {
    CREATE_DOCUMENT: "Tạo mới giấy tờ",
    UPDATE_DOCUMENT: "Cập nhật giấy tờ",
    UPDATE_DOCUMENT_EXPIRY: "Cập nhật hạn giấy tờ",
  }
  return labels[action] || action
}

const getActionBadgeVariant = (action: string) => {
  if (action.includes("CREATE")) return "success"
  if (action.includes("UPDATE")) return "default"
  return "secondary"
}

export default function BaoCaoLichSuGiayTo() {
  const setTitle = useUIStore((state) => state.setTitle)
  const [logs, setLogs] = useState<AuditLogEntry[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [searchQuery, setSearchQuery] = useState("")
  const [filterAction, setFilterAction] = useState("")
  const [filterDocType, setFilterDocType] = useState("")
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined)
  const [currentPage, setCurrentPage] = useState(1)

  useEffect(() => {
    setTitle("Báo cáo > Lịch sử thay đổi giấy tờ")
    loadAllAuditLogs()
  }, [setTitle])

  const loadAllAuditLogs = async () => {
    setIsLoading(true)
    try {
      // Use optimized API endpoint that fetches all logs in one request
      const allLogs = await vehicleService.getAllDocumentAuditLogs()
      setLogs(allLogs)
    } catch (error) {
      console.error("Failed to load audit logs:", error)
      toast.error("Không thể tải lịch sử thay đổi giấy tờ")
    } finally {
      setIsLoading(false)
    }
  }

  const filteredLogs = useMemo(() => {
    return logs.filter((log) => {
      // Search filter
      if (searchQuery) {
        const query = searchQuery.toLowerCase()
        const searchableText = [
          log.vehiclePlateNumber || "",
          log.userName || "",
          getDocumentTypeLabel(log.newValues?.document_type || ""),
          getActionLabel(log.action),
        ].join(" ").toLowerCase()
        
        if (!searchableText.includes(query)) return false
      }
      
      // Action filter
      if (filterAction && log.action !== filterAction) return false
      
      // Document type filter
      if (filterDocType && log.newValues?.document_type !== filterDocType) return false
      
      // Date range filter
      if (dateRange?.from) {
        const logDate = new Date(log.createdAt)
        const fromDate = new Date(dateRange.from)
        fromDate.setHours(0, 0, 0, 0)
        
        if (logDate < fromDate) return false
        
        if (dateRange.to) {
          const toDate = new Date(dateRange.to)
          toDate.setHours(23, 59, 59, 999)
          if (logDate > toDate) return false
        }
      }
      
      return true
    })
  }, [logs, searchQuery, filterAction, filterDocType, dateRange])

  // Pagination
  const totalPages = Math.ceil(filteredLogs.length / ITEMS_PER_PAGE)
  const startIndex = (currentPage - 1) * ITEMS_PER_PAGE
  const endIndex = startIndex + ITEMS_PER_PAGE
  const currentLogs = filteredLogs.slice(startIndex, endIndex)

  // Reset page when filters change
  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, filterAction, filterDocType, dateRange])

  const handleExportExcel = () => {
    if (filteredLogs.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel")
      return
    }

    try {
      const excelData = filteredLogs.map((log, index) => ({
        STT: index + 1,
        "Thời gian": format(new Date(log.createdAt), "dd/MM/yyyy HH:mm:ss"),
        "Biển số xe": log.vehiclePlateNumber || "-",
        "Loại giấy tờ": getDocumentTypeLabel(log.newValues?.document_type || ""),
        "Hành động": getActionLabel(log.action),
        "Người thực hiện": log.userName,
        "Số giấy tờ cũ": log.oldValues?.document_number || "-",
        "Số giấy tờ mới": log.newValues?.document_number || "-",
        "Ngày cấp cũ": log.oldValues?.issue_date 
          ? format(new Date(log.oldValues.issue_date), "dd/MM/yyyy") 
          : "-",
        "Ngày cấp mới": log.newValues?.issue_date 
          ? format(new Date(log.newValues.issue_date), "dd/MM/yyyy") 
          : "-",
        "Hết hạn cũ": log.oldValues?.expiry_date 
          ? format(new Date(log.oldValues.expiry_date), "dd/MM/yyyy") 
          : "-",
        "Hết hạn mới": log.newValues?.expiry_date 
          ? format(new Date(log.newValues.expiry_date), "dd/MM/yyyy") 
          : "-",
      }))

      const ws = XLSX.utils.json_to_sheet(excelData)
      const wb = XLSX.utils.book_new()
      XLSX.utils.book_append_sheet(wb, ws, "Lịch sử giấy tờ")

      const filename = `Lich-su-thay-doi-giay-to_${format(new Date(), "dd-MM-yyyy")}.xlsx`
      XLSX.writeFile(wb, filename)
      
      toast.success(`Đã xuất Excel: ${filename}`)
    } catch (error) {
      console.error("Failed to export Excel:", error)
      toast.error("Không thể xuất Excel")
    }
  }

  // Statistics
  const stats = useMemo(() => {
    return {
      total: filteredLogs.length,
      creates: filteredLogs.filter(l => l.action.includes("CREATE")).length,
      updates: filteredLogs.filter(l => l.action.includes("UPDATE")).length,
      uniqueVehicles: new Set(filteredLogs.map(l => l.vehiclePlateNumber)).size,
    }
  }, [filteredLogs])

  return (
    <div className="space-y-4">
      {/* Statistics Cards */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <Card className="bg-gradient-to-br from-blue-50 to-blue-100 border-blue-200">
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-blue-600">Tổng thay đổi</p>
                <p className="text-2xl font-bold text-blue-800">{stats.total}</p>
              </div>
              <History className={`h-8 w-8 ${iconStyles.infoIcon}`} />
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-green-50 to-green-100 border-green-200">
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-green-600">Tạo mới</p>
                <p className="text-2xl font-bold text-green-800">{stats.creates}</p>
              </div>
              <FileText className={`h-8 w-8 ${iconStyles.successIcon}`} />
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-orange-50 to-orange-100 border-orange-200">
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-orange-600">Cập nhật</p>
                <p className="text-2xl font-bold text-orange-800">{stats.updates}</p>
              </div>
              <Calendar className={`h-8 w-8 ${iconStyles.warningIcon}`} />
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-purple-50 to-purple-100 border-purple-200">
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-purple-600">Số xe</p>
                <p className="text-2xl font-bold text-purple-800">{stats.uniqueVehicles}</p>
              </div>
              <span className="text-3xl">🚌</span>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
          <CardTitle className="flex items-center gap-2">
            <History className={iconStyles.historyButton} />
            Lịch sử thay đổi giấy tờ xe
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredLogs.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className={iconStyles.infoIcon} />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadAllAuditLogs}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className={`${iconStyles.infoIcon} ${isLoading ? 'animate-spin' : ''}`} />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="relative">
              <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 ${iconStyles.navigationIcon}`} />
              <Input
                placeholder="Tìm biển số, người thực hiện..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>
            
            <Select
              value={filterAction}
              onChange={(e) => setFilterAction(e.target.value)}
            >
              <option value="">Tất cả hành động</option>
              <option value="CREATE_DOCUMENT">Tạo mới giấy tờ</option>
              <option value="UPDATE_DOCUMENT">Cập nhật giấy tờ</option>
              <option value="UPDATE_DOCUMENT_EXPIRY">Cập nhật hạn giấy tờ</option>
            </Select>
            
            <Select
              value={filterDocType}
              onChange={(e) => setFilterDocType(e.target.value)}
            >
              <option value="">Tất cả loại giấy tờ</option>
              <option value="registration">Đăng ký xe</option>
              <option value="inspection">Đăng kiểm</option>
              <option value="insurance">Bảo hiểm</option>
              <option value="operation_permit">Phù hiệu</option>
              <option value="emblem">Biển hiệu</option>
            </Select>
            
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              className="w-full"
            />
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <CardContent className="p-0">
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-50">
                  <TableHead className="w-12">STT</TableHead>
                  <TableHead>Thời gian</TableHead>
                  <TableHead>Biển số xe</TableHead>
                  <TableHead>Loại giấy tờ</TableHead>
                  <TableHead>Hành động</TableHead>
                  <TableHead>Người thực hiện</TableHead>
                  <TableHead>Số giấy tờ</TableHead>
                  <TableHead>Ngày cấp</TableHead>
                  <TableHead>Hết hạn</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={9} className="text-center py-12">
                      <div className="flex justify-center items-center gap-2">
                        <RefreshCw className={`${iconStyles.infoIcon} animate-spin`} />
                        Đang tải dữ liệu...
                      </div>
                    </TableCell>
                  </TableRow>
                ) : currentLogs.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={9} className="text-center py-12 text-gray-500">
                      <History className="h-12 w-12 mx-auto mb-4 text-gray-300" />
                      <p>Không có dữ liệu lịch sử</p>
                    </TableCell>
                  </TableRow>
                ) : (
                  currentLogs.map((log, index) => {
                    const isUpdate = log.oldValues && log.newValues
                    const values = log.newValues || log.oldValues || {}
                    
                    return (
                      <TableRow key={log.id} className="hover:bg-gray-50">
                        <TableCell className="font-medium">
                          {startIndex + index + 1}
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <Calendar className={`h-4 w-4 ${iconStyles.navigationIcon}`} />
                            <div>
                              <div className="font-medium">
                                {format(new Date(log.createdAt), "dd/MM/yyyy")}
                              </div>
                              <div className="text-xs text-gray-500">
                                {format(new Date(log.createdAt), "HH:mm:ss")}
                              </div>
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>
                          <span className="font-semibold text-blue-600">
                            {log.vehiclePlateNumber || "-"}
                          </span>
                        </TableCell>
                        <TableCell>
                          <Badge variant="secondary">
                            {getDocumentTypeLabel(values.document_type || "")}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Badge variant={getActionBadgeVariant(log.action) as any}>
                            {getActionLabel(log.action)}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <User className={`h-4 w-4 ${iconStyles.navigationIcon}`} />
                            <span>{log.userName}</span>
                          </div>
                        </TableCell>
                        <TableCell>
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.document_number && (
                                <div className="text-gray-500 line-through text-xs">
                                  {log.oldValues.document_number}
                                </div>
                              )}
                              {log.newValues?.document_number && (
                                <div className="text-green-700 font-medium">
                                  {log.newValues.document_number}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span>{values.document_number || "-"}</span>
                          )}
                        </TableCell>
                        <TableCell>
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.issue_date && (
                                <div className="text-gray-500 line-through text-xs">
                                  {format(new Date(log.oldValues.issue_date), "dd/MM/yyyy")}
                                </div>
                              )}
                              {log.newValues?.issue_date && (
                                <div className="text-green-700 font-medium">
                                  {format(new Date(log.newValues.issue_date), "dd/MM/yyyy")}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span>
                              {values.issue_date 
                                ? format(new Date(values.issue_date), "dd/MM/yyyy")
                                : "-"}
                            </span>
                          )}
                        </TableCell>
                        <TableCell>
                          {isUpdate ? (
                            <div className="space-y-1">
                              {log.oldValues?.expiry_date && (
                                <div className="text-gray-500 line-through text-xs">
                                  {format(new Date(log.oldValues.expiry_date), "dd/MM/yyyy")}
                                </div>
                              )}
                              {log.newValues?.expiry_date && (
                                <div className="text-green-700 font-medium">
                                  {format(new Date(log.newValues.expiry_date), "dd/MM/yyyy")}
                                </div>
                              )}
                            </div>
                          ) : (
                            <span>
                              {values.expiry_date 
                                ? format(new Date(values.expiry_date), "dd/MM/yyyy")
                                : "-"}
                            </span>
                          )}
                        </TableCell>
                      </TableRow>
                    )
                  })
                )}
              </TableBody>
            </Table>
          </div>

          {/* Pagination */}
          {totalPages > 1 && (
            <div className="flex items-center justify-between p-4 border-t">
              <div className="text-sm text-gray-600">
                Hiển thị {startIndex + 1}-{Math.min(endIndex, filteredLogs.length)} của {filteredLogs.length} bản ghi
              </div>
              <div className="flex items-center gap-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                  disabled={currentPage === 1}
                  className="gap-1"
                >
                  <ChevronLeft className={iconStyles.navigationIcon} />
                  Trước
                </Button>
                
                <div className="flex items-center gap-1">
                  {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                    let page = i + 1
                    if (totalPages > 5) {
                      if (currentPage > 3) {
                        page = currentPage - 2 + i
                      }
                      if (currentPage > totalPages - 2) {
                        page = totalPages - 4 + i
                      }
                    }
                    if (page < 1 || page > totalPages) return null
                    return (
                      <Button
                        key={page}
                        size="sm"
                        variant={currentPage === page ? "default" : "outline"}
                        onClick={() => setCurrentPage(page)}
                        className="w-8 h-8 p-0"
                      >
                        {page}
                      </Button>
                    )
                  })}
                </div>

                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                  disabled={currentPage === totalPages}
                  className="gap-1"
                >
                  Sau
                  <ChevronRight className={iconStyles.navigationIcon} />
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="client/src/pages/BaoCaoTinhHinhHoatDongMau1.tsx">
import { useEffect, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { Printer, ArrowLeft } from "lucide-react";
import { format } from "date-fns";
import { vi } from "date-fns/locale";
import { toast } from "react-toastify";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";

interface ReportRowData {
  routeOperator: string;
  thucHien: {
    luotXe: number;
    taiTrong: number;
    lePhi: number;
    hoaHong: number;
    luuDau: number;
    doanhThu: number;
  };
  truyThu: {
    luotXe: number;
    taiTrong: number;
    lePhi: number;
    hoaHong: number;
    doanhThu: number;
  };
  veBanThucTe: number;
  ghiChu: string;
}

export default function BaoCaoTinhHinhHoatDongMau1() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const setTitle = useUIStore((state) => state.setTitle);
  const [isLoading, setIsLoading] = useState(true);
  const [reportDate, setReportDate] = useState<Date>(new Date());
  const [data, setData] = useState<ReportRowData[]>([]);
  const [totals, setTotals] = useState<{
    thucHien: ReportRowData["thucHien"];
    truyThu: ReportRowData["truyThu"];
    veBanThucTe: number;
  } | null>(null);

  useEffect(() => {
    setTitle("Báo cáo > Báo cáo tình hình hoạt động (Mẫu 1)");
    
    // Get date from URL params or use today
    const dateParam = searchParams.get("date");
    if (dateParam) {
      const parsedDate = new Date(dateParam);
      if (!isNaN(parsedDate.getTime())) {
        setReportDate(parsedDate);
      }
    }
  }, [setTitle, searchParams]);

  useEffect(() => {
    if (reportDate) {
      loadData();
    }
  }, [reportDate]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Get start and end of the selected date
      const startDate = new Date(reportDate);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(reportDate);
      endDate.setHours(23, 59, 59, 999);

      // Load all dispatch records
      const dispatchRecords = await dispatchService.getAll();

      // Filter records by date
      const filteredRecords = dispatchRecords.filter((record) => {
        if (!record.entryTime) return false;
        const recordDate = new Date(record.entryTime);
        return recordDate >= startDate && recordDate <= endDate;
      });

      // Group by route and operator
      const grouped = new Map<string, ReportRowData>();

      filteredRecords.forEach((record) => {
        const routeName = record.routeName || "-";
        const operatorName = record.vehicle?.operator?.name || "-";
        const key = `${routeName}|${operatorName}`;

        if (!grouped.has(key)) {
          grouped.set(key, {
            routeOperator: operatorName ? `${routeName} - ${operatorName}` : routeName,
            thucHien: {
              luotXe: 0,
              taiTrong: 0,
              lePhi: 0,
              hoaHong: 0,
              luuDau: 0,
              doanhThu: 0,
            },
            truyThu: {
              luotXe: 0,
              taiTrong: 0,
              lePhi: 0,
              hoaHong: 0,
              doanhThu: 0,
            },
            veBanThucTe: 0,
            ghiChu: "",
          });
        }

        const item = grouped.get(key)!;

        // Extract metadata and fees
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const fees = (metadata.fees || {}) as Record<string, unknown>;
        const paymentAmount = record.paymentAmount || 0;

        // Calculate THỰC HIỆN (Performed)
        // Lượt xe - vehicle trips
        item.thucHien.luotXe += 1;

        // Tải trọng - load capacity (from vehicle or metadata)
        const loadCapacity = Number(metadata.loadCapacity) || 0;
        item.thucHien.taiTrong += loadCapacity;

        // Lệ phí - fees (ra vào bến, lưu bến, etc.)
        const lePhi = Number(fees.raVaoBen) || Number(fees.luuBen) || 0;
        item.thucHien.lePhi += lePhi;

        // Hoa hồng - commission
        const hoaHong = Number(fees.hoaHongVe) || 0;
        item.thucHien.hoaHong += hoaHong;

        // Lưu đậu - parking/waiting fee
        const luuDau = Number(fees.luuBen) || Number(fees.dauDem) || 0;
        item.thucHien.luuDau += luuDau;

        // Doanh thu - revenue
        item.thucHien.doanhThu += paymentAmount;

        // Calculate TRUY THU (Collected/Retroactive)
        // Truy thu chuyến - retroactive charge per trip
        const truyThuChuyen = Number(fees.truyThuChuyen) || 0;
        if (truyThuChuyen > 0) {
          item.truyThu.luotXe += 1;
          item.truyThu.lePhi += truyThuChuyen;
          item.truyThu.doanhThu += truyThuChuyen;
        }

        // Truy thu tháng - retroactive monthly charge
        const truyThuThang = Number(fees.truyThuThang) || 0;
        if (truyThuThang > 0) {
          item.truyThu.lePhi += truyThuThang;
          item.truyThu.hoaHong += Number(fees.hhTruyThuThang) || 0;
          item.truyThu.doanhThu += truyThuThang;
        }

        // VÉ BÁN THỰC TẾ - actual tickets sold
        const ticketsSold = record.passengersDeparting || 0;
        item.veBanThucTe += ticketsSold;
      });

      // Convert to array and sort
      const result = Array.from(grouped.values()).sort((a, b) =>
        a.routeOperator.localeCompare(b.routeOperator, "vi")
      );

      setData(result);

      // Calculate totals
      const totalThucHien = result.reduce(
        (acc, row) => ({
          luotXe: acc.luotXe + row.thucHien.luotXe,
          taiTrong: acc.taiTrong + row.thucHien.taiTrong,
          lePhi: acc.lePhi + row.thucHien.lePhi,
          hoaHong: acc.hoaHong + row.thucHien.hoaHong,
          luuDau: acc.luuDau + row.thucHien.luuDau,
          doanhThu: acc.doanhThu + row.thucHien.doanhThu,
        }),
        { luotXe: 0, taiTrong: 0, lePhi: 0, hoaHong: 0, luuDau: 0, doanhThu: 0 }
      );

      const totalTruyThu = result.reduce(
        (acc, row) => ({
          luotXe: acc.luotXe + row.truyThu.luotXe,
          taiTrong: acc.taiTrong + row.truyThu.taiTrong,
          lePhi: acc.lePhi + row.truyThu.lePhi,
          hoaHong: acc.hoaHong + row.truyThu.hoaHong,
          doanhThu: acc.doanhThu + row.truyThu.doanhThu,
        }),
        { luotXe: 0, taiTrong: 0, lePhi: 0, hoaHong: 0, doanhThu: 0 }
      );

      const totalVeBanThucTe = result.reduce(
        (acc, row) => acc + row.veBanThucTe,
        0
      );

      setTotals({
        thucHien: totalThucHien,
        truyThu: totalTruyThu,
        veBanThucTe: totalVeBanThucTe,
      });
    } catch (error) {
      console.error("Failed to load report data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePrint = () => {
    window.print();
  };

  const formatNumber = (num: number): string => {
    if (num === 0) return "";
    return num.toLocaleString("vi-VN");
  };

  const dateOnly = format(reportDate, "dd/MM/yyyy");

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="h-8 w-8 border-4 border-gray-300 border-t-blue-600 rounded-full animate-spin mx-auto mb-4" />
          <p className="text-gray-600">Đang tải dữ liệu...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white">
      {/* Print controls - hidden when printing */}
      <div className="no-print p-4 bg-gray-50 border-b sticky top-0 z-10">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <Button variant="outline" onClick={() => navigate(-1)}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Quay lại
          </Button>
          <Button onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            In báo cáo
          </Button>
        </div>
      </div>

      {/* Report Content */}
      <div className="report-content w-full mx-auto bg-white p-[15mm] print:p-[10mm]">
        {/* Header */}
        <div className="mb-6">
          <div className="flex justify-between items-start mb-4">
            <div className="text-center flex-1">
              <p className="font-semibold text-sm">Công ty CP Bố Hạ</p>
            </div>
            <div className="flex flex-col items-center flex-1">
              <p className="font-semibold text-sm uppercase text-center">
                CỘNG HOÀ XÃ HỘI CHỦ NGHĨA VIỆT NAM
              </p>
              <p className="text-sm italic text-center">Độc lập - Tự do - Hạnh phúc</p>
            </div>
          </div>
          <p className="text-right text-sm mb-4">
            Thành phố Hồ Chí Minh, ngày {dateOnly}
          </p>
          <h1 className="text-center font-bold text-lg uppercase mb-6">
            BÁO CÁO TÌNH HÌNH HOẠT ĐỘNG CÁC TUYẾN VẬN TẢI HÀNH KHÁCH
            <br />
            NGÀY {format(reportDate, "dd 'THÁNG' MM 'NĂM' yyyy", {
              locale: vi,
            }).toUpperCase()}
          </h1>
        </div>

        {/* Table */}
        <div className="overflow-x-auto">
          <table className="w-full border-collapse border border-black text-xs" style={{ minWidth: '100%' }}>
            <colgroup>
              <col className="print-col-tt" />
              <col className="print-col-route" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-ticket" />
              <col className="print-col-note" />
            </colgroup>
            <thead>
              <tr>
                <th
                  rowSpan={3}
                  className="border border-black p-2 bg-gray-100 font-semibold w-16"
                >
                  TT
                </th>
                <th
                  rowSpan={3}
                  className="border border-black p-2 bg-gray-100 font-semibold min-w-[250px]"
                >
                  Tuyến/đơn vị vận tải
                </th>
                <th
                  colSpan={6}
                  className="border border-black p-2 bg-gray-100 font-semibold"
                >
                  THỰC HIỆN
                </th>
                <th
                  colSpan={5}
                  className="border border-black p-2 bg-gray-100 font-semibold"
                >
                  TRUY THU
                </th>
                <th
                  rowSpan={3}
                  className="border border-black p-2 bg-gray-100 font-semibold min-w-[80px]"
                >
                  VÉ BÁN THỰC TẾ
                </th>
                <th
                  rowSpan={3}
                  className="border border-black p-2 bg-gray-100 font-semibold min-w-[180px]"
                >
                  GHI CHÚ
                </th>
              </tr>
              <tr>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Lượt xe
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tải trọng
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lệ phí
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Hoa hồng
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lưu đậu
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[90px]">
                  Doanh thu
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Lượt xe
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tải trọng
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lệ phí
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Hoa hồng
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[90px]">
                  Doanh thu
                </th>
              </tr>
            </thead>
            <tbody>
              {data.map((row, index) => (
                <tr key={index}>
                  <td className="border border-black p-2 text-center">
                    {index + 1}
                  </td>
                  <td className="border border-black p-2">{row.routeOperator}</td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.luotXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.taiTrong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.lePhi)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.hoaHong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.luuDau)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.doanhThu)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.truyThu.luotXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.truyThu.taiTrong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.truyThu.lePhi)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.truyThu.hoaHong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.truyThu.doanhThu)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.veBanThucTe)}
                  </td>
                  <td className="border border-black p-2">{row.ghiChu}</td>
                </tr>
              ))}
              {/* Total Row */}
              {totals && (
                <tr className="font-semibold bg-gray-50">
                  <td
                    colSpan={2}
                    className="border border-black p-2 text-center"
                  >
                    TỔNG CỘNG
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.luotXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.taiTrong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.lePhi)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.hoaHong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.luuDau)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.doanhThu)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.truyThu.luotXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.truyThu.taiTrong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.truyThu.lePhi)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.truyThu.hoaHong)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.truyThu.doanhThu)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.veBanThucTe)}
                  </td>
                  <td className="border border-black p-2"></td>
                </tr>
              )}
            </tbody>
          </table>
        </div>

        {/* Footer */}
        <div className="mt-6 space-y-4">
          <div className="text-sm">
            <p>
              <strong>Ghi chú:</strong> Lượt xe: {totals?.thucHien.luotXe || 0}
              , lượt khách: {totals?.veBanThucTe || 0}, Lưu đậu:{" "}
              {formatNumber(totals?.thucHien.luuDau || 0)}, doanh thu:{" "}
              {formatNumber(totals?.thucHien.doanhThu || 0)}
            </p>
          </div>
          <div className="flex justify-between items-end mt-8">
            <div className="text-center">
              <p className="font-semibold mb-12">TỔ THU NGÂN</p>
              <p className="text-sm italic">(Ký, ghi rõ họ tên)</p>
            </div>
            <div className="text-center">
              <p className="font-semibold mb-12">TỔ BÁN VÉ</p>
              <p className="text-sm italic">(Ký, ghi rõ họ tên)</p>
            </div>
            <div className="text-center">
              <p className="font-semibold mb-12">ĐỘI ĐIỀU HÀNH</p>
              <p className="text-sm italic">(Ký, ghi rõ họ tên)</p>
            </div>
          </div>
        </div>
      </div>

      {/* Print Styles */}
      <style>{`
        @media print {
          @page {
            size: A4 landscape;
            margin: 0;
          }
          
          * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
          }
          
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            background: white !important;
          }
          
          /* Hide all elements except report content */
          body * {
            visibility: hidden;
          }
          
          /* Show only report content and its children */
          .report-content,
          .report-content * {
            visibility: visible !important;
          }
          
          /* Hide print controls and other UI elements */
          .no-print,
          .print\\:hidden {
            display: none !important;
            visibility: hidden !important;
          }
          
          /* Position report content at top of page */
          .report-content {
            position: absolute !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 10mm !important;
            background: white !important;
            page-break-inside: avoid;
            font-size: 11px !important;
          }
          
          /* Header text sizes */
          .report-content h1 {
            font-size: 14px !important;
            line-height: 1.3 !important;
          }
          
          .report-content p {
            font-size: 11px !important;
            line-height: 1.3 !important;
          }
          
          /* Table styles */
          table {
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: collapse !important;
          }
          
          /* Force table to respect colgroup widths */
          colgroup col {
            width: inherit !important;
          }
          
          /* Remove any inline styles that might interfere */
          table[style] {
            min-width: 100% !important;
          }
          
          /* Override all Tailwind classes when printing */
          th[class*="min-w"],
          td[class*="min-w"],
          th[class*="w-"],
          td[class*="w-"] {
            min-width: 0 !important;
            width: auto !important;
          }
          
          /* Use colgroup for column widths when printing */
          col.print-col-tt {
            width: 2.5% !important;
          }
          
          col.print-col-route {
            width: 8% !important;
          }
          
          col.print-col-data {
            width: 6% !important;
          }
          
          col.print-col-ticket {
            width: 3% !important;
          }
          
          col.print-col-note {
            width: 3% !important;
          }
          
          /* Column widths - compact when printing */
          th:first-child,
          td:first-child {
            width: 2.5% !important;
            min-width: 0 !important;
            max-width: 2.5% !important;
          }
          
          th:nth-child(2),
          td:nth-child(2) {
            width: 8% !important;
            min-width: 0 !important;
            max-width: 8% !important;
          }
          
          /* THỰC HIỆN columns (3-8) */
          th:nth-child(3),
          td:nth-child(3),
          th:nth-child(4),
          td:nth-child(4),
          th:nth-child(5),
          td:nth-child(5),
          th:nth-child(6),
          td:nth-child(6),
          th:nth-child(7),
          td:nth-child(7),
          th:nth-child(8),
          td:nth-child(8) {
            width: 6% !important;
            min-width: 0 !important;
            max-width: 6% !important;
          }
          
          /* TRUY THU columns (9-13) */
          th:nth-child(9),
          td:nth-child(9),
          th:nth-child(10),
          td:nth-child(10),
          th:nth-child(11),
          td:nth-child(11),
          th:nth-child(12),
          td:nth-child(12),
          th:nth-child(13),
          td:nth-child(13) {
            width: 6% !important;
            min-width: 0 !important;
            max-width: 6% !important;
          }
          
          /* VÉ BÁN THỰC TẾ column (14) */
          th:nth-child(14),
          td:nth-child(14) {
            width: 3% !important;
            min-width: 0 !important;
            max-width: 3% !important;
          }
          
          /* GHI CHÚ column (15) */
          th:nth-child(15),
          td:nth-child(15) {
            width: 3% !important;
            min-width: 0 !important;
            max-width: 3% !important;
          }
          
          th, td {
            white-space: normal !important;
            border: 1px solid black !important;
            padding: 2px 3px !important;
            font-size: 11px !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            line-height: 1.2 !important;
          }
          
          /* Allow text wrapping for all columns */
          th:nth-child(2),
          td:nth-child(2) {
            white-space: normal !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
          }
          
          /* Ensure proper spacing */
          .report-content > * {
            page-break-inside: avoid;
          }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoTinhHinhHoatDongMau3.tsx">
import { useEffect, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { Printer, ArrowLeft } from "lucide-react";
import { format } from "date-fns";
import { vi } from "date-fns/locale";
import { toast } from "react-toastify";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";

interface ReportRowData {
  routeOperator: string;
  theoKeHoach: {
    tongSoXe: number;
    tongSoGhe: number;
    luotXeXuatBen: number;
  };
  thucHien: {
    tongSoXe: number;
    tongSoGhe: number;
    luotXeXuatBen: number;
    luotKhachDiXe: number;
  };
  tyLe: number;
  ghiChu: string;
}

export default function BaoCaoTinhHinhHoatDongMau3() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const setTitle = useUIStore((state) => state.setTitle);
  const [isLoading, setIsLoading] = useState(true);
  const [fromDate, setFromDate] = useState<Date>(new Date());
  const [toDate, setToDate] = useState<Date>(new Date());
  const [data, setData] = useState<ReportRowData[]>([]);
  const [totals, setTotals] = useState<{
    theoKeHoach: ReportRowData["theoKeHoach"];
    thucHien: ReportRowData["thucHien"];
  } | null>(null);

  useEffect(() => {
    setTitle("Báo cáo > Báo cáo tình hình hoạt động (Mẫu 3)");
    
    // Get dates from URL params
    const fromDateParam = searchParams.get("fromDate");
    const toDateParam = searchParams.get("toDate");
    
    if (fromDateParam) {
      const parsedFromDate = new Date(fromDateParam);
      if (!isNaN(parsedFromDate.getTime())) {
        setFromDate(parsedFromDate);
      }
    }
    
    if (toDateParam) {
      const parsedToDate = new Date(toDateParam);
      if (!isNaN(parsedToDate.getTime())) {
        setToDate(parsedToDate);
      }
    }
  }, [setTitle, searchParams]);

  useEffect(() => {
    if (fromDate && toDate) {
      loadData();
    }
  }, [fromDate, toDate]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Get start and end of date range
      const startDate = new Date(fromDate);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(toDate);
      endDate.setHours(23, 59, 59, 999);

      // Load all dispatch records
      const dispatchRecords = await dispatchService.getAll();

      // Filter records by date range
      const filteredRecords = dispatchRecords.filter((record) => {
        if (!record.entryTime) return false;
        const recordDate = new Date(record.entryTime);
        return recordDate >= startDate && recordDate <= endDate;
      });

      // Group by route and operator
      const grouped = new Map<string, ReportRowData>();

      filteredRecords.forEach((record) => {
        const routeName = record.routeName || "-";
        const operatorName = record.vehicle?.operator?.name || "-";
        const key = `${routeName}|${operatorName}`;

        if (!grouped.has(key)) {
          grouped.set(key, {
            routeOperator: operatorName ? `${routeName} - ${operatorName}` : routeName,
            theoKeHoach: {
              tongSoXe: 0,
              tongSoGhe: 0,
              luotXeXuatBen: 0,
            },
            thucHien: {
              tongSoXe: 0,
              tongSoGhe: 0,
              luotXeXuatBen: 0,
              luotKhachDiXe: 0,
            },
            tyLe: 0,
            ghiChu: "",
          });
        }

        const item = grouped.get(key)!;

        // Calculate THỰC HIỆN (Actual)
        // Tổng số xe - count unique vehicles
        item.thucHien.tongSoXe = 1; // Will be recalculated after grouping

        // Tổng số ghế - seat capacity (from vehicle metadata or default)
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const seatCount = Number(metadata.seatCount) || record.seatCount || 0;
        item.thucHien.tongSoGhe += seatCount;

        // Lượt xe xuất bến - departure trips
        if (record.exitTime) {
          item.thucHien.luotXeXuatBen += 1;
        }

        // Lượt khách đi xe - passengers departing
        const passengers = record.passengersDeparting || 0;
        item.thucHien.luotKhachDiXe += passengers;
      });

      // Recalculate unique vehicles per route/operator
      const routeOperatorKeys = Array.from(grouped.keys());
      routeOperatorKeys.forEach((key) => {
        const item = grouped.get(key)!;
        const [routeName, operatorName] = key.split("|");
        
        // Count unique vehicles for this route/operator
        const uniqueVehicles = new Set(
          filteredRecords
            .filter((r) => {
              const rRoute = r.routeName || "-";
              const rOperator = r.vehicle?.operator?.name || "-";
              return rRoute === routeName && rOperator === operatorName;
            })
            .map((r) => r.vehicleId)
        );
        
        item.thucHien.tongSoXe = uniqueVehicles.size;
        
        // Calculate Tỷ lệ (%) - percentage of actual vs planned
        // For now, we'll calculate based on actual trips
        if (item.theoKeHoach.luotXeXuatBen > 0) {
          item.tyLe = (item.thucHien.luotXeXuatBen / item.theoKeHoach.luotXeXuatBen) * 100;
        }
      });

      // Convert to array and sort
      const result = Array.from(grouped.values()).sort((a, b) =>
        a.routeOperator.localeCompare(b.routeOperator, "vi")
      );

      setData(result);

      // Calculate totals
      const totalTheoKeHoach = result.reduce(
        (acc, row) => ({
          tongSoXe: acc.tongSoXe + row.theoKeHoach.tongSoXe,
          tongSoGhe: acc.tongSoGhe + row.theoKeHoach.tongSoGhe,
          luotXeXuatBen: acc.luotXeXuatBen + row.theoKeHoach.luotXeXuatBen,
        }),
        { tongSoXe: 0, tongSoGhe: 0, luotXeXuatBen: 0 }
      );

      const totalThucHien = result.reduce(
        (acc, row) => ({
          tongSoXe: acc.tongSoXe + row.thucHien.tongSoXe,
          tongSoGhe: acc.tongSoGhe + row.thucHien.tongSoGhe,
          luotXeXuatBen: acc.luotXeXuatBen + row.thucHien.luotXeXuatBen,
          luotKhachDiXe: acc.luotKhachDiXe + row.thucHien.luotKhachDiXe,
        }),
        { tongSoXe: 0, tongSoGhe: 0, luotXeXuatBen: 0, luotKhachDiXe: 0 }
      );

      setTotals({
        theoKeHoach: totalTheoKeHoach,
        thucHien: totalThucHien,
      });
    } catch (error) {
      console.error("Failed to load report data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePrint = () => {
    window.print();
  };

  const formatNumber = (num: number): string => {
    if (num === 0) return "";
    return num.toLocaleString("vi-VN");
  };

  const formatPercentage = (num: number): string => {
    if (num === 0) return "";
    return `${num.toFixed(1)}%`;
  };

  const dateOnly = format(fromDate, "dd/MM/yyyy");

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="h-8 w-8 border-4 border-gray-300 border-t-blue-600 rounded-full animate-spin mx-auto mb-4" />
          <p className="text-gray-600">Đang tải dữ liệu...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white">
      {/* Print controls - hidden when printing */}
      <div className="no-print p-4 bg-gray-50 border-b sticky top-0 z-10">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <Button variant="outline" onClick={() => navigate(-1)}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Quay lại
          </Button>
          <Button onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            In báo cáo
          </Button>
        </div>
      </div>

      {/* Report Content */}
      <div className="report-content w-full mx-auto bg-white p-[15mm] print:p-[10mm]">
        {/* Header */}
        <div className="mb-6">
          <div className="flex justify-between items-start mb-4">
            <div className="text-center flex-1">
              <p className="font-semibold text-sm">Công ty CP Bố Hạ</p>
            </div>
            <div className="flex flex-col items-center flex-1">
              <p className="font-semibold text-sm uppercase text-center">
                CỘNG HOÀ XÃ HỘI CHỦ NGHĨA VIỆT NAM
              </p>
              <p className="text-sm italic text-center">Độc lập - Tự do - Hạnh phúc</p>
            </div>
          </div>
          <p className="text-right text-sm mb-4">
            Thành phố Hồ Chí Minh, ngày {dateOnly}
          </p>
          <h1 className="text-center font-bold text-lg uppercase mb-6">
            BÁO CÁO TÌNH HÌNH HOẠT ĐỘNG CÁC TUYẾN VẬN TẢI HÀNH KHÁCH
            <br />
            TỪ NGÀY {format(fromDate, "dd/MM/yyyy", { locale: vi }).toUpperCase()} ĐẾN NGÀY{" "}
            {format(toDate, "dd/MM/yyyy", { locale: vi }).toUpperCase()}
          </h1>
        </div>

        {/* Table */}
        <div className="overflow-x-auto">
          <table className="w-full border-collapse border border-black text-xs" style={{ minWidth: '100%' }}>
            <colgroup>
              <col className="print-col-tt" />
              <col className="print-col-route" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-data" />
              <col className="print-col-percent" />
              <col className="print-col-note" />
            </colgroup>
            <thead>
              <tr>
                <th rowSpan={3} className="border border-black p-2 bg-gray-100 font-semibold w-16">
                  TT
                </th>
                <th rowSpan={3} className="border border-black p-2 bg-gray-100 font-semibold min-w-[250px]">
                  Tuyến/đơn vị vận tải
                </th>
                <th colSpan={3} className="border border-black p-2 bg-gray-100 font-semibold">
                  Theo kế hoạch
                </th>
                <th colSpan={4} className="border border-black p-2 bg-gray-100 font-semibold">
                  Thực hiện
                </th>
                <th rowSpan={3} className="border border-black p-2 bg-gray-100 font-semibold min-w-[80px]">
                  Tỷ lệ (%) số nốt (tải) thực hiện trong tháng
                </th>
                <th rowSpan={3} className="border border-black p-2 bg-gray-100 font-semibold min-w-[180px]">
                  Ghi chú số nốt tài hoạt động trong ngày
                </th>
              </tr>
              <tr>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tổng số xe (xe)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tổng số ghế (ghế xe)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lượt xe xuất bến (lượt)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tổng số xe (xe)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[70px]">
                  Tổng số ghế (ghế xe)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lượt xe xuất bến (lượt)
                </th>
                <th className="border border-black p-1 bg-gray-100 font-semibold min-w-[80px]">
                  Lượt khách đi xe (khách)
                </th>
              </tr>
            </thead>
            <tbody>
              {data.map((row, index) => (
                <tr key={index}>
                  <td className="border border-black p-2 text-center">
                    {index + 1}
                  </td>
                  <td className="border border-black p-2">{row.routeOperator}</td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.theoKeHoach.tongSoXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.theoKeHoach.tongSoGhe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.theoKeHoach.luotXeXuatBen)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.tongSoXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.tongSoGhe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.luotXeXuatBen)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(row.thucHien.luotKhachDiXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatPercentage(row.tyLe)}
                  </td>
                  <td className="border border-black p-2">{row.ghiChu}</td>
                </tr>
              ))}
              {/* Total Row */}
              {totals && (
                <tr className="font-semibold bg-gray-50">
                  <td colSpan={2} className="border border-black p-2 text-center">
                    TỔNG CỘNG
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.theoKeHoach.tongSoXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.theoKeHoach.tongSoGhe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.theoKeHoach.luotXeXuatBen)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.tongSoXe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.tongSoGhe)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.luotXeXuatBen)}
                  </td>
                  <td className="border border-black p-2 text-right">
                    {formatNumber(totals.thucHien.luotKhachDiXe)}
                  </td>
                  <td className="border border-black p-2 text-right"></td>
                  <td className="border border-black p-2"></td>
                </tr>
              )}
            </tbody>
          </table>
        </div>

        {/* Footer */}
        <div className="mt-6 space-y-4">
          <div className="text-sm">
            <p>
              <strong>Ghi chú:</strong> Số liệu cuối kỳ là danh sách của tháng sau
            </p>
            <p className="mt-2">
              <strong>Nơi nhận:</strong>
            </p>
            <p>- P.KHĐT;</p>
            <p>- Lưu VT (s).</p>
          </div>
          <div className="flex justify-end items-end mt-8">
            <div className="text-center">
              <p className="font-semibold mb-12">GIÁM ĐỐC</p>
              <p className="text-sm italic">(Ký, ghi rõ họ tên)</p>
            </div>
          </div>
        </div>
      </div>

      {/* Print Styles */}
      <style>{`
        @media print {
          @page {
            size: A4 landscape;
            margin: 0;
          }
          
          * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
          }
          
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            background: white !important;
          }
          
          /* Hide all elements except report content */
          body * {
            visibility: hidden;
          }
          
          /* Show only report content and its children */
          .report-content,
          .report-content * {
            visibility: visible !important;
          }
          
          /* Hide print controls and other UI elements */
          .no-print,
          .print\\:hidden {
            display: none !important;
            visibility: hidden !important;
          }
          
          /* Position report content at top of page */
          .report-content {
            position: absolute !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 10mm !important;
            background: white !important;
            page-break-inside: avoid;
            font-size: 11px !important;
          }
          
          /* Header text sizes */
          .report-content h1 {
            font-size: 14px !important;
            line-height: 1.3 !important;
          }
          
          .report-content p {
            font-size: 11px !important;
            line-height: 1.3 !important;
          }
          
          /* Table styles */
          table {
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: collapse !important;
          }
          
          /* Force table to respect colgroup widths */
          colgroup col {
            width: inherit !important;
          }
          
          /* Remove any inline styles that might interfere */
          table[style] {
            min-width: 100% !important;
          }
          
          /* Override all Tailwind classes when printing */
          th[class*="min-w"],
          td[class*="min-w"],
          th[class*="w-"],
          td[class*="w-"] {
            min-width: 0 !important;
            width: auto !important;
          }
          
          /* Use colgroup for column widths when printing */
          col.print-col-tt {
            width: 2.5% !important;
          }
          
          col.print-col-route {
            width: 12% !important;
          }
          
          col.print-col-data {
            width: 7% !important;
          }
          
          col.print-col-percent {
            width: 8% !important;
          }
          
          col.print-col-note {
            width: 8% !important;
          }
          
          /* Column widths - compact when printing */
          th:first-child,
          td:first-child {
            width: 2.5% !important;
            min-width: 0 !important;
            max-width: 2.5% !important;
          }
          
          th:nth-child(2),
          td:nth-child(2) {
            width: 12% !important;
            min-width: 0 !important;
            max-width: 12% !important;
          }
          
          /* Theo kế hoạch columns (3-5) */
          th:nth-child(3),
          td:nth-child(3),
          th:nth-child(4),
          td:nth-child(4),
          th:nth-child(5),
          td:nth-child(5) {
            width: 7% !important;
            min-width: 0 !important;
            max-width: 7% !important;
          }
          
          /* Thực hiện columns (6-9) */
          th:nth-child(6),
          td:nth-child(6),
          th:nth-child(7),
          td:nth-child(7),
          th:nth-child(8),
          td:nth-child(8),
          th:nth-child(9),
          td:nth-child(9) {
            width: 7% !important;
            min-width: 0 !important;
            max-width: 7% !important;
          }
          
          /* Tỷ lệ column (10) */
          th:nth-child(10),
          td:nth-child(10) {
            width: 8% !important;
            min-width: 0 !important;
            max-width: 8% !important;
          }
          
          /* GHI CHÚ column (11) */
          th:nth-child(11),
          td:nth-child(11) {
            width: 8% !important;
            min-width: 0 !important;
            max-width: 8% !important;
          }
          
          th, td {
            white-space: normal !important;
            border: 1px solid black !important;
            padding: 2px 3px !important;
            font-size: 11px !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            line-height: 1.2 !important;
          }
          
          /* Ensure proper spacing */
          .report-content > * {
            page-break-inside: avoid;
          }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoXeDiThay.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { vehicleService } from "@/services/vehicle.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface ReplacementVehicleData {
  plateNumber: string;
  replacementPlateNumber: string;
  operatorName: string;
  routeName: string;
  replacementCount: number;
  replacementDate: string;
}

export default function BaoCaoXeDiThay() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<ReplacementVehicleData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  useEffect(() => {
    setTitle("Báo cáo > Xe đi thay");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Load all vehicles to get plate numbers
      const vehicles = await vehicleService.getAll();
      const vehicleMap = new Map(vehicles.map(v => [v.id, v.plateNumber]));
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          if (record.entryTime) {
            const recordDate = new Date(record.entryTime);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Group by vehicle and find replacement vehicles from metadata
      const replacementMap = new Map<string, {
        plateNumber: string;
        operatorName: string;
        routeName: string;
        replacements: Array<{ replacementPlate: string; date: string }>;
      }>();

      filteredRecords.forEach((record) => {
        const plateNumber = record.vehiclePlateNumber || "-";
        const operatorName = record.vehicle?.operator?.name || "-";
        const routeName = record.routeName || "-";

        // Check if record has replacement vehicle info in metadata
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        const replacementVehicleId = metadata.replacementVehicleId as string | undefined;
        const replacementDate = record.entryTime || record.createdAt || "";
        
        if (replacementVehicleId) {
          const replacementPlate = vehicleMap.get(replacementVehicleId) || "-";
          
          if (!replacementMap.has(plateNumber)) {
            replacementMap.set(plateNumber, {
              plateNumber,
              operatorName,
              routeName,
              replacements: [],
            });
          }
          
          const vehicleData = replacementMap.get(plateNumber)!;
          vehicleData.replacements.push({
            replacementPlate,
            date: replacementDate,
          });
        }
      });

      // Convert to report data format
      const result: ReplacementVehicleData[] = [];
      
      replacementMap.forEach((vehicleData) => {
        // Group replacements by replacement vehicle
        const replacementCountMap = new Map<string, number>();
        const replacementDateMap = new Map<string, string>();
        
        vehicleData.replacements.forEach((rep) => {
          const count = replacementCountMap.get(rep.replacementPlate) || 0;
          replacementCountMap.set(rep.replacementPlate, count + 1);
          
          // Keep the most recent date
          const existingDate = replacementDateMap.get(rep.replacementPlate);
          if (!existingDate || new Date(rep.date) > new Date(existingDate)) {
            replacementDateMap.set(rep.replacementPlate, rep.date);
          }
        });
        
        // Create entries for each replacement vehicle
        replacementCountMap.forEach((count, replacementPlate) => {
          result.push({
            plateNumber: vehicleData.plateNumber,
            replacementPlateNumber: replacementPlate,
            operatorName: vehicleData.operatorName,
            routeName: vehicleData.routeName,
            replacementCount: count,
            replacementDate: replacementDateMap.get(replacementPlate) || "",
          });
        });
      });

      // If no replacement data found, show empty or try alternative approach
      // For now, we'll show empty if no data
      setData(result);
    } catch (error) {
      console.error("Failed to load replacement vehicle data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredData = useMemo(() => {
    let filtered = data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.replacementPlateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "plateNumber":
            aValue = a.plateNumber || "";
            bValue = b.plateNumber || "";
            break;
          case "replacementPlateNumber":
            aValue = a.replacementPlateNumber || "";
            bValue = b.replacementPlateNumber || "";
            break;
          case "operatorName":
            aValue = a.operatorName || "";
            bValue = b.operatorName || "";
            break;
          case "routeName":
            aValue = a.routeName || "";
            bValue = b.routeName || "";
            break;
          case "replacementCount":
            aValue = a.replacementCount || 0;
            bValue = b.replacementCount || 0;
            break;
          case "replacementDate":
            aValue = a.replacementDate !== "" ? new Date(a.replacementDate).getTime() : 0;
            bValue = b.replacementDate !== "" ? new Date(b.replacementDate).getTime() : 0;
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [data, searchQuery, sortColumn, sortDirection]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Biển số xe đi thay": item.replacementPlateNumber,
        "Tên đơn vị": item.operatorName,
        "Tên luồng tuyến": item.routeName,
        "Số lần đi thay": item.replacementCount,
        "Ngày đi thay": item.replacementDate !== ""
          ? format(new Date(item.replacementDate), "dd/MM/yyyy HH:mm")
          : "-",
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe đi thay");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 20 },  // Biển số xe đi thay
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 15 },  // Số lần đi thay
        { wch: 20 },  // Ngày đi thay
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-xe-di-thay_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderDate = (value: string) => {
    if (value === "" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow className="bg-gray-100">
                  <TableHead className="text-center font-semibold">STT</TableHead>
                  <SortableTableHead
                    sortKey="plateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Biển số
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="replacementPlateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Biển số xe đi thay
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="operatorName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên đơn vị
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Tên luồng tuyến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="replacementCount"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Số lần đi thay
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="replacementDate"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                    className="text-center font-semibold"
                  >
                    Ngày đi thay
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <TableRow key={`${item.plateNumber}-${item.replacementPlateNumber}-${index}`}>
                      <TableCell className="text-center">
                        {index + 1}
                      </TableCell>
                      <TableCell className="text-center font-semibold">
                        {item.plateNumber}
                      </TableCell>
                      <TableCell className="text-center font-semibold text-blue-600">
                        {item.replacementPlateNumber}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.operatorName}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.routeName}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.replacementCount}
                      </TableCell>
                      <TableCell className="text-center">
                        {renderDate(item.replacementDate)}
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoXeKhongDuDieuKien.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
} from "@/components/ui/sticky-table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface IneligibleVehicleData {
  plateNumber: string;
  operatorName: string;
  routeName: string;
  routeType: string;
  transportOrderCode: string;
  entryTime: string;
  entryBy: string;
  permitTime: string;
  permitShift: string;
  paymentTime: string;
  paymentBy: string;
  departureOrderTime: string;
  departureOrderBy: string;
  departureOrderShift: string;
  plannedDepartureTime: string;
  actualDepartureTime: string;
  exitTime: string;
  exitBy: string;
  drivers: string;
  rejectionReason: string;
  parkingLocation: string;
  notes: string;
  hasImages: string;
  permitStatus: string;
  syncStatus: string;
}

export default function BaoCaoXeKhongDuDieuKien() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<IneligibleVehicleData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  useEffect(() => {
    setTitle("Báo cáo > Xe không đủ điều kiện");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          if (record.entryTime) {
            const recordDate = new Date(record.entryTime);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Only show records that are not eligible (permit_rejected)
      const ineligibleRecords = filteredRecords.filter(
        (record) => record.currentStatus === "permit_rejected" || record.permitStatus === "rejected"
      );

      // Map to ineligible vehicle data
      const result = ineligibleRecords.map((record) => {
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        return {
          plateNumber: record.vehiclePlateNumber || "-",
          operatorName: record.vehicle?.operator?.name || "-",
          routeName: record.routeName || "-",
          routeType: record.route?.routeType || "-",
          transportOrderCode: record.transportOrderCode || "-",
          entryTime: record.entryTime || "-",
          entryBy: record.entryBy || "-",
          permitTime: record.boardingPermitTime || "-",
          permitShift: String(metadata.permitShift || "-"),
          paymentTime: record.paymentTime || "-",
          paymentBy: record.paymentBy || "-",
          departureOrderTime: record.departureOrderTime || "-",
          departureOrderBy: record.departureOrderBy || "-",
          departureOrderShift: String(metadata.departureOrderShift || "-"),
          plannedDepartureTime: record.plannedDepartureTime || "-",
          actualDepartureTime: String(metadata.actualDepartureTime || "-"),
          exitTime: record.exitTime || "-",
          exitBy: record.exitBy || "-",
          drivers: record.driverName || "-",
          rejectionReason: record.rejectionReason || "-",
          parkingLocation: String(metadata.parkingLocation || "-"),
          notes: record.notes || "-",
          hasImages: metadata.hasImages ? "Có" : "Không",
          permitStatus: getPermitStatusLabel(record.permitStatus),
          syncStatus: getSyncStatus(record),
        };
      });

      setData(result);
    } catch (error) {
      console.error("Failed to load ineligible vehicle data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const getPermitStatusLabel = (permitStatus?: string): string => {
    if (!permitStatus) return "Chưa ký";
    
    switch (permitStatus) {
      case "approved":
        return "Đã ký";
      case "rejected":
        return "Từ chối";
      case "pending":
        return "Chờ ký";
      default:
        return permitStatus;
    }
  };

  const getSyncStatus = (record: any): string => {
    if (record.metadata?.synced === true) {
      return "Đã đồng bộ";
    }
    
    if (record.transportOrderCode && record.permitStatus === "approved") {
      return "Đã đồng bộ";
    }
    
    if (record.updatedAt) {
      const updatedTime = new Date(record.updatedAt).getTime();
      const now = new Date().getTime();
      const diffHours = (now - updatedTime) / (1000 * 60 * 60);
      
      if (diffHours < 1) {
        return "Đang đồng bộ";
      }
    }
    
    return "Chưa đồng bộ";
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query) ||
          item.transportOrderCode.toLowerCase().includes(query)
        );
      }
      return true;
    });
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Tên đơn vị": item.operatorName,
        "Tên luồng tuyến": item.routeName,
        "Loại tuyến": item.routeType,
        "Mã lệnh vận chuyển": item.transportOrderCode,
        "Thời gian vào bến": item.entryTime !== "-" ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cho vào bến": item.entryBy,
        "Giờ cấp phép lên nốt": item.permitTime !== "-" ? format(new Date(item.permitTime), "dd/MM/yyyy HH:mm") : "-",
        "Ca trực cấp nốt": item.permitShift,
        "Thời gian thanh toán": item.paymentTime !== "-" ? format(new Date(item.paymentTime), "dd/MM/yyyy HH:mm") : "-",
        "Người thanh toán": item.paymentBy,
        "Giờ cấp lệnh xuất bến": item.departureOrderTime !== "-" ? format(new Date(item.departureOrderTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cấp lệnh": item.departureOrderBy,
        "Ca trực cấp lệnh": item.departureOrderShift,
        "Giờ xuất bến KH": item.plannedDepartureTime !== "-" ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Giờ xuất bến khác": item.actualDepartureTime !== "-" ? format(new Date(item.actualDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Thời gian ra bến": item.exitTime !== "-" ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cho ra bến": item.exitBy,
        "Danh sách lái xe": item.drivers,
        "Lý do không đủ điều kiện": item.rejectionReason,
        "Vị trí đỗ": item.parkingLocation,
        "Ghi chú": item.notes,
        "Có ảnh vào ra": item.hasImages,
        "Trạng thái ký lệnh vận chuyển": item.permitStatus,
        "Trạng thái đồng bộ dữ liệu": item.syncStatus,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe không đủ điều kiện");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 15 },  // Loại tuyến
        { wch: 20 },  // Mã lệnh vận chuyển
        { wch: 20 },  // Thời gian vào bến
        { wch: 20 },  // Người cho vào bến
        { wch: 20 },  // Giờ cấp phép lên nốt
        { wch: 15 },  // Ca trực cấp nốt
        { wch: 20 },  // Thời gian thanh toán
        { wch: 20 },  // Người thanh toán
        { wch: 20 },  // Giờ cấp lệnh xuất bến
        { wch: 20 },  // Người cấp lệnh
        { wch: 15 },  // Ca trực cấp lệnh
        { wch: 20 },  // Giờ xuất bến KH
        { wch: 20 },  // Giờ xuất bến khác
        { wch: 20 },  // Thời gian ra bến
        { wch: 20 },  // Người cho ra bến
        { wch: 20 },  // Danh sách lái xe
        { wch: 30 },  // Lý do không đủ điều kiện
        { wch: 15 },  // Vị trí đỗ
        { wch: 30 },  // Ghi chú
        { wch: 15 },  // Có ảnh vào ra
        { wch: 25 },  // Trạng thái ký lệnh vận chuyển
        { wch: 25 },  // Trạng thái đồng bộ dữ liệu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-xe-khong-du-dieu-kien_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  // Sticky column positions (in pixels)
  // Using fixed widths for all columns to calculate sticky positions accurately
  const STICKY_COLUMN_WIDTH = 150;
  const NON_STICKY_COLUMN_WIDTH = 160; // Average width for non-sticky columns
  
  // Calculate positions: 3 sticky columns + 20 non-sticky columns before the last 2 sticky columns
  const stickyPositions = {
    plateNumber: 0,
    operatorName: STICKY_COLUMN_WIDTH,
    routeName: STICKY_COLUMN_WIDTH * 2,
    // Position after 3 sticky columns (450px) + 20 non-sticky columns (3200px)
    permitStatus: STICKY_COLUMN_WIDTH * 3 + (NON_STICKY_COLUMN_WIDTH * 20),
    // Position after permitStatus + its width
    syncStatus: STICKY_COLUMN_WIDTH * 3 + (NON_STICKY_COLUMN_WIDTH * 20) + STICKY_COLUMN_WIDTH,
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, tuyến, mã lệnh..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <StickyTable style={{ tableLayout: "fixed", width: "max-content" }}>
              <colgroup>
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
              </colgroup>
              <StickyTableHeader>
                <StickyTableRow className="bg-gray-100">
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.plateNumber}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Biển số
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.operatorName}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Tên đơn vị
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.routeName}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Tên luồng tuyến
                  </StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Loại tuyến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Mã lệnh vận chuyển</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian vào bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cho vào bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ cấp phép lên nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cấp nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ cấp lệnh xuất bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cấp lệnh</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cấp lệnh</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến KH</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến khác</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian ra bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cho ra bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Danh sách lái xe</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Lý do không đủ điều kiện</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Vị trí đỗ</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ghi chú</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Có ảnh vào ra</StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyRight={STICKY_COLUMN_WIDTH}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Trạng thái ký lệnh vận chuyển
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyRight={0}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Trạng thái đồng bộ dữ liệu
                  </StickyTableHead>
                </StickyTableRow>
              </StickyTableHeader>
              <StickyTableBody>
                {isLoading ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={25} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </StickyTableCell>
                  </StickyTableRow>
                ) : filteredData.length === 0 ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={25} className="text-center text-gray-500">
                      Không có dữ liệu
                    </StickyTableCell>
                  </StickyTableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <StickyTableRow key={`${item.plateNumber}-${item.entryTime}-${index}`}>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.plateNumber}
                        className="text-center font-semibold"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.plateNumber}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.operatorName}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.operatorName}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.routeName}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.routeName}
                      </StickyTableCell>
                      <StickyTableCell className="text-center">{item.routeType}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.transportOrderCode}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.entryTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.entryBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.permitTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.permitShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.paymentTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.paymentBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.departureOrderTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.departureOrderBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.departureOrderShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.plannedDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.actualDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.exitTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.exitBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.drivers}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.rejectionReason}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.parkingLocation}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.notes}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.hasImages}</StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyRight={STICKY_COLUMN_WIDTH}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.permitStatus}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyRight={0}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.syncStatus}
                      </StickyTableCell>
                    </StickyTableRow>
                  ))
                )}
              </StickyTableBody>
            </StickyTable>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoXeRaVaoBen.tsx">
import { useEffect, useMemo, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { RefreshCw, Search, FileSpreadsheet, ArrowLeft } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
} from "@/components/ui/sticky-table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface VehicleEntryExitData {
  plateNumber: string;
  entryPlateNumber: string;
  operatorName: string;
  routeName: string;
  entryTime: string;
  entryShift: string;
  plannedDepartureTime: string;
  actualDepartureTime: string;
  exitTime: string;
  exitShift: string;
  vehicleStatus: string;
  hasBoardingPermit: string;
  isTemporaryExit: string;
  hasImages: string;
}

export default function BaoCaoXeRaVaoBen() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<VehicleEntryExitData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  // Get vehicle plate number and return path from URL params
  const vehiclePlateNumberFilter = searchParams.get("vehiclePlateNumber") || "";
  const returnTo = searchParams.get("returnTo") || "";

  useEffect(() => {
    if (vehiclePlateNumberFilter) {
      setTitle(`Báo cáo xe ra vào bến của ${vehiclePlateNumberFilter}`);
    } else {
      setTitle("Báo cáo > Xe ra vào bến");
    }
  }, [setTitle, vehiclePlateNumberFilter]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange, vehiclePlateNumberFilter]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          if (record.entryTime) {
            const recordDate = new Date(record.entryTime);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Filter by vehicle plate number if provided in URL params
      let vehicleFilteredRecords = filteredRecords;
      if (vehiclePlateNumberFilter) {
        vehicleFilteredRecords = filteredRecords.filter((record) =>
          record.vehiclePlateNumber?.toLowerCase() === vehiclePlateNumberFilter.toLowerCase()
        );
      }

      // Map to vehicle entry/exit data
      const result = vehicleFilteredRecords.map((record) => {
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        return {
          plateNumber: record.vehiclePlateNumber || "-",
          entryPlateNumber: String(metadata.entryPlateNumber || record.vehiclePlateNumber || "-"),
          operatorName: record.vehicle?.operator?.name || "-",
          routeName: record.routeName || "-",
          entryTime: record.entryTime || "-",
          entryShift: String(metadata.entryShift || "-"),
          plannedDepartureTime: record.plannedDepartureTime || "-",
          actualDepartureTime: String(metadata.actualDepartureTime || "-"),
          exitTime: record.exitTime || "-",
          exitShift: String(metadata.exitShift || "-"),
          vehicleStatus: getVehicleStatus(record),
          hasBoardingPermit: record.boardingPermitTime ? "Có" : "Không",
          isTemporaryExit: metadata.isTemporaryExit ? "Có" : "Không",
          hasImages: metadata.hasImages ? "Có" : "Không",
        };
      });

      setData(result);
    } catch (error) {
      console.error("Failed to load vehicle entry/exit data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const getVehicleStatus = (record: any): string => {
    if (record.exitTime) {
      return "Đã ra bến";
    }
    if (record.departureOrderTime) {
      return "Đã xuất lệnh";
    }
    if (record.boardingPermitTime) {
      return "Đã cấp phép";
    }
    if (record.passengerDropTime) {
      return "Đã trả khách";
    }
    if (record.entryTime) {
      return "Đang trong bến";
    }
    return "-";
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.entryPlateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query)
        );
      }
      return true;
    });
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Biển số khi vào": item.entryPlateNumber,
        "Tên đơn vị": item.operatorName,
        "Tên luồng tuyến": item.routeName,
        "Thời gian vào bến": item.entryTime !== "-" ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") : "-",
        "Ca trực cho vào": item.entryShift,
        "Giờ xuất bến kế hoạch": item.plannedDepartureTime !== "-" ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Giờ xuất bến khác": item.actualDepartureTime !== "-" ? format(new Date(item.actualDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Thời gian ra bến": item.exitTime !== "-" ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm") : "-",
        "Ca trực cho ra": item.exitShift,
        "Trạng thái xe": item.vehicleStatus,
        "Xe lên nốt": item.hasBoardingPermit,
        "Xe tạm ra": item.isTemporaryExit,
        "Có ảnh vào ra": item.hasImages,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe ra vào bến");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 15 },  // Biển số khi vào
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 20 },  // Thời gian vào bến
        { wch: 15 },  // Ca trực cho vào
        { wch: 20 },  // Giờ xuất bến kế hoạch
        { wch: 20 },  // Giờ xuất bến khác
        { wch: 20 },  // Thời gian ra bến
        { wch: 15 },  // Ca trực cho ra
        { wch: 15 },  // Trạng thái xe
        { wch: 12 },  // Xe lên nốt
        { wch: 12 },  // Xe tạm ra
        { wch: 15 },  // Có ảnh vào ra
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-xe-ra-vao-ben_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  // Sticky column positions (in pixels)
  const STICKY_COLUMN_WIDTH = 150;
  const NON_STICKY_COLUMN_WIDTH = 160;
  
  const stickyPositions = {
    plateNumber: 0,
    entryPlateNumber: STICKY_COLUMN_WIDTH,
    operatorName: STICKY_COLUMN_WIDTH * 2,
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            {returnTo && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => navigate(returnTo)}
                className="gap-2"
              >
                <ArrowLeft className="h-4 w-4" />
                Quay lại
              </Button>
            )}
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <StickyTable style={{ tableLayout: "fixed", width: "max-content" }}>
              <colgroup>
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
              </colgroup>
              <StickyTableHeader>
                <StickyTableRow className="bg-gray-100">
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.plateNumber}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Biển số
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.entryPlateNumber}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Biển số khi vào
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.operatorName}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Tên đơn vị
                  </StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Tên luồng tuyến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian vào bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cho vào</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến kế hoạch</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến khác</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian ra bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cho ra</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Trạng thái xe</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Xe lên nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Xe tạm ra</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Có ảnh vào ra</StickyTableHead>
                </StickyTableRow>
              </StickyTableHeader>
              <StickyTableBody>
                {isLoading ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={14} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </StickyTableCell>
                  </StickyTableRow>
                ) : filteredData.length === 0 ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={14} className="text-center text-gray-500">
                      Không có dữ liệu
                    </StickyTableCell>
                  </StickyTableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <StickyTableRow key={`${item.plateNumber}-${item.entryTime}-${index}`}>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.plateNumber}
                        className="text-center font-semibold"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.plateNumber}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.entryPlateNumber}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.entryPlateNumber}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.operatorName}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.operatorName}
                      </StickyTableCell>
                      <StickyTableCell className="text-center">{item.routeName}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.entryTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.entryShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.plannedDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.actualDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.exitTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.exitShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.vehicleStatus}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.hasBoardingPermit}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.isTemporaryExit}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.hasImages}</StickyTableCell>
                    </StickyTableRow>
                  ))
                )}
              </StickyTableBody>
            </StickyTable>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/BaoCaoXeTraKhach.tsx">
import { useEffect, useMemo, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { RefreshCw, Search, FileSpreadsheet, ArrowLeft } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHeader,
  TableRow,
  SortableTableHead,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { operatorService } from "@/services/operator.service";
import type { DispatchRecord, Operator } from "@/types";
import { useUIStore } from "@/store/ui.store";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { DatePickerRange } from "@/components/DatePickerRange";

export default function BaoCaoXeTraKhach() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const setTitle = useUIStore((state) => state.setTitle);
  const [records, setRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");

  // Get vehicle plate number and return path from URL params
  const vehiclePlateNumberFilter = searchParams.get("vehiclePlateNumber") || "";
  const returnTo = searchParams.get("returnTo") || "";

  useEffect(() => {
    if (vehiclePlateNumberFilter) {
      setTitle(`Báo cáo xe trả khách của ${vehiclePlateNumberFilter}`);
    } else {
      setTitle("Báo cáo > Xe trả khách");
    }
    loadRecords();
    loadOperators();
  }, [setTitle, vehiclePlateNumberFilter]);

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      // Chỉ lấy các xe đã trả khách
      const filtered = data.filter((item) =>
        item.currentStatus === "passengers_dropped"
      );
      setRecords(filtered);
    } catch (error) {
      console.error("Failed to load dispatch records:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
    } finally {
      setIsLoading(false);
    }
  };

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const handleSort = (column: string) => {
    if (sortColumn === column) {
      // Cycle through: asc -> desc -> unsort
      if (sortDirection === "asc") {
        setSortDirection("desc");
      } else if (sortDirection === "desc") {
        // Reset to unsort
        setSortColumn(null);
        setSortDirection("asc");
      }
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredRecords = useMemo(() => {
    let filtered = records.filter((item) => {
      // Filter by vehicle plate number if provided in URL params
      let matchesVehicle = true;
      if (vehiclePlateNumberFilter) {
        matchesVehicle = item.vehiclePlateNumber?.toLowerCase() === vehiclePlateNumberFilter.toLowerCase();
      }
      
      // Full text search - search in both plate number and route name
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        const plateMatch = item.vehiclePlateNumber
          .toLowerCase()
          .includes(query);
        const routeMatch = (item.routeName || "")
          .toLowerCase()
          .includes(query);
        matchesSearch = plateMatch || routeMatch;
      }
      
      // Filter by operator
      let matchesOperator = true;
      if (selectedOperatorId) {
        matchesOperator = item.vehicle?.operatorId === selectedOperatorId;
      }
      
      // Filter by date range (using passengerDropTime)
      let matchesDate = true;
      if (dateRange?.from && dateRange?.to) {
        const filterDate = item.passengerDropTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          const toDate = new Date(dateRange.to);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = itemDate >= fromDate && itemDate <= toDate;
        } else {
          matchesDate = false;
        }
      } else if (dateRange?.from) {
        const filterDate = item.passengerDropTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = itemDate >= fromDate;
        } else {
          matchesDate = false;
        }
      }
      
      return matchesVehicle && matchesSearch && matchesOperator && matchesDate;
    });

    // Apply sorting
    if (sortColumn) {
      filtered = [...filtered].sort((a, b) => {
        let aValue: any;
        let bValue: any;

        switch (sortColumn) {
          case "vehiclePlateNumber":
            aValue = a.vehiclePlateNumber || "";
            bValue = b.vehiclePlateNumber || "";
            break;
          case "transportOrderCode":
            aValue = a.transportOrderCode || a.id.substring(0, 8) || "";
            bValue = b.transportOrderCode || b.id.substring(0, 8) || "";
            break;
          case "operatorName":
            aValue = a.vehicle?.operator?.name || "";
            bValue = b.vehicle?.operator?.name || "";
            break;
          case "routeName":
            aValue = a.routeName || "";
            bValue = b.routeName || "";
            break;
          case "routeType":
            aValue = a.route?.routeType || "";
            bValue = b.route?.routeType || "";
            break;
          case "passengerDropBy":
            aValue = a.passengerDropBy || "";
            bValue = b.passengerDropBy || "";
            break;
          case "passengerDropTime":
            aValue = a.passengerDropTime ? new Date(a.passengerDropTime).getTime() : 0;
            bValue = b.passengerDropTime ? new Date(b.passengerDropTime).getTime() : 0;
            break;
          case "passengersArrived":
            aValue = a.passengersArrived ?? a.seatCount ?? 0;
            bValue = b.passengersArrived ?? b.seatCount ?? 0;
            break;
          case "permitStatus":
            aValue = a.permitStatus === "approved" ? "Đã ký" : a.permitStatus === "rejected" ? "Từ chối" : "-";
            bValue = b.permitStatus === "approved" ? "Đã ký" : b.permitStatus === "rejected" ? "Từ chối" : "-";
            break;
          case "syncStatus":
            const aMetadata = (a.metadata || {}) as Record<string, unknown>;
            const bMetadata = (b.metadata || {}) as Record<string, unknown>;
            aValue = String(aMetadata.syncStatus || (aMetadata.syncTime ? "Đã đồng bộ" : "Chưa đồng bộ"));
            bValue = String(bMetadata.syncStatus || (bMetadata.syncTime ? "Đã đồng bộ" : "Chưa đồng bộ"));
            break;
          default:
            return 0;
        }

        // Handle string comparison
        if (typeof aValue === "string" && typeof bValue === "string") {
          const comparison = aValue.localeCompare(bValue, "vi", { numeric: true });
          return sortDirection === "asc" ? comparison : -comparison;
        }

        // Handle number comparison
        if (typeof aValue === "number" && typeof bValue === "number") {
          return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
        }

        // Handle mixed types (fallback)
        if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [records, searchQuery, dateRange, selectedOperatorId, sortColumn, sortDirection, vehiclePlateNumberFilter]);

  const renderTime = (value?: string) => (value ? formatVietnamDateTime(value) : "-");

  const totalPassengers = useMemo(() => {
    return filteredRecords.reduce((sum, item) => {
      const value = item.passengersArrived ?? item.seatCount;
      if (typeof value === "number") {
        return sum + value;
      }
      return sum;
    }, 0);
  }, [filteredRecords]);

  const handleExportExcel = () => {
    if (filteredRecords.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredRecords.map((item, index) => {
        const itemMetadata = (item.metadata || {}) as Record<string, unknown>;
        return {
          "STT": index + 1,
          "Biển số": item.vehiclePlateNumber || "-",
          "Biển số khi vào": item.vehiclePlateNumber || "-",
          "Mã lệnh trả khách": item.transportOrderCode || item.id.substring(0, 8) || "-",
          "Tên đơn vị": item.vehicle?.operator?.name || "-",
          "Tên luồng tuyến": item.routeName || "-",
          "Loại tuyến": "-",
          "Người xác nhận trả khách": item.passengerDropBy || "-",
          "Thời gian trả khách": item.passengerDropTime ? format(new Date(item.passengerDropTime), "dd/MM/yyyy HH:mm") : "-",
          "Số khách": item.passengersArrived ?? item.seatCount ?? "-",
          "Trạng thái ký lệnh vận chuyển": item.permitStatus === "approved" ? "Đã ký" : item.permitStatus === "rejected" ? "Từ chối" : "-",
          "Trạng thái đồng bộ dữ liệu": String(itemMetadata.syncStatus || (itemMetadata.syncTime ? "Đã đồng bộ" : "Chưa đồng bộ")),
        };
      });

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Báo cáo xe trả khách");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 15 },  // Biển số khi vào
        { wch: 18 },  // Mã lệnh trả khách
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 15 },  // Loại tuyến
        { wch: 25 },  // Người xác nhận trả khách
        { wch: 20 },  // Thời gian trả khách
        { wch: 10 },  // Số khách
        { wch: 25 },  // Trạng thái ký lệnh vận chuyển
        { wch: 20 },  // Trạng thái đồng bộ dữ liệu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-xe-tra-khach_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            {returnTo && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => navigate(returnTo)}
                className="gap-2"
              >
                <ArrowLeft className="h-4 w-4" />
                Quay lại
              </Button>
            )}
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredRecords.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadRecords}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số xe, luồng tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Chọn doanh nghiệp vận tải</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <SortableTableHead
                    sortKey="vehiclePlateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Biển số
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="vehiclePlateNumber"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Biển số khi vào
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="transportOrderCode"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Mã lệnh trả khách
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="operatorName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Tên đơn vị
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeName"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Tên luồng tuyến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="routeType"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Loại tuyến
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="passengerDropBy"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Người xác nhận trả khách
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="passengerDropTime"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Thời gian trả khách
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="passengersArrived"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Số khách
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="permitStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Trạng thái ký lệnh vận chuyển
                  </SortableTableHead>
                  <SortableTableHead
                    sortKey="syncStatus"
                    currentSortColumn={sortColumn}
                    sortDirection={sortDirection}
                    onSort={handleSort}
                  >
                    Trạng thái đồng bộ dữ liệu
                  </SortableTableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredRecords.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={11} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredRecords.map((item) => (
                      <TableRow key={item.id}>
                        <TableCell className="font-semibold">
                          {item.vehiclePlateNumber || "-"}
                        </TableCell>
                        <TableCell>
                          {item.vehiclePlateNumber || "-"}
                        </TableCell>
                        <TableCell>
                          {item.transportOrderCode || item.id.substring(0, 8) || "-"}
                        </TableCell>
                        <TableCell>
                          {item.vehicle?.operator?.name || "-"}
                        </TableCell>
                        <TableCell>{item.routeName || "-"}</TableCell>
                        <TableCell>
                          {item.route?.routeType || "-"}
                        </TableCell>
                        <TableCell>{item.passengerDropBy || "-"}</TableCell>
                        <TableCell>{renderTime(item.passengerDropTime)}</TableCell>
                        <TableCell>
                          {item.passengersArrived ?? item.seatCount ?? "-"}
                        </TableCell>
                        <TableCell>
                          {item.permitStatus === "approved" ? "Đã ký" :
                           item.permitStatus === "rejected" ? "Từ chối" : "-"}
                        </TableCell>
                        <TableCell>
                          {(() => {
                            const meta = (item.metadata || {}) as Record<string, unknown>;
                            return String(meta.syncStatus || (meta.syncTime ? "Đã đồng bộ" : "Chưa đồng bộ"));
                          })()}
                        </TableCell>
                      </TableRow>
                    ))}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell>
                        {`Tổng: ${filteredRecords.length} xe`}
                      </TableCell>
                      <TableCell colSpan={7}></TableCell>
                      <TableCell>
                        {totalPassengers > 0 ? totalPassengers : "-"}
                      </TableCell>
                      <TableCell colSpan={2}></TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/LienHe.tsx">
import { useState } from "react"
import { toast } from "react-toastify"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { Card, CardContent } from "@/components/ui/card"
import { Phone, Mail, Clock, MapPin } from "lucide-react"

export default function LienHe() {
    const [formData, setFormData] = useState({
        name: "",
        phone: "",
        email: "",
        company: "",
        subject: "",
        question: "",
    })

    const handleChange = (
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value,
        })
    }

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault()
        // TODO: Implement actual form submission to backend
        toast.success("Cảm ơn bạn đã liên hệ! Chúng tôi sẽ phản hồi sớm nhất có thể.")
        setFormData({
            name: "",
            phone: "",
            email: "",
            company: "",
            subject: "",
            question: "",
        })
    }

    return (
        <div className="w-full">
            {/* Banner Section */}
            <section className="relative bg-gradient-to-br from-teal-600 via-teal-700 to-teal-800 py-8 lg:py-12 overflow-hidden">
                <div className="absolute inset-0 bg-black/20"></div>
                <div className="container mx-auto px-4 relative z-10">
                    <h1 className="text-4xl lg:text-5xl font-bold text-white text-center">
                        Liên hệ
                    </h1>
                </div>
            </section>

            {/* Main Content */}
            <section className="py-12 lg:py-16 bg-gray-50">
                <div className="container mx-auto px-4">
                    <div className="grid lg:grid-cols-2 gap-8 lg:gap-12">
                        {/* Left Column - Contact Form */}
                        <div>
                            <Card className="border-2 border-gray-200 shadow-lg">
                                <CardContent className="p-6 lg:p-8">
                                    <p className="text-gray-700 mb-6 leading-relaxed">
                                        Hãy liên hệ khi bạn gặp bất cứ vấn đề nào liên quan đến công ty hoặc dịch vụ của chúng tôi. Chúng tôi sẽ cố gắng phản hồi trong thời gian sớm nhất.
                                    </p>

                                    <form onSubmit={handleSubmit} className="space-y-4">
                                        <div>
                                            <Label htmlFor="name" className="text-gray-900">
                                                Tên của bạn <span className="text-red-500">*</span>
                                            </Label>
                                            <Input
                                                id="name"
                                                name="name"
                                                type="text"
                                                required
                                                value={formData.name}
                                                onChange={handleChange}
                                                className="mt-1"
                                                placeholder="Nhập tên của bạn"
                                            />
                                        </div>

                                        <div>
                                            <Label htmlFor="phone" className="text-gray-900">
                                                Số điện thoại
                                            </Label>
                                            <Input
                                                id="phone"
                                                name="phone"
                                                type="tel"
                                                value={formData.phone}
                                                onChange={handleChange}
                                                className="mt-1"
                                                placeholder="Nhập số điện thoại"
                                            />
                                        </div>

                                        <div>
                                            <Label htmlFor="email" className="text-gray-900">
                                                Email của bạn <span className="text-red-500">*</span>
                                            </Label>
                                            <Input
                                                id="email"
                                                name="email"
                                                type="email"
                                                required
                                                value={formData.email}
                                                onChange={handleChange}
                                                className="mt-1"
                                                placeholder="Nhập email của bạn"
                                            />
                                        </div>

                                        <div>
                                            <Label htmlFor="company" className="text-gray-900">
                                                Công ty của bạn
                                            </Label>
                                            <Input
                                                id="company"
                                                name="company"
                                                type="text"
                                                value={formData.company}
                                                onChange={handleChange}
                                                className="mt-1"
                                                placeholder="Nhập tên công ty"
                                            />
                                        </div>

                                        <div>
                                            <Label htmlFor="subject" className="text-gray-900">
                                                Tiêu đề <span className="text-red-500">*</span>
                                            </Label>
                                            <Input
                                                id="subject"
                                                name="subject"
                                                type="text"
                                                required
                                                value={formData.subject}
                                                onChange={handleChange}
                                                className="mt-1"
                                                placeholder="Nhập tiêu đề"
                                            />
                                        </div>

                                        <div>
                                            <Label htmlFor="question" className="text-gray-900">
                                                Câu hỏi
                                            </Label>
                                            <Textarea
                                                id="question"
                                                name="question"
                                                value={formData.question}
                                                onChange={handleChange}
                                                className="mt-1 min-h-[120px]"
                                                placeholder="Nhập câu hỏi hoặc nội dung bạn muốn gửi"
                                            />
                                        </div>

                                        <Button
                                            type="submit"
                                            className="w-full bg-teal-600 hover:bg-teal-700 text-white"
                                            size="lg"
                                        >
                                            Gửi
                                        </Button>
                                    </form>
                                </CardContent>
                            </Card>
                        </div>

                        {/* Right Column - Contact Information */}
                        <div>
                            <Card className="border-2 border-gray-200 shadow-lg">
                                <CardContent className="p-6 lg:p-8">
                                    <h2 className="text-2xl font-bold text-gray-900 mb-6">
                                        Thông tin liên hệ:
                                    </h2>

                                    <div className="space-y-6">
                                        {/* Head Office */}
                                        <div>
                                            <div className="flex items-start gap-3 mb-2">
                                                <MapPin className="h-5 w-5 text-teal-600 mt-1 flex-shrink-0" />
                                                <div>
                                                    <h3 className="font-bold text-gray-900 mb-1">
                                                        Trụ sở chính
                                                    </h3>
                                                    <p className="text-gray-700 leading-relaxed">
                                                        Tổ 9, phường Tân Lập, TP Thái Nguyên
                                                    </p>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Central Office */}
                                        <div>
                                            <div className="flex items-start gap-3 mb-2">
                                                <MapPin className="h-5 w-5 text-teal-600 mt-1 flex-shrink-0" />
                                                <div>
                                                    <h3 className="font-bold text-gray-900 mb-1">
                                                        Văn phòng Miền Trung
                                                    </h3>
                                                    <p className="text-gray-700 leading-relaxed">
                                                        Tầng 2, Bến xe Trung Tâm Đà Nẵng, Đường Tôn Đức Thắng, P. Hòa Minh, Q. Liên Chiểu, Thành phố Đà Nẵng.
                                                    </p>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Southern Office */}
                                        <div>
                                            <div className="flex items-start gap-3 mb-2">
                                                <MapPin className="h-5 w-5 text-teal-600 mt-1 flex-shrink-0" />
                                                <div>
                                                    <h3 className="font-bold text-gray-900 mb-1">
                                                        Văn phòng Miền Nam
                                                    </h3>
                                                    <p className="text-gray-700 leading-relaxed">
                                                        Số 43, Đường Nguyễn Trọng Trí, Phường An Lạc A, Quận Bình Tân - TP Hồ Chí Minh
                                                    </p>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Contact Details */}
                                        <div className="pt-4 border-t border-gray-200 space-y-4">
                                            <div className="flex items-center gap-3">
                                                <Phone className="h-5 w-5 text-teal-600 flex-shrink-0" />
                                                <span className="text-gray-700">02083.607.668</span>
                                            </div>

                                            <div className="flex items-center gap-3">
                                                <Mail className="h-5 w-5 text-teal-600 flex-shrink-0" />
                                                <a
                                                    href="mailto:abctn@gmail.com"
                                                    className="text-teal-600 hover:text-teal-700 hover:underline"
                                                >
                                                    abctn@gmail.com
                                                </a>
                                            </div>

                                            <div className="flex items-center gap-3">
                                                <span className="text-2xl font-bold text-teal-600">
                                                    Hotline: 1900.4751
                                                </span>
                                            </div>
                                        </div>

                                        {/* Support Hours */}
                                        <div className="pt-4 border-t border-gray-200">
                                            <div className="flex items-start gap-3">
                                                <Clock className="h-5 w-5 text-teal-600 mt-1 flex-shrink-0" />
                                                <div>
                                                    <h3 className="font-bold text-gray-900 mb-2">
                                                        Thời gian hỗ trợ sản phẩm hàng ngày
                                                    </h3>
                                                    <div className="space-y-1 text-gray-700">
                                                        <p>Bắt đầu: 03:00</p>
                                                        <p>Kết thúc: 22:00</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </CardContent>
                            </Card>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    )
}
</file>

<file path="client/src/pages/QuanLyBenDen.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Search, Edit, Eye, Trash2, MapPin } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { locationService } from "@/services/location.service"
import type { Location, LocationInput } from "@/types"
import { useUIStore } from "@/store/ui.store"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { STATION_TYPES } from "@/constants/vietnam-locations"
import { provinceService, type Province, type District, type Ward } from "@/services/province.service"

const locationSchema = z.object({
  code: z.string().min(1, "Mã bến là bắt buộc"),
  stationType: z.string().min(1, "Loại bến là bắt buộc"),
  name: z.string().min(1, "Tên bến là bắt buộc"),
  phone: z.string().optional(),
  email: z.string().email("Email không hợp lệ").optional().or(z.literal("")),
  province: z.string().min(1, "Tỉnh/Thành phố là bắt buộc"),
  district: z.string().min(1, "Quận/Huyện/Thị xã là bắt buộc"),
  ward: z.string().optional(), // Phường/Xã (chỉ dùng cho v1)
  address: z.string().optional(),
  isActive: z.boolean().default(true),
})

type LocationFormData = z.infer<typeof locationSchema>

export default function QuanLyBenDen() {
  const [locations, setLocations] = useState<Location[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create")
  const setTitle = useUIStore((state) => state.setTitle)

  const [useApiV2, setUseApiV2] = useState(false) // false = v1 (trước sáp nhập), true = v2 (sau sáp nhập)
  const [provinces, setProvinces] = useState<Province[]>([])
  const [districts, setDistricts] = useState<District[]>([])
  const [wards, setWards] = useState<Ward[]>([]) // Phường/Xã cho v1
  const [isLoadingProvinces, setIsLoadingProvinces] = useState(false)
  const [isLoadingDistricts, setIsLoadingDistricts] = useState(false)
  const [isLoadingWards, setIsLoadingWards] = useState(false)
  const [selectedProvinceCode, setSelectedProvinceCode] = useState<string | null>(null)
  const [selectedDistrictCode, setSelectedDistrictCode] = useState<string | null>(null)

  const {
    register,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<LocationFormData>({
    resolver: zodResolver(locationSchema),
    defaultValues: {
      isActive: true,
    },
  })

  const watchProvince = watch("province")
  const watchDistrict = watch("district")

  // Load provinces từ API
  const loadProvinces = async (apiVersion: boolean) => {
    setIsLoadingProvinces(true)
    try {
      const data = apiVersion
        ? await provinceService.getProvincesV2()
        : await provinceService.getProvincesV1()
      setProvinces(data)
    } catch (error) {
      console.error("Failed to load provinces:", error)
      toast.error("Không thể tải danh sách tỉnh thành. Vui lòng thử lại sau.")
    } finally {
      setIsLoadingProvinces(false)
    }
  }

  // Load districts khi chọn province
  const loadDistricts = async (provinceCode: string, apiVersion: boolean): Promise<District[]> => {
    if (!provinceCode) {
      setDistricts([])
      return []
    }

    setIsLoadingDistricts(true)
    try {
      let result: District[] = []
      if (apiVersion) {
        // V2: Lấy phường/xã trực tiếp từ province (không có cấp quận/huyện)
        const wards = await provinceService.getWardsByProvinceV2(provinceCode)
        // Convert wards to districts format for display
        result = wards.map(w => ({ code: w.code, name: w.name }))
        setDistricts(result)
      } else {
        // V1: Lấy quận/huyện từ province
        result = await provinceService.getDistrictsByProvinceV1(provinceCode)
        setDistricts(result)
      }
      return result
    } catch (error) {
      console.error("Failed to load districts:", error)
      toast.error("Không thể tải danh sách quận/huyện. Vui lòng thử lại sau.")
      setDistricts([])
      return []
    } finally {
      setIsLoadingDistricts(false)
    }
  }

  // Load wards khi chọn district (chỉ cho v1)
  // Sử dụng API từ addresskit.cas.so để lấy dữ liệu chính xác từ Cục Thống Kê
  const loadWards = async (provinceCode: string, districtCode: string) => {
    if (!provinceCode || !districtCode) {
      setWards([])
      return
    }

    setIsLoadingWards(true)
    try {
      const data = await provinceService.getWardsByDistrictV1(provinceCode, districtCode)
      setWards(data)
    } catch (error) {
      console.error("Failed to load wards:", error)
      toast.error("Không thể tải danh sách phường/xã. Vui lòng thử lại sau.")
      setWards([])
    } finally {
      setIsLoadingWards(false)
    }
  }

  useEffect(() => {
    setTitle("Quản lý bến đến")
    loadLocations()
    loadProvinces(useApiV2)
  }, [setTitle])

  // Reload provinces khi đổi API version
  useEffect(() => {
    loadProvinces(useApiV2)
    setDistricts([])
    setWards([])
    setValue("province", "")
    setValue("district", "")
    setValue("ward", "")
    setSelectedProvinceCode(null)
    setSelectedDistrictCode(null)
  }, [useApiV2, setValue])

  useEffect(() => {
    if (selectedLocation && (viewMode === "edit" || viewMode === "view")) {
      // Parse address theo format: "Địa chỉ cụ thể, phường xã, quận huyện, tỉnh thành phố"
      const addressValue = selectedLocation.address || ""
      const addressParts = addressValue.split(",").map(s => s.trim()).filter(Boolean)
      
      let addressDetail = ""
      let wardName = ""
      let districtName = ""
      let provinceName = ""
      
      if (addressParts.length > 0) {
        // Lấy tỉnh (phần cuối)
        if (addressParts.length >= 1) {
          provinceName = addressParts[addressParts.length - 1]
        }
        
        // Với v2: chỉ có 2 phần (phường/xã, tỉnh) hoặc 3 phần (địa chỉ, phường/xã, tỉnh)
        // Với v1: có 3 phần (phường/xã, quận/huyện, tỉnh) hoặc 4 phần (địa chỉ, phường/xã, quận/huyện, tỉnh)
        if (useApiV2) {
          if (addressParts.length >= 2) {
            wardName = addressParts[addressParts.length - 2] // Phường/Xã
            if (addressParts.length >= 3) {
              addressDetail = addressParts.slice(0, -2).join(", ") // Địa chỉ cụ thể
            }
          }
        } else {
          if (addressParts.length >= 3) {
            wardName = addressParts[addressParts.length - 3] // Phường/Xã
            districtName = addressParts[addressParts.length - 2] // Quận/Huyện
            if (addressParts.length >= 4) {
              addressDetail = addressParts.slice(0, -3).join(", ") // Địa chỉ cụ thể
            }
          } else if (addressParts.length === 2) {
            // Có thể chỉ có quận/huyện và tỉnh (không có phường/xã)
            districtName = addressParts[addressParts.length - 2]
          }
        }
      }
      
      // Tìm province code từ name
      const province = provinces.find(p => p.name === provinceName)
      if (province) {
        setSelectedProvinceCode(province.code)
        loadDistricts(province.code, useApiV2).then((loadedDistricts) => {
          if (useApiV2) {
            // V2: wardName là phường/xã
            reset({
              code: selectedLocation.code,
              stationType: selectedLocation.stationType || "",
              name: selectedLocation.name,
              phone: selectedLocation.phone || "",
              email: selectedLocation.email || "",
              province: provinceName,
              district: wardName, // V2: district là phường/xã
              ward: "",
              address: addressDetail,
              isActive: selectedLocation.isActive,
            })
          } else {
            // V1: tìm district và load wards
            const district = loadedDistricts.find(d => d.name === districtName)
            if (district) {
              setSelectedDistrictCode(district.code)
              loadWards(province.code, district.code).then(() => {
                reset({
                  code: selectedLocation.code,
                  stationType: selectedLocation.stationType || "",
                  name: selectedLocation.name,
                  phone: selectedLocation.phone || "",
                  email: selectedLocation.email || "",
                  province: provinceName,
                  district: districtName,
                  ward: wardName,
                  address: addressDetail,
                  isActive: selectedLocation.isActive,
                })
              })
              return
            }
            reset({
              code: selectedLocation.code,
              stationType: selectedLocation.stationType || "",
              name: selectedLocation.name,
              phone: selectedLocation.phone || "",
              email: selectedLocation.email || "",
              province: provinceName,
              district: districtName,
              ward: wardName,
              address: addressDetail,
              isActive: selectedLocation.isActive,
            })
          }
        })
      } else {
        reset({
          code: selectedLocation.code,
          stationType: selectedLocation.stationType || "",
          name: selectedLocation.name,
          phone: selectedLocation.phone || "",
          email: selectedLocation.email || "",
          province: provinceName,
          district: useApiV2 ? wardName : districtName,
          ward: useApiV2 ? "" : wardName,
          address: addressDetail,
          isActive: selectedLocation.isActive,
        })
      }
    } else {
      setDistricts([])
      setWards([])
      setSelectedProvinceCode(null)
      setSelectedDistrictCode(null)
      reset({
        code: "",
        stationType: "",
        name: "",
        phone: "",
        email: "",
        province: "",
        district: "",
        ward: "",
        address: "",
        isActive: true,
      })
    }
  }, [selectedLocation, viewMode, reset, provinces, useApiV2])

  // Khi chọn province từ dropdown
  useEffect(() => {
    if (watchProvince) {
      const province = provinces.find(p => p.name === watchProvince)
      if (province && province.code !== selectedProvinceCode) {
        setSelectedProvinceCode(province.code)
        loadDistricts(province.code, useApiV2)
        // Reset district and ward when province changes
        if (viewMode === "create") {
          setValue("district", "")
          setValue("ward", "")
        }
        setWards([])
        setSelectedDistrictCode(null)
      }
    } else {
      setDistricts([])
      setWards([])
      setSelectedProvinceCode(null)
      setSelectedDistrictCode(null)
    }
  }, [watchProvince, provinces, selectedProvinceCode, viewMode, selectedLocation, setValue, useApiV2])

  // Khi chọn district từ dropdown (chỉ cho v1)
  useEffect(() => {
    if (!useApiV2 && watchDistrict && selectedProvinceCode) {
      const district = districts.find(d => d.name === watchDistrict)
      if (district && district.code !== selectedDistrictCode) {
        setSelectedDistrictCode(district.code)
        loadWards(selectedProvinceCode, district.code)
        // Reset ward when district changes
        if (viewMode === "create") {
          setValue("ward", "")
        }
      }
    } else if (useApiV2) {
      setWards([])
      setSelectedDistrictCode(null)
    }
  }, [watchDistrict, selectedProvinceCode, districts, selectedDistrictCode, useApiV2, viewMode, selectedLocation, setValue])

  const loadLocations = async () => {
    setIsLoading(true)
    try {
      const data = await locationService.getAll()
      setLocations(data)
    } catch (error) {
      console.error("Failed to load locations:", error)
      toast.error("Không thể tải danh sách bến đến. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  const filteredLocations = locations.filter((location) => {
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      return (
        location.name.toLowerCase().includes(query) ||
        location.code.toLowerCase().includes(query) ||
        (location.address || "").toLowerCase().includes(query) ||
        (location.email || "").toLowerCase().includes(query)
      )
    }
    return true
  })

  const handleCreate = () => {
    setSelectedLocation(null)
    setViewMode("create")
    setDistricts([])
    setWards([])
    setSelectedProvinceCode(null)
    setSelectedDistrictCode(null)
    setDialogOpen(true)
  }

  const handleEdit = (location: Location) => {
    setSelectedLocation(location)
    setViewMode("edit")
    setDialogOpen(true)
  }

  const handleView = (location: Location) => {
    setSelectedLocation(location)
    setViewMode("view")
    setDialogOpen(true)
  }

  const handleDialogClose = (open: boolean) => {
    setDialogOpen(open)
    if (!open) {
      setSelectedLocation(null)
      setDistricts([])
      setWards([])
      setSelectedProvinceCode(null)
      setSelectedDistrictCode(null)
    }
  }

  const handleDelete = async (id: string) => {
    if (window.confirm("Bạn có chắc chắn muốn xóa bến đến này?")) {
      try {
        await locationService.delete(id)
        toast.success("Xóa bến đến thành công")
        loadLocations()
      } catch (error) {
        console.error("Failed to delete location:", error)
        toast.error("Không thể xóa bến đến. Có thể bến này đang được sử dụng.")
      }
    }
  }

  const onSubmit = async (data: LocationFormData) => {
    try {
      // Ghép tất cả thành address theo format: "Địa chỉ cụ thể, phường xã, quận huyện, tỉnh thành phố"
      const addressParts: string[] = []
      
      if (data.address) {
        addressParts.push(data.address)
      }
      
      if (useApiV2) {
        // V2: district đã là phường/xã
        if (data.district) {
          addressParts.push(data.district)
        }
        if (data.province) {
          addressParts.push(data.province)
        }
      } else {
        // V1: có ward (phường/xã), district (quận/huyện), province (tỉnh)
        if (data.ward) {
          addressParts.push(data.ward)
        }
        if (data.district) {
          addressParts.push(data.district)
        }
        if (data.province) {
          addressParts.push(data.province)
        }
      }
      
      const fullAddress = addressParts.length > 0 ? addressParts.join(", ") : undefined

      const locationData: LocationInput = {
        code: data.code,
        name: data.name,
        stationType: data.stationType || undefined,
        phone: data.phone || undefined,
        email: data.email || undefined,
        address: fullAddress,
      }

      if (viewMode === "create") {
        await locationService.create(locationData)
        toast.success("Thêm bến đến thành công")
      } else if (viewMode === "edit" && selectedLocation) {
        await locationService.update(selectedLocation.id, locationData)
        toast.success("Cập nhật bến đến thành công")
      }
      setDialogOpen(false)
      loadLocations()
    } catch (error: any) {
      console.error("Failed to save location:", error)
      toast.error(
        error.response?.data?.message ||
          `Không thể ${viewMode === "create" ? "thêm" : "cập nhật"} bến đến. Vui lòng thử lại.`
      )
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-end">
        <Button onClick={handleCreate}>
          <Plus className="mr-2 h-4 w-4" />
          Thêm bến đến
        </Button>
      </div>

      {/* Search */}
      <Card>
        <CardContent className="pt-6">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
            <Input
              placeholder="Tìm kiếm theo mã, tên bến xe, địa chỉ, email..."
              className="pl-10"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="text-center">Mã bến xe</TableHead>
              <TableHead className="text-center">Tên bến xe</TableHead>
              <TableHead className="text-center">Tỉnh thành</TableHead>
              <TableHead className="text-center">Loại bến</TableHead>
              <TableHead className="text-center">Địa chỉ</TableHead>
              <TableHead className="text-center">Email</TableHead>
              <TableHead className="text-center">Trạng thái</TableHead>
              <TableHead className="text-center">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={8} className="text-center py-8">
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : filteredLocations.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="text-center py-8 text-gray-500">
                  Không có dữ liệu
                </TableCell>
              </TableRow>
            ) : (
              filteredLocations.map((location) => {
                // Parse tỉnh từ address (phần cuối cùng)
                const getProvinceFromAddress = (address?: string): string => {
                  if (!address) return "N/A"
                  const parts = address.split(",").map(s => s.trim()).filter(Boolean)
                  return parts.length > 0 ? parts[parts.length - 1] : "N/A"
                }

                return (
                  <TableRow key={location.id}>
                    <TableCell className="font-medium text-center">
                      {location.code}
                    </TableCell>
                    <TableCell className="text-center">
                      <div className="flex items-center justify-center">
                        <MapPin className="h-4 w-4 mr-2 text-gray-400" />
                        {location.name}
                      </div>
                    </TableCell>
                    <TableCell className="text-center">
                      {getProvinceFromAddress(location.address)}
                    </TableCell>
                    <TableCell className="text-center">
                      {location.stationType || "N/A"}
                    </TableCell>
                    <TableCell className="text-center">
                      {location.address || "N/A"}
                    </TableCell>
                    <TableCell className="text-center">
                      {location.email || "N/A"}
                    </TableCell>
                    <TableCell className="text-center">
                      <StatusBadge
                        status={location.isActive ? "active" : "inactive"}
                      />
                    </TableCell>
                    <TableCell className="text-center">
                      <div className="flex items-center justify-center gap-2">
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleView(location)}
                          aria-label="Xem"
                        >
                          <Eye className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleEdit(location)}
                          aria-label="Sửa"
                        >
                          <Edit className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleDelete(location.id)}
                          aria-label="Xóa"
                        >
                          <Trash2 className="h-4 w-4 text-red-600" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                )
              })
            )}
          </TableBody>
        </Table>
      </Card>

      {/* Dialog */}
      <Dialog open={dialogOpen} onOpenChange={handleDialogClose}>
        <DialogContent className="w-[95vw] sm:w-[90vw] md:w-[85vw] lg:w-[800px] max-w-4xl max-h-[95vh] sm:max-h-[90vh] overflow-y-auto p-4 sm:p-6">
          <DialogHeader>
            <DialogTitle className="text-xl sm:text-2xl">
              {viewMode === "create" && "Thêm bến đến mới"}
              {viewMode === "edit" && "Sửa thông tin bến đến"}
              {viewMode === "view" && "Chi tiết bến đến"}
            </DialogTitle>
          </DialogHeader>
          <form onSubmit={handleSubmit(onSubmit)} className="mt-4 space-y-4 sm:space-y-6">
            {/* Thông tin chung */}
            <div className="space-y-3 sm:space-y-4">
              <h3 className="text-base sm:text-lg font-semibold text-gray-800 border-b pb-2">
                Thông tin chung
              </h3>
              
              <div>
                <Label htmlFor="code">
                  Mã bến <span className="text-red-500">(*)</span>
                </Label>
                <Input
                  id="code"
                  placeholder="Mã bến"
                  {...register("code")}
                  disabled={viewMode === "view"}
                  className={errors.code ? "border-red-500" : ""}
                />
                {errors.code && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.code.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="stationType">
                  Loại bến <span className="text-red-500">(*)</span>
                </Label>
                <Select
                  id="stationType"
                  {...register("stationType")}
                  disabled={viewMode === "view"}
                  className={errors.stationType ? "border-red-500" : ""}
                >
                  <option value="">Loại bến</option>
                  {STATION_TYPES.map((type) => (
                    <option key={type} value={type}>
                      {type}
                    </option>
                  ))}
                </Select>
                {errors.stationType && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.stationType.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="name">
                  Tên bến <span className="text-red-500">(*)</span>
                </Label>
                <Input
                  id="name"
                  placeholder="Tên bến"
                  {...register("name")}
                  disabled={viewMode === "view"}
                  className={errors.name ? "border-red-500" : ""}
                />
                {errors.name && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.name.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="phone">Số điện thoại</Label>
                <Input
                  id="phone"
                  placeholder="Số điện thoại"
                  {...register("phone")}
                  disabled={viewMode === "view"}
                />
              </div>

              <div>
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  placeholder="Email"
                  {...register("email")}
                  disabled={viewMode === "view"}
                  className={errors.email ? "border-red-500" : ""}
                />
                {errors.email && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.email.message}
                  </p>
                )}
              </div>
            </div>

            {/* Thông tin địa chỉ bến xe */}
            <div className="space-y-3 sm:space-y-4">
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 border-b pb-2">
                <h3 className="text-base sm:text-lg font-semibold text-gray-800">
                  Thông tin địa chỉ bến xe
                </h3>
                {/* Checkbox chọn API version */}
                {viewMode !== "view" && (
                  <div className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      id="useApiV2"
                      checked={useApiV2}
                      onChange={(e) => setUseApiV2(e.target.checked)}
                      className="h-4 w-4"
                    />
                    <Label htmlFor="useApiV2" className="cursor-pointer text-xs sm:text-sm">
                      Sử dụng dữ liệu sau sáp nhập.
                    </Label>
                  </div>
                )}
              </div>

              {useApiV2 ? (
                // V2: 2 cột (Tỉnh và Phường/Xã)
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                  <div>
                    <Label htmlFor="province">
                      Tỉnh/Thành phố <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="province"
                      {...register("province")}
                      disabled={viewMode === "view" || isLoadingProvinces}
                      className={errors.province ? "border-red-500" : ""}
                    >
                      <option value="">
                        {isLoadingProvinces ? "Đang tải..." : "Tỉnh/Thành phố"}
                      </option>
                      {provinces.map((province) => (
                        <option key={province.code} value={province.name}>
                          {province.name}
                        </option>
                      ))}
                    </Select>
                    {errors.province && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.province.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="district">
                      Phường/Xã <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="district"
                      {...register("district")}
                      disabled={viewMode === "view" || !watchProvince || isLoadingDistricts}
                      className={errors.district ? "border-red-500" : ""}
                    >
                      <option value="">
                        {isLoadingDistricts ? "Đang tải..." : "Phường/Xã"}
                      </option>
                      {districts.map((district) => (
                        <option key={district.code} value={district.name}>
                          {district.name}
                        </option>
                      ))}
                    </Select>
                    {errors.district && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.district.message}
                      </p>
                    )}
                    {watchProvince && !isLoadingDistricts && districts.length === 0 && (
                      <p className="text-sm text-gray-500 mt-1">
                        Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                      </p>
                    )}
                  </div>
                </div>
              ) : (
                // V1: 3 cột (Tỉnh, Quận/Huyện, Phường/Xã)
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                  <div>
                    <Label htmlFor="province">
                      Tỉnh/Thành phố <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="province"
                      {...register("province")}
                      disabled={viewMode === "view" || isLoadingProvinces}
                      className={errors.province ? "border-red-500" : ""}
                    >
                      <option value="">
                        {isLoadingProvinces ? "Đang tải..." : "Tỉnh/Thành phố"}
                      </option>
                      {provinces.map((province) => (
                        <option key={province.code} value={province.name}>
                          {province.name}
                        </option>
                      ))}
                    </Select>
                    {errors.province && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.province.message}
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="district">
                      Quận/Huyện/Thị xã <span className="text-red-500">(*)</span>
                    </Label>
                    <Select
                      id="district"
                      {...register("district")}
                      disabled={viewMode === "view" || !watchProvince || isLoadingDistricts}
                      className={errors.district ? "border-red-500" : ""}
                    >
                      <option value="">
                        {isLoadingDistricts ? "Đang tải..." : "Quận/Huyện/Thị xã"}
                      </option>
                      {districts.map((district) => (
                        <option key={district.code} value={district.name}>
                          {district.name}
                        </option>
                      ))}
                    </Select>
                    {errors.district && (
                      <p className="text-sm text-red-500 mt-1">
                        {errors.district.message}
                      </p>
                    )}
                    {watchProvince && !isLoadingDistricts && districts.length === 0 && (
                      <p className="text-sm text-gray-500 mt-1">
                        Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="ward">Phường/Xã</Label>
                    <Select
                      id="ward"
                      {...register("ward")}
                      disabled={viewMode === "view" || !watchDistrict || isLoadingWards}
                    >
                      <option value="">
                        {isLoadingWards ? "Đang tải..." : "Phường/Xã"}
                      </option>
                      {wards.map((ward) => (
                        <option key={ward.code} value={ward.name}>
                          {ward.name}
                        </option>
                      ))}
                    </Select>
                    {watchDistrict && !isLoadingWards && wards.length === 0 && (
                      <p className="text-sm text-gray-500 mt-1">
                        Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                      </p>
                    )}
                  </div>
                </div>
              )}

              <div>
                <Label htmlFor="address">Địa chỉ cụ thể</Label>
                <Input
                  id="address"
                  placeholder="Địa chỉ cụ thể"
                  {...register("address")}
                  disabled={viewMode === "view"}
                />
              </div>
            </div>

            {viewMode !== "view" && (
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="isActive"
                  {...register("isActive")}
                  className="h-4 w-4"
                />
                <Label htmlFor="isActive" className="cursor-pointer">
                  Kích hoạt
                </Label>
              </div>
            )}

            {viewMode === "view" && (
              <div>
                <Label>Trạng thái</Label>
                <div className="mt-2">
                  <StatusBadge
                    status={selectedLocation?.isActive ? "active" : "inactive"}
                  />
                </div>
              </div>
            )}

            <div className="flex flex-col-reverse sm:flex-row justify-end gap-2 sm:gap-2 pt-4 border-t">
              <Button
                type="button"
                variant="outline"
                onClick={() => setDialogOpen(false)}
                className="w-full sm:w-auto"
              >
                {viewMode === "view" ? "Đóng" : "Hủy"}
              </Button>
              {viewMode !== "view" && (
                <Button type="submit" className="w-full sm:w-auto">
                  {viewMode === "create" ? "Thêm" : "Cập nhật"}
                </Button>
              )}
            </div>
          </form>
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="client/src/pages/QuanLyDichVu.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Plus, Search, Edit, Eye, Trash2, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { StatusBadge } from "@/components/layout/StatusBadge"
import { ServiceDialog } from "@/components/service/ServiceDialog"
import { serviceService } from "@/services/service.service"
import type { Service } from "@/types"
import { useUIStore } from "@/store/ui.store"

export default function QuanLyDichVu() {
  const [services, setServices] = useState<Service[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [filterStatus, setFilterStatus] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedService, setSelectedService] = useState<Service | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create")
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý dịch vụ")
    loadServices()
  }, [setTitle])

  const loadServices = async () => {
    setIsLoading(true)
    try {
      const data = await serviceService.getAll()
      setServices(data)
    } catch (error) {
      console.error("Failed to load services:", error)
      toast.error("Không thể tải danh sách dịch vụ. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  const filteredServices = services.filter((service) => {
    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      const matchesSearch =
        service.code.toLowerCase().includes(query) ||
        service.name.toLowerCase().includes(query) ||
        service.unit.toLowerCase().includes(query) ||
        service.materialType.toLowerCase().includes(query)
      if (!matchesSearch) return false
    }

    // Status filter
    if (filterStatus) {
      const isActive = filterStatus === "active"
      if (service.isActive !== isActive) return false
    }

    return true
  })

  const handleCreate = () => {
    setSelectedService(null)
    setViewMode("create")
    setDialogOpen(true)
  }

  const handleEdit = async (service: Service) => {
    try {
      // Load đầy đủ thông tin dịch vụ bao gồm biểu thức đã chọn
      const fullService = await serviceService.getById(service.id)
      setSelectedService(fullService)
      setViewMode("edit")
      setDialogOpen(true)
    } catch (error) {
      console.error("Failed to load service details:", error)
      toast.error("Không thể tải thông tin dịch vụ. Vui lòng thử lại sau.")
    }
  }

  const handleView = async (service: Service) => {
    try {
      // Load đầy đủ thông tin dịch vụ bao gồm biểu thức đã chọn
      const fullService = await serviceService.getById(service.id)
      setSelectedService(fullService)
      setViewMode("view")
      setDialogOpen(true)
    } catch (error) {
      console.error("Failed to load service details:", error)
      toast.error("Không thể tải thông tin dịch vụ. Vui lòng thử lại sau.")
    }
  }

  const handleDelete = async (id: string) => {
    if (window.confirm("Bạn có chắc chắn muốn xóa dịch vụ này?")) {
      try {
        await serviceService.delete(id)
        toast.success("Xóa dịch vụ thành công")
        loadServices()
      } catch (error: any) {
        console.error("Failed to delete service:", error)
        toast.error(error.response?.data?.error || "Không thể xóa dịch vụ. Vui lòng thử lại sau.")
      }
    }
  }

  const handleToggleStatus = async (service: Service) => {
    try {
      await serviceService.update(service.id, { isActive: !service.isActive } as any)
      toast.success(`Đã ${service.isActive ? "vô hiệu hóa" : "kích hoạt"} dịch vụ`)
      loadServices()
    } catch (error) {
      console.error("Failed to toggle service status:", error)
      toast.error("Không thể thay đổi trạng thái dịch vụ")
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Quản lý dịch vụ</h1>
          <p className="text-gray-600 mt-1">Quản lý thông tin dịch vụ</p>
        </div>
        <Button onClick={handleCreate}>
          <Plus className="mr-2 h-4 w-4" />
          Thêm dịch vụ
        </Button>
      </div>

      {/* Search and Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
              <Input
                placeholder="Tìm kiếm theo mã dịch vụ, tên dịch vụ, đơn vị tính..."
                className="pl-10"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="space-y-2">
                <Label htmlFor="filterStatus" className="text-sm font-medium">
                  Lọc theo trạng thái
                </Label>
                <Select
                  id="filterStatus"
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                >
                  <option value="">Tất cả trạng thái</option>
                  <option value="active">Đang hoạt động</option>
                  <option value="inactive">Ngừng hoạt động</option>
                </Select>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="text-center sticky left-0 bg-white z-10">Tên dịch vụ</TableHead>
                <TableHead className="text-center">Đơn vị tính</TableHead>
                <TableHead className="text-center">Phần trăm thuế</TableHead>
                <TableHead className="text-center">Loại vật tư/hàng hóa</TableHead>
                <TableHead className="text-center">Sử dụng công thức tính số lượng</TableHead>
                <TableHead className="text-center">Sử dụng công thức tính đơn giá</TableHead>
                <TableHead className="text-center">Mặc định chọn</TableHead>
                <TableHead className="text-center">Tự động tính số lượng</TableHead>
                <TableHead className="text-center sticky right-0 bg-white z-10">Trạng thái</TableHead>
                <TableHead className="text-center">Thao tác</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={10} className="text-center py-8">
                    Đang tải...
                  </TableCell>
                </TableRow>
              ) : filteredServices.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={10} className="text-center py-8 text-gray-500">
                    Không có dữ liệu
                  </TableCell>
                </TableRow>
              ) : (
                filteredServices.map((service) => (
                  <TableRow key={service.id}>
                    <TableCell className="font-medium text-center sticky left-0 bg-white z-10">
                      {service.name}
                    </TableCell>
                    <TableCell className="text-center">{service.unit}</TableCell>
                    <TableCell className="text-center">{service.taxPercentage}%</TableCell>
                    <TableCell className="text-center">{service.materialType}</TableCell>
                    <TableCell className="text-center">
                      {service.useQuantityFormula ? "✓" : "✗"}
                    </TableCell>
                    <TableCell className="text-center">
                      {service.usePriceFormula ? "✓" : "✗"}
                    </TableCell>
                    <TableCell className="text-center">
                      {service.isDefault ? "✓" : "✗"}
                    </TableCell>
                    <TableCell className="text-center">
                      {service.autoCalculateQuantity ? "✓" : "✗"}
                    </TableCell>
                    <TableCell className="text-center sticky right-0 bg-white z-10">
                      <StatusBadge
                        status={service.isActive ? "active" : "inactive"}
                      />
                    </TableCell>
                    <TableCell className="text-center">
                      <div className="flex items-center justify-center gap-2">
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleView(service)}
                          aria-label="Xem"
                        >
                          <Eye className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleEdit(service)}
                          aria-label="Sửa"
                        >
                          <Edit className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleToggleStatus(service)}
                          aria-label={service.isActive ? "Vô hiệu hóa" : "Kích hoạt"}
                          title={service.isActive ? "Vô hiệu hóa" : "Kích hoạt"}
                        >
                          {service.isActive ? (
                            <X className="h-4 w-4 text-orange-600" />
                          ) : (
                            <Plus className="h-4 w-4 text-green-600" />
                          )}
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleDelete(service.id)}
                          aria-label="Xóa"
                        >
                          <Trash2 className="h-4 w-4 text-red-600" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      </Card>

      {/* Dialog */}
      <ServiceDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        viewMode={viewMode}
        selectedService={selectedService}
        onSuccess={loadServices}
      />
    </div>
  )
}
</file>

<file path="client/src/pages/QuanLyTuyen.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Search, Eye, RefreshCw, ChevronLeft, ChevronRight, MapPin, FileText } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { routeService, LegacyRoute } from "@/services/route.service"
import { useUIStore } from "@/store/ui.store"

export default function QuanLyTuyen() {
  const [routes, setRoutes] = useState<LegacyRoute[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [filterDepartureProvince, setFilterDepartureProvince] = useState("")
  const [filterArrivalProvince, setFilterArrivalProvince] = useState("")
  const [filterRouteType, setFilterRouteType] = useState("")
  const [filterOperationStatus, setFilterOperationStatus] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedRoute, setSelectedRoute] = useState<LegacyRoute | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [currentPage, setCurrentPage] = useState(1)
  const itemsPerPage = 20
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý tuyến xe")
    loadRoutes()
  }, [setTitle])

  const loadRoutes = async (forceRefresh = false) => {
    setIsLoading(true)
    try {
      const data = await routeService.getLegacy(forceRefresh)
      setRoutes(data)
    } catch (error) {
      console.error("Failed to load routes:", error)
      toast.error("Không thể tải danh sách tuyến. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  // Get unique values for filters
  const departureProvinces = Array.from(new Set(routes.map((r) => r.departureProvince).filter(Boolean))).sort()
  const arrivalProvinces = Array.from(new Set(routes.map((r) => r.arrivalProvince).filter(Boolean))).sort()
  const routeTypes = Array.from(new Set(routes.map((r) => r.routeType).filter(Boolean))).sort()
  const operationStatuses = Array.from(new Set(routes.map((r) => r.operationStatus).filter(Boolean))).sort()

  const filteredRoutes = routes.filter((route) => {
    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      const matchesSearch =
        route.routeCode.toLowerCase().includes(query) ||
        route.departureStation.toLowerCase().includes(query) ||
        route.arrivalStation.toLowerCase().includes(query) ||
        route.departureProvince.toLowerCase().includes(query) ||
        route.arrivalProvince.toLowerCase().includes(query) ||
        route.routePath.toLowerCase().includes(query)
      if (!matchesSearch) return false
    }

    // Province filters
    if (filterDepartureProvince && route.departureProvince !== filterDepartureProvince) {
      return false
    }
    if (filterArrivalProvince && route.arrivalProvince !== filterArrivalProvince) {
      return false
    }

    // Route type filter
    if (filterRouteType && route.routeType !== filterRouteType) {
      return false
    }

    // Operation status filter
    if (filterOperationStatus && route.operationStatus !== filterOperationStatus) {
      return false
    }

    return true
  })

  // Pagination calculations
  const totalPages = Math.ceil(filteredRoutes.length / itemsPerPage)
  const startIndex = (currentPage - 1) * itemsPerPage
  const endIndex = startIndex + itemsPerPage
  const paginatedRoutes = filteredRoutes.slice(startIndex, endIndex)

  // Reset to page 1 when filters change
  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, filterDepartureProvince, filterArrivalProvince, filterRouteType, filterOperationStatus])

  const handleView = (route: LegacyRoute) => {
    setSelectedRoute(route)
    setDialogOpen(true)
  }

  const clearFilters = () => {
    setSearchQuery("")
    setFilterDepartureProvince("")
    setFilterArrivalProvince("")
    setFilterRouteType("")
    setFilterOperationStatus("")
  }

  const formatDate = (dateStr: string) => {
    if (!dateStr) return "N/A"
    // Handle format "2025-04-14 00:00:00" or "dd/mm/yyyy"
    if (dateStr.includes("-")) {
      const parts = dateStr.split(" ")[0].split("-")
      if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`
      }
    }
    return dateStr
  }

  const getStatusColor = (status: string) => {
    const s = status.toLowerCase()
    if (s.includes("mới") || s.includes("hoạt động")) return "bg-emerald-100 text-emerald-700"
    if (s.includes("ngừng") || s.includes("đóng")) return "bg-rose-100 text-rose-700"
    return "bg-gray-100 text-gray-700"
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Quản lý tuyến xe</h1>
          <p className="text-gray-600 mt-1">
            Danh mục tuyến cố định - {routes.length.toLocaleString()} tuyến
          </p>
        </div>
        <Button onClick={() => loadRoutes(true)} disabled={isLoading} variant="outline">
          <RefreshCw className={`mr-2 h-4 w-4 ${isLoading ? "animate-spin" : ""}`} />
          Làm mới
        </Button>
      </div>

      {/* Search and Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
              <Input
                placeholder="Tìm kiếm theo mã tuyến, bến đi, bến đến, tỉnh, hành trình..."
                className="pl-10"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <div className="space-y-2">
                <Label htmlFor="filterDepartureProvince" className="text-sm font-medium">
                  Tỉnh đi
                </Label>
                <Select
                  id="filterDepartureProvince"
                  value={filterDepartureProvince}
                  onChange={(e) => setFilterDepartureProvince(e.target.value)}
                >
                  <option value="">Tất cả</option>
                  {departureProvinces.map((province) => (
                    <option key={province} value={province}>
                      {province}
                    </option>
                  ))}
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="filterArrivalProvince" className="text-sm font-medium">
                  Tỉnh đến
                </Label>
                <Select
                  id="filterArrivalProvince"
                  value={filterArrivalProvince}
                  onChange={(e) => setFilterArrivalProvince(e.target.value)}
                >
                  <option value="">Tất cả</option>
                  {arrivalProvinces.map((province) => (
                    <option key={province} value={province}>
                      {province}
                    </option>
                  ))}
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="filterRouteType" className="text-sm font-medium">
                  Loại tuyến
                </Label>
                <Select
                  id="filterRouteType"
                  value={filterRouteType}
                  onChange={(e) => setFilterRouteType(e.target.value)}
                >
                  <option value="">Tất cả</option>
                  {routeTypes.map((type) => (
                    <option key={type} value={type}>
                      {type}
                    </option>
                  ))}
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="filterOperationStatus" className="text-sm font-medium">
                  Tình trạng
                </Label>
                <Select
                  id="filterOperationStatus"
                  value={filterOperationStatus}
                  onChange={(e) => setFilterOperationStatus(e.target.value)}
                >
                  <option value="">Tất cả</option>
                  {operationStatuses.map((status) => (
                    <option key={status} value={status}>
                      {status}
                    </option>
                  ))}
                </Select>
              </div>
            </div>
            {(searchQuery || filterDepartureProvince || filterArrivalProvince || filterRouteType || filterOperationStatus) && (
              <div className="flex items-center justify-between pt-2">
                <p className="text-sm text-gray-500">
                  Hiển thị {filteredRoutes.length.toLocaleString()} / {routes.length.toLocaleString()} tuyến
                </p>
                <Button variant="ghost" size="sm" onClick={clearFilters}>
                  Xóa bộ lọc
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="text-center w-[120px]">Mã tuyến</TableHead>
              <TableHead className="text-center">Bến đi</TableHead>
              <TableHead className="text-center">Tỉnh đi</TableHead>
              <TableHead className="text-center">Bến đến</TableHead>
              <TableHead className="text-center">Tỉnh đến</TableHead>
              <TableHead className="text-center w-[80px]">Cự ly (km)</TableHead>
              <TableHead className="text-center w-[100px]">Chuyến/tháng</TableHead>
              <TableHead className="text-center w-[120px]">Tình trạng</TableHead>
              <TableHead className="text-center w-[80px]">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={9} className="text-center py-8">
                  <RefreshCw className="h-6 w-6 animate-spin mx-auto mb-2" />
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : paginatedRoutes.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9} className="text-center py-8 text-gray-500">
                  Không có dữ liệu
                </TableCell>
              </TableRow>
            ) : (
              paginatedRoutes.map((route) => (
                <TableRow key={route.id} className="hover:bg-gray-50">
                  <TableCell className="font-mono text-sm text-center">{route.routeCode}</TableCell>
                  <TableCell className="text-center">{route.departureStation || "N/A"}</TableCell>
                  <TableCell className="text-center text-gray-600">{route.departureProvince || "N/A"}</TableCell>
                  <TableCell className="text-center">{route.arrivalStation || "N/A"}</TableCell>
                  <TableCell className="text-center text-gray-600">{route.arrivalProvince || "N/A"}</TableCell>
                  <TableCell className="text-center">{route.distanceKm || "N/A"}</TableCell>
                  <TableCell className="text-center">{route.totalTripsMonth || "N/A"}</TableCell>
                  <TableCell className="text-center">
                    <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(route.operationStatus)}`}>
                      {route.operationStatus || "N/A"}
                    </span>
                  </TableCell>
                  <TableCell className="text-center">
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => handleView(route)}
                      aria-label="Xem chi tiết"
                    >
                      <Eye className="h-4 w-4" />
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex items-center justify-between px-4 py-3 border-t">
            <p className="text-sm text-gray-500">
              Trang {currentPage} / {totalPages} ({filteredRoutes.length.toLocaleString()} tuyến)
            </p>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
                disabled={currentPage === 1}
              >
                <ChevronLeft className="h-4 w-4" />
                Trước
              </Button>
              <div className="flex items-center gap-1">
                {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                  let pageNum: number
                  if (totalPages <= 5) {
                    pageNum = i + 1
                  } else if (currentPage <= 3) {
                    pageNum = i + 1
                  } else if (currentPage >= totalPages - 2) {
                    pageNum = totalPages - 4 + i
                  } else {
                    pageNum = currentPage - 2 + i
                  }
                  return (
                    <Button
                      key={pageNum}
                      variant={currentPage === pageNum ? "default" : "outline"}
                      size="sm"
                      onClick={() => setCurrentPage(pageNum)}
                      className="w-8 h-8 p-0"
                    >
                      {pageNum}
                    </Button>
                  )
                })}
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))}
                disabled={currentPage === totalPages}
              >
                Sau
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        )}
      </Card>

      {/* Detail Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="text-xl">Chi tiết tuyến xe</DialogTitle>
          </DialogHeader>
          {selectedRoute && (
            <div className="space-y-6">
              {/* Basic Info */}
              <div className="grid grid-cols-2 gap-4">
                <div className="col-span-2 bg-blue-50 p-4 rounded-lg">
                  <p className="text-sm text-blue-600 font-medium">Mã tuyến</p>
                  <p className="text-2xl font-bold text-blue-900">{selectedRoute.routeCode}</p>
                  {selectedRoute.routeCodeOld && selectedRoute.routeCodeOld !== selectedRoute.routeCode && (
                    <p className="text-sm text-blue-500">Mã cũ: {selectedRoute.routeCodeOld}</p>
                  )}
                </div>
              </div>

              {/* Route Details */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-4">
                  <div className="flex items-start gap-2">
                    <MapPin className="h-5 w-5 text-green-600 mt-0.5 flex-shrink-0" />
                    <div>
                      <p className="text-sm text-gray-500">Bến đi</p>
                      <p className="font-medium">{selectedRoute.departureStation}</p>
                      <p className="text-sm text-gray-600">{selectedRoute.departureProvince}</p>
                    </div>
                  </div>
                </div>
                <div className="space-y-4">
                  <div className="flex items-start gap-2">
                    <MapPin className="h-5 w-5 text-red-600 mt-0.5 flex-shrink-0" />
                    <div>
                      <p className="text-sm text-gray-500">Bến đến</p>
                      <p className="font-medium">{selectedRoute.arrivalStation}</p>
                      <p className="text-sm text-gray-600">{selectedRoute.arrivalProvince}</p>
                    </div>
                  </div>
                </div>
              </div>

              {/* Route Path */}
              {selectedRoute.routePath && (
                <div className="bg-gray-50 p-4 rounded-lg">
                  <p className="text-sm text-gray-500 mb-1">Hành trình chạy xe</p>
                  <p className="text-sm">{selectedRoute.routePath}</p>
                </div>
              )}

              {/* Statistics */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div className="bg-gray-50 p-3 rounded-lg text-center">
                  <p className="text-sm text-gray-500">Cự ly</p>
                  <p className="text-xl font-bold">{selectedRoute.distanceKm} km</p>
                </div>
                <div className="bg-gray-50 p-3 rounded-lg text-center">
                  <p className="text-sm text-gray-500">Chuyến/tháng</p>
                  <p className="text-xl font-bold">{selectedRoute.totalTripsMonth}</p>
                </div>
                <div className="bg-gray-50 p-3 rounded-lg text-center">
                  <p className="text-sm text-gray-500">Đang khai thác</p>
                  <p className="text-xl font-bold">{selectedRoute.tripsInOperation}</p>
                </div>
                <div className="bg-gray-50 p-3 rounded-lg text-center">
                  <p className="text-sm text-gray-500">Giãn cách (phút)</p>
                  <p className="text-xl font-bold">{selectedRoute.minIntervalMinutes}</p>
                </div>
              </div>

              {/* Status & Type */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-gray-500">Loại tuyến</p>
                  <p className="font-medium">{selectedRoute.routeType || "N/A"}</p>
                </div>
                <div>
                  <p className="text-sm text-gray-500">Tình trạng khai thác</p>
                  <span className={`inline-flex px-2 py-1 text-sm font-medium rounded-full ${getStatusColor(selectedRoute.operationStatus)}`}>
                    {selectedRoute.operationStatus || "N/A"}
                  </span>
                </div>
              </div>

              {/* Decision Info */}
              <div className="border-t pt-4">
                <div className="flex items-center gap-2 mb-3">
                  <FileText className="h-5 w-5 text-gray-400" />
                  <p className="font-medium">Thông tin quyết định</p>
                </div>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <p className="text-gray-500">Số quyết định</p>
                    <p>{selectedRoute.decisionNumber || "N/A"}</p>
                  </div>
                  <div>
                    <p className="text-gray-500">Ngày ban hành</p>
                    <p>{formatDate(selectedRoute.decisionDate)}</p>
                  </div>
                  <div className="col-span-2">
                    <p className="text-gray-500">Đơn vị ban hành</p>
                    <p>{selectedRoute.issuingAuthority || "N/A"}</p>
                  </div>
                </div>
              </div>

              {/* Notes */}
              {selectedRoute.notes && (
                <div className="border-t pt-4">
                  <p className="text-sm text-gray-500 mb-1">Ghi chú</p>
                  <p className="text-sm">{selectedRoute.notes}</p>
                </div>
              )}
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="client/src/pages/Register.tsx">
import { useState } from "react"
import { useNavigate, Link } from "react-router-dom"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { User, Lock, Mail, Phone, UserCircle, ArrowRight, CheckCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useAuthStore } from "@/store/auth.store"
import logo from "@/assets/logo.png"

const registerSchema = z.object({
  username: z.string().min(3, "Tối thiểu 3 ký tự").max(50, "Tối đa 50 ký tự"),
  password: z.string().min(6, "Tối thiểu 6 ký tự"),
  confirmPassword: z.string().min(6, "Tối thiểu 6 ký tự"),
  fullName: z.string().min(1, "Bắt buộc").max(100, "Tối đa 100 ký tự"),
  email: z.string().email("Email không hợp lệ").optional().or(z.literal("")),
  phone: z.string().max(20, "Tối đa 20 ký tự").optional().or(z.literal("")),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Mật khẩu không khớp",
  path: ["confirmPassword"],
})

type RegisterFormData = z.infer<typeof registerSchema>

// Same image as Login for consistency
const BACKGROUND_IMAGE = "https://images.unsplash.com/photo-1494515843206-f3117d3f51b7?w=1920&q=80"

const benefits = [
  "Quản lý xe và tài xế hiệu quả",
  "Theo dõi điều độ thời gian thực",
  "Báo cáo doanh thu tự động",
  "Hỗ trợ kỹ thuật 24/7"
]

export default function Register() {
  const navigate = useNavigate()
  const register = useAuthStore((state) => state.register)
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)

  const {
    register: registerField,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
  })

  const onSubmit = async (data: RegisterFormData) => {
    try {
      setIsLoading(true)
      setError("")
      await register({
        username: data.username,
        password: data.password,
        fullName: data.fullName,
        email: data.email || undefined,
        phone: data.phone || undefined,
      })
      navigate("/dashboard")
    } catch (err: any) {
      setError(err?.response?.data?.error || err?.message || "Đăng ký thất bại")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex">
      {/* Left Side - Cinematic Hero */}
      <div className="hidden lg:flex lg:w-[50%] xl:w-[55%] relative overflow-hidden">
        {/* Background Image */}
        <img
          src={BACKGROUND_IMAGE}
          alt="Bus interior"
          className="absolute inset-0 w-full h-full object-cover"
        />

        {/* Gradient Overlay */}
        <div className="absolute inset-0 bg-gradient-to-br from-stone-900/95 via-stone-900/85 to-stone-800/80" />
        <div className="absolute inset-0 bg-gradient-to-t from-stone-900/60 via-transparent to-stone-900/40" />

        {/* Content */}
        <div className="relative z-10 flex flex-col justify-between p-12 xl:p-16 w-full">
          {/* Logo */}
          <Link to="/" className="inline-flex items-center gap-3 group">
            <img src={logo} alt="ABC C&T" className="h-12 w-auto" />
            <span className="font-display text-2xl text-white">ABC C&T</span>
          </Link>

          {/* Main Content */}
          <div className="max-w-md space-y-8">
            <div className="space-y-6">
              <h1 className="font-display text-4xl xl:text-5xl text-white leading-tight">
                <span className="block">Tham gia</span>
                <span className="block italic text-emerald-400">hệ sinh thái</span>
                <span className="block">số hóa.</span>
              </h1>
              <p className="text-lg text-stone-400 leading-relaxed">
                Đăng ký miễn phí và bắt đầu trải nghiệm giải pháp quản lý bến xe thông minh.
              </p>
            </div>

            {/* Benefits */}
            <div className="space-y-4">
              {benefits.map((benefit, index) => (
                <div key={index} className="flex items-center gap-3">
                  <div className="w-6 h-6 rounded-full bg-emerald-500/20 flex items-center justify-center flex-shrink-0">
                    <CheckCircle className="w-4 h-4 text-emerald-400" />
                  </div>
                  <span className="text-stone-300 text-sm">{benefit}</span>
                </div>
              ))}
            </div>
          </div>

          {/* Footer */}
          <div className="text-sm text-stone-600">
            © 2025 ABC C&T. Đồng hành cùng ngành vận tải Việt Nam.
          </div>
        </div>
      </div>

      {/* Right Side - Register Form */}
      <div className="w-full lg:w-[50%] xl:w-[45%] flex items-center justify-center p-6 sm:p-8 bg-stone-50 overflow-y-auto">
        <div className="w-full max-w-[420px]">
          {/* Mobile Logo */}
          <div className="lg:hidden flex justify-center mb-8">
            <Link to="/" className="inline-flex items-center gap-2.5">
              <img src={logo} alt="ABC C&T" className="h-10 w-auto" />
              <span className="font-display text-xl text-stone-800">ABC C&T</span>
            </Link>
          </div>

          {/* Form Header */}
          <div className="mb-8">
            <h2 className="font-display text-3xl text-stone-800 mb-2">
              Đăng ký
            </h2>
            <p className="text-stone-500">
              Tạo tài khoản mới để sử dụng hệ thống.
            </p>
          </div>

          {/* Register Form */}
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-5">
            {error && (
              <div className="p-4 bg-red-50 border border-red-100 rounded-xl text-sm text-red-600">
                {error}
              </div>
            )}

            {/* Username & Full Name Row */}
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1.5">
                <Label htmlFor="username" className="text-stone-700 text-sm font-medium">
                  Tên đăng nhập *
                </Label>
                <div className="relative">
                  <User className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="username"
                    type="text"
                    placeholder="username"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("username")}
                  />
                </div>
                {errors.username && (
                  <p className="text-xs text-red-500">{errors.username.message}</p>
                )}
              </div>

              <div className="space-y-1.5">
                <Label htmlFor="fullName" className="text-stone-700 text-sm font-medium">
                  Họ và tên *
                </Label>
                <div className="relative">
                  <UserCircle className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="fullName"
                    type="text"
                    placeholder="Nguyễn Văn A"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("fullName")}
                  />
                </div>
                {errors.fullName && (
                  <p className="text-xs text-red-500">{errors.fullName.message}</p>
                )}
              </div>
            </div>

            {/* Email & Phone Row */}
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1.5">
                <Label htmlFor="email" className="text-stone-700 text-sm font-medium">
                  Email
                </Label>
                <div className="relative">
                  <Mail className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="email"
                    type="email"
                    placeholder="email@example.com"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("email")}
                  />
                </div>
                {errors.email && (
                  <p className="text-xs text-red-500">{errors.email.message}</p>
                )}
              </div>

              <div className="space-y-1.5">
                <Label htmlFor="phone" className="text-stone-700 text-sm font-medium">
                  Số điện thoại
                </Label>
                <div className="relative">
                  <Phone className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="phone"
                    type="tel"
                    placeholder="0901234567"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("phone")}
                  />
                </div>
                {errors.phone && (
                  <p className="text-xs text-red-500">{errors.phone.message}</p>
                )}
              </div>
            </div>

            {/* Password Row */}
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1.5">
                <Label htmlFor="password" className="text-stone-700 text-sm font-medium">
                  Mật khẩu *
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="password"
                    type="password"
                    placeholder="••••••"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("password")}
                  />
                </div>
                {errors.password && (
                  <p className="text-xs text-red-500">{errors.password.message}</p>
                )}
              </div>

              <div className="space-y-1.5">
                <Label htmlFor="confirmPassword" className="text-stone-700 text-sm font-medium">
                  Xác nhận *
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
                  <Input
                    id="confirmPassword"
                    type="password"
                    placeholder="••••••"
                    className="pl-10 h-11 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 text-sm"
                    {...registerField("confirmPassword")}
                  />
                </div>
                {errors.confirmPassword && (
                  <p className="text-xs text-red-500">{errors.confirmPassword.message}</p>
                )}
              </div>
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              className="w-full h-12 bg-stone-800 hover:bg-stone-900 text-white font-medium rounded-xl transition-colors group mt-2"
              disabled={isLoading}
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Đang xử lý...</span>
                </div>
              ) : (
                <span className="flex items-center justify-center gap-2">
                  Tạo tài khoản
                  <ArrowRight className="w-4 h-4 group-hover:translate-x-0.5 transition-transform" />
                </span>
              )}
            </Button>

            {/* Login Link */}
            <p className="text-center text-stone-500 text-sm">
              Đã có tài khoản?{" "}
              <Link
                to="/login"
                className="text-emerald-600 hover:text-emerald-700 font-medium transition-colors"
              >
                Đăng nhập
              </Link>
            </p>
          </form>

          {/* Footer - Mobile */}
          <div className="lg:hidden mt-8 pt-6 border-t border-stone-200 text-center text-xs text-stone-400">
            © 2025 ABC C&T. Bảo lưu mọi quyền.
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/services/auth.service.ts">
// Backward compatibility re-export
// TODO: Update all imports to use @/features/auth directly, then remove this file

import { authApi } from '@/features/auth'

export const authService = authApi
export default authApi
</file>

<file path="client/src/services/driver.service.ts">
import api from '@/lib/api'
import type { Driver, DriverInput } from '@/types'

export const driverService = {
  getAll: async (operatorId?: string, isActive?: boolean): Promise<Driver[]> => {
    try {
      const params = new URLSearchParams()
      if (operatorId) params.append('operatorId', operatorId)
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/drivers?${queryString}` : '/drivers'

      const response = await api.get<Driver[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching drivers:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Driver> => {
    const response = await api.get<Driver>(`/drivers/${id}`)
    return response.data
  },

  create: async (input: DriverInput): Promise<Driver> => {
    const response = await api.post<Driver>('/drivers', input)
    return response.data
  },

  update: async (id: string, input: Partial<DriverInput>): Promise<Driver> => {
    const response = await api.put<Driver>(`/drivers/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/drivers/${id}`)
  },
}
</file>

<file path="client/src/services/location.service.ts">
import api from '@/lib/api'
import type { Location, LocationInput } from '@/types'

export const locationService = {
  getAll: async (isActive?: boolean): Promise<Location[]> => {
    try {
      const params = new URLSearchParams()
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/locations?${queryString}` : '/locations'

      const response = await api.get<Location[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching locations:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Location> => {
    const response = await api.get<Location>(`/locations/${id}`)
    return response.data
  },

  create: async (input: LocationInput): Promise<Location> => {
    const response = await api.post<Location>('/locations', input)
    return response.data
  },

  update: async (id: string, input: Partial<LocationInput>): Promise<Location> => {
    const response = await api.put<Location>(`/locations/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/locations/${id}`)
  },
}
</file>

<file path="client/src/services/schedule.service.ts">
import api from '@/lib/api'
import type { Schedule, ScheduleInput } from '@/types'

export const scheduleService = {
  getAll: async (routeId?: string, operatorId?: string, isActive?: boolean): Promise<Schedule[]> => {
    try {
      const params = new URLSearchParams()
      if (routeId) params.append('routeId', routeId)
      if (operatorId) params.append('operatorId', operatorId)
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/schedules?${queryString}` : '/schedules'

      const response = await api.get<Schedule[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching schedules:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Schedule> => {
    const response = await api.get<Schedule>(`/schedules/${id}`)
    return response.data
  },

  create: async (input: ScheduleInput): Promise<Schedule> => {
    const response = await api.post<Schedule>('/schedules', input)
    return response.data
  },

  update: async (id: string, input: Partial<ScheduleInput>): Promise<Schedule> => {
    const response = await api.put<Schedule>(`/schedules/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/schedules/${id}`)
  },
}
</file>

<file path="client/src/services/service-formula.service.ts">
import api from '@/lib/api'
import type { ServiceFormula, ServiceFormulaInput } from '@/types'

export const serviceFormulaService = {
  getAll: async (formulaType?: 'quantity' | 'price', isActive?: boolean): Promise<ServiceFormula[]> => {
    try {
      const params = new URLSearchParams()
      if (formulaType) params.append('formulaType', formulaType)
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/service-formulas?${queryString}` : '/service-formulas'

      const response = await api.get<ServiceFormula[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching service formulas:', error)
      return []
    }
  },

  getById: async (id: string): Promise<ServiceFormula> => {
    const response = await api.get<ServiceFormula>(`/service-formulas/${id}`)
    return response.data
  },

  create: async (input: ServiceFormulaInput): Promise<ServiceFormula> => {
    const response = await api.post<ServiceFormula>('/service-formulas', input)
    return response.data
  },

  update: async (id: string, input: Partial<ServiceFormulaInput>): Promise<ServiceFormula> => {
    const response = await api.put<ServiceFormula>(`/service-formulas/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/service-formulas/${id}`)
  },
}
</file>

<file path="client/src/services/service.service.ts">
import api from '@/lib/api'
import type { Service, ServiceInput } from '@/types'

export const serviceService = {
  getAll: async (isActive?: boolean): Promise<Service[]> => {
    try {
      const params = new URLSearchParams()
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/services?${queryString}` : '/services'

      const response = await api.get<Service[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching services:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Service> => {
    const response = await api.get<Service>(`/services/${id}`)
    return response.data
  },

  create: async (input: ServiceInput): Promise<Service> => {
    const response = await api.post<Service>('/services', input)
    return response.data
  },

  update: async (id: string, input: Partial<ServiceInput>): Promise<Service> => {
    const response = await api.put<Service>(`/services/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/services/${id}`)
  },
}
</file>

<file path="client/src/services/vehicle-type.service.ts">
import api from '@/lib/api'
import type { VehicleType } from '@/types'

export const vehicleTypeService = {
  getAll: async (): Promise<VehicleType[]> => {
    try {
      const response = await api.get<VehicleType[]>('/vehicle-types')
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle types:', error)
      return []
    }
  },

  getById: async (id: string): Promise<VehicleType> => {
    const response = await api.get<VehicleType>(`/vehicle-types/${id}`)
    return response.data
  },

  create: async (input: { name: string; description?: string }): Promise<VehicleType> => {
    const response = await api.post<VehicleType>('/vehicle-types', input)
    return response.data
  },

  update: async (id: string, input: { name?: string; description?: string }): Promise<VehicleType> => {
    const response = await api.put<VehicleType>(`/vehicle-types/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/vehicle-types/${id}`)
  },
}
</file>

<file path="client/src/store/auth.store.ts">
// Backward compatibility re-export
// TODO: Update all imports to use @/features/auth directly, then remove this file

export { useAuthStore } from '@/features/auth'
</file>

<file path="client/src/types/index.ts">
// Main types barrel export
// Re-exports all types for backward compatibility

export * from './auth.types'
export * from './fleet.types'
export * from './dispatch.types'
export * from './common.types'
</file>

<file path="client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@features/*": ["./src/features/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@types/*": ["./src/types/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@features': path.resolve(__dirname, './src/features'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@types': path.resolve(__dirname, './src/types'),
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // React core
          'vendor-react': ['react', 'react-dom', 'react-router-dom'],
          // UI library - Radix UI (only installed packages)
          'vendor-radix': [
            '@radix-ui/react-popover',
            '@radix-ui/react-radio-group',
          ],
          // Utilities
          'vendor-utils': [
            'date-fns',
            'axios',
            'zustand',
            'clsx',
            'tailwind-merge',
            'class-variance-authority',
          ],
          // Icons
          'vendor-icons': ['lucide-react'],
          // Charts
          'vendor-charts': ['recharts'],
          // Toast
          'vendor-toast': ['react-toastify'],
        },
      },
    },
  },
})
</file>

<file path="package.json">
{
    "name": "benxe-management",
    "version": "1.0.0",
    "description": "Bus Station Management System - Full Stack Application",
    "private": true,
    "workspaces": [
        "client",
        "server"
    ],
    "scripts": {
        "dev": "npm run dev:server & npm run dev:client",
        "dev:client": "npm run dev --workspace=client",
        "dev:server": "npm run dev --workspace=server",
        "build": "npm run build --workspaces",
        "build:client": "npm run build --workspace=client",
        "build:server": "npm run build --workspace=server",
        "start": "npm run start --workspace=server",
        "install:all": "npm install",
        "clean": "rimraf node_modules client/node_modules server/node_modules",
        "seed": "npm run seed --workspace=server",
        "create-admin": "npm run create-admin --workspace=server",
        "deploy:server": "npm run deploy --workspace=server",
        "deploy:client": "npm run deploy --workspace=client"
    },
    "keywords": [
        "bus-station",
        "management",
        "react",
        "express",
        "firebase",
        "fullstack"
    ],
    "author": "",
    "license": "ISC",
    "engines": {
        "node": ">=18.0.0"
    }
}
</file>

<file path="server/src/controllers/auth.controller.ts">
import { Request, Response } from 'express'
import bcrypt from 'bcryptjs'
import jwt, { SignOptions } from 'jsonwebtoken'
import { db, firebaseDb } from '../config/database.js'
import { loginSchema, registerSchema } from '../utils/validation.js'

export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const validated = loginSchema.parse(req.body)
    const { usernameOrEmail, password } = validated

    // Use Firebase Admin SDK for authentication
    console.log('Starting Firebase Admin SDK query for users...')
    let allUsers: any = null
    try {
      const startTime = Date.now()
      allUsers = await firebaseDb.get('users')
      const queryTime = Date.now() - startTime
      console.log(`Firebase Admin SDK query completed in ${queryTime}ms`)
      console.log(`Found ${allUsers ? Object.keys(allUsers).length : 0} users`)
    } catch (error: any) {
      console.error('Firebase Admin SDK query error:', error)
      res.status(500).json({ error: 'Database connection error', details: error.message })
      return
    }

    if (!allUsers) {
      res.status(401).json({ error: 'Invalid credentials' })
      return
    }

    // Convert to array and find user
    const usersArray = Object.keys(allUsers).map(key => ({
      id: key,
      ...allUsers[key]
    }))

    // Try to find user by username first
    console.log(`Looking for user with usernameOrEmail: ${usernameOrEmail}`)
    let user = usersArray.find(u => u.username === usernameOrEmail)

    // If not found by username, try to find by email
    if (!user) {
      user = usersArray.find(u => u.email === usernameOrEmail)
    }

    if (!user) {
      console.log('User not found')
      res.status(401).json({ error: 'Invalid credentials' })
      return
    }

    console.log(`User found: ${user.username}`)

    // Check if user is active
    if (user.is_active === false) {
      res.status(403).json({ error: 'Account is disabled' })
      return
    }

    // Verify password
    const isValid = await bcrypt.compare(password, user.password_hash)
    if (!isValid) {
      res.status(401).json({ error: 'Invalid credentials' })
      return
    }

    // Generate JWT token
    const jwtSecret = process.env.JWT_SECRET!
    if (!jwtSecret) {
      res.status(500).json({ error: 'JWT secret not configured' })
      return
    }
    const token = jwt.sign(
      {
        id: user.id,
        username: user.username,
        role: user.role,
      },
      jwtSecret,
      {
        expiresIn: process.env.JWT_EXPIRES_IN || '7d'
      } as SignOptions
    )

    res.json({
      token,
      user: {
        id: user.id,
        username: user.username,
        fullName: user.full_name,
        email: user.email,
        role: user.role,
      },
    })
  } catch (error) {
    console.error('Login error:', error)
    if (error instanceof Error) {
      res.status(400).json({ error: error.message })
      return
    }
    res.status(500).json({ error: 'Login failed' })
  }
}

export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const validated = registerSchema.parse(req.body)
    const { username, password, fullName, email, phone, role } = validated

    // Set default role to 'user' if not provided
    const userRole = role || 'user'

    if (!db) {
      res.status(500).json({ error: 'Database connection error' })
      return
    }

    // Check if username already exists - query directly from Firebase
    const snapshot = await db.ref('users').once('value')
    const allUsers = snapshot.val() || {}
    const usersArray = Object.keys(allUsers).map(key => ({
      id: key,
      ...allUsers[key]
    }))

    const existingUser = usersArray.find(u => u.username === username)
    if (existingUser) {
      res.status(409).json({ error: 'Username already exists' })
      return
    }

    // Check if email already exists (if provided)
    if (email) {
      const existingEmail = usersArray.find(u => u.email === email)
      if (existingEmail) {
        res.status(409).json({ error: 'Email already exists' })
        return
      }
    }

    // Hash password
    const saltRounds = 10
    const passwordHash = await bcrypt.hash(password, saltRounds)

    // Generate ID
    const userId = `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 15)}`

    // Create user in Firebase
    const newUser = {
      id: userId,
      username,
      password_hash: passwordHash,
      full_name: fullName,
      email: email || null,
      phone: phone || null,
      role: userRole,
      is_active: true,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    }

    await db.ref(`users/${userId}`).set(newUser)

    // Generate JWT token
    const jwtSecret = process.env.JWT_SECRET!
    if (!jwtSecret) {
      res.status(500).json({ error: 'JWT secret not configured' })
      return
    }
    const token = jwt.sign(
      {
        id: newUser.id,
        username: newUser.username,
        role: newUser.role,
      },
      jwtSecret,
      {
        expiresIn: process.env.JWT_EXPIRES_IN || '7d'
      } as SignOptions
    )

    res.status(201).json({
      token,
      user: {
        id: newUser.id,
        username: newUser.username,
        fullName: newUser.full_name,
        email: newUser.email,
        phone: newUser.phone,
        role: newUser.role,
      },
    })
  } catch (error) {
    console.error('Register error:', error)
    if (error instanceof Error) {
      res.status(400).json({ error: error.message })
      return
    }
    res.status(500).json({ error: 'Registration failed' })
  }
}

export const getCurrentUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const authReq = req as any
    const userId = authReq.user?.id

    if (!userId) {
      res.status(401).json({ error: 'Unauthorized' })
      return
    }

    // Use Firebase Admin SDK
    const allUsers = await firebaseDb.get('users')

    if (!allUsers) {
      res.status(404).json({ error: 'User not found' })
      return
    }

    // Find user by ID
    const userKey = Object.keys(allUsers).find(key => {
      const u = allUsers[key]
      return u.id === userId || key === userId
    })

    if (!userKey) {
      res.status(404).json({ error: 'User not found' })
      return
    }

    const userData = allUsers[userKey]
    res.json({
      id: userData.id || userKey,
      username: userData.username,
      fullName: userData.full_name,
      email: userData.email,
      role: userData.role,
    })
  } catch (error) {
    console.error('Get current user error:', error)
    res.status(500).json({ error: 'Failed to get user' })
  }
}
</file>

<file path="server/src/controllers/route.controller.ts">
import { Request, Response } from 'express'
import { firebase, firebaseDb } from '../config/database.js'
import { z } from 'zod'
import { syncRouteChanges } from '../utils/denormalization-sync.js'

// Cache for legacy routes
let legacyRoutesCache: { data: any[]; timestamp: number } | null = null
const LEGACY_CACHE_TTL = 30 * 60 * 1000 // 30 minutes

const routeSchema = z.object({
  routeCode: z.string().min(1, 'Route code is required'),
  routeName: z.string().min(1, 'Route name is required'),
  originId: z.string().min(1, 'Invalid origin ID'),
  destinationId: z.string().min(1, 'Invalid destination ID'),
  distanceKm: z.number().positive().optional(),
  estimatedDurationMinutes: z.number().int().positive().optional(),
  
  plannedFrequency: z.string().optional(),
  boardingPoint: z.string().optional(),
  journeyDescription: z.string().optional(),
  departureTimesDescription: z.string().optional(),
  restStops: z.string().optional(),
  
  stops: z.array(z.object({
    locationId: z.string().min(1),
    stopOrder: z.number().int().positive(),
    distanceFromOriginKm: z.number().optional(),
    estimatedMinutesFromOrigin: z.number().int().optional(),
  })).optional(),
})

export const getAllRoutes = async (req: Request, res: Response) => {
  try {
    const { originId, destinationId, isActive } = req.query

    let query = firebase
      .from('routes')
      .select(`
        *,
        origin:origin_id(id, name, code),
        destination:destination_id(id, name, code)
      `)
      .order('route_name', { ascending: true })

    if (originId) {
      query = query.eq('origin_id', originId as string)
    }
    if (destinationId) {
      query = query.eq('destination_id', destinationId as string)
    }
    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data: routes, error } = await query

    if (error) throw error

    // Fetch stops for all routes
    const routeIds = routes.map((r: any) => r.id)
    const { data: stops } = await firebase
      .from('route_stops')
      .select('*')
      .in('route_id', routeIds)
      .order('stop_order', { ascending: true })

    const routesWithStops = routes.map((route: any) => {
      const routeStops = stops?.filter((s: any) => s.route_id === route.id) || []
      return {
        id: route.id,
        routeCode: route.route_code,
        routeName: route.route_name,
        originId: route.origin_id,
        origin: route.origin ? {
          id: route.origin.id,
          name: route.origin.name,
          code: route.origin.code,
        } : undefined,
        destinationId: route.destination_id,
        destination: route.destination ? {
          id: route.destination.id,
          name: route.destination.name,
          code: route.destination.code,
        } : undefined,
        distanceKm: route.distance_km ? parseFloat(route.distance_km) : null,
        estimatedDurationMinutes: route.estimated_duration_minutes,
        
        plannedFrequency: route.planned_frequency,
        boardingPoint: route.boarding_point,
        journeyDescription: route.journey_description,
        departureTimesDescription: route.departure_times_description,
        restStops: route.rest_stops,
        
        isActive: route.is_active,
        stops: routeStops.map((stop: any) => ({
          id: stop.id,
          locationId: stop.location_id,
          stopOrder: stop.stop_order,
          distanceFromOriginKm: stop.distance_from_origin_km ? parseFloat(stop.distance_from_origin_km) : null,
          estimatedMinutesFromOrigin: stop.estimated_minutes_from_origin,
          createdAt: stop.created_at,
        })),
        createdAt: route.created_at,
        updatedAt: route.updated_at,
      }
    })

    return res.json(routesWithStops)
  } catch (error) {
    console.error('Error fetching routes:', error)
    return res.status(500).json({ error: 'Failed to fetch routes' })
  }
}

export const getRouteById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data: route, error } = await firebase
      .from('routes')
      .select(`
        *,
        origin:origin_id(id, name, code),
        destination:destination_id(id, name, code)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!route) {
      return res.status(404).json({ error: 'Route not found' })
    }

    const { data: stops } = await firebase
      .from('route_stops')
      .select(`
        *,
        locations:location_id(id, name, code)
      `)
      .eq('route_id', id)
      .order('stop_order', { ascending: true })

    return res.json({
      id: route.id,
      routeCode: route.route_code,
      routeName: route.route_name,
      originId: route.origin_id,
      origin: route.origin ? {
        id: route.origin.id,
        name: route.origin.name,
        code: route.origin.code,
      } : undefined,
      destinationId: route.destination_id,
      destination: route.destination ? {
        id: route.destination.id,
        name: route.destination.name,
        code: route.destination.code,
      } : undefined,
      distanceKm: route.distance_km ? parseFloat(route.distance_km) : null,
      estimatedDurationMinutes: route.estimated_duration_minutes,
      isActive: route.is_active,
      stops: stops?.map((stop: any) => ({
        id: stop.id,
        locationId: stop.location_id,
        location: stop.locations ? {
          id: stop.locations.id,
          name: stop.locations.name,
          code: stop.locations.code,
        } : undefined,
        stopOrder: stop.stop_order,
        distanceFromOriginKm: stop.distance_from_origin_km ? parseFloat(stop.distance_from_origin_km) : null,
        estimatedMinutesFromOrigin: stop.estimated_minutes_from_origin,
        createdAt: stop.created_at,
      })) || [],
      createdAt: route.created_at,
      updatedAt: route.updated_at,
    })
  } catch (error) {
    console.error('Error fetching route:', error)
    return res.status(500).json({ error: 'Failed to fetch route' })
  }
}

export const createRoute = async (req: Request, res: Response) => {
  try {
    const validated = routeSchema.parse(req.body)
    const { 
      routeCode, routeName, originId, destinationId, distanceKm, estimatedDurationMinutes, 
      plannedFrequency, boardingPoint, journeyDescription, departureTimesDescription, restStops,
      stops 
    } = validated

    // Insert route
    const { data: route, error: routeError } = await firebase
      .from('routes')
      .insert({
        route_code: routeCode,
        route_name: routeName,
        origin_id: originId,
        destination_id: destinationId,
        distance_km: distanceKm || null,
        estimated_duration_minutes: estimatedDurationMinutes || null,
        
        planned_frequency: plannedFrequency || null,
        boarding_point: boardingPoint || null,
        journey_description: journeyDescription || null,
        departure_times_description: departureTimesDescription || null,
        rest_stops: restStops || null,
        
        is_active: true,
      })
      .select(`
        *,
        origin:origin_id(id, name, code),
        destination:destination_id(id, name, code)
      `)
      .single()

    if (routeError) throw routeError

    // Insert stops if provided
    if (stops && stops.length > 0) {
      const stopsToInsert = stops.map((stop) => ({
        route_id: route.id,
        location_id: stop.locationId,
        stop_order: stop.stopOrder,
        distance_from_origin_km: stop.distanceFromOriginKm || null,
        estimated_minutes_from_origin: stop.estimatedMinutesFromOrigin || null,
      }))

      const { error: stopsError } = await firebase
        .from('route_stops')
        .insert(stopsToInsert)

      if (stopsError) throw stopsError
    }

    // Fetch complete route with stops
    const { data: routeStops } = await firebase
      .from('route_stops')
      .select('*')
      .eq('route_id', route.id)
      .order('stop_order', { ascending: true })

    return res.status(201).json({
      id: route.id,
      routeCode: route.route_code,
      routeName: route.route_name,
      originId: route.origin_id,
      origin: route.origin ? {
        id: route.origin.id,
        name: route.origin.name,
        code: route.origin.code,
      } : undefined,
      destinationId: route.destination_id,
      destination: route.destination ? {
        id: route.destination.id,
        name: route.destination.name,
        code: route.destination.code,
      } : undefined,
      distanceKm: route.distance_km ? parseFloat(route.distance_km) : null,
      estimatedDurationMinutes: route.estimated_duration_minutes,
      
      plannedFrequency: route.planned_frequency,
      boardingPoint: route.boarding_point,
      journeyDescription: route.journey_description,
      departureTimesDescription: route.departure_times_description,
      restStops: route.rest_stops,
      
      isActive: route.is_active,
      stops: routeStops?.map((stop: any) => ({
        id: stop.id,
        locationId: stop.location_id,
        stopOrder: stop.stop_order,
        distanceFromOriginKm: stop.distance_from_origin_km ? parseFloat(stop.distance_from_origin_km) : null,
        estimatedMinutesFromOrigin: stop.estimated_minutes_from_origin,
        createdAt: stop.created_at,
      })) || [],
      createdAt: route.created_at,
      updatedAt: route.updated_at,
    })
  } catch (error: any) {
    if (error.code === '23505') {
      return res.status(409).json({ error: 'Route with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create route' })
  }
}

export const updateRoute = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = routeSchema.partial().parse(req.body)

    // Update route
    const updateData: any = {}
    if (validated.routeCode) updateData.route_code = validated.routeCode
    if (validated.routeName) updateData.route_name = validated.routeName
    if (validated.originId) updateData.origin_id = validated.originId
    if (validated.destinationId) updateData.destination_id = validated.destinationId
    if (validated.distanceKm !== undefined) updateData.distance_km = validated.distanceKm || null
    if (validated.estimatedDurationMinutes !== undefined) updateData.estimated_duration_minutes = validated.estimatedDurationMinutes || null
    
    if (validated.plannedFrequency !== undefined) updateData.planned_frequency = validated.plannedFrequency || null
    if (validated.boardingPoint !== undefined) updateData.boarding_point = validated.boardingPoint || null
    if (validated.journeyDescription !== undefined) updateData.journey_description = validated.journeyDescription || null
    if (validated.departureTimesDescription !== undefined) updateData.departure_times_description = validated.departureTimesDescription || null
    if (validated.restStops !== undefined) updateData.rest_stops = validated.restStops || null

    if (Object.keys(updateData).length > 0) {
      const { error: routeError } = await firebase
        .from('routes')
        .update(updateData)
        .eq('id', id)

      if (routeError) throw routeError
    }

    // Update stops if provided
    if (validated.stops) {
      // Delete existing stops
      await firebase
        .from('route_stops')
        .delete()
        .eq('route_id', id)

      // Insert new stops
      if (validated.stops.length > 0) {
        const stopsToInsert = validated.stops.map((stop) => ({
          route_id: id,
          location_id: stop.locationId,
          stop_order: stop.stopOrder,
          distance_from_origin_km: stop.distanceFromOriginKm || null,
          estimated_minutes_from_origin: stop.estimatedMinutesFromOrigin || null,
        }))

        const { error: stopsError } = await firebase
          .from('route_stops')
          .insert(stopsToInsert)

        if (stopsError) throw stopsError
      }
    }

    // Fetch updated route
    const { data: route } = await firebase
      .from('routes')
      .select(`
        *,
        origin:origin_id(id, name, code),
        destination:destination_id(id, name, code)
      `)
      .eq('id', id)
      .single()

    // Sync denormalized data to dispatch_records if route_name or destination changed
    if (updateData.route_name || updateData.destination_id) {
      const destData = route.destination
        ? (Array.isArray(route.destination) ? route.destination[0] : route.destination)
        : null

      // Run sync in background (non-blocking)
      syncRouteChanges(id, {
        routeName: route.route_name,
        routeType: route.route_type,
        destinationId: route.destination_id,
        destinationName: destData?.name || null,
        destinationCode: destData?.code || null,
      }).catch((err) => {
        console.error('[Route Update] Failed to sync denormalized data:', err)
      })
    }

    const { data: stops } = await firebase
      .from('route_stops')
      .select('*')
      .eq('route_id', id)
      .order('stop_order', { ascending: true })

    return res.json({
      id: route.id,
      routeCode: route.route_code,
      routeName: route.route_name,
      originId: route.origin_id,
      origin: route.origin ? {
        id: route.origin.id,
        name: route.origin.name,
        code: route.origin.code,
      } : undefined,
      destinationId: route.destination_id,
      destination: route.destination ? {
        id: route.destination.id,
        name: route.destination.name,
        code: route.destination.code,
      } : undefined,
      distanceKm: route.distance_km ? parseFloat(route.distance_km) : null,
      estimatedDurationMinutes: route.estimated_duration_minutes,
      isActive: route.is_active,
      stops: stops?.map((stop: any) => ({
        id: stop.id,
        locationId: stop.location_id,
        stopOrder: stop.stop_order,
        distanceFromOriginKm: stop.distance_from_origin_km ? parseFloat(stop.distance_from_origin_km) : null,
        estimatedMinutesFromOrigin: stop.estimated_minutes_from_origin,
        createdAt: stop.created_at,
      })) || [],
      createdAt: route.created_at,
      updatedAt: route.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update route' })
  }
}

export const deleteRoute = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('routes')
      .delete()
      .eq('id', id)

    if (error) throw error

    res.status(204).send()
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to delete route' })
  }
}

// Get legacy routes from datasheet/DANHMUCTUYENCODINH
export const getLegacyRoutes = async (req: Request, res: Response) => {
  try {
    const forceRefresh = req.query.refresh === 'true'
    
    // Check cache
    if (!forceRefresh && legacyRoutesCache && Date.now() - legacyRoutesCache.timestamp < LEGACY_CACHE_TTL) {
      return res.json(legacyRoutesCache.data)
    }

    const snapshot = await firebaseDb.ref('datasheet/DANHMUCTUYENCODINH').once('value')
    const rawData = snapshot.val() || {}

    const routes = Object.entries(rawData).map(([key, value]: [string, any]) => ({
      id: key,
      routeCode: value.route_code || value.MaSoTuyen || '',
      routeCodeOld: value.route_code_old || value.MaSoTuyen_Cu || '',
      routeCodeFixed: value.route_code_fixed || value.MaSoTuyen_Fix || '',
      routeClass: value.route_class || value.MaO || '',
      routeType: value.route_type || value.PhanLoaiTuyen || '',
      routePath: value.route_path || value.HanhTrinh || '',
      
      departureStation: value.departure_station || value.BenDi || '',
      departureStationRef: value.departure_station_ref || value.BenDi_Ref || '',
      departureProvince: value.departure_province || value.TinhDi || '',
      departureProvinceOld: value.departure_province_old || value.TinhDi_Cu || '',
      
      arrivalStation: value.arrival_station || value.BenDen || '',
      arrivalStationRef: value.arrival_station_ref || value.BenDen_Ref || '',
      arrivalProvince: value.arrival_province || value.TinhDen || '',
      arrivalProvinceOld: value.arrival_province_old || value.TinhDen_Cu || '',
      
      distanceKm: parseInt(value.distance_km || value.CuLyTuyen_km) || 0,
      minIntervalMinutes: parseInt(value.min_interval_minutes || value.GianCachToiThieu_phut) || 0,
      totalTripsMonth: parseInt(value.total_trips_month || value.TongChuyenThang) || 0,
      tripsInOperation: parseInt(value.trips_in_operation || value.ChuyenDaKhaiThac) || 0,
      remainingCapacity: parseInt(value.remaining_capacity || value.LuuLuongConLai) || 0,
      
      operationStatus: value.operation_status || value.TinhTrangKhaiThac || '',
      calendarType: value.calendar_type || value.Kieulich || '',
      
      decisionNumber: value.decision_number || value.SoQuyetDinh || '',
      decisionDate: value.decision_date || value.NgayBanHanh || '',
      issuingAuthority: value.issuing_authority || value.DonViBanHanh || '',
      
      notes: value.notes || value.Ghichu || '',
      filePath: value.file_path || value.File || '',
      
      _source: 'datasheet',
    }))

    // Sort by route code
    routes.sort((a, b) => a.routeCode.localeCompare(b.routeCode))

    // Update cache
    legacyRoutesCache = { data: routes, timestamp: Date.now() }

    return res.json(routes)
  } catch (error: any) {
    console.error('Error fetching legacy routes:', error)
    return res.status(500).json({ error: 'Failed to fetch legacy routes' })
  }
}
</file>

<file path="server/src/controllers/service-charge.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const serviceChargeSchema = z.object({
  dispatchRecordId: z.string().min(1, 'Dispatch record ID is required'),
  serviceTypeId: z.string().min(1, 'Service ID is required'), // Giữ tên cũ để tương thích với frontend
  quantity: z.number().positive().default(1),
  unitPrice: z.number().nonnegative('Unit price must be non-negative'),
  totalAmount: z.number().nonnegative('Total amount must be non-negative'),
})

export const getAllServiceCharges = async (req: Request, res: Response) => {
  try {
    const { dispatchRecordId } = req.query

    let query = firebase
      .from('service_charges')
      .select(`
        *,
        services:service_id(id, code, name, base_price, unit, description)
      `)
      .order('created_at', { ascending: false })

    if (dispatchRecordId) {
      query = query.eq('dispatch_record_id', dispatchRecordId as string)
    }

    const { data, error } = await query

    if (error) throw error

    const serviceCharges = data.map((charge: any) => ({
      id: charge.id,
      dispatchRecordId: charge.dispatch_record_id,
      serviceTypeId: charge.service_id, // Map từ service_id nhưng giữ tên serviceTypeId để tương thích
      serviceType: charge.services ? {
        id: charge.services.id,
        code: charge.services.code,
        name: charge.services.name,
        basePrice: parseFloat(charge.services.base_price || 0),
        unit: charge.services.unit,
        description: charge.services.description,
      } : undefined,
      quantity: parseFloat(charge.quantity),
      unitPrice: parseFloat(charge.unit_price),
      totalAmount: parseFloat(charge.total_amount),
      createdAt: charge.created_at,
    }))

    return res.json(serviceCharges)
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch service charges' })
  }
}

export const getServiceChargeById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('service_charges')
      .select(`
        *,
        services:service_id(id, code, name, base_price, unit, description)
      `)
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Service charge not found' })
    }

    return res.json({
      id: data.id,
      dispatchRecordId: data.dispatch_record_id,
      serviceTypeId: data.service_id, // Map từ service_id nhưng giữ tên serviceTypeId để tương thích
      serviceType: data.services ? {
        id: data.services.id,
        code: data.services.code,
        name: data.services.name,
        basePrice: parseFloat(data.services.base_price || 0),
        unit: data.services.unit,
        description: data.services.description,
      } : undefined,
      quantity: parseFloat(data.quantity),
      unitPrice: parseFloat(data.unit_price),
      totalAmount: parseFloat(data.total_amount),
      createdAt: data.created_at,
    })
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch service charge' })
  }
}

export const createServiceCharge = async (req: Request, res: Response) => {
  try {
    const validated = serviceChargeSchema.parse(req.body)

    const { data, error } = await firebase
      .from('service_charges')
      .insert({
        dispatch_record_id: validated.dispatchRecordId,
        service_id: validated.serviceTypeId, // Map serviceTypeId từ request vào service_id trong DB
        quantity: validated.quantity,
        unit_price: validated.unitPrice,
        total_amount: validated.totalAmount,
      })
      .select(`
        *,
        services:service_id(id, code, name, base_price, unit, description)
      `)
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      dispatchRecordId: data.dispatch_record_id,
      serviceTypeId: data.service_id, // Map từ service_id nhưng giữ tên serviceTypeId để tương thích
      serviceType: data.services ? {
        id: data.services.id,
        code: data.services.code,
        name: data.services.name,
        basePrice: parseFloat(data.services.base_price || 0),
        unit: data.services.unit,
        description: data.services.description,
      } : undefined,
      quantity: parseFloat(data.quantity),
      unitPrice: parseFloat(data.unit_price),
      totalAmount: parseFloat(data.total_amount),
      createdAt: data.created_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create service charge' })
  }
}

export const deleteServiceCharge = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('service_charges')
      .delete()
      .eq('id', id)

    if (error) throw error

    res.status(204).send()
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to delete service charge' })
  }
}

export const getAllServiceTypes = async (req: Request, res: Response) => {
  try {
    const { isActive } = req.query

    // Lấy từ bảng services (bảng chính) thay vì service_types
    let query = firebase
      .from('services')
      .select('id, code, name, description, base_price, unit, is_active, created_at, updated_at')
      .order('display_order', { ascending: true })
      .order('name', { ascending: true })

    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    // Map từ services sang ServiceType format để tương thích với frontend
    const serviceTypes = data.map((svc: any) => ({
      id: svc.id,
      code: svc.code,
      name: svc.name,
      description: svc.description,
      basePrice: parseFloat(svc.base_price || 0),
      unit: svc.unit,
      isActive: svc.is_active,
      createdAt: svc.created_at,
      updatedAt: svc.updated_at,
    }))

    res.json(serviceTypes)
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to fetch service types' })
  }
}
</file>

<file path="server/src/controllers/service-formula.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const serviceFormulaSchema = z.object({
  code: z.string().min(1, 'Code is required'),
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  formulaType: z.enum(['quantity', 'price'], {
    errorMap: () => ({ message: 'Formula type must be either quantity or price' }),
  }),
  formulaExpression: z.string().optional(),
  isActive: z.boolean().default(true),
})

export const getAllServiceFormulas = async (req: Request, res: Response) => {
  try {
    const { formulaType, isActive } = req.query

    // Query from service_formulas table directly (Firebase doesn't support views)
    let query = firebase
      .from('service_formulas')
      .select('*')

    if (formulaType) {
      query = query.eq('formula_type', formulaType as string)
    }

    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    // Get formula usage data
    const { data: usageData } = await firebase
      .from('service_formula_usage')
      .select('*')

    // Get services data to get service names
    const { data: servicesData } = await firebase
      .from('services')
      .select('*')

    // Create a map of formula_id -> service names
    const formulaUsageMap: Record<string, { count: number; serviceNames: string[] }> = {}

    if (usageData && servicesData) {
      const servicesMap = new Map(servicesData.map((s: any) => [s.id, s.name]))

      usageData.forEach((usage: any) => {
        const formulaId = usage.formula_id
        const serviceName = servicesMap.get(usage.service_id) as string

        if (!formulaUsageMap[formulaId]) {
          formulaUsageMap[formulaId] = { count: 0, serviceNames: [] }
        }

        formulaUsageMap[formulaId].count++
        if (serviceName && !formulaUsageMap[formulaId].serviceNames.includes(serviceName)) {
          formulaUsageMap[formulaId].serviceNames.push(serviceName)
        }
      })
    }

    // Sort in memory since Firebase query builder may not support multiple order by
    const sortedData = (data || []).sort((a: any, b: any) => {
      if (a.formula_type !== b.formula_type) {
        return a.formula_type.localeCompare(b.formula_type)
      }
      return (a.code || '').localeCompare(b.code || '')
    })

    const formulas = sortedData.map((formula: any) => {
      const usage = formulaUsageMap[formula.id] || { count: 0, serviceNames: [] }
      return {
        id: formula.id,
        code: formula.code,
        name: formula.name,
        description: formula.description,
        formulaType: formula.formula_type,
        formulaExpression: formula.formula_expression,
        isActive: formula.is_active,
        usageCount: usage.count,
        usedByServices: usage.serviceNames.join(', '),
        createdAt: formula.created_at,
        updatedAt: formula.updated_at,
      }
    })

    return res.json(formulas)
  } catch (error: any) {
    console.error('Error fetching service formulas:', error)
    return res.status(500).json({ error: 'Failed to fetch service formulas' })
  }
}

export const getServiceFormulaById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Query formula directly (Firebase doesn't support SQL-style joins)
    const { data, error } = await firebase
      .from('service_formulas')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Service formula not found' })
    }

    // Get usage data for this formula
    const { data: usageData } = await firebase
      .from('service_formula_usage')
      .select('*')
      .eq('formula_id', id)

    // Get service names
    let usageCount = 0
    const serviceNames: string[] = []

    if (usageData && usageData.length > 0) {
      usageCount = usageData.length
      const serviceIds = usageData.map((u: any) => u.service_id)

      const { data: servicesData } = await firebase
        .from('services')
        .select('*')

      if (servicesData) {
        servicesData.forEach((s: any) => {
          if (serviceIds.includes(s.id) && !serviceNames.includes(s.name)) {
            serviceNames.push(s.name)
          }
        })
      }
    }

    return res.json({
      id: data.id,
      code: data.code,
      name: data.name,
      description: data.description,
      formulaType: data.formula_type,
      formulaExpression: data.formula_expression,
      isActive: data.is_active,
      usageCount: usageCount,
      usedByServices: serviceNames.join(', '),
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error fetching service formula:', error)
    return res.status(500).json({ error: 'Failed to fetch service formula' })
  }
}

export const createServiceFormula = async (req: Request, res: Response) => {
  try {
    const validated = serviceFormulaSchema.parse(req.body)

    const { data, error } = await firebase
      .from('service_formulas')
      .insert({
        code: validated.code,
        name: validated.name,
        description: validated.description,
        formula_type: validated.formulaType,
        formula_expression: validated.formulaExpression,
        is_active: validated.isActive,
      })
      .select('*')
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      code: data.code,
      name: data.name,
      description: data.description,
      formulaType: data.formula_type,
      formulaExpression: data.formula_expression,
      isActive: data.is_active,
      usageCount: 0,
      usedByServices: '',
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Formula code already exists' })
    }
    console.error('Error creating service formula:', error)
    return res.status(500).json({ error: 'Failed to create service formula' })
  }
}

export const updateServiceFormula = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = serviceFormulaSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.code !== undefined) updateData.code = validated.code
    if (validated.name !== undefined) updateData.name = validated.name
    if (validated.description !== undefined) updateData.description = validated.description
    if (validated.formulaType !== undefined) updateData.formula_type = validated.formulaType
    if (validated.formulaExpression !== undefined) updateData.formula_expression = validated.formulaExpression
    if (validated.isActive !== undefined) updateData.is_active = validated.isActive

    const { data, error } = await firebase
      .from('service_formulas')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Service formula not found' })
    }

    return res.json({
      id: data.id,
      code: data.code,
      name: data.name,
      description: data.description,
      formulaType: data.formula_type,
      formulaExpression: data.formula_expression,
      isActive: data.is_active,
      usageCount: 0,
      usedByServices: '',
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Formula code already exists' })
    }
    console.error('Error updating service formula:', error)
    return res.status(500).json({ error: 'Failed to update service formula' })
  }
}

export const deleteServiceFormula = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Delete formula directly (usage check skipped for Firebase - can be added later)
    const { error } = await firebase
      .from('service_formulas')
      .delete()
      .eq('id', id)

    if (error) throw error

    return res.status(204).send()
  } catch (error: any) {
    console.error('Error deleting service formula:', error)
    return res.status(500).json({ error: 'Failed to delete service formula' })
  }
}
</file>

<file path="server/src/controllers/upload.controller.ts">
import { Request, Response } from 'express';
import { getStorage } from 'firebase-admin/storage';
import { getApps } from 'firebase-admin/app';
import fs from 'fs';
import path from 'path';

// Import to trigger Firebase initialization  
import '../config/database.js';

// Get Firebase Storage bucket (uses default bucket configured in initializeApp)
function getStorageBucket() {
  if (getApps().length === 0) {
    throw new Error('Firebase not initialized. Make sure database.ts is imported first.');
  }
  return getStorage().bucket();
}

export const uploadImage = async (req: Request, res: Response): Promise<Response> => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const bucket = getStorageBucket();
    const timestamp = Date.now();
    const ext = path.extname(req.file.originalname);
    const fileName = `dispatch-images/${timestamp}-${Math.random().toString(36).substring(7)}${ext}`;

    // Upload to Firebase Storage
    await bucket.upload(req.file.path, {
      destination: fileName,
      metadata: {
        contentType: req.file.mimetype,
        metadata: {
          originalName: req.file.originalname,
          uploadedAt: new Date().toISOString(),
        },
      },
    });

    // Make file publicly accessible
    const file = bucket.file(fileName);
    await file.makePublic();

    // Get public URL
    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;

    // Remove temp file
    fs.unlinkSync(req.file.path);

    return res.status(200).json({
      url: publicUrl,
      fileName: fileName,
    });
  } catch (error: any) {
    console.error('Upload error:', error);
    
    // Try to remove temp file if it exists
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }
    
    return res.status(500).json({ 
      message: 'Image upload failed', 
      error: error.message || 'Unknown error'
    });
  }
};
</file>

<file path="server/src/controllers/vehicle-type.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'

const vehicleTypeSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  defaultSeatCapacity: z.number().int().min(0).optional(),
  defaultBedCapacity: z.number().int().min(0).optional(),
})

export const getAllVehicleTypes = async (_req: Request, res: Response) => {
  try {
    const { data, error } = await firebase
      .from('vehicle_types')
      .select('*')
      .order('name', { ascending: true })

    if (error) throw error

    const vehicleTypes = data.map((vt: any) => ({
      id: vt.id,
      name: vt.name,
      description: vt.description,
      defaultSeatCapacity: vt.default_seat_capacity ?? null,
      defaultBedCapacity: vt.default_bed_capacity ?? null,
      createdAt: vt.created_at,
    }))

    return res.json(vehicleTypes)
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch vehicle types' })
  }
}

export const getVehicleTypeById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('vehicle_types')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Vehicle type not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      description: data.description,
      defaultSeatCapacity: data.default_seat_capacity ?? null,
      defaultBedCapacity: data.default_bed_capacity ?? null,
      createdAt: data.created_at,
    })
  } catch (error: any) {
    return res.status(500).json({ error: error.message || 'Failed to fetch vehicle type' })
  }
}

export const createVehicleType = async (req: Request, res: Response) => {
  try {
    const validated = vehicleTypeSchema.parse(req.body)

    const { data, error } = await firebase
      .from('vehicle_types')
      .insert({
        name: validated.name,
        description: validated.description || null,
        default_seat_capacity: validated.defaultSeatCapacity ?? null,
        default_bed_capacity: validated.defaultBedCapacity ?? null,
      })
      .select()
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      name: data.name,
      description: data.description,
      defaultSeatCapacity: data.default_seat_capacity ?? null,
      defaultBedCapacity: data.default_bed_capacity ?? null,
      createdAt: data.created_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create vehicle type' })
  }
}

export const updateVehicleType = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = vehicleTypeSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.name) updateData.name = validated.name
    if (validated.description !== undefined) updateData.description = validated.description || null
    if (validated.defaultSeatCapacity !== undefined) updateData.default_seat_capacity = validated.defaultSeatCapacity
    if (validated.defaultBedCapacity !== undefined) updateData.default_bed_capacity = validated.defaultBedCapacity

    const { data, error } = await firebase
      .from('vehicle_types')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Vehicle type not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      description: data.description,
      defaultSeatCapacity: data.default_seat_capacity ?? null,
      defaultBedCapacity: data.default_bed_capacity ?? null,
      createdAt: data.created_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update vehicle type' })
  }
}

export const deleteVehicleType = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('vehicle_types')
      .delete()
      .eq('id', id)

    if (error) throw error

    res.status(204).send()
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to delete vehicle type' })
  }
}
</file>

<file path="server/src/functions.ts">
/**
 * Firebase Cloud Functions Entry Point
 *
 * This file exports the Express app as a Firebase Cloud Function.
 * Deploy using: firebase deploy --only functions
 */

import { onRequest } from 'firebase-functions/v2/https'
import { app } from './index.js'

// Export Express app as Firebase Function
// The function will be available at: https://<region>-<project-id>.cloudfunctions.net/api
// Note: JWT_SECRET is now loaded from .env file instead of Firebase Secrets
export const api = onRequest(
  {
    // Function configuration
    region: 'asia-southeast1', // Singapore region for Vietnam
    memory: '512MiB',
    timeoutSeconds: 60,
    minInstances: 0,
    maxInstances: 10,
    // Allow unauthenticated access (API handles its own auth)
    invoker: 'public',
  },
  // Cast Express app to request handler - Firebase Functions accepts Express apps
  app as unknown as (req: any, res: any) => void | Promise<void>
)
</file>

<file path="server/src/modules/chat/chat.controller.ts">
import { Request, Response } from 'express'
import { aiService } from './services/ai.service.js'
import { chatCacheService } from './services/chat-cache.service.js'
import type { ChatRequest, ChatResponse } from './types/chat.types.js'

const generateSessionId = (): string => {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

export const processMessage = async (req: Request, res: Response): Promise<void> => {
  const { message, sessionId: inputSessionId } = req.body as ChatRequest
  const startTime = Date.now()
  const sessionId = inputSessionId || generateSessionId()

  if (!message || typeof message !== 'string' || message.trim().length === 0) {
    res.status(400).json({
      response: 'Vui lòng nhập tin nhắn',
      type: 'error',
      sessionId
    } as ChatResponse)
    return
  }

  if (message.length > 1000) {
    res.status(400).json({
      response: 'Tin nhắn quá dài (tối đa 1000 ký tự)',
      type: 'error',
      sessionId
    } as ChatResponse)
    return
  }

  try {
    // Ensure cache is ready (non-blocking if already warm)
    if (!chatCacheService.isReady()) {
      chatCacheService.preWarm().catch(err => console.error('[Chat] Cache pre-warm error:', err))
    }

    // Use AI with function calling - handles everything
    const response = await aiService.generateResponse(message.trim(), sessionId)
    const processingTime = Date.now() - startTime

    console.log(`[Chat] Processed in ${processingTime}ms: "${message.substring(0, 50)}..."`)

    res.json({
      response,
      type: 'ai',
      sessionId,
      metadata: {
        queryType: 'AI_FUNCTION_CALLING',
        processingTime
      }
    } as ChatResponse)
  } catch (error: any) {
    console.error('Chat error:', error)

    // Never return "busy" - always provide helpful response
    const stats = chatCacheService.isReady() ? chatCacheService.getSystemStats() : null
    const fallbackResponse = `Xin lỗi, tôi gặp sự cố khi xử lý yêu cầu của bạn.

**Bạn có thể thử:**
• Tìm xe: "xe 98H07480"
• Tìm tài xế: "tài xế Nguyễn Văn A"
• Tìm đơn vị: "đơn vị Phương Trang"
• Tìm tuyến: "tuyến TP.HCM - Đà Lạt"
• Thống kê: "thống kê điều độ"${stats ? `\n\nHệ thống có ${stats.vehicles} xe, ${stats.drivers} tài xế.` : ''}`

    res.json({
      response: fallbackResponse,
      type: 'ai',
      sessionId,
      metadata: {
        processingTime: Date.now() - startTime,
        error: true
      }
    } as ChatResponse)
  }
}

export const clearHistory = async (req: Request, res: Response): Promise<void> => {
  const { sessionId } = req.params

  if (!sessionId) {
    res.status(400).json({ success: false, error: 'Session ID is required' })
    return
  }

  // Clear AI conversation history
  aiService.clearHistory(sessionId)
  res.json({ success: true })
}
</file>

<file path="server/src/modules/chat/services/ai.service.ts">
import { GoogleGenerativeAI, Content, FunctionCallingMode } from '@google/generative-ai'
import { CHAT_FUNCTIONS, executeFunction } from './chat-functions.js'
import { chatCacheService } from './chat-cache.service.js'

const GEMINI_API_KEY = process.env.GEMINI_API_KEY

const SYSTEM_PROMPT = `Bạn là trợ lý ảo thông minh của hệ thống quản lý bến xe khách.

**Vai trò:**
- Hỗ trợ người dùng tra cứu thông tin về xe, tài xế, tuyến đường, phù hiệu, dịch vụ
- Giải thích quy trình nghiệp vụ điều độ xe
- Trả lời câu hỏi về hệ thống quản lý bến xe

**Quy tắc quan trọng:**
- Trả lời bằng tiếng Việt, ngắn gọn và dễ hiểu
- LUÔN sử dụng function calling để truy vấn dữ liệu khi người dùng hỏi về thông tin cụ thể
- Khi có kết quả từ function call, hãy format thông tin một cách rõ ràng và thân thiện
- Nếu không tìm thấy dữ liệu, hãy gợi ý cách tìm kiếm khác
- KHÔNG BAO GIỜ nói "hệ thống bận" hay từ chối trả lời

**Hệ thống quản lý:**
- Quản lý xe khách, xe buýt tuyến cố định
- Điều độ xe vào/ra bến
- Quản lý tài xế, giấy phép lái xe
- Quản lý đơn vị vận tải
- Cấp phù hiệu xe
- Quản lý tuyến đường và lịch trình
- Quản lý dịch vụ, hóa đơn, vi phạm

**Ví dụ câu hỏi:**
- "xe 98H07480" → gọi search_vehicle
- "tài xế Nguyễn" → gọi search_driver
- "đơn vị Phương Trang" → gọi search_operator
- "tuyến Sài Gòn Đà Lạt" → gọi search_route
- "thống kê hôm nay" → gọi get_dispatch_stats
- "hệ thống có bao nhiêu xe" → gọi get_system_stats`

class AIService {
  private genAI: GoogleGenerativeAI | null = null
  private conversationHistory: Map<string, Content[]> = new Map()

  private getGenAI(): GoogleGenerativeAI {
    if (!this.genAI) {
      if (!GEMINI_API_KEY) {
        throw new Error('GEMINI_API_KEY is not configured')
      }
      this.genAI = new GoogleGenerativeAI(GEMINI_API_KEY)
    }
    return this.genAI
  }

  async generateResponse(
    message: string,
    sessionId: string
  ): Promise<string> {
    try {
      const genAI = this.getGenAI()

      // Get model with function calling enabled
      const model = genAI.getGenerativeModel({
        model: 'gemini-2.5-flash',
        tools: [{ functionDeclarations: CHAT_FUNCTIONS as any }],
        toolConfig: {
          functionCallingConfig: {
            mode: FunctionCallingMode.AUTO
          }
        },
        systemInstruction: SYSTEM_PROMPT
      })

      // Get conversation history
      let history = this.conversationHistory.get(sessionId) || []

      // Start chat with history
      const chat = model.startChat({
        history: history,
        generationConfig: {
          maxOutputTokens: 1500,
          temperature: 0.7,
        },
      })

      // Send message
      let result = await chat.sendMessage(message)
      let response = result.response

      // Check for function calls
      let functionCalls = response.functionCalls()
      let iterations = 0
      const maxIterations = 3

      while (functionCalls && functionCalls.length > 0 && iterations < maxIterations) {
        iterations++
        console.log(`[AI] Function call ${iterations}: ${functionCalls.map(fc => fc.name).join(', ')}`)

        // Execute all function calls
        const functionResponses = await Promise.all(
          functionCalls.map(async (fc) => {
            const result = await executeFunction(fc.name, fc.args as Record<string, any>)
            return {
              functionResponse: {
                name: fc.name,
                response: result
              }
            }
          })
        )

        // Send function results back to model
        result = await chat.sendMessage(functionResponses)
        response = result.response
        functionCalls = response.functionCalls()
      }

      const responseText = response.text()

      // Update history (keep last 20 messages = 10 exchanges)
      history = [...history, { role: 'user', parts: [{ text: message }] }, { role: 'model', parts: [{ text: responseText }] }]
      if (history.length > 20) {
        history = history.slice(-20)
      }
      this.conversationHistory.set(sessionId, history)

      return responseText
    } catch (error: any) {
      console.error('AI Service error:', error?.message || error)
      console.error('AI Service error stack:', error?.stack)
      console.error('AI Service error details:', JSON.stringify(error, null, 2))
      return this.getFallbackResponse(message, error)
    }
  }

  private async getFallbackResponse(message: string, _error?: any): Promise<string> {
    // Try to use cached data as fallback
    try {
      if (!chatCacheService.isReady()) {
        await chatCacheService.preWarm()
      }

      const results = chatCacheService.fuzzySearch(message)
      if (results.length > 0) {
        return this.formatFallbackResults(results)
      }
    } catch {
      // Ignore cache errors
    }

    // Return helpful guidance instead of error
    const stats = chatCacheService.isReady() ? chatCacheService.getSystemStats() : null
    const statsInfo = stats
      ? `\n\nHệ thống hiện có ${stats.vehicles} xe, ${stats.drivers} tài xế, ${stats.operators} đơn vị vận tải.`
      : ''

    return `Xin lỗi, tôi không thể tìm thấy thông tin bạn cần.

**Bạn có thể thử:**
• Tìm xe: "xe 98H07480" hoặc "biển số 51B12345"
• Tìm tài xế: "tài xế Nguyễn Văn A"
• Tìm đơn vị: "đơn vị Phương Trang"
• Tìm tuyến: "tuyến TP.HCM - Đà Lạt"
• Thống kê: "thống kê điều độ hôm nay"
• Tổng quan: "hệ thống có bao nhiêu xe"${statsInfo}`
  }

  private formatFallbackResults(results: any[]): string {
    let response = '**Kết quả tìm kiếm:**\n\n'

    const vehicles = results.filter(r => r._source === 'vehicles')
    const badges = results.filter(r => r._source === 'badges')
    const operators = results.filter(r => r._source === 'operators')
    const drivers = results.filter(r => r._source === 'drivers')
    const routes = results.filter(r => r._source === 'routes')

    if (vehicles.length > 0) {
      response += `**Xe (${vehicles.length}):**\n`
      vehicles.slice(0, 3).forEach(v => {
        const plate = v.plate_number || v.BienSo || 'N/A'
        const type = v.LoaiXe || v.vehicle_type || ''
        response += `• ${plate}${type ? ` - ${type}` : ''}\n`
      })
      response += '\n'
    }

    if (badges.length > 0) {
      response += `**Phù hiệu (${badges.length}):**\n`
      badges.slice(0, 3).forEach(b => {
        const plate = b.BienSoXe || b.plate_number || 'N/A'
        const badgeNum = b.SoPhuHieu || b.badge_number || ''
        response += `• ${plate}${badgeNum ? ` - PH: ${badgeNum}` : ''}\n`
      })
      response += '\n'
    }

    if (operators.length > 0) {
      response += `**Đơn vị (${operators.length}):**\n`
      operators.slice(0, 3).forEach(o => {
        const name = o.TenDonVi || o.name || 'N/A'
        response += `• ${name}\n`
      })
      response += '\n'
    }

    if (drivers.length > 0) {
      response += `**Tài xế (${drivers.length}):**\n`
      drivers.slice(0, 3).forEach(d => {
        const name = d.full_name || d.fullName || 'N/A'
        response += `• ${name}\n`
      })
      response += '\n'
    }

    if (routes.length > 0) {
      response += `**Tuyến (${routes.length}):**\n`
      routes.slice(0, 3).forEach(r => {
        const code = r.MaSoTuyen || r.route_code || ''
        const departure = r.BenDi || r.departure_station || ''
        const arrival = r.BenDen || r.arrival_station || ''
        response += `• ${code ? `[${code}] ` : ''}${departure} - ${arrival}\n`
      })
    }

    return response.trim()
  }

  clearHistory(sessionId: string): void {
    this.conversationHistory.delete(sessionId)
  }

  hasApiKey(): boolean {
    return !!GEMINI_API_KEY
  }
}

export const aiService = new AIService()
</file>

<file path="server/src/modules/chat/types/chat.types.ts">
export type QueryType =
  | 'VEHICLE_LOOKUP'
  | 'DRIVER_SEARCH'
  | 'ROUTE_INFO'
  | 'SCHEDULE_QUERY'
  | 'DISPATCH_STATS'
  | 'BADGE_LOOKUP'
  | 'OPERATOR_INFO'
  | 'GENERAL_QUESTION'
  | 'AI_FUNCTION_CALLING'

export interface ChatMessage {
  id: string
  sessionId: string
  role: 'user' | 'assistant'
  content: string
  type: 'data_query' | 'ai_response' | 'error'
  metadata?: {
    queryType?: QueryType
    dataSource?: string
    processingTime?: number
    resultCount?: number
  }
  createdAt: string
}

export interface IntentResult {
  type: QueryType
  confidence: number
  extractedParams: Record<string, string>
}

export interface QueryResult {
  success: boolean
  data?: any
  error?: string
  source: string
}

export interface ChatRequest {
  message: string
  sessionId?: string
}

export interface ChatResponse {
  response: string
  type: 'data' | 'ai' | 'error'
  sessionId: string
  metadata?: {
    queryType?: QueryType
    processingTime?: number
    resultCount?: number
    hasContext?: boolean
  }
}
</file>

<file path="server/src/modules/dispatch/dispatch-mappers.ts">
/**
 * Dispatch Mappers
 * Transform database records to API format
 */

import type { DispatchDBRecord, DispatchRecord } from './dispatch-types.js'

/**
 * Map database record to API response format
 */
export function mapDispatchToAPI(record: DispatchDBRecord): DispatchRecord {
  return {
    id: record.id,
    vehicleId: record.vehicle_id,
    vehicle: {
      id: record.vehicle_id,
      plateNumber: record.vehicle_plate_number || '',
      operatorId: record.vehicle_operator_id || null,
      operator: record.vehicle_operator_name ? {
        id: record.vehicle_operator_id!,
        name: record.vehicle_operator_name,
        code: record.vehicle_operator_code || '',
      } : undefined,
    },
    vehiclePlateNumber: record.vehicle_plate_number || '',
    driverId: record.driver_id,
    driverName: record.driver_full_name || '',
    scheduleId: record.schedule_id,
    routeId: record.route_id,
    route: record.route_name ? {
      id: record.route_id!,
      routeName: record.route_name,
      routeType: record.route_type,
      destination: record.route_destination_name ? {
        id: record.route_destination_id!,
        name: record.route_destination_name,
        code: record.route_destination_code || '',
      } : undefined,
    } : undefined,
    routeName: record.route_name || '',
    entryTime: record.entry_time,
    entryBy: record.entry_by_name || record.entry_by,
    entryImageUrl: record.entry_image_url,
    passengerDropTime: record.passenger_drop_time,
    passengersArrived: record.passengers_arrived,
    passengerDropBy: record.passenger_drop_by_name || record.passenger_drop_by,
    boardingPermitTime: record.boarding_permit_time,
    plannedDepartureTime: record.planned_departure_time,
    transportOrderCode: record.transport_order_code,
    seatCount: record.seat_count,
    permitStatus: record.permit_status as 'approved' | 'rejected' | null,
    rejectionReason: record.rejection_reason,
    boardingPermitBy: record.boarding_permit_by_name || record.boarding_permit_by,
    paymentTime: record.payment_time,
    paymentAmount: record.payment_amount ? parseFloat(String(record.payment_amount)) : null,
    paymentMethod: record.payment_method as 'cash' | 'transfer' | 'card' | null,
    invoiceNumber: record.invoice_number,
    paymentBy: record.payment_by_name || record.payment_by,
    departureOrderTime: record.departure_order_time,
    passengersDeparting: record.passengers_departing,
    departureOrderBy: record.departure_order_by_name || record.departure_order_by,
    exitTime: record.exit_time,
    exitBy: record.exit_by_name || record.exit_by,
    currentStatus: record.current_status,
    notes: record.notes,
    metadata: record.metadata,
    createdAt: record.created_at,
    updatedAt: record.updated_at,
  }
}

/**
 * Map array of database records to API format
 */
export function mapDispatchListToAPI(records: DispatchDBRecord[]): DispatchRecord[] {
  return records.map(mapDispatchToAPI)
}
</file>

<file path="server/src/modules/dispatch/dispatch-types.ts">
/**
 * Dispatch Module Types
 */

export interface DispatchRecord {
  id: string
  vehicleId: string
  vehiclePlateNumber: string
  vehicle?: {
    id: string
    plateNumber: string
    operatorId?: string | null
    operator?: {
      id: string
      name: string
      code: string
    }
  }
  driverId: string
  driverName: string
  scheduleId?: string | null
  routeId?: string | null
  routeName?: string
  route?: {
    id: string
    routeName: string
    routeType?: string | null
    destination?: {
      id: string
      name: string
      code: string
    }
  }
  entryTime: string
  entryBy?: string | null
  entryImageUrl?: string | null
  passengerDropTime?: string | null
  passengersArrived?: number | null
  passengerDropBy?: string | null
  boardingPermitTime?: string | null
  plannedDepartureTime?: string | null
  transportOrderCode?: string | null
  seatCount?: number | null
  permitStatus?: 'approved' | 'rejected' | null
  rejectionReason?: string | null
  boardingPermitBy?: string | null
  paymentTime?: string | null
  paymentAmount?: number | null
  paymentMethod?: 'cash' | 'transfer' | 'card' | null
  invoiceNumber?: string | null
  paymentBy?: string | null
  departureOrderTime?: string | null
  passengersDeparting?: number | null
  departureOrderBy?: string | null
  exitTime?: string | null
  exitBy?: string | null
  currentStatus: string
  notes?: string | null
  metadata?: Record<string, unknown> | null
  createdAt: string
  updatedAt: string
}

export interface DispatchDBRecord {
  id: string
  vehicle_id: string
  vehicle_plate_number?: string | null
  vehicle_operator_id?: string | null
  vehicle_operator_name?: string | null
  vehicle_operator_code?: string | null
  driver_id: string
  driver_full_name?: string | null
  schedule_id?: string | null
  route_id?: string | null
  route_name?: string | null
  route_type?: string | null
  route_destination_id?: string | null
  route_destination_name?: string | null
  route_destination_code?: string | null
  entry_time: string
  entry_by?: string | null
  entry_by_name?: string | null
  entry_image_url?: string | null
  passenger_drop_time?: string | null
  passengers_arrived?: number | null
  passenger_drop_by?: string | null
  passenger_drop_by_name?: string | null
  boarding_permit_time?: string | null
  planned_departure_time?: string | null
  transport_order_code?: string | null
  seat_count?: number | null
  permit_status?: string | null
  rejection_reason?: string | null
  boarding_permit_by?: string | null
  boarding_permit_by_name?: string | null
  payment_time?: string | null
  payment_amount?: string | number | null
  payment_method?: string | null
  invoice_number?: string | null
  payment_by?: string | null
  payment_by_name?: string | null
  departure_order_time?: string | null
  passengers_departing?: number | null
  departure_order_by?: string | null
  departure_order_by_name?: string | null
  exit_time?: string | null
  exit_by?: string | null
  exit_by_name?: string | null
  current_status: string
  notes?: string | null
  metadata?: Record<string, unknown> | null
  created_at: string
  updated_at: string
  // Shift IDs
  entry_shift_id?: string | null
  permit_shift_id?: string | null
  payment_shift_id?: string | null
  departure_order_shift_id?: string | null
  exit_shift_id?: string | null
}

export interface DispatchFilters {
  status?: string
  vehicleId?: string
  driverId?: string
  routeId?: string
}

// Note: Input types are defined in dispatch-validation.ts via Zod schemas
// Use those types instead: CreateDispatchInput, PassengerDropInput, IssuePermitInput,
// PaymentInput, DepartureOrderInput, ExitInput
</file>

<file path="server/src/modules/dispatch/dispatch-validation.ts">
/**
 * Dispatch Validation
 * Zod schemas and validation functions
 */

import { z } from 'zod'
import {
  DISPATCH_STATUS,
  validateStatusTransition,
  type DispatchStatusType
} from '../../shared/validation/index.js'

// Re-export status utilities for convenience
export { DISPATCH_STATUS, validateStatusTransition }
export type { DispatchStatusType }

/**
 * Schema for creating a new dispatch record
 */
export const createDispatchSchema = z.object({
  vehicleId: z.string().min(1, 'Invalid vehicle ID'),
  driverId: z.string().min(1).optional(),  // Optional - bypass driver requirement
  scheduleId: z.string().min(1).optional(),
  routeId: z.string().min(1, 'Invalid route ID').optional(),
  entryTime: z.string().refine(
    (val) => {
      const date = new Date(val)
      return !isNaN(date.getTime())
    },
    { message: 'Invalid entry time format' }
  ),
  notes: z.string().optional(),
  entryShiftId: z.string().min(1).optional(),
})

/**
 * Schema for passenger drop
 */
export const passengerDropSchema = z.object({
  passengersArrived: z.number().int().min(0, 'Passengers must be non-negative').optional(),
  routeId: z.string().min(1).optional(),
})

/**
 * Schema for issuing permit
 */
export const issuePermitSchema = z.object({
  transportOrderCode: z.string().optional(),
  plannedDepartureTime: z.string().optional(),
  seatCount: z.number().int().positive().optional(),
  permitStatus: z.enum(['approved', 'rejected']),
  rejectionReason: z.string().optional(),
  routeId: z.string().min(1).optional(),
  scheduleId: z.string().min(1).optional(),
  replacementVehicleId: z.string().optional(),
  permitShiftId: z.string().min(1).optional(),
})

/**
 * Schema for payment
 */
export const paymentSchema = z.object({
  paymentAmount: z.number().min(0, 'Payment amount must be >= 0'),
  paymentMethod: z.enum(['cash', 'transfer', 'card']).optional(),
  invoiceNumber: z.string().optional(),
  paymentShiftId: z.string().min(1).optional(),
})

/**
 * Schema for departure order
 */
export const departureOrderSchema = z.object({
  passengersDeparting: z.number().int().min(0).optional(),
  departureOrderShiftId: z.string().min(1).optional(),
})

/**
 * Schema for exit
 */
export const exitSchema = z.object({
  exitTime: z.string().optional(),
  passengersDeparting: z.number().int().min(0).optional(),
  exitShiftId: z.string().min(1).optional(),
})

/**
 * Type exports from schemas
 */
export type CreateDispatchInput = z.infer<typeof createDispatchSchema>
export type PassengerDropInput = z.infer<typeof passengerDropSchema>
export type IssuePermitInput = z.infer<typeof issuePermitSchema>
export type PaymentInput = z.infer<typeof paymentSchema>
export type DepartureOrderInput = z.infer<typeof departureOrderSchema>
export type ExitInput = z.infer<typeof exitSchema>

/**
 * Validation functions
 */
export function validateCreateDispatch(data: unknown): CreateDispatchInput {
  return createDispatchSchema.parse(data)
}

export function validatePassengerDrop(data: unknown): PassengerDropInput {
  return passengerDropSchema.parse(data)
}

export function validateIssuePermit(data: unknown): IssuePermitInput {
  const result = issuePermitSchema.parse(data)
  // Additional validation: transport order code required for approval
  if (result.permitStatus === 'approved' && !result.transportOrderCode) {
    throw new z.ZodError([{
      code: 'custom',
      message: 'Transport order code is required for approval',
      path: ['transportOrderCode'],
    }])
  }
  return result
}

export function validatePayment(data: unknown): PaymentInput {
  return paymentSchema.parse(data)
}

export function validateDepartureOrder(data: unknown): DepartureOrderInput {
  return departureOrderSchema.parse(data)
}

export function validateExit(data: unknown): ExitInput {
  return exitSchema.parse(data)
}
</file>

<file path="server/src/modules/fleet/controllers/driver.controller.ts">
/**
 * Driver Controller
 * Handles HTTP requests for driver operations
 */

import { Request, Response } from 'express'
import { firebase } from '../../../config/database.js'
import { syncDriverChanges } from '../../../utils/denormalization-sync.js'
import { validateCreateDriver, validateUpdateDriver } from '../fleet-validation.js'

interface OperatorInfo {
  id: string
  name: string
  code: string
}

/**
 * Fetch junction table data for operators (manual join for Firebase RTDB)
 */
async function fetchDriverOperators(driverId: string) {
  // Get junction records
  const { data: junctionData, error } = await firebase
    .from('driver_operators')
    .select('*')
    .eq('driver_id', driverId)

  if (error) throw error
  if (!junctionData || junctionData.length === 0) return []

  // Get all operators for manual join
  const { data: operatorsData } = await firebase
    .from('operators')
    .select('id, name, code')

  const operatorsMap = new Map<string, OperatorInfo>((operatorsData || []).map((op: any) => [op.id, op]))

  // Manual join
  return junctionData.map((junction: any) => {
    const op = operatorsMap.get(junction.operator_id)
    return {
      operator_id: junction.operator_id,
      is_primary: junction.is_primary,
      operators: op ? { id: op.id, name: op.name, code: op.code } : null,
    }
  }).filter((j: any) => j.operators !== null)
}

/**
 * Update driver-operator junction records
 */
async function updateDriverOperators(driverId: string, operatorIds: string[]): Promise<void> {
  // Delete existing junction records
  await firebase.from('driver_operators').delete().eq('driver_id', driverId)

  // Create new junction records
  const junctionRecords = operatorIds.map((opId, index) => ({
    driver_id: driverId,
    operator_id: opId,
    is_primary: index === 0,
  }))

  const { error } = await firebase.from('driver_operators').insert(junctionRecords)
  if (error) throw error
}

// ========== Controller Handlers ==========

export const getAllDrivers = async (req: Request, res: Response) => {
  try {
    const { operatorId, isActive } = req.query

    // Load all drivers (without join - Firebase RTDB doesn't support joins)
    let driversQuery = firebase
      .from('drivers')
      .select('*')
      .order('created_at', { ascending: false })

    if (isActive !== undefined) {
      driversQuery = driversQuery.eq('is_active', isActive === 'true')
    }

    const { data: driversData, error: driversError } = await driversQuery
    if (driversError) throw driversError

    // Load all operators for manual join
    const { data: operatorsData } = await firebase
      .from('operators')
      .select('id, name, code')

    const operatorsMap = new Map((operatorsData || []).map((op: any) => [op.id, op]))

    // Load all junction records for manual join
    const { data: junctionData } = await firebase
      .from('driver_operators')
      .select('*')

    // Create driver_id -> operators map
    const driverOperatorsMap = new Map<string, any[]>()
    ;(junctionData || []).forEach((junction: any) => {
      const list = driverOperatorsMap.get(junction.driver_id) || []
      list.push(junction)
      driverOperatorsMap.set(junction.driver_id, list)
    })

    // Map drivers with operator info
    let drivers = (driversData || []).map((driver: any) => {
      // Get primary operator
      const primaryOperatorData = driver.operator_id ? operatorsMap.get(driver.operator_id) as any : null
      const primaryOperator = primaryOperatorData ? {
        id: primaryOperatorData.id,
        name: primaryOperatorData.name,
        code: primaryOperatorData.code,
      } : undefined

      // Get all operators from junction table
      const junctionRecords = driverOperatorsMap.get(driver.id) || []
      const allOperators = junctionRecords.map((junction: any) => {
        const opData = operatorsMap.get(junction.operator_id) as any
        return opData ? {
          id: opData.id,
          name: opData.name,
          code: opData.code,
          isPrimary: junction.is_primary,
        } : null
      }).filter((op: any) => op !== null)

      // Use junction operators if available, otherwise fallback to primary
      const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

      return {
        id: driver.id,
        operatorId: driver.operator_id,
        operator: primaryOperator,
        operatorIds: operators.map((op: any) => op.id),
        operators: operators,
        fullName: driver.full_name,
        idNumber: driver.id_number,
        phone: driver.phone,
        province: driver.province,
        district: driver.district,
        address: driver.address,
        licenseNumber: driver.license_number,
        licenseClass: driver.license_class,
        licenseExpiryDate: driver.license_expiry_date,
        imageUrl: driver.image_url,
        isActive: driver.is_active,
        createdAt: driver.created_at,
        updatedAt: driver.updated_at,
      }
    })

    // Filter by operatorId if provided
    if (operatorId) {
      const opId = operatorId as string
      drivers = drivers.filter((driver: any) => {
        if (driver.operatorId === opId) return true
        if (driver.operatorIds.includes(opId)) return true
        return false
      })
    }

    return res.json(drivers)
  } catch (error: unknown) {
    const err = error as { message?: string }
    console.error('Error fetching drivers:', error)
    return res.status(500).json({ error: err.message || 'Failed to fetch drivers' })
  }
}

export const getDriverById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Get driver without join
    const { data: driverData, error: driverError } = await firebase
      .from('drivers')
      .select('*')
      .eq('id', id)
      .single()

    if (driverError) throw driverError
    if (!driverData) return res.status(404).json({ error: 'Driver not found' })

    // Manual join: fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (driverData.operator_id) {
      const { data: opData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', driverData.operator_id)
        .single()
      if (opData) {
        primaryOperator = { id: opData.id, name: opData.name, code: opData.code }
      }
    }

    // Get junction operators
    const junctionData = await fetchDriverOperators(id)
    const allOperators = junctionData.map((j: any) => ({
      id: j.operators.id,
      name: j.operators.name,
      code: j.operators.code,
      isPrimary: j.is_primary,
    }))

    const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

    return res.json({
      id: driverData.id,
      operatorId: driverData.operator_id,
      operator: primaryOperator,
      operatorIds: operators.map((op: any) => op.id),
      operators: operators,
      fullName: driverData.full_name,
      idNumber: driverData.id_number,
      phone: driverData.phone,
      province: driverData.province,
      district: driverData.district,
      address: driverData.address,
      licenseNumber: driverData.license_number,
      licenseClass: driverData.license_class,
      licenseExpiryDate: driverData.license_expiry_date,
      imageUrl: driverData.image_url,
      isActive: driverData.is_active,
      createdAt: driverData.created_at,
      updatedAt: driverData.updated_at,
    })
  } catch (error: unknown) {
    const err = error as { message?: string }
    console.error('Error fetching driver:', error)
    return res.status(500).json({ error: err.message || 'Failed to fetch driver' })
  }
}

export const createDriver = async (req: Request, res: Response) => {
  try {
    const validated = validateCreateDriver(req.body)
    const primaryOperatorId = validated.operatorIds[0]

    // Create driver without join
    const { data: driverData, error: driverError } = await firebase
      .from('drivers')
      .insert({
        operator_id: primaryOperatorId,
        full_name: validated.fullName,
        id_number: validated.idNumber,
        phone: validated.phone || null,
        province: validated.province || null,
        district: validated.district || null,
        address: validated.address || null,
        license_number: validated.licenseNumber,
        license_class: validated.licenseClass,
        license_expiry_date: validated.licenseExpiryDate,
        image_url: validated.imageUrl || null,
        is_active: true,
      })
      .select('*')
      .single()

    if (driverError) throw driverError

    // Create junction records
    await updateDriverOperators(driverData.id, validated.operatorIds)

    // Manual join: fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (driverData.operator_id) {
      const { data: opData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', driverData.operator_id)
        .single()
      if (opData) {
        primaryOperator = { id: opData.id, name: opData.name, code: opData.code }
      }
    }

    // Get junction operators
    const junctionData = await fetchDriverOperators(driverData.id)
    const allOperators = junctionData.map((j: any) => ({
      id: j.operators.id,
      name: j.operators.name,
      code: j.operators.code,
      isPrimary: j.is_primary,
    }))

    const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

    return res.status(201).json({
      id: driverData.id,
      operatorId: driverData.operator_id,
      operator: primaryOperator,
      operatorIds: operators.map((op: any) => op.id),
      operators: operators,
      fullName: driverData.full_name,
      idNumber: driverData.id_number,
      phone: driverData.phone,
      province: driverData.province,
      district: driverData.district,
      address: driverData.address,
      licenseNumber: driverData.license_number,
      licenseClass: driverData.license_class,
      licenseExpiryDate: driverData.license_expiry_date,
      imageUrl: driverData.image_url,
      isActive: driverData.is_active,
      createdAt: driverData.created_at,
      updatedAt: driverData.updated_at,
    })
  } catch (error: unknown) {
    const err = error as { code?: string; name?: string; errors?: Array<{ message: string }>; message?: string }
    console.error('Error creating driver:', error)
    if (err.code === '23505') return res.status(400).json({ error: 'Driver with this ID number or license already exists' })
    if (err.name === 'ZodError') return res.status(400).json({ error: err.errors?.[0]?.message })
    return res.status(500).json({ error: err.message || 'Failed to create driver' })
  }
}

export const updateDriver = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = validateUpdateDriver(req.body)

    const updateData: Record<string, unknown> = {}
    if (validated.fullName) updateData.full_name = validated.fullName
    if (validated.idNumber) updateData.id_number = validated.idNumber
    if (validated.phone !== undefined) updateData.phone = validated.phone || null
    if (validated.province !== undefined) updateData.province = validated.province || null
    if (validated.district !== undefined) updateData.district = validated.district || null
    if (validated.address !== undefined) updateData.address = validated.address || null
    if (validated.licenseNumber) updateData.license_number = validated.licenseNumber
    if (validated.licenseClass) updateData.license_class = validated.licenseClass
    if (validated.licenseExpiryDate) updateData.license_expiry_date = validated.licenseExpiryDate
    if (validated.imageUrl !== undefined) updateData.image_url = validated.imageUrl || null

    // Update operators if provided
    if (validated.operatorIds && validated.operatorIds.length > 0) {
      updateData.operator_id = validated.operatorIds[0]
      await updateDriverOperators(id, validated.operatorIds)
    }

    // Update driver without join
    const { data, error } = await firebase
      .from('drivers')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) return res.status(404).json({ error: 'Driver not found' })

    // Sync denormalized data if full_name changed
    if (updateData.full_name) {
      syncDriverChanges(id, data.full_name).catch((err) => {
        console.error('[Driver Update] Failed to sync denormalized data:', err)
      })
    }

    // Manual join: fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (data.operator_id) {
      const { data: opData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', data.operator_id)
        .single()
      if (opData) {
        primaryOperator = { id: opData.id, name: opData.name, code: opData.code }
      }
    }

    // Get junction operators
    const junctionData = await fetchDriverOperators(id)
    const allOperators = junctionData.map((j: any) => ({
      id: j.operators.id,
      name: j.operators.name,
      code: j.operators.code,
      isPrimary: j.is_primary,
    }))

    const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

    return res.json({
      id: data.id,
      operatorId: data.operator_id,
      operator: primaryOperator,
      operatorIds: operators.map((op: any) => op.id),
      operators: operators,
      fullName: data.full_name,
      idNumber: data.id_number,
      phone: data.phone,
      province: data.province,
      district: data.district,
      address: data.address,
      licenseNumber: data.license_number,
      licenseClass: data.license_class,
      licenseExpiryDate: data.license_expiry_date,
      imageUrl: data.image_url,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: unknown) {
    const err = error as { name?: string; errors?: Array<{ message: string }>; message?: string }
    console.error('Error updating driver:', error)
    if (err.name === 'ZodError') return res.status(400).json({ error: err.errors?.[0]?.message })
    return res.status(500).json({ error: err.message || 'Failed to update driver' })
  }
}

export const deleteDriver = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase.from('drivers').delete().eq('id', id)
    if (error) throw error

    return res.status(204).send()
  } catch (error: unknown) {
    const err = error as { message?: string }
    console.error('Error deleting driver:', error)
    return res.status(500).json({ error: err.message || 'Failed to delete driver' })
  }
}
</file>

<file path="server/src/modules/fleet/fleet-mappers.ts">
/**
 * Fleet Module Mappers
 * Transform database records to API format
 */

import {
  VehicleRecord,
  VehicleDBRecord,
  VehicleDocumentDB,
  VehicleDocuments,
  DriverRecord,
  DriverDBRecord,
  OperatorInfo,
  AuditLogRecord,
} from './fleet-types.js'

// ========== Vehicle Mappers ==========

/**
 * Build documents map from vehicle documents array
 */
export function buildDocumentsMap(documents: VehicleDocumentDB[] | null): VehicleDocuments {
  const docsMap: VehicleDocuments = {}
  const today = new Date().toISOString().split('T')[0]

  documents?.forEach((doc) => {
    const mappedDoc = {
      number: doc.document_number,
      issueDate: doc.issue_date,
      expiryDate: doc.expiry_date,
      issuingAuthority: doc.issuing_authority,
      documentUrl: doc.document_url,
      notes: doc.notes,
      isValid: doc.expiry_date >= today,
    }

    switch (doc.document_type) {
      case 'registration':
        docsMap.registration = mappedDoc
        break
      case 'inspection':
        docsMap.inspection = mappedDoc
        break
      case 'insurance':
        docsMap.insurance = mappedDoc
        break
      case 'operation_permit':
        docsMap.operation_permit = mappedDoc
        break
      case 'emblem':
        docsMap.emblem = mappedDoc
        break
    }
  })

  return docsMap
}

/**
 * Map vehicle database record to API format
 * Note: operator and vehicleType should be passed separately (Firebase RTDB doesn't support joins)
 */
export function mapVehicleToAPI(
  vehicle: VehicleDBRecord,
  documents?: VehicleDocumentDB[] | null,
  operator?: { id: string; name: string; code: string } | null,
  vehicleType?: { id: string; name: string } | null
): VehicleRecord {
  const docsMap = documents ? buildDocumentsMap(documents) : undefined

  return {
    id: vehicle.id,
    plateNumber: vehicle.plate_number,
    vehicleTypeId: vehicle.vehicle_type_id,
    vehicleType: vehicleType
      ? {
          id: vehicleType.id,
          name: vehicleType.name,
        }
      : undefined,
    operatorId: vehicle.operator_id,
    operator: operator
      ? {
          id: operator.id,
          name: operator.name,
          code: operator.code,
        }
      : undefined,
    seatCapacity: vehicle.seat_capacity,
    bedCapacity: vehicle.bed_capacity ?? undefined,
    manufactureYear: vehicle.manufacture_year,
    chassisNumber: vehicle.chassis_number,
    engineNumber: vehicle.engine_number,
    color: vehicle.color,
    imageUrl: vehicle.image_url,
    insuranceExpiryDate: vehicle.insurance_expiry_date,
    inspectionExpiryDate: vehicle.inspection_expiry_date,
    cargoLength: vehicle.cargo_length,
    cargoWidth: vehicle.cargo_width,
    cargoHeight: vehicle.cargo_height,
    gpsProvider: vehicle.gps_provider,
    gpsUsername: vehicle.gps_username,
    gpsPassword: vehicle.gps_password,
    province: vehicle.province,
    isActive: vehicle.is_active,
    notes: vehicle.notes,
    documents: docsMap
      ? {
          registration: docsMap.registration,
          inspection: docsMap.inspection,
          insurance: docsMap.insurance,
          operation_permit: docsMap.operation_permit,
          emblem: docsMap.emblem,
        }
      : undefined,
    createdAt: vehicle.created_at,
    updatedAt: vehicle.updated_at,
  }
}

// ========== Driver Mappers ==========

/**
 * Extract operators from driver record with junction table data
 */
function extractOperators(driver: DriverDBRecord): {
  primaryOperator: OperatorInfo | undefined
  allOperators: OperatorInfo[]
} {
  // Get primary operator from operator_id (backward compatibility)
  const primaryOperator: OperatorInfo | undefined = driver.operators
    ? {
        id: driver.operators.id,
        name: driver.operators.name,
        code: driver.operators.code,
      }
    : undefined

  // Get all operators from junction table
  const allOperators: OperatorInfo[] =
    driver.driver_operators
      ?.map((doRel) => ({
        id: doRel.operators?.id ?? '',
        name: doRel.operators?.name ?? '',
        code: doRel.operators?.code ?? '',
        isPrimary: doRel.is_primary,
      }))
      .filter((op) => op.id) ?? []

  // If no operators from junction table, use primary operator
  const operators =
    allOperators.length > 0 ? allOperators : primaryOperator ? [primaryOperator] : []

  return { primaryOperator, allOperators: operators }
}

/**
 * Map driver database record to API format
 */
export function mapDriverToAPI(driver: DriverDBRecord): DriverRecord {
  const { primaryOperator, allOperators } = extractOperators(driver)

  return {
    id: driver.id,
    operatorId: driver.operator_id,
    operator: primaryOperator,
    operatorIds: allOperators.map((op) => op.id),
    operators: allOperators,
    fullName: driver.full_name,
    idNumber: driver.id_number,
    phone: driver.phone,
    email: driver.email,
    province: driver.province,
    district: driver.district,
    address: driver.address,
    licenseNumber: driver.license_number,
    licenseClass: driver.license_class,
    licenseIssueDate: driver.license_issue_date,
    licenseExpiryDate: driver.license_expiry_date,
    imageUrl: driver.image_url,
    isActive: driver.is_active,
    createdAt: driver.created_at,
    updatedAt: driver.updated_at,
  }
}

/**
 * Map driver with separately fetched junction data
 */
export function mapDriverWithOperators(
  driver: DriverDBRecord,
  junctionData: Array<{
    operator_id: string
    is_primary: boolean
    operators?: { id: string; name: string; code: string }
  }> | null
): DriverRecord {
  const primaryOperator: OperatorInfo | undefined = driver.operators
    ? {
        id: driver.operators.id,
        name: driver.operators.name,
        code: driver.operators.code,
      }
    : undefined

  const allOperators: OperatorInfo[] =
    junctionData
      ?.map((doRel) => ({
        id: doRel.operators?.id ?? '',
        name: doRel.operators?.name ?? '',
        code: doRel.operators?.code ?? '',
        isPrimary: doRel.is_primary,
      }))
      .filter((op) => op.id) ?? []

  const operators =
    allOperators.length > 0 ? allOperators : primaryOperator ? [primaryOperator] : []

  return {
    id: driver.id,
    operatorId: driver.operator_id,
    operator: primaryOperator,
    operatorIds: operators.map((op) => op.id),
    operators,
    fullName: driver.full_name,
    idNumber: driver.id_number,
    phone: driver.phone,
    email: driver.email,
    province: driver.province,
    district: driver.district,
    address: driver.address,
    licenseNumber: driver.license_number,
    licenseClass: driver.license_class,
    licenseIssueDate: driver.license_issue_date,
    licenseExpiryDate: driver.license_expiry_date,
    imageUrl: driver.image_url,
    isActive: driver.is_active,
    createdAt: driver.created_at,
    updatedAt: driver.updated_at,
  }
}

// ========== Audit Log Mappers ==========

/**
 * Convert UTC timestamp to Vietnam timezone (UTC+7)
 */
function toVietnamTime(timestamp: string): string {
  if (!timestamp || typeof timestamp !== 'string') return timestamp

  if (timestamp.endsWith('Z')) {
    const utcDate = new Date(timestamp)
    const vietnamDate = new Date(utcDate.getTime() + 7 * 60 * 60 * 1000)
    const year = vietnamDate.getUTCFullYear()
    const month = String(vietnamDate.getUTCMonth() + 1).padStart(2, '0')
    const day = String(vietnamDate.getUTCDate()).padStart(2, '0')
    const hours = String(vietnamDate.getUTCHours()).padStart(2, '0')
    const minutes = String(vietnamDate.getUTCMinutes()).padStart(2, '0')
    const seconds = String(vietnamDate.getUTCSeconds()).padStart(2, '0')
    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+07:00`
  }

  if (!timestamp.includes('+') && !timestamp.includes('Z')) {
    return timestamp.endsWith('+07:00') ? timestamp : `${timestamp}+07:00`
  }

  return timestamp
}

/**
 * Map audit log to API format
 */
export function mapAuditLogToAPI(log: {
  id: string
  user_id?: string | null
  users?: { full_name?: string; username?: string } | null
  action: string
  record_id: string
  old_values?: Record<string, unknown> | null
  new_values?: Record<string, unknown> | null
  created_at: string
}): AuditLogRecord {
  return {
    id: log.id,
    userId: log.user_id,
    userName: log.users?.full_name || log.users?.username || 'Không xác định',
    action: log.action,
    recordId: log.record_id,
    oldValues: log.old_values,
    newValues: log.new_values,
    createdAt: toVietnamTime(log.created_at),
  }
}
</file>

<file path="server/src/modules/fleet/index.ts">
/**
 * Fleet Module
 * Public exports for Vehicle, Driver, VehicleType management
 */

// Types
export type {
  VehicleRecord,
  VehicleDBRecord,
  VehicleDocument,
  VehicleDocuments,
  VehicleDocumentDB,
  VehicleFilters as VehicleQueryFilters,
  DriverRecord,
  DriverDBRecord,
  DriverFilters as DriverQueryFilters,
  OperatorInfo,
  DocumentType,
  AuditLogRecord,
} from './fleet-types.js'

// Validation
export {
  createVehicleSchema,
  updateVehicleSchema,
  createDriverSchema,
  updateDriverSchema,
  validateCreateVehicle,
  validateUpdateVehicle,
  validateCreateDriver,
  validateUpdateDriver,
} from './fleet-validation.js'
export type {
  CreateVehicleInput,
  UpdateVehicleInput,
  CreateDriverInput,
  UpdateDriverInput,
  VehicleDocumentInput,
  VehicleDocumentsInput,
} from './fleet-validation.js'

// Mappers
export {
  mapVehicleToAPI,
  mapDriverToAPI,
  mapDriverWithOperators,
  buildDocumentsMap,
  mapAuditLogToAPI,
} from './fleet-mappers.js'

// Repositories
export { vehicleRepository, VehicleRepository } from './repositories/vehicle.repository.js'
export { driverRepository, DriverRepository } from './repositories/driver.repository.js'
export { vehicleTypeRepository, VehicleTypeRepository } from './repositories/vehicle-type.repository.js'

// Services
export { vehicleService, VehicleService } from './services/vehicle.service.js'
export type { CreateVehicleDTO, UpdateVehicleDTO, VehicleFilters } from './services/vehicle.service.js'
export { driverService, DriverService } from './services/driver.service.js'
export type { CreateDriverDTO, UpdateDriverDTO, DriverFilters } from './services/driver.service.js'

// Controllers
export {
  getAllVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  getVehicleDocumentAuditLogs,
} from './controllers/vehicle.controller.js'
export {
  getAllDrivers,
  getDriverById,
  createDriver,
  updateDriver,
  deleteDriver,
} from './controllers/driver.controller.js'

// Routes
export { default as vehicleRoutes } from './vehicle.routes.js'
export { default as driverRoutes } from './driver.routes.js'
</file>

<file path="server/src/modules/operator/index.ts">
/**
 * Operator Module
 * Public exports for the Operator module
 */

export { operatorRepository, OperatorRepository } from './repositories/operator.repository.js'
export { operatorService, OperatorService } from './services/operator.service.js'
export type { CreateOperatorDTO, UpdateOperatorDTO } from './services/operator.service.js'
export { default as operatorRoutes } from './operator.routes.js'
</file>

<file path="server/src/routes/dashboard.routes.ts">
import { Router } from 'express'
import {
  getDashboardData,
  getStats,
  getChartData,
  getRecentActivity,
  getWarnings,
} from '../controllers/dashboard.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getDashboardData)
router.get('/stats', getStats)
router.get('/chart', getChartData)
router.get('/chart-data', getChartData)
router.get('/recent-activity', getRecentActivity)
router.get('/warnings', getWarnings)

export default router
</file>

<file path="server/src/routes/dispatch.routes.ts">
import { Router } from 'express'
import {
  getAllDispatchRecords,
  getDispatchRecordById,
  createDispatchRecord,
  recordPassengerDrop,
  issuePermit,
  processPayment,
  issueDepartureOrder,
  recordExit,
  deleteDispatchRecord,
  updateDispatchRecord,
} from '../controllers/dispatch.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllDispatchRecords)
router.get('/:id', getDispatchRecordById)
router.post('/', createDispatchRecord)
router.put('/:id', updateDispatchRecord)
router.delete('/:id', deleteDispatchRecord)
router.post('/:id/passenger-drop', recordPassengerDrop)
router.post('/:id/permit', issuePermit)
router.post('/:id/payment', processPayment)
router.post('/:id/departure-order', issueDepartureOrder)
router.post('/:id/exit', recordExit)

export default router
</file>

<file path="server/src/routes/province.routes.ts">
import { Router } from 'express'
import {
  getProvincesV1,
  getProvincesV2,
  getDistrictsByProvinceV1,
  getWardsByDistrictV1,
  getWardsByProvinceV2,
  clearCache,
} from '../controllers/province.controller.js'

const router = Router()

// Public routes (no authentication required for provinces API)

// V1 endpoints (trước sáp nhập - 63 tỉnh)
router.get('/v1', getProvincesV1)
router.get('/v1/:code/districts', getDistrictsByProvinceV1)
router.get('/v1/:provinceCode/districts/:districtCode/wards', getWardsByDistrictV1)

// V2 endpoints (sau sáp nhập 2025 - 34 tỉnh)
router.get('/v2', getProvincesV2)
router.get('/v2/:code/wards', getWardsByProvinceV2)

// Utility
router.post('/clear-cache', clearCache)

export default router
</file>

<file path="server/src/routes/vehicle.routes.ts">
import { Router } from 'express'
import {
  getAllVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  getVehicleDocumentAuditLogs,
  lookupVehicleByPlate,
} from '../controllers/vehicle.controller.js'
import { authenticate } from '../middleware/auth.js'

const router = Router()

router.use(authenticate)

router.get('/', getAllVehicles)
router.get('/lookup/:plate', lookupVehicleByPlate)
router.get('/:id/document-audit-logs', getVehicleDocumentAuditLogs)
router.get('/:id', getVehicleById)
router.post('/', createVehicle)
router.put('/:id', updateVehicle)
router.delete('/:id', deleteVehicle)

export default router
</file>

<file path="server/src/shared/database/base-repository.ts">
/**
 * Base Repository for Firebase Realtime Database
 * Provides common CRUD operations for all entities
 */

import { firebaseREST } from '../../lib/firebase-rest.js'
import { DatabaseError, NotFoundError } from '../errors/app-error.js'

export interface QueryOptions {
  orderBy?: string
  limitToFirst?: number
  limitToLast?: number
  startAt?: string | number
  endAt?: string | number
  equalTo?: string | number | boolean
}

export interface PaginationOptions {
  page?: number
  limit?: number
}

export interface PaginatedResult<T> {
  data: T[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasNext: boolean
    hasPrev: boolean
  }
}

/**
 * Base repository class with common CRUD operations
 */
export abstract class BaseRepository<TDB, TAPI> {
  protected readonly collectionPath: string

  constructor(collectionPath: string) {
    this.collectionPath = collectionPath
  }

  /**
   * Map database entity to API format
   * Must be implemented by child classes
   */
  protected abstract mapToAPI(db: TDB, ...args: unknown[]): TAPI

  /**
   * Map API entity to database format
   * Must be implemented by child classes
   */
  protected abstract mapToDB(api: Partial<TAPI>): Partial<TDB>

  /**
   * Generate a unique ID
   */
  protected generateId(): string {
    return `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 15)}`
  }

  /**
   * Get current timestamp
   */
  protected getTimestamp(): string {
    return new Date().toISOString()
  }

  /**
   * Get all records from the collection
   */
  async findAll(): Promise<TAPI[]> {
    try {
      const data = await firebaseREST.get(this.collectionPath)
      if (!data) return []

      return Object.keys(data).map((key) => {
        const record = { id: key, ...data[key] } as TDB
        return this.mapToAPI(record)
      })
    } catch (error) {
      console.error(`[${this.collectionPath}] findAll error:`, error)
      throw new DatabaseError(`Failed to fetch ${this.collectionPath}`)
    }
  }

  /**
   * Get all records with filtering
   */
  async findAllFiltered(filterFn: (item: TAPI) => boolean): Promise<TAPI[]> {
    const all = await this.findAll()
    return all.filter(filterFn)
  }

  /**
   * Get paginated records
   */
  async findPaginated(
    options: PaginationOptions = {},
    filterFn?: (item: TAPI) => boolean
  ): Promise<PaginatedResult<TAPI>> {
    const { page = 1, limit = 50 } = options

    let allItems = await this.findAll()
    if (filterFn) {
      allItems = allItems.filter(filterFn)
    }

    const total = allItems.length
    const totalPages = Math.ceil(total / limit)
    const startIndex = (page - 1) * limit
    const data = allItems.slice(startIndex, startIndex + limit)

    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      },
    }
  }

  /**
   * Find a single record by ID
   */
  async findById(id: string): Promise<TAPI | null> {
    try {
      const data = await firebaseREST.get(`${this.collectionPath}/${id}`)
      if (!data) return null

      const record = { id, ...data } as TDB
      return this.mapToAPI(record)
    } catch (error) {
      console.error(`[${this.collectionPath}] findById error:`, error)
      throw new DatabaseError(`Failed to fetch ${this.collectionPath}/${id}`)
    }
  }

  /**
   * Find a single record by ID or throw NotFoundError
   */
  async findByIdOrFail(id: string): Promise<TAPI> {
    const record = await this.findById(id)
    if (!record) {
      throw new NotFoundError(this.collectionPath, id)
    }
    return record
  }

  /**
   * Find records by a specific field value
   */
  async findByField(field: string, value: string | number | boolean): Promise<TAPI[]> {
    const all = await this.findAll()
    return all.filter((item) => {
      const record = item as Record<string, unknown>
      return record[field] === value
    })
  }

  /**
   * Find single record by field
   */
  async findOneByField(field: string, value: string | number | boolean): Promise<TAPI | null> {
    const results = await this.findByField(field, value)
    return results[0] || null
  }

  /**
   * Create a new record
   */
  async create(data: Partial<TAPI>): Promise<TAPI> {
    try {
      const id = this.generateId()
      const dbData = this.mapToDB(data)
      const timestamp = this.getTimestamp()

      const record = {
        ...dbData,
        id,
        created_at: timestamp,
        updated_at: timestamp,
      }

      await firebaseREST.set(`${this.collectionPath}/${id}`, record)

      return this.mapToAPI(record as unknown as TDB)
    } catch (error) {
      console.error(`[${this.collectionPath}] create error:`, error)
      throw new DatabaseError(`Failed to create ${this.collectionPath}`)
    }
  }

  /**
   * Update an existing record
   */
  async updateById(id: string, data: Partial<TAPI>): Promise<TAPI> {
    try {
      // Check if exists
      const existing = await this.findById(id)
      if (!existing) {
        throw new NotFoundError(this.collectionPath, id)
      }

      const dbData = this.mapToDB(data)
      const updateData = {
        ...dbData,
        updated_at: this.getTimestamp(),
      }

      await firebaseREST.update(`${this.collectionPath}/${id}`, updateData)

      return this.findByIdOrFail(id)
    } catch (error) {
      if (error instanceof NotFoundError) throw error
      console.error(`[${this.collectionPath}] update error:`, error)
      throw new DatabaseError(`Failed to update ${this.collectionPath}/${id}`)
    }
  }

  /**
   * Delete a record
   */
  async deleteById(id: string): Promise<void> {
    try {
      // Check if exists
      const existing = await this.findById(id)
      if (!existing) {
        throw new NotFoundError(this.collectionPath, id)
      }

      await firebaseREST.remove(`${this.collectionPath}/${id}`)
    } catch (error) {
      if (error instanceof NotFoundError) throw error
      console.error(`[${this.collectionPath}] delete error:`, error)
      throw new DatabaseError(`Failed to delete ${this.collectionPath}/${id}`)
    }
  }

  /**
   * Soft delete (set is_active to false)
   */
  async softDelete(id: string): Promise<TAPI> {
    return this.updateById(id, { isActive: false } as unknown as Partial<TAPI>)
  }

  /**
   * Check if a record exists
   */
  async exists(id: string): Promise<boolean> {
    const record = await this.findById(id)
    return record !== null
  }

  /**
   * Count all records
   */
  async count(filterFn?: (item: TAPI) => boolean): Promise<number> {
    const all = await this.findAll()
    if (filterFn) {
      return all.filter(filterFn).length
    }
    return all.length
  }

  /**
   * Get raw data from Firebase (for complex queries)
   */
  protected async getRawData(): Promise<Record<string, TDB> | null> {
    try {
      return await firebaseREST.get(this.collectionPath)
    } catch (error) {
      console.error(`[${this.collectionPath}] getRawData error:`, error)
      throw new DatabaseError(`Failed to fetch raw data from ${this.collectionPath}`)
    }
  }
}
</file>

<file path="server/src/shared/index.ts">
/**
 * Shared Module Exports
 * Central export point for all shared utilities
 */

// Database utilities
export * from './database/index.js'

// Error handling
export * from './errors/index.js'

// Mappers
export * from './mappers/index.js'

// API Response utilities
export * from './response/index.js'

// Services
export * from './services/index.js'

// Validation
export * from './validation/index.js'
</file>

<file path="server/src/types/index.ts">
/**
 * Types Index
 * Central export for all shared types
 */

// Common types (errors, responses, pagination)
export {
  isAppError,
  getErrorMessage,
  isDuplicateKeyError,
  isValidationError,
} from './common.js'

export type {
  AppError,
  ApiSuccessResponse,
  ApiErrorResponse,
  ApiResponse,
  PaginationParams,
  PaginatedResponse,
  BaseDBRecord,
  FirebaseQueryResult,
  FirebaseSingleResult,
  OperatorSummary,
  VehicleTypeSummary,
  RouteSummary,
  UserSummary,
} from './common.js'

// Re-export module-specific types for convenience
// Dispatch types
export type {
  DispatchRecord,
  DispatchDBRecord,
  DispatchFilters,
} from '../modules/dispatch/dispatch-types.js'

export type {
  DispatchStatusType,
  CreateDispatchInput,
  PassengerDropInput,
  IssuePermitInput,
  PaymentInput,
  DepartureOrderInput,
  ExitInput,
} from '../modules/dispatch/dispatch-validation.js'

// Fleet types
export type {
  VehicleRecord,
  VehicleDBRecord,
  VehicleDocument,
  VehicleDocuments,
  VehicleDocumentDB,
  VehicleFilters as VehicleQueryFilters,
  DriverRecord,
  DriverDBRecord,
  DriverFilters as DriverQueryFilters,
  OperatorInfo,
  DocumentType,
  AuditLogRecord,
} from '../modules/fleet/fleet-types.js'

export type {
  CreateVehicleInput,
  UpdateVehicleInput,
  CreateDriverInput,
  UpdateDriverInput,
  VehicleDocumentInput,
  VehicleDocumentsInput,
} from '../modules/fleet/fleet-validation.js'
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "moduleResolution": "node",
    "rootDir": "./src",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "isolatedModules": true,
    "typeRoots": ["./node_modules/@types"],
    "types": ["node", "jest"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="client/src/App.tsx">
import { lazy, Suspense } from "react"
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom"
import { ToastContainer } from "react-toastify"
import "react-toastify/dist/ReactToastify.css"
import { ProtectedRoute } from "@/features/auth"
import { MainLayout } from "@/components/layout/MainLayout"
import { PublicLayout } from "@/components/layout/PublicLayout"
import { PageLoader } from "@/components/common/PageLoader"
import { ChatWidget } from "@/features/chat"

// ============================================
// LAZY LOADED PAGES - Grouped by Feature Domain
// ============================================

// Auth Pages
const Login = lazy(() => import("@/pages/Login"))
const Register = lazy(() => import("@/pages/Register"))

// Public Pages
const HomePage = lazy(() => import("@/pages/HomePage"))
const LienHe = lazy(() => import("@/pages/LienHe"))

// Dashboard
const Dashboard = lazy(() => import("@/pages/Dashboard"))
const Profile = lazy(() => import("@/pages/Profile"))

// Dispatch (Dieu Do) Feature
const DieuDo = lazy(() => import("@/pages/DieuDo"))
const ThanhToan = lazy(() => import("@/pages/ThanhToan"))
const TaoMoiDonHang = lazy(() => import("@/pages/TaoMoiDonHang"))
const XeXuatBen = lazy(() => import("@/pages/XeXuatBen"))
const XeTraKhach = lazy(() => import("@/pages/XeTraKhach"))
const XeKhongDuDieuKien = lazy(() => import("@/pages/XeKhongDuDieuKien"))

// Fleet Management Feature
const QuanLyXe = lazy(() => import("@/pages/QuanLyXe"))
const QuanLyLaiXe = lazy(() => import("@/pages/QuanLyLaiXe"))
const QuanLyDonViVanTai = lazy(() => import("@/pages/QuanLyDonViVanTai"))
const QuanLyPhuHieuXe = lazy(() => import("@/pages/QuanLyPhuHieuXe"))

// Route & Location Management
const QuanLyTuyen = lazy(() => import("@/pages/QuanLyTuyen"))
const QuanLyBenDen = lazy(() => import("@/pages/QuanLyBenDen"))

// Service & Formula Management
const QuanLyDichVu = lazy(() => import("@/pages/QuanLyDichVu"))
const QuanLyBieuThuc = lazy(() => import("@/pages/QuanLyBieuThuc"))

// Shift Management
const DanhSachCaTruc = lazy(() => import("@/pages/DanhSachCaTruc"))

// Reports Feature
const BaoCao = lazy(() => import("@/pages/BaoCao"))
const BaoCaoXeTraKhach = lazy(() => import("@/pages/BaoCaoXeTraKhach"))
const BaoCaoTheoDoiLenhXuatBen = lazy(() => import("@/pages/BaoCaoTheoDoiLenhXuatBen"))
const BaoCaoTongHopTuyen = lazy(() => import("@/pages/BaoCaoTongHopTuyen"))
const BaoCaoTongHop = lazy(() => import("@/pages/BaoCaoTongHop"))
const BaoCaoDoanhThuBenBanVe = lazy(() => import("@/pages/BaoCaoDoanhThuBenBanVe"))
const BaoCaoCapPhepRaBen = lazy(() => import("@/pages/BaoCaoCapPhepRaBen"))
const BaoCaoTheoDoiLenhTraKhach = lazy(() => import("@/pages/BaoCaoTheoDoiLenhTraKhach"))
const BaoCaoNhatTrinhXe = lazy(() => import("@/pages/BaoCaoNhatTrinhXe"))
const BaoCaoXeDiThay = lazy(() => import("@/pages/BaoCaoXeDiThay"))
const BaoCaoXeKhongDuDieuKien = lazy(() => import("@/pages/BaoCaoXeKhongDuDieuKien"))
const BaoCaoXeRaVaoBen = lazy(() => import("@/pages/BaoCaoXeRaVaoBen"))
const BaoCaoXeTangCuong = lazy(() => import("@/pages/BaoCaoXeTangCuong"))
const BaoCaoChamCongDangTai = lazy(() => import("@/pages/BaoCaoChamCongDangTai"))
const BaoCaoLichSuGiayTo = lazy(() => import("@/pages/BaoCaoLichSuGiayTo"))
const LapBaoCao = lazy(() => import("@/pages/LapBaoCao"))
const BaoCaoTinhHinhHoatDongMau1 = lazy(() => import("@/pages/BaoCaoTinhHinhHoatDongMau1"))
const BaoCaoTinhHinhHoatDongMau3 = lazy(() => import("@/pages/BaoCaoTinhHinhHoatDongMau3"))
const BangKeDoanhThu = lazy(() => import("@/pages/BangKeDoanhThu"))
const BangKeDoanhThu02 = lazy(() => import("@/pages/BangKeDoanhThu02"))
const BangKeHoaDon = lazy(() => import("@/pages/BangKeHoaDon"))

// Pricing Pages
const BangGiaVeDienTu = lazy(() => import("@/pages/pricing/BangGiaVeDienTu"))
const BangGiaLenhVanChuyen = lazy(() => import("@/pages/pricing/BangGiaLenhVanChuyen"))
const BangGiaChuKySo = lazy(() => import("@/pages/pricing/BangGiaChuKySo"))
const BangGiaHoaDonDienTu = lazy(() => import("@/pages/pricing/BangGiaHoaDonDienTu"))

// Guide Pages
const HuongDanBanVeUyThac = lazy(() => import("@/pages/guide/HuongDanBanVeUyThac"))

function App() {
  return (
    <BrowserRouter future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
      <ToastContainer
        position="top-right"
        autoClose={3000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
        theme="light"
      />
      <Routes>
        {/* Auth Routes */}
        <Route path="/login" element={
          <Suspense fallback={<PageLoader />}>
            <Login />
          </Suspense>
        } />
        <Route path="/register" element={
          <Suspense fallback={<PageLoader />}>
            <Register />
          </Suspense>
        } />

        {/* Public Home */}
        <Route
          path="/"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <HomePage />
              </Suspense>
            </PublicLayout>
          }
        />
        <Route
          path="/home"
          element={<Navigate to="/" replace />}
        />

        {/* Dashboard */}
        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <Dashboard />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Dispatch Feature */}
        <Route
          path="/dieu-do"
          element={
            <ProtectedRoute>
              <MainLayout disablePadding>
                <Suspense fallback={<PageLoader />}>
                  <DieuDo />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/thanh-toan"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <ThanhToan />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/thanh-toan/:id"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <ThanhToan />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/thanh-toan/tao-moi"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <TaoMoiDonHang />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/truyen-tai/xe-xuat-ben"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <XeXuatBen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/truyen-tai/xe-tra-khach"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <XeTraKhach />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/truyen-tai/xe-khong-du-dieu-kien"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <XeKhongDuDieuKien />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Fleet Management */}
        <Route
          path="/quan-ly-xe"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyXe />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/quan-ly-lai-xe"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyLaiXe />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/quan-ly-don-vi-van-tai"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyDonViVanTai />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/quan-ly-phu-hieu-xe"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyPhuHieuXe />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Route & Location Management */}
        <Route
          path="/quan-ly-tuyen"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyTuyen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/quan-ly-ben-den"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyBenDen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Service & Formula Management */}
        <Route
          path="/quan-ly-dich-vu"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyDichVu />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/quan-ly-bieu-thuc"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <QuanLyBieuThuc />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Shift Management */}
        <Route
          path="/danh-sach-ca-truc"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <DanhSachCaTruc />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Reports Feature */}
        <Route
          path="/bao-cao"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCao />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/xe-tra-khach"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoXeTraKhach />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/theo-doi-lenh-xuat-ben"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTheoDoiLenhXuatBen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/tong-hop-tuyen"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTongHopTuyen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/tong-hop"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTongHop />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/doanh-thu-ben-ban-ve"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoDoanhThuBenBanVe />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/cap-phep-ra-ben"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoCapPhepRaBen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/theo-doi-lenh-tra-khach"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTheoDoiLenhTraKhach />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/nhat-trinh-xe"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoNhatTrinhXe />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/xe-di-thay"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoXeDiThay />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/xe-khong-du-dieu-kien"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoXeKhongDuDieuKien />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/xe-ra-vao-ben"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoXeRaVaoBen />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/xe-tang-cuong"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoXeTangCuong />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/cham-cong-dang-tai"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoChamCongDangTai />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/lich-su-giay-to"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoLichSuGiayTo />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/lap-bao-cao"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <LapBaoCao />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/tinh-hinh-hoat-dong-mau-1"
          element={
            <ProtectedRoute>
              <MainLayout disablePadding>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTinhHinhHoatDongMau1 />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/tinh-hinh-hoat-dong-mau-3"
          element={
            <ProtectedRoute>
              <MainLayout disablePadding>
                <Suspense fallback={<PageLoader />}>
                  <BaoCaoTinhHinhHoatDongMau3 />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/bang-ke-doanh-thu"
          element={
            <ProtectedRoute>
              <MainLayout disablePadding>
                <Suspense fallback={<PageLoader />}>
                  <BangKeDoanhThu />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/bang-ke-doanh-thu-02-rut-gon"
          element={
            <ProtectedRoute>
              <MainLayout disablePadding>
                <Suspense fallback={<PageLoader />}>
                  <BangKeDoanhThu02 />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />
        <Route
          path="/bao-cao/bang-ke-hoa-don"
          element={
            <ProtectedRoute>
              <MainLayout>
                <Suspense fallback={<PageLoader />}>
                  <BangKeHoaDon />
                </Suspense>
              </MainLayout>
            </ProtectedRoute>
          }
        />

        {/* Profile */}
        <Route
          path="/profile"
          element={
            <ProtectedRoute>
              <PublicLayout>
                <Suspense fallback={<PageLoader />}>
                  <Profile />
                </Suspense>
              </PublicLayout>
            </ProtectedRoute>
          }
        />

        {/* Pricing Pages */}
        <Route
          path="/pricing/electronic-ticket"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <BangGiaVeDienTu />
              </Suspense>
            </PublicLayout>
          }
        />
        <Route
          path="/pricing/dispatch-order"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <BangGiaLenhVanChuyen />
              </Suspense>
            </PublicLayout>
          }
        />
        <Route
          path="/pricing/icorp-signature"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <BangGiaChuKySo />
              </Suspense>
            </PublicLayout>
          }
        />
        <Route
          path="/pricing/icorp-invoice"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <BangGiaHoaDonDienTu />
              </Suspense>
            </PublicLayout>
          }
        />

        {/* Guide Pages */}
        <Route
          path="/guide/bus-station/consignment"
          element={
            <Suspense fallback={<PageLoader />}>
              <HuongDanBanVeUyThac />
            </Suspense>
          }
        />

        {/* Contact */}
        <Route
          path="/lien-he"
          element={
            <PublicLayout>
              <Suspense fallback={<PageLoader />}>
                <LienHe />
              </Suspense>
            </PublicLayout>
          }
        />

        {/* Fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
      <ChatWidget />
    </BrowserRouter>
  )
}

export default App
</file>

<file path="client/src/components/dashboard/stats/LiveActivityFeed.tsx">
import { Bus, CheckCircle, Banknote, ArrowRight, Target, Radio, MapPin } from "lucide-react";
import { cn } from "@/lib/utils";
import type { RecentActivity } from "@/services/dashboard.service";
import { LiveBeacon } from "./LiveBeacon";
import { formatVietnamTime } from "@/utils/timezone";

interface LiveActivityFeedProps {
  activities: RecentActivity[];
  isLoading: boolean;
}

export function LiveActivityFeed({ activities, isLoading }: LiveActivityFeedProps) {
  const getStatusConfig = (status: string) => {
    const configs: Record<
      string,
      { color: string; bg: string; icon: React.ElementType; label: string }
    > = {
      entered: {
        color: "text-blue-600",
        bg: "bg-blue-50",
        icon: ArrowRight,
        label: "Vào bến",
      },
      passengers_dropped: {
        color: "text-purple-600",
        bg: "bg-purple-50",
        icon: Target,
        label: "Trả khách",
      },
      permit_issued: {
        color: "text-amber-600",
        bg: "bg-amber-50",
        icon: CheckCircle,
        label: "Cấp nốt",
      },
      paid: {
        color: "text-emerald-600",
        bg: "bg-emerald-50",
        icon: Banknote,
        label: "Thanh toán",
      },
      departure_ordered: {
        color: "text-cyan-600",
        bg: "bg-cyan-50",
        icon: Radio,
        label: "Lệnh xuất",
      },
      departed: {
        color: "text-stone-600",
        bg: "bg-stone-100",
        icon: Bus,
        label: "Xuất bến",
      },
    };
    return (
      configs[status] || {
        color: "text-stone-600",
        bg: "bg-stone-100",
        icon: Bus,
        label: status,
      }
    );
  };

  if (isLoading) {
    return (
      <div className="space-y-3">
        {[1, 2, 3, 4].map((i) => (
          <div
            key={i}
            className="animate-pulse flex items-center gap-4 p-4 rounded-xl bg-stone-50"
          >
            <div className="w-12 h-12 rounded-xl bg-stone-200" />
            <div className="flex-1 space-y-2">
              <div className="h-4 bg-stone-200 rounded w-1/3" />
              <div className="h-3 bg-stone-200 rounded w-1/2" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (activities.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12">
        <div className="relative">
          <div className="w-20 h-20 rounded-2xl bg-stone-100 flex items-center justify-center">
            <Bus className="w-10 h-10 text-stone-300" />
          </div>
          {/* Floating dots animation */}
          <div
            className="absolute -top-2 -right-2 w-4 h-4 rounded-full bg-emerald-200 animate-bounce"
            style={{ animationDelay: "0ms" }}
          />
          <div
            className="absolute -bottom-1 -left-3 w-3 h-3 rounded-full bg-amber-200 animate-bounce"
            style={{ animationDelay: "150ms" }}
          />
          <div
            className="absolute top-1/2 -right-4 w-2 h-2 rounded-full bg-blue-200 animate-bounce"
            style={{ animationDelay: "300ms" }}
          />
        </div>
        <p className="text-stone-600 font-medium mt-4">Chưa có hoạt động nào</p>
        <p className="text-stone-400 text-sm">Các xe mới sẽ hiển thị tại đây</p>
      </div>
    );
  }

  return (
    <div className="space-y-2 max-h-[500px] overflow-y-auto pr-1">
      {activities.map((activity, index) => {
        const config = getStatusConfig(activity.status);
        const StatusIcon = config.icon;

        return (
          <div
            key={activity.id}
            className={cn(
              "group flex items-center gap-4 p-4 rounded-xl transition-all duration-300",
              "hover:bg-stone-50 border border-transparent hover:border-stone-200",
              "cursor-pointer",
              index === 0 &&
                "bg-emerald-50/50 border-emerald-100"
            )}
            style={{
              animation: `slideInRight 0.4s ease-out ${index * 0.1}s backwards`,
            }}
          >
            {/* Status Icon */}
            <div
              className={cn(
                "relative flex-shrink-0 w-12 h-12 rounded-xl flex items-center justify-center",
                config.bg
              )}
            >
              <StatusIcon className={cn("w-6 h-6", config.color)} />
              {index === 0 && (
                <span className="absolute -top-1 -right-1">
                  <LiveBeacon size="small" />
                </span>
              )}
            </div>

            {/* Content */}
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2">
                <p className="font-bold text-stone-800">
                  {activity.vehiclePlateNumber}
                </p>
                {index === 0 && (
                  <span className="px-2 py-0.5 rounded-full bg-emerald-500 text-white text-[10px] font-bold uppercase">
                    Mới
                  </span>
                )}
              </div>
              <div className="flex items-center gap-2 mt-0.5">
                <MapPin className="w-3 h-3 text-stone-400" />
                <p className="text-sm text-stone-500 truncate">
                  {activity.route || "Không có tuyến"}
                </p>
              </div>
            </div>

            {/* Time & Status */}
            <div className="flex-shrink-0 text-right">
              <span
                className={cn(
                  "inline-flex items-center gap-1.5 px-2.5 py-1 rounded-lg text-xs font-semibold",
                  config.bg,
                  config.color
                )}
              >
                <StatusIcon className="w-3 h-3" />
                {config.label}
              </span>
              <p className="text-xs text-stone-400 mt-1 font-mono">
                {formatVietnamTime(activity.entryTime)}
              </p>
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/sections/VehicleInfoSection.tsx">
import { Truck, AlertTriangle, CheckCircle } from "lucide-react";
import { format } from "date-fns";
import { formatVietnamTime } from "@/utils/timezone";
import { Select } from "@/components/ui/select";
import { Autocomplete } from "@/components/ui/autocomplete";
import { GlassCard, SectionHeader, FormField, StyledInput, StyledSelect } from "@/components/shared/styled-components";
import type { VehicleBadge } from "@/services/vehicle-badge.service";
import type { DispatchRecord, Schedule, Vehicle, Operator } from "@/types";

interface VehicleInfoSectionProps {
  record: DispatchRecord;
  readOnly: boolean;
  permitType: string;
  setPermitType: (value: string) => void;
  registeredPlateNumber: string;
  setRegisteredPlateNumber: (value: string) => void;
  selectedVehicle: Vehicle | null;
  vehicleBadges: VehicleBadge[];
  vehicles: Vehicle[];
  vehiclesWithStatus: (Vehicle & { isBusy: boolean })[];
  replacementVehicleId: string;
  setReplacementVehicleId: (value: string) => void;
  entryPlateNumber: string;
  setEntryPlateNumber: (value: string) => void;
  operatorNameFromVehicle: string;
  selectedOperatorId: string;
  setSelectedOperatorId: (value: string) => void;
  operators: Operator[];
  scheduleId: string;
  setScheduleId: (value: string) => void;
  routeId: string;
  schedules: Schedule[];
  departureTime: string;
}

export function VehicleInfoSection({
  record,
  readOnly,
  permitType,
  setPermitType,
  registeredPlateNumber,
  setRegisteredPlateNumber,
  selectedVehicle,
  vehicleBadges,
  vehicles: _vehicles,
  vehiclesWithStatus,
  replacementVehicleId,
  setReplacementVehicleId,
  entryPlateNumber,
  setEntryPlateNumber,
  operatorNameFromVehicle,
  selectedOperatorId,
  setSelectedOperatorId,
  operators,
  scheduleId,
  setScheduleId,
  routeId,
  schedules,
  departureTime,
}: VehicleInfoSectionProps) {
  return (
    <GlassCard>
      <SectionHeader
        icon={Truck}
        title="Thông tin xe"
        badge={
          <Select
            value={permitType}
            onChange={(e) => setPermitType(e.target.value)}
            className="ml-auto w-28 text-xs py-1.5 px-3 rounded-lg bg-gray-100 border-gray-200 text-gray-700"
            disabled={readOnly}
          >
            <option value="fixed">Cố định</option>
            <option value="temporary">Tạm thời</option>
          </Select>
        }
      />
      <div className="p-5 space-y-4">
        <div className="grid grid-cols-2 gap-4">
          <FormField label="Biển số đăng ký">
            <Autocomplete
              value={registeredPlateNumber || selectedVehicle?.plateNumber || ""}
              onChange={(value) => setRegisteredPlateNumber(value)}
              options={vehicleBadges
                .filter(badge => badge.license_plate_sheet)
                .map(badge => ({
                  value: badge.license_plate_sheet,
                  label: `${badge.license_plate_sheet} ${badge.operational_status === 'dang_chay' ? '(Đang chạy)' : '(Trong bến)'}`
                }))}
              placeholder="Chọn hoặc nhập biển số"
              disabled={readOnly}
              className="bg-gray-50 border-gray-200 rounded-xl"
            />
          </FormField>
          <FormField label="Xe đi thay">
            <Autocomplete
              value={replacementVehicleId}
              onChange={(value) => setReplacementVehicleId(value)}
              options={vehiclesWithStatus
                .filter(v => v.plateNumber && v.id !== selectedVehicle?.id)
                .map(v => ({
                  value: v.id,
                  label: `${v.plateNumber} ${v.isBusy ? '(Đang bận)' : '(Sẵn sàng)'}`
                }))}
              placeholder="Chọn hoặc nhập biển số xe thay thế"
              disabled={readOnly}
              className="bg-gray-50 border-gray-200 rounded-xl"
            />
            {replacementVehicleId && (() => {
              const selectedReplacement = vehiclesWithStatus.find(v => v.id === replacementVehicleId);
              if (selectedReplacement?.isBusy) {
                return (
                  <div className="flex items-center gap-1.5 mt-2 text-amber-600 text-xs">
                    <AlertTriangle className="h-3.5 w-3.5" />
                    <span>Xe đang bận (có dispatch chưa hoàn thành)</span>
                  </div>
                );
              }
              if (selectedReplacement) {
                return (
                  <div className="flex items-center gap-1.5 mt-2 text-emerald-600 text-xs">
                    <CheckCircle className="h-3.5 w-3.5" />
                    <span>Xe sẵn sàng</span>
                  </div>
                );
              }
              return null;
            })()}
          </FormField>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <FormField label="Biển số khi vào">
            <Autocomplete
              value={entryPlateNumber}
              onChange={(value) => setEntryPlateNumber(value)}
              options={vehicleBadges
                .filter(badge => badge.license_plate_sheet)
                .map(badge => ({
                  value: badge.license_plate_sheet,
                  label: `${badge.license_plate_sheet}`
                }))}
              placeholder="Nhập biển số"
              disabled={readOnly}
              className="bg-gray-50 border-gray-200 rounded-xl"
            />
          </FormField>
          <FormField label="Đơn vị vận tải">
            {operatorNameFromVehicle && !selectedOperatorId ? (
              <StyledInput
                value={operatorNameFromVehicle}
                readOnly
                className="bg-gray-100"
              />
            ) : (
              <StyledSelect
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
                disabled={readOnly}
              >
                <option value="">{operatorNameFromVehicle || "-- Chọn đơn vị --"}</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name} {op.code ? `(${op.code})` : ''}
                  </option>
                ))}
              </StyledSelect>
            )}
          </FormField>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <FormField label="Giờ vào bến">
            <StyledInput
              value={formatVietnamTime(record.entryTime, "HH:mm dd/MM/yyyy")}
              readOnly
              className="bg-gray-100"
            />
          </FormField>
          <FormField label="Biểu đồ giờ" required={!departureTime}>
            <StyledSelect
              value={scheduleId}
              onChange={(e) => setScheduleId(e.target.value)}
              disabled={!routeId || readOnly}
            >
              <option value="">
                {!routeId ? "Chọn tuyến trước" : schedules.length === 0 ? "Không có biểu đồ" : "Chọn giờ"}
              </option>
              {schedules.map((s) => (
                <option key={s.id} value={s.id}>
                  {format(new Date(`2000-01-01T${s.departureTime}`), "HH:mm:ss")}
                </option>
              ))}
            </StyledSelect>
          </FormField>
        </div>
      </div>
    </GlassCard>
  );
}
</file>

<file path="client/src/components/dispatch/ThemTaiXeDialog.tsx">
import { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { toast } from "react-toastify";
import { X, Search, User } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { driverService } from "@/services/driver.service";
import type { Driver } from "@/types";

interface ThemTaiXeDialogProps {
  operatorId?: string;  // Optional - load all drivers if not provided
  open: boolean;
  onClose: () => void;
  onSuccess: (driver: Driver) => void;
}

export function ThemTaiXeDialog({
  operatorId,
  open,
  onClose,
  onSuccess,
}: ThemTaiXeDialogProps) {
  const [drivers, setDrivers] = useState<Driver[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (open) {
      loadDrivers();
    }
  }, [open, operatorId]);

  const loadDrivers = async () => {
    setIsLoading(true);
    try {
      // Load drivers for specific operator, or all drivers if no operatorId
      const data = await driverService.getAll(operatorId || undefined, true);
      setDrivers(data);
    } catch (error) {
      console.error("Failed to load drivers:", error);
      toast.error("Không thể tải danh sách tài xế");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSelect = (driver: Driver) => {
    onSuccess(driver);
    onClose();
  };

  const filteredDrivers = drivers.filter(
    (d) =>
      d.fullName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      d.licenseNumber.toLowerCase().includes(searchTerm.toLowerCase()) ||
      d.phone?.includes(searchTerm)
  );

  if (!open) return null;

  return createPortal(
    <div className="fixed inset-0 z-[60] bg-black/50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-lg w-full max-w-2xl p-6 relative max-h-[90vh] flex flex-col">
        <button
          onClick={onClose}
          className="absolute right-4 top-4 text-gray-400 hover:text-gray-600"
        >
          <X className="h-5 w-5" />
        </button>

        <h2 className="text-xl font-bold mb-4">Chọn tài xế</h2>

        <div className="relative mb-4">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
          <Input
            placeholder="Tìm kiếm theo tên, số GPLX, SĐT..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-9"
          />
        </div>

        <div className="flex-1 overflow-y-auto border rounded-md">
          <table className="w-full text-sm text-left">
            <thead className="bg-gray-50 text-gray-700 font-medium sticky top-0">
              <tr>
                <th className="px-4 py-3 w-16">Ảnh</th>
                <th className="px-4 py-3">Họ và tên</th>
                <th className="px-4 py-3">Số GPLX</th>
                <th className="px-4 py-3">Hạng</th>
                <th className="px-4 py-3">SĐT</th>
                <th className="px-4 py-3 text-right">Thao tác</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {isLoading ? (
                <tr>
                  <td
                    colSpan={6}
                    className="px-4 py-8 text-center text-gray-500"
                  >
                    Đang tải...
                  </td>
                </tr>
              ) : filteredDrivers.length === 0 ? (
                <tr>
                  <td
                    colSpan={6}
                    className="px-4 py-8 text-center text-gray-500"
                  >
                    Không tìm thấy tài xế nào
                  </td>
                </tr>
              ) : (
                filteredDrivers.map((driver) => (
                  <tr key={driver.id} className="hover:bg-gray-50">
                    <td className="px-4 py-3">
                      {driver.imageUrl ? (
                        <img
                          src={driver.imageUrl}
                          alt={driver.fullName}
                          className="w-10 h-10 rounded-full object-cover border"
                        />
                      ) : (
                        <div className="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
                          <User className="h-5 w-5 text-gray-400" />
                        </div>
                      )}
                    </td>
                    <td className="px-4 py-3 font-medium">{driver.fullName}</td>
                    <td className="px-4 py-3">{driver.licenseNumber}</td>
                    <td className="px-4 py-3">{driver.licenseClass}</td>
                    <td className="px-4 py-3">{driver.phone || "-"}</td>
                    <td className="px-4 py-3 text-right">
                      <Button
                        size="sm"
                        onClick={() => handleSelect(driver)}
                        className="h-8"
                      >
                        Chọn
                      </Button>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>

        <div className="flex justify-end mt-4 pt-4 border-t">
          <Button variant="outline" onClick={onClose}>
            Đóng
          </Button>
        </div>
      </div>
    </div>,
    document.body
  );
}
</file>

<file path="client/src/components/dispatch/XeTraKhachDialog.tsx">
import { useState, useEffect } from "react"
import { toast } from "react-toastify"
import { Search } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import { Autocomplete } from "@/components/ui/autocomplete"
import { routeService, type LegacyRoute } from "@/services/route.service"
import { scheduleService } from "@/services/schedule.service"
import { dispatchService } from "@/services/dispatch.service"
import { vehicleService } from "@/services/vehicle.service"
import type { DispatchRecord, Schedule, Vehicle } from "@/types"
import { formatVietnamTime } from "@/utils/timezone"

interface XeTraKhachDialogProps {
  record: DispatchRecord
  onClose: () => void
  onSuccess?: () => void
}

export function XeTraKhachDialog({ 
  record, 
  onClose,
  onSuccess 
}: XeTraKhachDialogProps) {
  const [scheduleId, setScheduleId] = useState(record.scheduleId || "")
  const [passengersArrived, setPassengersArrived] = useState(
    record.passengersArrived?.toString() || "1"
  )
  const [routeId, setRouteId] = useState(record.routeId || "")
  const [signAndTransmit, setSignAndTransmit] = useState(true)
  const [printDisplay, setPrintDisplay] = useState(false)
  
  const [routes, setRoutes] = useState<LegacyRoute[]>([])
  const [schedules, setSchedules] = useState<Schedule[]>([])
  const [selectedVehicle, setSelectedVehicle] = useState<Vehicle | null>(null)
  const [transportOrderDisplay] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [scheduleSearchQuery, setScheduleSearchQuery] = useState("")

  useEffect(() => {
    loadRoutes()
    if (record.vehicleId) {
      loadVehicleDetails(record.vehicleId)
    }
  }, [])

  useEffect(() => {
    if (routeId) {
      loadSchedules(routeId)
    } else {
      setSchedules([])
    }
  }, [routeId])

  const loadRoutes = async () => {
    try {
      // Use legacy routes from Google Sheets sync (877 routes)
      const data = await routeService.getLegacy()
      setRoutes(data)
      // Set initial route if record has one
      if (record.routeId) {
        setRouteId(record.routeId)
      }
    } catch (error) {
      console.error("Failed to load routes:", error)
    }
  }

  const loadVehicleDetails = async (vehicleId: string) => {
    try {
      const vehicle = await vehicleService.getById(vehicleId)
      setSelectedVehicle(vehicle)
    } catch (error) {
      console.error("Failed to load vehicle details:", error)
    }
  }

  const loadSchedules = async (routeId: string) => {
    try {
      const data = await scheduleService.getAll(routeId, undefined, true)
      setSchedules(data)
      // Set initial schedule if record has one
      if (record.scheduleId && data.some(s => s.id === record.scheduleId)) {
        setScheduleId(record.scheduleId)
      }
    } catch (error) {
      console.error("Failed to load schedules:", error)
    }
  }

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    
    if (!routeId || !passengersArrived) {
      toast.warning("Vui lòng điền đầy đủ các trường bắt buộc")
      return
    }

    setIsLoading(true)
    try {
      await dispatchService.recordPassengerDrop(
        record.id,
        parseInt(passengersArrived)
      )

      // Update route if changed
      if (routeId !== record.routeId) {
        // You might need to add an API endpoint to update route
        // For now, we'll just record the passenger drop
      }

      if (onSuccess) {
        onSuccess()
      }
      onClose()
    } catch (error) {
      console.error("Failed to record passenger drop:", error)
      toast.error("Không thể xác nhận trả khách. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  const filteredSchedules = schedules.filter((schedule) => {
    if (!scheduleSearchQuery) return true
    const query = scheduleSearchQuery.toLowerCase()
    return (
      schedule.scheduleCode.toLowerCase().includes(query) ||
      (schedule.route?.routeName || '').toLowerCase().includes(query)
    )
  })

  const getVehicleDisplayText = () => {
    if (!selectedVehicle) return record.vehiclePlateNumber
    const operatorName = selectedVehicle.operator?.name || ''
    return `${record.vehiclePlateNumber}${operatorName ? ` (${operatorName})` : ''}`
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Left Panel - Form */}
        <div className="space-y-6">
          {/* Thông tin xe vào bến */}
          <div className="space-y-4">
            <h3 className="text-lg font-semibold text-gray-900">
              Thông tin xe vào bến
            </h3>
            
            <div>
              <Label htmlFor="vehicle">Biển kiểm soát</Label>
              <Input
                id="vehicle"
                value={getVehicleDisplayText()}
                className="mt-1 bg-gray-50"
                readOnly
              />
            </div>

            <div>
              <Label htmlFor="entryTime">Thời gian vào</Label>
              <Input
                id="entryTime"
                value={formatVietnamTime(record.entryTime, "HH:mm dd/MM/yyyy")}
                className="mt-1 bg-gray-50"
                readOnly
              />
            </div>
          </div>

          {/* Thông tin xe trả khách */}
          <div className="space-y-4 pt-4 border-t">
            <h3 className="text-lg font-semibold text-gray-900">
              Thông tin xe trả khách
            </h3>

            {/* Nhật trình - hiện tại ẩn vì chưa có data từ Google Sheets */}
            {schedules.length > 0 && (
              <div>
                <Label htmlFor="schedule">Chọn nhật trình</Label>
                <div className="relative mt-1">
                  <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
                  <Input
                    id="schedule"
                    placeholder="Tìm kiếm"
                    value={scheduleSearchQuery}
                    onChange={(e) => setScheduleSearchQuery(e.target.value)}
                    className="pl-10"
                  />
                </div>
                {scheduleSearchQuery && (
                  <div className="mt-1 border border-gray-200 rounded-md bg-white shadow-lg max-h-48 overflow-y-auto">
                    {filteredSchedules.length === 0 ? (
                      <div className="p-2 text-sm text-gray-500">Không tìm thấy nhật trình</div>
                    ) : (
                      filteredSchedules.map((schedule) => (
                        <button
                          key={schedule.id}
                          type="button"
                          onClick={() => {
                            setScheduleId(schedule.id)
                            setScheduleSearchQuery("")
                          }}
                          className="w-full text-left p-2 hover:bg-gray-100 text-sm"
                        >
                          {schedule.scheduleCode} - {schedule.route?.routeName || ''}
                        </button>
                      ))
                    )}
                  </div>
                )}
                {scheduleId && (
                  <div className="mt-2 text-sm text-gray-600">
                    Đã chọn: {schedules.find(s => s.id === scheduleId)?.scheduleCode || scheduleId}
                  </div>
                )}
              </div>
            )}

            <div>
              <Label htmlFor="passengersArrived">
                Số khách đến bến <span className="text-red-500">(*)</span>
              </Label>
              <Input
                id="passengersArrived"
                type="number"
                value={passengersArrived}
                onChange={(e) => setPassengersArrived(e.target.value)}
                className="mt-1"
                min="0"
                required
              />
            </div>

            <div>
              <Label htmlFor="route">
                Tuyến vận chuyển <span className="text-red-500">(*)</span>
              </Label>
              <Autocomplete
                value={routeId}
                onChange={(value) => setRouteId(value)}
                options={routes.map((r) => ({
                  value: r.id,
                  label: `${r.routePath} (${r.routeCode})`,
                }))}
                placeholder="Tìm tuyến vận chuyển..."
                className="mt-1"
              />
              {routeId && (
                <div className="mt-1 text-sm text-gray-600">
                  Đã chọn: {routes.find(r => r.id === routeId)?.routePath || routeId}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Right Panel - Transportation Order Display */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-gray-900">
            Bản thể hiện lệnh vận chuyển
          </h3>
          <div className="border border-gray-200 rounded-lg bg-gray-50 min-h-[400px] flex items-center justify-center relative">
            {transportOrderDisplay ? (
              <div className="p-4 text-sm text-gray-700">
                {transportOrderDisplay}
              </div>
            ) : (
              <p className="text-gray-400">Không có bản thể hiện</p>
            )}
            <div className="absolute bottom-4 left-1/2 -translate-x-1/2">
              <Search className="h-5 w-5 text-gray-400" />
            </div>
          </div>
        </div>
      </div>

      {/* Bottom Checkboxes */}
      <div className="flex items-center space-x-6 pt-4 border-t">
        <div className="flex items-center space-x-2">
          <Checkbox
            id="signAndTransmit"
            checked={signAndTransmit}
            onChange={(e) => setSignAndTransmit(e.target.checked)}
          />
          <Label htmlFor="signAndTransmit" className="cursor-pointer">
            Ký lệnh và truyền tải
          </Label>
        </div>
        <div className="flex items-center space-x-2">
          <Checkbox
            id="printDisplay"
            checked={printDisplay}
            onChange={(e) => setPrintDisplay(e.target.checked)}
          />
          <Label htmlFor="printDisplay" className="cursor-pointer">
            In bản thể hiện
          </Label>
        </div>
      </div>

      {/* Action Buttons */}
      <div className="flex justify-end gap-2 pt-4 border-t">
        <Button 
          type="button" 
          variant="outline" 
          onClick={onClose}
          disabled={isLoading}
        >
          HỦY
        </Button>
        <Button 
          type="submit"
          disabled={isLoading}
        >
          {isLoading ? "Đang xử lý..." : "XÁC NHẬN"}
        </Button>
      </div>
    </form>
  )
}
</file>

<file path="client/src/components/operator/OperatorForm.tsx">
import { useState, useEffect, useRef } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { toast } from "react-toastify"

import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import { Select } from "@/components/ui/select"
import { operatorService } from "@/services/operator.service"
import { Operator, OperatorInput } from "@/types"
import { provinceService, type Province, type District } from "@/services/province.service"

const operatorSchema = z.object({
  name: z.string().min(1, "Tên đơn vị là bắt buộc"),
  code: z.string().min(1, "Mã đơn vị là bắt buộc"),
  taxCode: z.string().min(1, "Mã số thuế là bắt buộc"),
  isTicketDelegated: z.boolean().optional(),
  province: z.string().min(1, "Tỉnh/Thành phố là bắt buộc"),
  district: z.string().min(1, "Quận/Huyện là bắt buộc"),
  address: z.string().min(1, "Địa chỉ là bắt buộc"),
  phone: z.string().min(1, "Số điện thoại là bắt buộc"),
  email: z.string().email("Email không hợp lệ").min(1, "Email là bắt buộc"),
  representativeName: z.string().min(1, "Người đại diện là bắt buộc"),
  representativePosition: z.string().min(1, "Chức vụ là bắt buộc"),
})

type OperatorFormData = z.infer<typeof operatorSchema>

interface OperatorWithSource extends Operator {
  source?: "database" | "legacy" | "google_sheets"
}

interface OperatorFormProps {
  operator: OperatorWithSource | null
  mode: "create" | "edit"
  onClose: () => void
}

export function OperatorForm({ operator, mode, onClose }: OperatorFormProps) {
  const [useApiV2, setUseApiV2] = useState(false) // false = v1 (trước sáp nhập), true = v2 (sau sáp nhập)
  const [provinces, setProvinces] = useState<Province[]>([])
  const [districts, setDistricts] = useState<District[]>([])
  const [isLoadingProvinces, setIsLoadingProvinces] = useState(false)
  const [isLoadingDistricts, setIsLoadingDistricts] = useState(false)
  const [selectedProvinceCode, setSelectedProvinceCode] = useState<string | null>(null)
  const isInitialMount = useRef(true)
  const isLoadingDistrictsRef = useRef(false)

  const {
    register,
    handleSubmit,
    setValue,
    watch,
    reset,
    formState: { errors, isSubmitting },
  } = useForm<OperatorFormData>({
    resolver: zodResolver(operatorSchema),
    defaultValues: operator
      ? {
          name: operator.name,
          code: operator.code,
          taxCode: operator.taxCode || "",
          isTicketDelegated: operator.isTicketDelegated,
          province: operator.province || "",
          district: operator.district || "",
          address: operator.address || "",
          phone: operator.phone || "",
          email: operator.email || "",
          representativeName: operator.representativeName || "",
          representativePosition: operator.representativePosition || "",
        }
      : {
          isTicketDelegated: false,
        },
  })

  const isTicketDelegated = watch("isTicketDelegated")
  const watchProvince = watch("province")
  const watchDistrict = watch("district")

  // Hàm normalize tên tỉnh để tìm kiếm gần đúng
  const normalizeProvinceName = (name: string): string => {
    if (!name) return ""
    // Loại bỏ các ký tự đặc biệt và chuẩn hóa
    return name
      .replace(/^Thành phố\s+/i, "")
      .replace(/^TP\.?\s*/i, "")
      .replace(/^Tỉnh\s+/i, "")
      .trim()
  }

  // Tìm province theo tên (có thể không khớp chính xác)
  const findProvinceByName = (name: string): Province | undefined => {
    if (!name || provinces.length === 0) return undefined
    
    // Tìm chính xác trước
    let province = provinces.find(p => p.name === name)
    if (province) return province
    
    // Tìm gần đúng
    const normalizedName = normalizeProvinceName(name)
    province = provinces.find(p => {
      const normalizedP = normalizeProvinceName(p.name)
      return normalizedP === normalizedName || 
             p.name.includes(name) || 
             name.includes(p.name) ||
             normalizedP.includes(normalizedName) ||
             normalizedName.includes(normalizedP)
    })
    
    return province
  }

  // Load provinces từ API
  const loadProvinces = async (apiVersion: boolean) => {
    setIsLoadingProvinces(true)
    try {
      const data = apiVersion
        ? await provinceService.getProvincesV2()
        : await provinceService.getProvincesV1()
      setProvinces(data)
    } catch (error) {
      console.error("Failed to load provinces:", error)
      toast.error("Không thể tải danh sách tỉnh thành. Vui lòng thử lại sau.")
    } finally {
      setIsLoadingProvinces(false)
    }
  }

  // Load districts khi chọn province
  const loadDistricts = async (provinceCode: string, apiVersion: boolean): Promise<District[]> => {
    if (!provinceCode) {
      setDistricts([])
      return []
    }

    // Tránh gọi lại nếu đang load
    if (isLoadingDistrictsRef.current) {
      return []
    }

    isLoadingDistrictsRef.current = true
    setIsLoadingDistricts(true)
    try {
      let result: District[] = []
      if (apiVersion) {
        // V2: Lấy phường/xã trực tiếp từ province (không có cấp quận/huyện)
        const wards = await provinceService.getWardsByProvinceV2(provinceCode)
        // Convert wards to districts format for display
        result = wards.map(w => ({ code: w.code, name: w.name }))
        setDistricts(result)
      } else {
        // V1: Lấy quận/huyện từ province
        result = await provinceService.getDistrictsByProvinceV1(provinceCode)
        setDistricts(result)
      }
      return result
    } catch (error) {
      console.error("Failed to load districts:", error)
      toast.error("Không thể tải danh sách quận/huyện. Vui lòng thử lại sau.")
      setDistricts([])
      return []
    } finally {
      setIsLoadingDistricts(false)
      isLoadingDistrictsRef.current = false
    }
  }

  // Load provinces khi component mount
  useEffect(() => {
    loadProvinces(useApiV2)
  }, [])

  // Reload provinces khi đổi API version
  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false
      return
    }
    loadProvinces(useApiV2)
    setDistricts([])
    setValue("province", "")
    setValue("district", "")
    setSelectedProvinceCode(null)
    isLoadingDistrictsRef.current = false
  }, [useApiV2, setValue])

  // Reset form khi operator thay đổi
  useEffect(() => {
    if (operator && mode === "edit") {
      reset({
        name: operator.name,
        code: operator.code,
        taxCode: operator.taxCode || "",
        isTicketDelegated: operator.isTicketDelegated,
        province: operator.province || "",
        district: operator.district || "",
        address: operator.address || "",
        phone: operator.phone || "",
        email: operator.email || "",
        representativeName: operator.representativeName || "",
        representativePosition: operator.representativePosition || "",
      })
    } else if (!operator && mode === "create") {
      reset({
        isTicketDelegated: false,
        province: "",
        district: "",
        address: "",
        phone: "",
        email: "",
        name: "",
        code: "",
        taxCode: "",
        representativeName: "",
        representativePosition: "",
      })
      setDistricts([])
      setSelectedProvinceCode(null)
    }
  }, [operator, mode, reset])

  // Load districts khi operator có province và provinces đã được load (edit mode)
  useEffect(() => {
    if (operator && operator.province && provinces.length > 0 && mode === "edit") {
      const province = findProvinceByName(operator.province)
      if (province && province.code !== selectedProvinceCode) {
        setSelectedProvinceCode(province.code)
        // Cập nhật lại giá trị province trong form nếu tên không khớp chính xác
        if (province.name !== operator.province) {
          setValue("province", province.name)
        }
        loadDistricts(province.code, useApiV2).then((loadedDistricts) => {
          // Tìm district tương ứng sau khi districts đã được load
          if (operator.district && loadedDistricts.length > 0) {
            const districtName = operator.district
            const district = loadedDistricts.find(d => {
              const normalizedD = normalizeProvinceName(d.name)
              const normalizedOpD = normalizeProvinceName(districtName)
              return d.name === districtName ||
                     normalizedD === normalizedOpD ||
                     d.name.includes(districtName) ||
                     districtName.includes(d.name)
            })
            if (district && district.name !== operator.district) {
              setValue("district", district.name)
            }
          }
        })
      }
    }
  }, [operator, provinces, selectedProvinceCode, mode, useApiV2, setValue])

  // Load districts khi province thay đổi (từ dropdown hoặc khi provinces load xong)
  useEffect(() => {
    if (watchProvince && provinces.length > 0) {
      const province = findProvinceByName(watchProvince)
      if (province && province.code !== selectedProvinceCode) {
        setSelectedProvinceCode(province.code)
        loadDistricts(province.code, useApiV2)
        // Reset district when province changes (chỉ trong create mode)
        if (mode === "create") {
          setValue("district", "")
        }
      }
    } else if (!watchProvince) {
      setDistricts([])
      setSelectedProvinceCode(null)
    }
  }, [watchProvince, provinces, selectedProvinceCode, mode, setValue, useApiV2])

  const onSubmit = async (data: OperatorFormData) => {
    try {
      const operatorData: OperatorInput = {
        name: data.name,
        code: data.code,
        taxCode: data.taxCode || undefined,
        isTicketDelegated: data.isTicketDelegated,
        province: data.province && data.province.trim() !== '' ? data.province.trim() : undefined,
        district: data.district && data.district.trim() !== '' ? data.district.trim() : undefined,
        address: data.address || undefined,
        phone: data.phone || undefined,
        email: data.email || undefined,
        representativeName: data.representativeName || undefined,
        representativePosition: data.representativePosition || undefined,
      }

      if (mode === "create") {
        await operatorService.create(operatorData)
        toast.success("Thêm đơn vị vận tải thành công")
      } else if (operator && mode === "edit") {
        // Use legacy endpoint for Google Sheets data
        if (operator.source === "legacy" || operator.source === "google_sheets") {
          await operatorService.updateLegacy(operator.id, operatorData)
        } else {
          await operatorService.update(operator.id, operatorData)
        }
        toast.success("Cập nhật đơn vị vận tải thành công")
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to save operator:", error)
      
      // Handle specific error messages from backend
      const errorMessage = error.response?.data?.error || error.message
      
      if (errorMessage?.includes("already exists") || errorMessage?.includes("duplicate key")) {
        toast.error("Mã đơn vị đã tồn tại. Vui lòng sử dụng mã khác.")
      } else {
        toast.error(errorMessage || "Có lỗi xảy ra. Vui lòng thử lại.")
      }
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6 w-full">
      <div className="space-y-6 w-full">
        {/* Section 1: Thông tin đơn vị vận tải */}
        <div className="space-y-4 w-full">
          <h3 className="text-xl font-semibold text-center">Thông tin đơn vị vận tải</h3>
          
          <div className="flex items-center space-x-2">
             <Checkbox 
              id="isTicketDelegated" 
              checked={isTicketDelegated}
              onChange={(e) => {
                setValue("isTicketDelegated", e.target.checked)
              }}
            />
            <Label htmlFor="isTicketDelegated" className="font-normal">Doanh nghiệp ủy thác bến xe bán vé</Label>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
             <div className="space-y-2">
              <Label htmlFor="code">Mã đơn vị <span className="text-red-500">*</span></Label>
              <Input id="code" {...register("code")} placeholder="DV001" />
              {errors.code && <p className="text-sm text-red-500">{errors.code.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="taxCode">Mã số thuế <span className="text-red-500">*</span></Label>
              <Input id="taxCode" {...register("taxCode")} />
              {errors.taxCode && <p className="text-sm text-red-500">{errors.taxCode.message}</p>}
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="name">Tên đơn vị <span className="text-red-500">*</span></Label>
            <Input id="name" {...register("name")} />
            {errors.name && <p className="text-sm text-red-500">{errors.name.message}</p>}
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="phone">Số điện thoại <span className="text-red-500">*</span></Label>
              <Input id="phone" {...register("phone")} />
              {errors.phone && <p className="text-sm text-red-500">{errors.phone.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email <span className="text-red-500">*</span></Label>
              <Input id="email" type="email" {...register("email")} />
              {errors.email && <p className="text-sm text-red-500">{errors.email.message}</p>}
            </div>
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between border-b pb-2">
              <Label className="text-base font-semibold">Địa chỉ</Label>
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="useApiV2"
                  checked={useApiV2}
                  onChange={(e) => setUseApiV2(e.target.checked)}
                  className="h-4 w-4"
                />
                <Label htmlFor="useApiV2" className="cursor-pointer text-sm font-normal">
                  Sử dụng dữ liệu sau sáp nhập
                </Label>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="province">
                  Tỉnh/Thành phố <span className="text-red-500">*</span>
                </Label>
                <Select
                  id="province"
                  {...register("province")}
                  value={watchProvince || ""}
                  disabled={isLoadingProvinces}
                  className={errors.province ? "border-red-500" : ""}
                >
                  <option value="">
                    {isLoadingProvinces ? "Đang tải..." : "Tỉnh/Thành phố"}
                  </option>
                  {provinces.map((province) => (
                    <option key={province.code} value={province.name}>
                      {province.name}
                    </option>
                  ))}
                </Select>
                {errors.province && (
                  <p className="text-sm text-red-500">{errors.province.message}</p>
                )}
              </div>
              <div className="space-y-2">
                <Label htmlFor="district">
                  {useApiV2 ? "Phường/Xã" : "Quận/Huyện"} <span className="text-red-500">*</span>
                </Label>
                <Select
                  id="district"
                  {...register("district")}
                  value={watchDistrict || ""}
                  disabled={!watchProvince || isLoadingDistricts}
                  className={errors.district ? "border-red-500" : ""}
                >
                  <option value="">
                    {isLoadingDistricts ? "Đang tải..." : useApiV2 ? "Phường/Xã" : "Quận/Huyện"}
                  </option>
                  {districts.map((district) => (
                    <option key={district.code} value={district.name}>
                      {district.name}
                    </option>
                  ))}
                </Select>
                {errors.district && (
                  <p className="text-sm text-red-500">{errors.district.message}</p>
                )}
                {watchProvince && !isLoadingDistricts && districts.length === 0 && (
                  <p className="text-sm text-gray-500">
                    Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                  </p>
                )}
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="address">Địa chỉ cụ thể <span className="text-red-500">*</span></Label>
            <Input id="address" {...register("address")} />
            {errors.address && <p className="text-sm text-red-500">{errors.address.message}</p>}
          </div>
        </div>

        {/* Section 2: Thông tin người đại diện pháp luật */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold">Thông tin người đại diện pháp luật</h3>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="representativeName">Đại diện <span className="text-red-500">*</span></Label>
              <Input id="representativeName" {...register("representativeName")} />
              {errors.representativeName && <p className="text-sm text-red-500">{errors.representativeName.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="representativePosition">Chức vụ <span className="text-red-500">*</span></Label>
              <Input id="representativePosition" {...register("representativePosition")} />
              {errors.representativePosition && <p className="text-sm text-red-500">{errors.representativePosition.message}</p>}
            </div>
          </div>
        </div>
      </div>

      <div className="flex justify-end space-x-4 pt-4 border-t">
        <Button type="button" variant="outline" onClick={onClose}>
          Hủy
        </Button>
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Đang xử lý..." : (mode === "create" ? "Thêm mới" : "Lưu thay đổi")}
        </Button>
      </div>
    </form>
  )
}
</file>

<file path="client/src/components/ui/autocomplete.tsx">
import * as React from "react"
import { useState, useRef, useEffect } from "react"
import { cn } from "@/lib/utils"
import { Input } from "./input"
import { ChevronDown, X } from "lucide-react"

export interface AutocompleteOption {
  value: string
  label: string
}

export interface AutocompleteProps {
  options: AutocompleteOption[]
  value?: string
  onChange?: (value: string) => void
  placeholder?: string
  className?: string
  disabled?: boolean
  id?: string
}

export function Autocomplete({
  options,
  value,
  onChange,
  placeholder = "Chọn hoặc nhập...",
  className,
  disabled,
  id,
}: AutocompleteProps) {
  const [open, setOpen] = useState(false)
  const [inputValue, setInputValue] = useState("")
  const containerRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLInputElement>(null)

  // Sync input value with selected value
  useEffect(() => {
    if (value) {
      const selected = options.find(opt => opt.value === value)
      setInputValue(selected?.label || value)
    } else {
      setInputValue("")
    }
  }, [value, options])

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setOpen(false)
      }
    }
    document.addEventListener("mousedown", handleClickOutside)
    return () => document.removeEventListener("mousedown", handleClickOutside)
  }, [])

  // Filter options based on input and limit to 100 items for performance
  const filteredOptions = options
    .filter(option =>
      option.label.toLowerCase().includes(inputValue.toLowerCase())
    )
    .slice(0, 100)

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value
    setInputValue(newValue)
    onChange?.(newValue)
    if (!open) setOpen(true)
  }

  const handleSelect = (option: AutocompleteOption) => {
    setInputValue(option.label)
    onChange?.(option.value)
    setOpen(false)
  }

  const handleClear = (e: React.MouseEvent) => {
    e.stopPropagation()
    e.preventDefault()
    setInputValue("")
    onChange?.("")
    inputRef.current?.focus()
    setOpen(true)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Escape") {
      setOpen(false)
    }
    if (e.key === "Enter") {
      setOpen(false)
    }
  }

  return (
    <div ref={containerRef} className={cn("relative", className)}>
      <Input
        ref={inputRef}
        id={id}
        value={inputValue}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        onFocus={() => setOpen(true)}
        onClick={() => setOpen(true)}
        placeholder={placeholder}
        disabled={disabled}
        className="pr-16"
        autoComplete="off"
      />
      <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
        {inputValue && !disabled && (
          <button
            type="button"
            onClick={handleClear}
            className="p-1 hover:bg-gray-100 rounded text-gray-400 hover:text-gray-600"
          >
            <X className="h-4 w-4" />
          </button>
        )}
        <button
          type="button"
          onClick={() => {
            setOpen(!open)
            inputRef.current?.focus()
          }}
          className="p-1 hover:bg-gray-100 rounded text-gray-400 hover:text-gray-600"
        >
          <ChevronDown className={cn("h-4 w-4 transition-transform", open && "rotate-180")} />
        </button>
      </div>
      
      {open && (
        <div className="absolute z-50 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg max-h-60 overflow-y-auto">
          {filteredOptions.length === 0 ? (
            <div className="py-3 px-4 text-sm text-gray-500">
              Không tìm thấy kết quả
            </div>
          ) : (
            filteredOptions.map((option) => (
              <div
                key={option.value}
                onClick={() => handleSelect(option)}
                className={cn(
                  "px-4 py-2 text-sm cursor-pointer hover:bg-blue-50",
                  value === option.value && "bg-blue-100 font-medium"
                )}
              >
                {option.label}
              </div>
            ))
          )}
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/features/chat/components/ChatWidget.tsx">
import { useEffect, useRef } from 'react'
import { MessageCircle, X, Trash2, Loader2, Bus, Headphones } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { useChatStore } from '../store/chatStore'
import { ChatMessage } from './ChatMessage'
import { ChatInput } from './ChatInput'

export function ChatWidget() {
  const {
    isOpen,
    messages,
    isLoading,
    toggleChat,
    sendMessage,
    clearChat
  } = useChatStore()

  const messagesEndRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  // Close on Escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        toggleChat()
      }
    }
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, toggleChat])

  return (
    <>
      {/* Chat Window */}
      {isOpen && (
        <div className="fixed bottom-24 right-4 w-[380px] h-[520px] bg-white rounded-2xl shadow-2xl shadow-stone-300/40 flex flex-col z-[9999] border border-stone-200/50 overflow-hidden">
          {/* Header */}
          <div className="flex items-center justify-between px-4 py-3.5 bg-stone-800 text-white">
            <div className="flex items-center gap-3">
              <div className="w-9 h-9 rounded-xl bg-emerald-500 flex items-center justify-center">
                <Headphones className="w-5 h-5" />
              </div>
              <div>
                <span className="font-semibold text-sm tracking-tight">Hỗ trợ trực tuyến</span>
                <div className="flex items-center gap-1.5">
                  <span className="w-1.5 h-1.5 bg-emerald-400 rounded-full animate-pulse" />
                  <span className="text-[10px] text-stone-400">Sẵn sàng hỗ trợ</span>
                </div>
              </div>
            </div>
            <div className="flex gap-1">
              <Button
                variant="ghost"
                size="icon"
                onClick={() => clearChat()}
                className="hover:bg-white/20 text-white h-8 w-8 rounded-lg"
                title="Xóa lịch sử chat"
              >
                <Trash2 className="w-4 h-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                onClick={toggleChat}
                className="hover:bg-white/20 text-white h-8 w-8 rounded-lg"
                title="Đóng (Esc)"
              >
                <X className="w-4 h-4" />
              </Button>
            </div>
          </div>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto bg-stone-50">
            {messages.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-full text-stone-500 text-sm p-6 text-center">
                <div className="w-14 h-14 rounded-2xl bg-stone-800 flex items-center justify-center mb-4">
                  <Bus className="w-7 h-7 text-emerald-400" />
                </div>
                <p className="font-semibold text-stone-800 mb-1">Xin chào!</p>
                <p className="text-xs text-stone-500 mb-6">
                  Hỏi về xe, tài xế, tuyến đường, phù hiệu...
                </p>
                <div className="text-left text-xs bg-white p-4 rounded-xl border border-stone-200 w-full">
                  <p className="font-medium mb-3 text-stone-600 uppercase tracking-wide text-[10px]">
                    Gợi ý tìm kiếm
                  </p>
                  <ul className="space-y-2.5 text-stone-600">
                    <li className="flex items-center gap-2 hover:text-emerald-600 cursor-pointer transition-colors">
                      <span className="w-1 h-1 bg-stone-300 rounded-full" />
                      xe 98H07480
                    </li>
                    <li className="flex items-center gap-2 hover:text-emerald-600 cursor-pointer transition-colors">
                      <span className="w-1 h-1 bg-stone-300 rounded-full" />
                      đơn vị Phương Trang
                    </li>
                    <li className="flex items-center gap-2 hover:text-emerald-600 cursor-pointer transition-colors">
                      <span className="w-1 h-1 bg-stone-300 rounded-full" />
                      thống kê điều độ
                    </li>
                    <li className="flex items-center gap-2 hover:text-emerald-600 cursor-pointer transition-colors">
                      <span className="w-1 h-1 bg-stone-300 rounded-full" />
                      tuyến TP.HCM - Đà Lạt
                    </li>
                  </ul>
                </div>
              </div>
            ) : (
              <>
                {messages.map((msg) => (
                  <ChatMessage key={msg.id} message={msg} />
                ))}
                {isLoading && (
                  <div className="flex gap-3 p-4">
                    <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-emerald-100 to-teal-100 flex items-center justify-center">
                      <Loader2 className="w-4 h-4 text-emerald-600 animate-spin" />
                    </div>
                    <div className="bg-white rounded-2xl px-4 py-2.5 text-sm text-stone-500 border border-stone-100">
                      Đang xử lý...
                    </div>
                  </div>
                )}
                <div ref={messagesEndRef} />
              </>
            )}
          </div>

          {/* Input */}
          <ChatInput onSend={sendMessage} disabled={isLoading} />
        </div>
      )}

      {/* Toggle Button */}
      <Button
        onClick={toggleChat}
        className={`fixed bottom-6 right-6 w-14 h-14 rounded-2xl shadow-xl z-[9999] transition-all duration-300 ${
          isOpen
            ? 'bg-stone-600 hover:bg-stone-500 shadow-stone-400/30'
            : 'bg-emerald-500 hover:bg-emerald-600 shadow-emerald-500/40'
        }`}
        size="icon"
      >
        {isOpen ? (
          <X className="w-5 h-5" />
        ) : (
          <MessageCircle className="w-5 h-5" />
        )}
      </Button>
    </>
  )
}
</file>

<file path="client/src/features/fleet/operators/api/operatorApi.ts">
// Operator API Service

import api from '@/lib/api'
import type { Operator, OperatorInput } from '../types'

export const operatorApi = {
  getAll: async (_isActive?: boolean): Promise<Operator[]> => {
    try {
      // Use legacy endpoint to get operators from RTDB (Google Sheets data)
      // This returns 2943+ operators vs only 3 from Supabase
      const response = await api.get<Operator[]>('/operators/legacy')
      return response.data
    } catch (error) {
      console.error('Error fetching operators:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Operator> => {
    const response = await api.get<Operator>(`/operators/${id}`)
    return response.data
  },

  create: async (input: OperatorInput): Promise<Operator> => {
    const response = await api.post<Operator>('/operators', input)
    return response.data
  },

  update: async (id: string, input: Partial<OperatorInput>): Promise<Operator> => {
    const response = await api.put<Operator>(`/operators/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/operators/${id}`)
  },
}

// Re-export for backward compatibility
export const operatorService = operatorApi
export default operatorApi
</file>

<file path="client/src/hooks/useOperatorDetail.ts">
import { useState, useEffect, useMemo } from "react";
import { toast } from "react-toastify";
import { vehicleService } from "@/services/vehicle.service";
import { vehicleBadgeService, type VehicleBadge } from "@/services/vehicle-badge.service";
import { invoiceService } from "@/services/invoice.service";
import { dispatchService } from "@/services/dispatch.service";
import type { Vehicle, Invoice, DispatchRecord, Operator } from "@/types";

// Extended Operator type with source field
type OperatorWithSource = Operator & {
  source?: "database" | "legacy" | "google_sheets";
};
import { format, parseISO, isValid } from "date-fns";

export interface PaymentHistoryItem {
  id: string;
  invoiceNumber: string;
  issueDate: string;
  paymentDate: string | null;
  totalAmount: number;
  source: "invoice" | "dispatch";
  vehiclePlateNumber?: string;
  routeName?: string;
}

// Extended Vehicle type for badge vehicles
interface BadgeVehicle {
  id: string;
  plateNumber: string;
  vehicleType: { id: string | null; name: string };
  vehicleTypeName: string;
  seatCapacity: number;
  bedCapacity: number;
  manufacturer: string;
  modelCode: string;
  manufactureYear: number | null;
  color: string;
  chassisNumber: string;
  engineNumber: string;
  operatorId: string | null;
  operator: { id: string | null; name: string; code: string };
  operatorName: string;
  isActive: boolean;
  notes: string;
  source: string;
  badgeNumber: string;
  badgeType: string;
  badgeExpiryDate: string;
  documents: Record<string, never>;
}

export function useOperatorDetail(operator: OperatorWithSource | null, open: boolean) {
  const [activeTab, setActiveTab] = useState("vehicles");
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [badges, setBadges] = useState<VehicleBadge[]>([]);
  const [allDispatchRecords, setAllDispatchRecords] = useState<DispatchRecord[]>([]);
  const [invoices, setInvoices] = useState<Invoice[]>([]);
  const [paidDispatchRecords, setPaidDispatchRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (open && operator) {
      loadData();
    }
  }, [open, operator]);

  const loadData = async () => {
    if (!operator) return;

    setIsLoading(true);
    setError(null);
    try {
      // Check if operator is from Google Sheets or legacy source (not from database)
      const isExternalOperator = operator.source === "google_sheets" || operator.source === "legacy" || operator.id.startsWith("legacy_");
      
      // Load badge vehicles by issuing_authority_ref (Ref_DonViCapPhuHieu)
      let vehiclesData: Vehicle[] = [];
      let badgesData: VehicleBadge[] = [];
      
      if (isExternalOperator) {
        // Load all badges and filter by issuing_authority_ref matching operator.id
        const allBadges = await vehicleBadgeService.getAll();
        badgesData = allBadges.filter(badge => 
          badge.issuing_authority_ref === operator.id
        );
        console.log('[OperatorDetail] Badges for operator', operator.id, '(', operator.name, '):', badgesData.length);
        
        // Convert badges to vehicle format for display
        vehiclesData = badgesData.map(badge => ({
          id: badge.id,
          plateNumber: badge.license_plate_sheet,
          vehicleType: { id: null, name: badge.badge_type || '' },
          vehicleTypeName: badge.badge_type || '',
          seatCapacity: 0,
          bedCapacity: 0,
          manufacturer: '',
          modelCode: '',
          manufactureYear: null,
          color: '',
          chassisNumber: '',
          engineNumber: '',
          operatorId: operator.id,
          operator: { id: operator.id, name: operator.name || '', code: '' },
          operatorName: operator.name || '',
          isActive: badge.status !== 'Thu hồi',
          notes: `Phù hiệu: ${badge.badge_number}`,
          source: 'badge',
          badgeNumber: badge.badge_number,
          badgeType: badge.badge_type,
          badgeExpiryDate: badge.expiry_date,
          documents: {},
        } as BadgeVehicle)) as unknown as Vehicle[];
        
        setBadges(badgesData);
      } else {
        vehiclesData = await vehicleService.getAll(operator.id, undefined, false);
      }
      setVehicles(Array.isArray(vehiclesData) ? vehiclesData : []);

      // Get vehicle plate numbers for filtering dispatch records
      const vehiclePlates = new Set(
        vehiclesData.map((v: Vehicle) => 
          v.plateNumber?.replace(/[.\-\s]/g, '').toUpperCase()
        ).filter(Boolean)
      );

      // Load all dispatch records and invoices
      const [allDispatch, invoicesData] = await Promise.all([
        dispatchService.getAll(),
        invoiceService.getAll(operator.id).catch(() => []),
      ]);

      // Filter dispatch records by vehicle plates
      const operatorDispatch = allDispatch.filter((record: DispatchRecord) => {
        const recordPlate = record.vehiclePlateNumber?.replace(/[.\-\s]/g, '').toUpperCase();
        return recordPlate && vehiclePlates.has(recordPlate);
      });

      setAllDispatchRecords(operatorDispatch);
      
      // Filter paid dispatch records
      const paidRecords = operatorDispatch.filter(
        (record: DispatchRecord) =>
          record.paymentTime &&
          record.paymentAmount &&
          record.paymentAmount > 0
      );
      setPaidDispatchRecords(paidRecords);

      setInvoices(Array.isArray(invoicesData) ? invoicesData : []);
    } catch (err: unknown) {
      console.error("Failed to load operator details:", err);
      const error = err as { response?: { data?: { error?: string } }; message?: string };
      const errorMessage =
        error?.response?.data?.error ||
        error?.message ||
        "Không thể tải thông tin chi tiết";
      setError(errorMessage);
      toast.error(errorMessage);
      setVehicles([]);
      setInvoices([]);
      setPaidDispatchRecords([]);
      setAllDispatchRecords([]);
    } finally {
      setIsLoading(false);
    }
  };

  // Unpaid dispatch records (công nợ từ dispatch - chưa thanh toán)
  const unpaidDispatchRecords = useMemo(
    () => allDispatchRecords.filter(
      (record) => !record.paymentTime && record.currentStatus !== 'cancelled'
    ),
    [allDispatchRecords]
  );

  // Legacy: unpaid invoices
  const unpaidInvoices = useMemo(
    () =>
      invoices.filter(
        (inv) => inv.paymentStatus === "pending" || inv.paymentStatus === "overdue"
      ),
    [invoices]
  );

  // Total debt from both dispatch records and invoices
  const totalDebt = useMemo(() => {
    // Sum service charges from unpaid dispatch records
    const dispatchDebt = unpaidDispatchRecords.reduce((sum, record) => {
      // Use metadata.totalServiceCharges if available, otherwise 0
      const metadata = record.metadata as { totalServiceCharges?: number } | undefined;
      return sum + (metadata?.totalServiceCharges || 0);
    }, 0);
    const invoiceDebt = unpaidInvoices.reduce((sum, inv) => sum + inv.totalAmount, 0);
    return dispatchDebt + invoiceDebt;
  }, [unpaidDispatchRecords, unpaidInvoices]);

  const paidInvoices = useMemo(
    () => invoices.filter((inv) => inv.paymentStatus === "paid"),
    [invoices]
  );

  const allPaymentHistory = useMemo(() => {
    const paymentHistoryFromDispatch: PaymentHistoryItem[] = paidDispatchRecords
      .filter((record) => record.paymentTime && record.paymentAmount)
      .map((record) => ({
        id: record.id,
        invoiceNumber:
          record.invoiceNumber || `ĐH-${record.id.substring(0, 8).toUpperCase()}`,
        issueDate: record.entryTime,
        paymentDate: record.paymentTime || null,
        totalAmount: record.paymentAmount || 0,
        source: "dispatch" as const,
        vehiclePlateNumber: record.vehiclePlateNumber,
        routeName: record.routeName,
      }));

    const combined: PaymentHistoryItem[] = [
      ...paidInvoices.map((inv) => ({
        id: inv.id,
        invoiceNumber: inv.invoiceNumber,
        issueDate: inv.issueDate,
        paymentDate: inv.paymentDate || inv.issueDate,
        totalAmount: inv.totalAmount,
        source: "invoice" as const,
      })),
      ...paymentHistoryFromDispatch,
    ].sort((a, b) => {
      const dateA = a.paymentDate ? parseISO(a.paymentDate).getTime() : 0;
      const dateB = b.paymentDate ? parseISO(b.paymentDate).getTime() : 0;
      return dateB - dateA;
    });

    return combined;
  }, [paidInvoices, paidDispatchRecords]);

  const totalPaid = useMemo(
    () => allPaymentHistory.reduce((sum, item) => sum + item.totalAmount, 0),
    [allPaymentHistory]
  );

  const formatDate = (dateString: string | undefined | null): string => {
    if (!dateString) return "N/A";
    try {
      const date = parseISO(dateString);
      return isValid(date) ? format(date, "dd/MM/yyyy") : "N/A";
    } catch {
      return "N/A";
    }
  };

  const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND",
    }).format(amount);
  };

  const resetTab = () => setActiveTab("vehicles");

  return {
    activeTab,
    setActiveTab,
    vehicles,
    badges,
    invoices,
    allDispatchRecords,
    paidDispatchRecords,
    unpaidDispatchRecords,
    isLoading,
    error,
    loadData,
    unpaidInvoices,
    totalDebt,
    paidInvoices,
    allPaymentHistory,
    totalPaid,
    formatDate,
    formatCurrency,
    resetTab,
  };
}
</file>

<file path="client/src/hooks/useOperatorManagement.ts">
import { useState, useEffect, useMemo } from "react";
import { toast } from "react-toastify";
import { operatorService } from "@/services/operator.service";
import { quanlyDataService } from "@/services/quanly-data.service";
import { useUIStore } from "@/store/ui.store";
import type { Operator } from "@/types";

export interface OperatorWithSource extends Operator {
  source?: "database" | "legacy" | "google_sheets";
  vehicleCount?: number;
}

const ITEMS_PER_PAGE = 20;

export function useOperatorManagement() {
  const [operators, setOperators] = useState<OperatorWithSource[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [filterStatus, setFilterStatus] = useState("");
  const [filterTicketDelegated, setFilterTicketDelegated] = useState("");
  const [filterProvince, setFilterProvince] = useState<"all" | "bac_ninh" | "ngoai_bac_ninh">("all");
  const [quickFilter, setQuickFilter] = useState<"all" | "active" | "inactive">("all");
  const [isLoading, setIsLoading] = useState(false);
  const [selectedOperator, setSelectedOperator] = useState<Operator | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create");
  const [detailDialogOpen, setDetailDialogOpen] = useState(false);
  const [selectedOperatorForDetail, setSelectedOperatorForDetail] = useState<Operator | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [displayMode, setDisplayMode] = useState<"table" | "grid">("table");
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [operatorToDelete, setOperatorToDelete] = useState<OperatorWithSource | null>(null);
  const setTitle = useUIStore((state) => state.setTitle);

  useEffect(() => {
    setTitle("Quản lý Đơn vị vận tải");
    loadOperators();
  }, [setTitle]);

  const loadOperators = async (forceRefresh = false) => {
    setIsLoading(true);
    try {
      // Use optimized unified endpoint for faster loading
      const data = await quanlyDataService.getOperators(forceRefresh);
      setOperators(data as OperatorWithSource[]);
    } catch (error) {
      console.error("Failed to load operators:", error);
      toast.error("Không thể tải danh sách đơn vị vận tải. Vui lòng thử lại sau.");
    } finally {
      setIsLoading(false);
    }
  };

  const stats = useMemo(() => {
    const active = operators.filter((o) => o.isActive).length;
    const inactive = operators.length - active;
    const delegated = operators.filter((o) => o.isTicketDelegated).length;
    
    // Check if province contains "Bắc Ninh" (handles variations like "Tỉnh Bắc Ninh", "Bắc Ninh", etc.)
    const isBacNinh = (province: string | undefined) => 
      province && province.toLowerCase().includes("bắc ninh");
    
    const bacNinh = operators.filter((o) => isBacNinh(o.province)).length;
    const ngoaiBacNinh = operators.filter((o) => o.province && !isBacNinh(o.province)).length;
    return { total: operators.length, active, inactive, delegated, bacNinh, ngoaiBacNinh };
  }, [operators]);

  const filteredOperators = useMemo(() => {
    return operators.filter((operator) => {
      if (quickFilter === "active" && !operator.isActive) return false;
      if (quickFilter === "inactive" && operator.isActive) return false;

      // Province filter - check if province contains "Bắc Ninh"
      const isBacNinh = operator.province && operator.province.toLowerCase().includes("bắc ninh");
      if (filterProvince === "bac_ninh" && !isBacNinh) return false;
      if (filterProvince === "ngoai_bac_ninh") {
        if (!operator.province || isBacNinh) return false;
      }

      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const matchesSearch =
          operator.name.toLowerCase().includes(query) ||
          (operator.code || "").toLowerCase().includes(query) ||
          (operator.phone || "").toLowerCase().includes(query) ||
          (operator.address || "").toLowerCase().includes(query) ||
          (operator.province || "").toLowerCase().includes(query);
        if (!matchesSearch) return false;
      }
      if (filterStatus) {
        const isActive = filterStatus === "active";
        if (operator.isActive !== isActive) return false;
      }
      if (filterTicketDelegated) {
        const isDelegated = filterTicketDelegated === "yes";
        if (operator.isTicketDelegated !== isDelegated) return false;
      }
      return true;
    });
  }, [operators, searchQuery, filterStatus, filterTicketDelegated, filterProvince, quickFilter]);

  const totalPages = Math.ceil(filteredOperators.length / ITEMS_PER_PAGE);

  const paginatedOperators = useMemo(() => {
    const start = (currentPage - 1) * ITEMS_PER_PAGE;
    return filteredOperators.slice(start, start + ITEMS_PER_PAGE);
  }, [filteredOperators, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchQuery, filterStatus, filterTicketDelegated, filterProvince, quickFilter]);

  const handleCreate = () => {
    setSelectedOperator(null);
    setViewMode("create");
    setDialogOpen(true);
  };

  const handleView = (operator: Operator) => {
    setSelectedOperator(operator);
    setViewMode("view");
    setDialogOpen(true);
  };

  const handleEdit = (operator: OperatorWithSource) => {
    setSelectedOperator(operator);
    setViewMode("edit");
    setDialogOpen(true);
  };

  const handleDelete = (operator: OperatorWithSource) => {
    setOperatorToDelete(operator);
    setDeleteDialogOpen(true);
  };

  const confirmDelete = async () => {
    if (!operatorToDelete) return;
    try {
      // Use legacy endpoint for Google Sheets data
      if (operatorToDelete.source === "legacy" || operatorToDelete.source === "google_sheets") {
        await operatorService.deleteLegacy(operatorToDelete.id);
      } else {
        await operatorService.delete(operatorToDelete.id);
      }
      toast.success("Xóa đơn vị vận tải thành công");
      setDeleteDialogOpen(false);
      setOperatorToDelete(null);
      loadOperators();
    } catch (error) {
      console.error("Failed to delete operator:", error);
      toast.error(
        "Không thể xóa đơn vị vận tải. Có thể đơn vị này đang có xe hoặc lái xe hoạt động."
      );
    }
  };

  const handleRowClick = (operator: Operator) => {
    setSelectedOperatorForDetail(operator);
    setDetailDialogOpen(true);
  };

  const clearFilters = () => {
    setSearchQuery("");
    setFilterStatus("");
    setFilterTicketDelegated("");
    setFilterProvince("all");
    setQuickFilter("all");
  };

  const hasActiveFilters = searchQuery || filterStatus || filterTicketDelegated || filterProvince !== "all";

  return {
    // Data
    operators,
    paginatedOperators,
    filteredOperators,
    stats,
    // Search & Filters
    searchQuery,
    setSearchQuery,
    filterStatus,
    setFilterStatus,
    filterTicketDelegated,
    setFilterTicketDelegated,
    filterProvince,
    setFilterProvince,
    quickFilter,
    setQuickFilter,
    hasActiveFilters,
    clearFilters,
    showAdvancedFilters,
    setShowAdvancedFilters,
    // Loading
    isLoading,
    loadOperators,
    // Pagination
    currentPage,
    setCurrentPage,
    totalPages,
    ITEMS_PER_PAGE,
    // Display
    displayMode,
    setDisplayMode,
    // Dialog states
    dialogOpen,
    setDialogOpen,
    viewMode,
    selectedOperator,
    detailDialogOpen,
    setDetailDialogOpen,
    selectedOperatorForDetail,
    setSelectedOperatorForDetail,
    deleteDialogOpen,
    setDeleteDialogOpen,
    operatorToDelete,
    setOperatorToDelete,
    // Handlers
    handleCreate,
    handleView,
    handleEdit,
    handleDelete,
    confirmDelete,
    handleRowClick,
  };
}
</file>

<file path="client/src/pages/BaoCaoXeTangCuong.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  StickyTable,
  StickyTableHeader,
  StickyTableBody,
  StickyTableRow,
  StickyTableHead,
  StickyTableCell,
} from "@/components/ui/sticky-table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { dispatchService } from "@/services/dispatch.service";
import { useUIStore } from "@/store/ui.store";
import { DatePickerRange } from "@/components/DatePickerRange";
import { formatVietnamDateTime } from "@/lib/vietnam-time";

interface ReinforcementVehicleData {
  plateNumber: string;
  operatorName: string;
  routeName: string;
  routeType: string;
  transportOrderCode: string;
  reinforcementDate: string;
  entryTime: string;
  entryBy: string;
  permitTime: string;
  permitBy: string;
  permitShift: string;
  paymentTime: string;
  paymentBy: string;
  departureOrderTime: string;
  departureOrderBy: string;
  departureOrderShift: string;
  exitTime: string;
  plannedDepartureTime: string;
  actualDepartureTime: string;
  exitBy: string;
  passengersDeparting: number;
  drivers: string;
  parkingLocation: string;
  notes: string;
  permitStatus: string;
  syncStatus: string;
}

export default function BaoCaoXeTangCuong() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [data, setData] = useState<ReinforcementVehicleData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  useEffect(() => {
    setTitle("Báo cáo > Xe tăng cường");
  }, [setTitle]);

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dateRange]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // Load dispatch records
      const dispatchRecords = await dispatchService.getAll();
      
      // Filter by date range if provided
      let filteredRecords = dispatchRecords;
      if (dateRange?.from && dateRange?.to) {
        const fromDate = new Date(dateRange.from);
        fromDate.setHours(0, 0, 0, 0);
        const toDate = new Date(dateRange.to);
        toDate.setHours(23, 59, 59, 999);
        
        filteredRecords = dispatchRecords.filter((record) => {
          if (record.entryTime) {
            const recordDate = new Date(record.entryTime);
            return recordDate >= fromDate && recordDate <= toDate;
          }
          return false;
        });
      }

      // Filter for reinforcement vehicles (xe tăng cường)
      // This could be identified by metadata or a specific flag
      // For now, show all records if no specific filter is available
      // In production, this should be filtered by metadata.isReinforcement or similar flag
      const reinforcementRecords = filteredRecords.filter(
        (record) => {
          // If metadata has reinforcement flag, use it
          const metadata = (record.metadata || {}) as Record<string, unknown>;
          if (metadata.isReinforcement === true || metadata.reinforcementDate) {
            return true;
          }
          // For now, show all records (can be adjusted based on actual data structure)
          // TODO: Add proper filter when reinforcement flag is available in database
          return true;
        }
      );

      // Map to reinforcement vehicle data
      const result = reinforcementRecords.map((record) => {
        const metadata = (record.metadata || {}) as Record<string, unknown>;
        return {
          plateNumber: record.vehiclePlateNumber || "-",
          operatorName: record.vehicle?.operator?.name || "-",
          routeName: record.routeName || "-",
          routeType: record.route?.routeType || "-",
          transportOrderCode: record.transportOrderCode || "-",
          reinforcementDate: String(metadata.reinforcementDate || record.entryTime || "-"),
          entryTime: record.entryTime || "-",
          entryBy: record.entryBy || "-",
          permitTime: record.boardingPermitTime || "-",
          permitBy: record.boardingPermitBy || "-",
          permitShift: String(metadata.permitShift || "-"),
          paymentTime: record.paymentTime || "-",
          paymentBy: record.paymentBy || "-",
          departureOrderTime: record.departureOrderTime || "-",
          departureOrderBy: record.departureOrderBy || "-",
          departureOrderShift: String(metadata.departureOrderShift || "-"),
          exitTime: record.exitTime || "-",
          plannedDepartureTime: record.plannedDepartureTime || "-",
          actualDepartureTime: String(metadata.actualDepartureTime || "-"),
          exitBy: record.exitBy || "-",
          passengersDeparting: record.passengersDeparting || 0,
          drivers: record.driverName || "-",
          parkingLocation: String(metadata.parkingLocation || "-"),
          notes: record.notes || "-",
          permitStatus: getPermitStatusLabel(record.permitStatus),
          syncStatus: getSyncStatus(record),
        };
      });

      setData(result);
    } catch (error) {
      console.error("Failed to load reinforcement vehicle data:", error);
      toast.error("Không thể tải dữ liệu báo cáo");
      setData([]); // Ensure data is set to empty array on error
    } finally {
      setIsLoading(false);
    }
  };

  const getPermitStatusLabel = (permitStatus?: string): string => {
    if (!permitStatus) return "Chưa ký";
    
    switch (permitStatus) {
      case "approved":
        return "Đã ký";
      case "rejected":
        return "Từ chối";
      case "pending":
        return "Chờ ký";
      default:
        return permitStatus;
    }
  };

  const getSyncStatus = (record: any): string => {
    if (record.metadata?.synced === true) {
      return "Đã đồng bộ";
    }
    
    if (record.transportOrderCode && record.permitStatus === "approved") {
      return "Đã đồng bộ";
    }
    
    if (record.updatedAt) {
      const updatedTime = new Date(record.updatedAt).getTime();
      const now = new Date().getTime();
      const diffHours = (now - updatedTime) / (1000 * 60 * 60);
      
      if (diffHours < 1) {
        return "Đang đồng bộ";
      }
    }
    
    return "Chưa đồng bộ";
  };

  const filteredData = useMemo(() => {
    return data.filter((item) => {
      // Search filter
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        return (
          item.plateNumber.toLowerCase().includes(query) ||
          item.operatorName.toLowerCase().includes(query) ||
          item.routeName.toLowerCase().includes(query) ||
          item.transportOrderCode.toLowerCase().includes(query)
        );
      }
      return true;
    });
  }, [data, searchQuery]);

  const handleExportExcel = () => {
    if (filteredData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredData.map((item, index) => ({
        "STT": index + 1,
        "Biển số": item.plateNumber,
        "Tên đơn vị": item.operatorName,
        "Tên luồng tuyến": item.routeName,
        "Loại tuyến": item.routeType,
        "Mã lệnh vận chuyển": item.transportOrderCode,
        "Ngày tăng cường": item.reinforcementDate !== "-" ? format(new Date(item.reinforcementDate), "dd/MM/yyyy") : "-",
        "Thời gian vào bến": item.entryTime !== "-" ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cho vào bến": item.entryBy,
        "Giờ cấp phép lên nốt": item.permitTime !== "-" ? format(new Date(item.permitTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cấp phép lên nốt": item.permitBy,
        "Ca trực cấp nốt": item.permitShift,
        "Thời gian thanh toán": item.paymentTime !== "-" ? format(new Date(item.paymentTime), "dd/MM/yyyy HH:mm") : "-",
        "Người thanh toán": item.paymentBy,
        "Giờ cấp lệnh xuất bến": item.departureOrderTime !== "-" ? format(new Date(item.departureOrderTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cấp lệnh": item.departureOrderBy,
        "Ca trực cấp lệnh": item.departureOrderShift,
        "Thời gian ra bến": item.exitTime !== "-" ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm") : "-",
        "Giờ xuất bến KH": item.plannedDepartureTime !== "-" ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Giờ xuất bến khách": item.actualDepartureTime !== "-" ? format(new Date(item.actualDepartureTime), "dd/MM/yyyy HH:mm") : "-",
        "Người cho ra bến": item.exitBy,
        "Số khách XB": item.passengersDeparting,
        "Danh sách lái xe": item.drivers,
        "Vị trí đỗ": item.parkingLocation,
        "Ghi chú": item.notes,
        "Trạng thái ký lệnh vận chuyển": item.permitStatus,
        "Trạng thái đồng bộ dữ liệu": item.syncStatus,
      }));

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe tăng cường");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số
        { wch: 25 },  // Tên đơn vị
        { wch: 25 },  // Tên luồng tuyến
        { wch: 15 },  // Loại tuyến
        { wch: 20 },  // Mã lệnh vận chuyển
        { wch: 15 },  // Ngày tăng cường
        { wch: 20 },  // Thời gian vào bến
        { wch: 20 },  // Người cho vào bến
        { wch: 20 },  // Giờ cấp phép lên nốt
        { wch: 20 },  // Người cấp phép lên nốt
        { wch: 15 },  // Ca trực cấp nốt
        { wch: 20 },  // Thời gian thanh toán
        { wch: 20 },  // Người thanh toán
        { wch: 20 },  // Giờ cấp lệnh xuất bến
        { wch: 20 },  // Người cấp lệnh
        { wch: 15 },  // Ca trực cấp lệnh
        { wch: 20 },  // Thời gian ra bến
        { wch: 20 },  // Giờ xuất bến KH
        { wch: 20 },  // Giờ xuất bến khách
        { wch: 20 },  // Người cho ra bến
        { wch: 12 },  // Số khách XB
        { wch: 20 },  // Danh sách lái xe
        { wch: 15 },  // Vị trí đỗ
        { wch: 30 },  // Ghi chú
        { wch: 25 },  // Trạng thái ký lệnh vận chuyển
        { wch: 25 },  // Trạng thái đồng bộ dữ liệu
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Bao-cao-xe-tang-cuong_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  const renderTime = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return formatVietnamDateTime(value);
    } catch {
      return "-";
    }
  };

  const renderDate = (value: string) => {
    if (value === "-" || !value) return "-";
    try {
      return format(new Date(value), "dd/MM/yyyy");
    } catch {
      return "-";
    }
  };

  // Sticky column positions (in pixels)
  const STICKY_COLUMN_WIDTH = 150;
  const NON_STICKY_COLUMN_WIDTH = 160;
  
  // Calculate positions: 3 sticky columns + 19 non-sticky columns before the last 2 sticky columns
  const stickyPositions = {
    plateNumber: 0,
    operatorName: STICKY_COLUMN_WIDTH,
    routeName: STICKY_COLUMN_WIDTH * 2,
    // Position after 3 sticky columns (450px) + 19 non-sticky columns (3040px)
    permitStatus: STICKY_COLUMN_WIDTH * 3 + (NON_STICKY_COLUMN_WIDTH * 19),
    // Position after permitStatus + its width
    syncStatus: STICKY_COLUMN_WIDTH * 3 + (NON_STICKY_COLUMN_WIDTH * 19) + STICKY_COLUMN_WIDTH,
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredData.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadData}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số, đơn vị, tuyến, mã lệnh..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
          </div>

          <div className="border rounded-lg overflow-auto">
            <StickyTable style={{ tableLayout: "fixed", width: "max-content" }}>
              <colgroup>
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${NON_STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
                <col style={{ width: `${STICKY_COLUMN_WIDTH}px`, minWidth: `${STICKY_COLUMN_WIDTH}px` }} />
              </colgroup>
              <StickyTableHeader>
                <StickyTableRow className="bg-gray-100">
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.plateNumber}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Biển số
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.operatorName}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Tên đơn vị
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyLeft={stickyPositions.routeName}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Tên luồng tuyến
                  </StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Loại tuyến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Mã lệnh vận chuyển</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ngày tăng cường</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian vào bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cho vào bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ cấp phép lên nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cấp phép lên nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cấp nốt</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người thanh toán</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ cấp lệnh xuất bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cấp lệnh</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ca trực cấp lệnh</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Thời gian ra bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến KH</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Giờ xuất bến khách</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Người cho ra bến</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Số khách XB</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Danh sách lái xe</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Vị trí đỗ</StickyTableHead>
                  <StickyTableHead className="text-center font-semibold">Ghi chú</StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyRight={STICKY_COLUMN_WIDTH}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Trạng thái ký lệnh vận chuyển
                  </StickyTableHead>
                  <StickyTableHead
                    sticky
                    stickyRight={0}
                    className="text-center font-semibold bg-gray-100"
                    style={{ width: "150px", minWidth: "150px", backgroundColor: "#f3f4f6" }}
                  >
                    Trạng thái đồng bộ dữ liệu
                  </StickyTableHead>
                </StickyTableRow>
              </StickyTableHeader>
              <StickyTableBody>
                {isLoading ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={25} className="text-center text-gray-500 py-8">
                      Đang tải dữ liệu...
                    </StickyTableCell>
                  </StickyTableRow>
                ) : filteredData.length === 0 ? (
                  <StickyTableRow>
                    <StickyTableCell colSpan={25} className="text-center text-gray-500 py-8">
                      Không có dữ liệu
                    </StickyTableCell>
                  </StickyTableRow>
                ) : (
                  filteredData.map((item, index) => (
                    <StickyTableRow key={`${item.plateNumber}-${item.entryTime}-${index}`}>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.plateNumber}
                        className="text-center font-semibold"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.plateNumber}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.operatorName}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.operatorName}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyLeft={stickyPositions.routeName}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.routeName}
                      </StickyTableCell>
                      <StickyTableCell className="text-center">{item.routeType}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.transportOrderCode}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderDate(item.reinforcementDate)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.entryTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.entryBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.permitTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.permitBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.permitShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.paymentTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.paymentBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.departureOrderTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.departureOrderBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.departureOrderShift}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.exitTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.plannedDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{renderTime(item.actualDepartureTime)}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.exitBy}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.passengersDeparting || "-"}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.drivers}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.parkingLocation}</StickyTableCell>
                      <StickyTableCell className="text-center">{item.notes}</StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyRight={STICKY_COLUMN_WIDTH}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.permitStatus}
                      </StickyTableCell>
                      <StickyTableCell
                        sticky
                        stickyRight={0}
                        className="text-center"
                        style={{ width: "150px", minWidth: "150px", backgroundColor: "#ffffff" }}
                      >
                        {item.syncStatus}
                      </StickyTableCell>
                    </StickyTableRow>
                  ))
                )}
              </StickyTableBody>
            </StickyTable>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/QuanLyLaiXe.tsx">
import { useState, useEffect, useMemo } from "react"
import { toast } from "react-toastify"
import { 
  Plus, 
  Search, 
  Edit, 
  Eye, 
  Trash2, 
  Users,
  UserCheck,
  UserX,
  Phone,
  CreditCard,
  Calendar,
  ChevronLeft,
  ChevronRight,
  LayoutGrid,
  List,
  RefreshCw,
  AlertCircle,
  TrendingUp,
  SlidersHorizontal,
  X,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Label } from "@/components/ui/label"
import { driverService } from "@/services/driver.service"
import type { Driver } from "@/types"
import { format, isValid, parseISO } from "date-fns"
import { useUIStore } from "@/store/ui.store"
import { DriverDialog } from "@/components/driver/DriverDialog"

// Helper function to safely format dates
const formatDate = (dateString: string | undefined | null): string => {
  if (!dateString) return "N/A"
  const date = typeof dateString === 'string' ? parseISO(dateString) : new Date(dateString)
  return isValid(date) ? format(date, "dd/MM/yyyy") : "N/A"
}

// Avatar color based on name hash
const getAvatarColor = (name: string) => {
  const colors = [
    'from-sky-400 to-sky-600',
    'from-emerald-400 to-emerald-600', 
    'from-amber-400 to-amber-600',
    'from-rose-400 to-rose-600',
    'from-violet-400 to-violet-600',
    'from-cyan-400 to-cyan-600',
    'from-pink-400 to-pink-600',
    'from-indigo-400 to-indigo-600',
  ]
  const hash = name.split('').reduce((a, b) => a + b.charCodeAt(0), 0)
  return colors[hash % colors.length]
}

// Skeleton Row Component
const SkeletonRow = () => (
  <tr className="animate-pulse">
    <td className="px-6 py-4">
      <div className="flex items-center gap-3">
        <div className="w-10 h-10 rounded-xl bg-slate-200" />
        <div>
          <div className="h-4 w-32 bg-slate-200 rounded mb-2" />
          <div className="h-3 w-20 bg-slate-100 rounded" />
        </div>
      </div>
    </td>
    <td className="px-6 py-4"><div className="h-4 w-28 bg-slate-200 rounded" /></td>
    <td className="px-6 py-4"><div className="h-4 w-32 bg-slate-200 rounded" /></td>
    <td className="px-6 py-4 text-center"><div className="h-4 w-24 bg-slate-200 rounded mx-auto" /></td>
    <td className="px-6 py-4 text-center"><div className="h-6 w-20 bg-slate-200 rounded-full mx-auto" /></td>
    <td className="px-6 py-4"><div className="h-8 w-24 bg-slate-200 rounded mx-auto" /></td>
  </tr>
)

// Quick Filter Chip
const QuickFilter = ({ label, count, active, onClick }: { 
  label: string; count?: number; active?: boolean; onClick: () => void 
}) => (
  <button
    onClick={onClick}
    className={`px-4 py-2 rounded-xl text-sm font-medium transition-all ${
      active 
        ? "bg-emerald-500 text-white shadow-md shadow-emerald-500/25" 
        : "bg-slate-100 text-slate-600 hover:bg-slate-200"
    }`}
  >
    {label}
    {count !== undefined && (
      <span className={`ml-2 px-2 py-0.5 rounded-full text-xs ${
        active ? "bg-white/20 text-white" : "bg-slate-200 text-slate-500"
      }`}>
        {count.toLocaleString()}
      </span>
    )}
  </button>
)

const ITEMS_PER_PAGE = 20

export default function QuanLyLaiXe() {
  const [drivers, setDrivers] = useState<Driver[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [filterStatus, setFilterStatus] = useState("")
  const [quickFilter, setQuickFilter] = useState<"all" | "active" | "inactive">("all")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedDriver, setSelectedDriver] = useState<Driver | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create")
  const [imageDialogOpen, setImageDialogOpen] = useState(false)
  const [selectedImageUrl, setSelectedImageUrl] = useState<string | null>(null)
  const [currentPage, setCurrentPage] = useState(1)
  const [displayMode, setDisplayMode] = useState<"table" | "grid">("table")
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const [driverToDelete, setDriverToDelete] = useState<Driver | null>(null)
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý lái xe")
    loadDrivers()
  }, [setTitle])

  const loadDrivers = async () => {
    setIsLoading(true)
    try {
      const data = await driverService.getAll()
      setDrivers(data)
    } catch (error) {
      console.error("Failed to load drivers:", error)
      toast.error("Không thể tải danh sách lái xe. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  // Stats
  const stats = useMemo(() => {
    const active = drivers.filter(d => d.isActive).length
    const inactive = drivers.length - active
    const withLicense = drivers.filter(d => d.licenseNumber).length
    return { total: drivers.length, active, inactive, withLicense }
  }, [drivers])

  const filteredDrivers = useMemo(() => {
    return drivers.filter((driver) => {
      // Quick filter
      if (quickFilter === "active" && !driver.isActive) return false
      if (quickFilter === "inactive" && driver.isActive) return false

      if (searchQuery) {
        const query = searchQuery.toLowerCase()
        const matchesSearch = 
          driver.fullName.toLowerCase().includes(query) ||
          (driver.phone || '').toLowerCase().includes(query) ||
          (driver.licenseNumber || '').toLowerCase().includes(query)
        if (!matchesSearch) return false
      }
      if (filterStatus) {
        const isActive = filterStatus === "active"
        if (driver.isActive !== isActive) return false
      }
      return true
    })
  }, [drivers, searchQuery, filterStatus, quickFilter])

  // Pagination
  const totalPages = Math.ceil(filteredDrivers.length / ITEMS_PER_PAGE)
  const paginatedDrivers = useMemo(() => {
    const start = (currentPage - 1) * ITEMS_PER_PAGE
    return filteredDrivers.slice(start, start + ITEMS_PER_PAGE)
  }, [filteredDrivers, currentPage])

  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, filterStatus, quickFilter])

  const handleCreate = () => {
    setSelectedDriver(null)
    setViewMode("create")
    setDialogOpen(true)
  }

  const handleEdit = (driver: Driver) => {
    setSelectedDriver(driver)
    setViewMode("edit")
    setDialogOpen(true)
  }

  const handleView = (driver: Driver) => {
    setSelectedDriver(driver)
    setViewMode("view")
    setDialogOpen(true)
  }

  const handleViewImage = (imageUrl: string) => {
    setSelectedImageUrl(imageUrl)
    setImageDialogOpen(true)
  }

  const handleDelete = (driver: Driver) => {
    setDriverToDelete(driver)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = async () => {
    if (!driverToDelete) return
    try {
      await driverService.delete(driverToDelete.id)
      toast.success("Xóa lái xe thành công")
      setDeleteDialogOpen(false)
      setDriverToDelete(null)
      loadDrivers()
    } catch (error) {
      console.error("Failed to delete driver:", error)
      toast.error("Không thể xóa lái xe. Vui lòng thử lại.")
    }
  }

  const clearFilters = () => {
    setSearchQuery("")
    setFilterStatus("")
    setQuickFilter("all")
  }

  const hasActiveFilters = searchQuery || filterStatus

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-slate-100 to-emerald-50">
      <div className="max-w-[1600px] mx-auto p-6 space-y-6">
        {/* Header */}
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div className="flex items-center gap-4">
            <div className="p-4 rounded-2xl bg-gradient-to-br from-emerald-500 to-green-500 shadow-xl shadow-emerald-500/30">
              <Users className="h-7 w-7 text-white" />
            </div>
            <div>
              <h1 className="text-3xl font-bold text-slate-800 tracking-tight">
                Quản lý lái xe
              </h1>
              <p className="text-slate-500 text-sm mt-1">
                Quản lý thông tin tài xế vận tải
              </p>
            </div>
          </div>
          
          <div className="flex items-center gap-3">
            <Button
              onClick={loadDrivers}
              disabled={isLoading}
              className="px-4 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 hover:border-slate-300 transition-all shadow-sm"
            >
              <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
              Làm mới
            </Button>
            <Button
              onClick={handleCreate}
              className="px-6 py-2.5 rounded-xl bg-gradient-to-r from-emerald-500 to-green-500 text-white font-semibold hover:from-emerald-600 hover:to-green-600 shadow-lg shadow-emerald-500/30 transition-all hover:shadow-xl hover:shadow-emerald-500/40 hover:-translate-y-0.5"
            >
              <Plus className="h-4 w-4 mr-2" />
              Thêm lái xe
            </Button>
          </div>
        </div>

        {/* Hero Stats - Asymmetric Layout */}
        <div className="grid grid-cols-12 gap-4">
          {/* Primary Stat - Hero Card */}
          <div className="col-span-12 lg:col-span-5 bg-gradient-to-br from-emerald-500 via-emerald-600 to-green-600 rounded-3xl p-8 text-white relative overflow-hidden">
            <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full -translate-y-1/2 translate-x-1/2" />
            <div className="absolute bottom-0 left-0 w-32 h-32 bg-white/5 rounded-full translate-y-1/2 -translate-x-1/2" />
            <div className="relative">
              <div className="flex items-center gap-2 text-emerald-100 mb-2">
                <Users className="h-5 w-5" />
                <span className="text-sm font-medium uppercase tracking-wider">Tổng số lái xe</span>
              </div>
              <p className="text-6xl font-bold tracking-tight">{stats.total.toLocaleString()}</p>
              <div className="flex items-center gap-2 mt-4 text-emerald-100">
                <TrendingUp className="w-4 h-4" />
                <span className="text-sm">Đang quản lý trong hệ thống</span>
              </div>
            </div>
          </div>

          {/* Secondary Stats */}
          <div className="col-span-12 lg:col-span-7 grid grid-cols-3 gap-4">
            {/* Active */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-emerald-100 group-hover:bg-emerald-500 transition-colors">
                  <UserCheck className="w-4 h-4 text-emerald-600 group-hover:text-white transition-colors" />
                </div>
                <span className="text-xs font-medium text-emerald-600 bg-emerald-50 px-2 py-1 rounded-full">
                  {stats.total > 0 ? Math.round((stats.active / stats.total) * 100) : 0}%
                </span>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.active.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Đang hoạt động</p>
              <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-emerald-400 to-emerald-500 rounded-full transition-all duration-500"
                  style={{ width: `${stats.total > 0 ? (stats.active / stats.total) * 100 : 0}%` }}
                />
              </div>
            </div>

            {/* Inactive */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-rose-100 group-hover:bg-rose-500 transition-colors">
                  <UserX className="w-4 h-4 text-rose-600 group-hover:text-white transition-colors" />
                </div>
                <span className="text-xs font-medium text-rose-600 bg-rose-50 px-2 py-1 rounded-full">
                  {stats.total > 0 ? Math.round((stats.inactive / stats.total) * 100) : 0}%
                </span>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.inactive.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Ngừng hoạt động</p>
              <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-rose-400 to-rose-500 rounded-full transition-all duration-500"
                  style={{ width: `${stats.total > 0 ? (stats.inactive / stats.total) * 100 : 0}%` }}
                />
              </div>
            </div>

            {/* With License */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-amber-100 group-hover:bg-amber-500 transition-colors">
                  <CreditCard className="w-4 h-4 text-amber-600 group-hover:text-white transition-colors" />
                </div>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.withLicense.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Có bằng lái</p>
              <div className="mt-3 flex items-center gap-1">
                {Array.from({ length: Math.min(5, stats.withLicense) }).map((_, i) => (
                  <div key={i} className="w-6 h-6 rounded-full bg-gradient-to-br from-amber-400 to-orange-500 border-2 border-white -ml-2 first:ml-0" />
                ))}
                {stats.withLicense > 5 && (
                  <span className="text-xs text-slate-500 ml-1">+{stats.withLicense - 5}</span>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Unified Search Bar */}
        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-2 flex flex-col lg:flex-row lg:items-center gap-2">
          {/* Search Input */}
          <div className="flex-1 flex items-center gap-3 px-4 py-2 bg-slate-50 rounded-xl">
            <Search className="w-5 h-5 text-slate-400" />
            <input 
              type="text"
              placeholder="Tìm kiếm tên, số điện thoại, bằng lái..."
              className="flex-1 bg-transparent border-none outline-none text-sm text-slate-700 placeholder-slate-400"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
          
          {/* Divider */}
          <div className="hidden lg:block w-px h-10 bg-slate-200" />
          
          {/* Quick Filters */}
          <div className="flex items-center gap-2 px-2">
            <QuickFilter 
              label="Tất cả" 
              count={stats.total} 
              active={quickFilter === "all"} 
              onClick={() => setQuickFilter("all")} 
            />
            <QuickFilter 
              label="Hoạt động" 
              count={stats.active} 
              active={quickFilter === "active"} 
              onClick={() => setQuickFilter("active")} 
            />
            <QuickFilter 
              label="Ngừng" 
              count={stats.inactive} 
              active={quickFilter === "inactive"} 
              onClick={() => setQuickFilter("inactive")} 
            />
          </div>

          {/* Divider */}
          <div className="hidden lg:block w-px h-10 bg-slate-200" />

          {/* View Toggle */}
          <div className="flex items-center gap-2 px-2">
            <div className="flex items-center bg-slate-100 rounded-xl p-1">
              <button
                onClick={() => setDisplayMode("table")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "table" 
                    ? "bg-white text-emerald-600 shadow-sm" 
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <List className="h-4 w-4" />
              </button>
              <button
                onClick={() => setDisplayMode("grid")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "grid" 
                    ? "bg-white text-emerald-600 shadow-sm" 
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <LayoutGrid className="h-4 w-4" />
              </button>
            </div>

            <Button
              onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
              className={`px-4 py-2.5 rounded-xl border transition-all ${
                showAdvancedFilters || hasActiveFilters
                  ? "bg-emerald-50 border-emerald-200 text-emerald-600"
                  : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50"
              }`}
            >
              <SlidersHorizontal className="h-4 w-4 mr-2" />
              Nâng cao
            </Button>
          </div>
        </div>

        {/* Advanced Filter Panel */}
        {showAdvancedFilters && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6 animate-in slide-in-from-top-2 duration-200">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">Trạng thái</Label>
                <select
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-emerald-500/30 focus:border-emerald-400 transition-all"
                >
                  <option value="">Tất cả trạng thái</option>
                  <option value="active">Đang hoạt động</option>
                  <option value="inactive">Ngừng hoạt động</option>
                </select>
              </div>
            </div>
            {hasActiveFilters && (
              <div className="mt-4 flex justify-end">
                <Button
                  onClick={clearFilters}
                  className="px-4 py-2 rounded-lg text-sm text-slate-500 hover:text-slate-700 hover:bg-slate-100 transition-all"
                >
                  Xóa bộ lọc
                </Button>
              </div>
            )}
          </div>
        )}

        {/* Results info */}
        <div className="flex items-center justify-between text-sm text-slate-500">
          <span>
            Hiển thị <strong className="text-slate-700">{paginatedDrivers.length}</strong> trong tổng số <strong className="text-slate-700">{filteredDrivers.length.toLocaleString()}</strong> lái xe
          </span>
          {totalPages > 1 && (
            <span>Trang {currentPage} / {totalPages}</span>
          )}
        </div>

        {/* Content - Table View */}
        {displayMode === "table" && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="bg-gradient-to-r from-slate-800 to-slate-900">
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Lái xe
                    </th>
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Số điện thoại
                    </th>
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Số bằng lái
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Hạn bằng lái
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Trạng thái
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Thao tác
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-100">
                  {isLoading ? (
                    Array.from({ length: 8 }).map((_, i) => <SkeletonRow key={i} />)
                  ) : paginatedDrivers.length === 0 ? (
                    <tr>
                      <td colSpan={6} className="px-6 py-16 text-center">
                        <div className="flex flex-col items-center">
                          <div className="relative mb-4">
                            <div className="w-24 h-24 rounded-full bg-gradient-to-br from-emerald-100 to-green-100 flex items-center justify-center">
                              <Users className="h-12 w-12 text-emerald-500" />
                            </div>
                            <div className="absolute -bottom-1 -right-1 w-8 h-8 rounded-full bg-white border-2 border-emerald-500 flex items-center justify-center">
                              <Plus className="w-4 h-4 text-emerald-500" />
                            </div>
                          </div>
                          <h3 className="text-lg font-semibold text-slate-800 mb-1">Chưa có lái xe nào</h3>
                          <p className="text-slate-500 mb-4">Bắt đầu bằng cách thêm lái xe đầu tiên</p>
                          {hasActiveFilters ? (
                            <Button onClick={clearFilters} className="text-emerald-600 hover:text-emerald-700">
                              Xóa bộ lọc
                            </Button>
                          ) : (
                            <Button onClick={handleCreate} className="bg-emerald-500 hover:bg-emerald-600 text-white rounded-xl px-6 py-2.5">
                              <Plus className="w-4 h-4 mr-2" />
                              Thêm lái xe
                            </Button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ) : (
                    paginatedDrivers.map((driver, index) => (
                      <tr 
                        key={driver.id} 
                        className="group hover:bg-emerald-50/50 transition-colors"
                        style={{ 
                          animation: 'fadeInUp 0.3s ease forwards',
                          animationDelay: `${index * 30}ms`,
                          opacity: 0
                        }}
                      >
                        <td className="px-6 py-4">
                          <div className="flex items-center gap-3">
                            {driver.imageUrl ? (
                              <img 
                                src={driver.imageUrl} 
                                alt={driver.fullName}
                                className="w-10 h-10 rounded-xl object-cover cursor-pointer hover:scale-105 transition-transform"
                                onClick={() => handleViewImage(driver.imageUrl!)}
                              />
                            ) : (
                              <div className={`w-10 h-10 rounded-xl bg-gradient-to-br ${getAvatarColor(driver.fullName)} flex items-center justify-center text-white font-bold text-sm shadow-md`}>
                                {driver.fullName.charAt(0).toUpperCase()}
                              </div>
                            )}
                            <div>
                              <p className="font-semibold text-slate-800">{driver.fullName}</p>
                              <p className="text-xs text-slate-500">Hạng {driver.licenseClass || "B2"}</p>
                            </div>
                          </div>
                        </td>
                        <td className="px-6 py-4">
                          <div className="flex items-center gap-2">
                            <Phone className="h-4 w-4 text-slate-400" />
                            <span className="text-slate-600">{driver.phone || "N/A"}</span>
                          </div>
                        </td>
                        <td className="px-6 py-4">
                          <span className="font-mono text-sm bg-slate-100 text-slate-700 px-3 py-1.5 rounded-lg">
                            {driver.licenseNumber || "N/A"}
                          </span>
                        </td>
                        <td className="px-6 py-4 text-center">
                          <div className="flex items-center justify-center gap-2 text-slate-600">
                            <Calendar className="h-4 w-4 text-slate-400" />
                            <span className="text-sm">{formatDate(driver.licenseExpiryDate)}</span>
                          </div>
                        </td>
                        <td className="px-6 py-4 text-center">
                          <span className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold ${
                            driver.isActive 
                              ? "bg-emerald-100 text-emerald-700" 
                              : "bg-slate-100 text-slate-600"
                          }`}>
                            <span className={`w-2 h-2 rounded-full ${
                              driver.isActive ? "bg-emerald-500 animate-pulse" : "bg-slate-400"
                            }`} />
                            {driver.isActive ? "Hoạt động" : "Ngừng"}
                          </span>
                        </td>
                        <td className="px-6 py-4">
                          <div className="flex items-center justify-center gap-1 opacity-60 group-hover:opacity-100 transition-opacity">
                            <button
                              onClick={() => handleView(driver)}
                              className="p-2 rounded-lg text-slate-500 hover:text-emerald-600 hover:bg-emerald-50 transition-all"
                              title="Xem chi tiết"
                            >
                              <Eye className="h-4 w-4" />
                            </button>
                            <button
                              onClick={() => handleEdit(driver)}
                              className="p-2 rounded-lg text-slate-500 hover:text-amber-600 hover:bg-amber-50 transition-all"
                              title="Chỉnh sửa"
                            >
                              <Edit className="h-4 w-4" />
                            </button>
                            <button
                              onClick={() => handleDelete(driver)}
                              className="p-2 rounded-lg text-slate-500 hover:text-rose-600 hover:bg-rose-50 transition-all"
                              title="Xóa"
                            >
                              <Trash2 className="h-4 w-4" />
                            </button>
                          </div>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>
        )}

        {/* Content - Grid View */}
        {displayMode === "grid" && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {isLoading ? (
              Array.from({ length: 8 }).map((_, i) => (
                <div key={i} className="bg-white rounded-2xl border border-slate-200 p-5 animate-pulse">
                  <div className="flex items-center gap-3 mb-4">
                    <div className="w-14 h-14 rounded-xl bg-slate-200" />
                    <div className="flex-1">
                      <div className="h-5 bg-slate-200 rounded w-3/4 mb-2" />
                      <div className="h-3 bg-slate-100 rounded w-1/2" />
                    </div>
                  </div>
                  <div className="space-y-2">
                    <div className="h-3 bg-slate-100 rounded" />
                    <div className="h-3 bg-slate-100 rounded w-2/3" />
                  </div>
                </div>
              ))
            ) : paginatedDrivers.length === 0 ? (
              <div className="col-span-full py-16 text-center">
                <Users className="h-16 w-16 text-slate-300 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-slate-800">Không tìm thấy lái xe nào</h3>
              </div>
            ) : (
              paginatedDrivers.map((driver, index) => (
                <div 
                  key={driver.id} 
                  className="bg-white rounded-2xl border border-slate-200 p-5 hover:shadow-lg hover:border-emerald-200 transition-all group hover:-translate-y-1"
                  style={{ 
                    animation: 'fadeInUp 0.3s ease forwards',
                    animationDelay: `${index * 50}ms`,
                    opacity: 0
                  }}
                >
                  <div className="flex items-start justify-between mb-4">
                    <div className="flex items-center gap-3">
                      {driver.imageUrl ? (
                        <img 
                          src={driver.imageUrl} 
                          alt={driver.fullName}
                          className="w-14 h-14 rounded-xl object-cover cursor-pointer hover:scale-105 transition-transform"
                          onClick={() => handleViewImage(driver.imageUrl!)}
                        />
                      ) : (
                        <div className={`w-14 h-14 rounded-xl bg-gradient-to-br ${getAvatarColor(driver.fullName)} flex items-center justify-center text-white font-bold text-xl shadow-lg`}>
                          {driver.fullName.charAt(0).toUpperCase()}
                        </div>
                      )}
                      <div>
                        <h3 className="font-bold text-slate-800">{driver.fullName}</h3>
                        <p className="text-sm text-slate-500">Hạng {driver.licenseClass || "B2"}</p>
                      </div>
                    </div>
                    <span className={`inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-semibold ${
                      driver.isActive 
                        ? "bg-emerald-100 text-emerald-700" 
                        : "bg-slate-100 text-slate-600"
                    }`}>
                      <span className={`w-1.5 h-1.5 rounded-full ${
                        driver.isActive ? "bg-emerald-500" : "bg-slate-400"
                      }`} />
                      {driver.isActive ? "Hoạt động" : "Ngừng"}
                    </span>
                  </div>

                  <div className="space-y-2 mb-4">
                    <div className="flex items-center gap-2 text-sm">
                      <Phone className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600">{driver.phone || "N/A"}</span>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                      <CreditCard className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600 font-mono">{driver.licenseNumber || "N/A"}</span>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                      <Calendar className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600">Hạn: {formatDate(driver.licenseExpiryDate)}</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-end gap-1 pt-4 border-t border-slate-100">
                    <button
                      onClick={() => handleView(driver)}
                      className="p-2 rounded-lg text-slate-400 hover:text-emerald-600 hover:bg-emerald-50 transition-all"
                    >
                      <Eye className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleEdit(driver)}
                      className="p-2 rounded-lg text-slate-400 hover:text-amber-600 hover:bg-amber-50 transition-all"
                    >
                      <Edit className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleDelete(driver)}
                      className="p-2 rounded-lg text-slate-400 hover:text-rose-600 hover:bg-rose-50 transition-all"
                    >
                      <Trash2 className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              ))
            )}
          </div>
        )}

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm px-6 py-4">
            <div className="flex items-center justify-between">
              <p className="text-sm text-slate-600">
                Hiển thị {((currentPage - 1) * ITEMS_PER_PAGE) + 1}-{Math.min(currentPage * ITEMS_PER_PAGE, filteredDrivers.length)} trong tổng số {filteredDrivers.length.toLocaleString()} lái xe
              </p>
              <div className="flex items-center gap-2">
                <Button
                  onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                  disabled={currentPage === 1}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronLeft className="h-4 w-4" />
                </Button>
                
                <div className="flex items-center gap-1">
                  {Array.from({ length: totalPages }, (_, i) => i + 1)
                    .filter((page) => 
                      page === 1 || 
                      page === totalPages || 
                      (page >= currentPage - 1 && page <= currentPage + 1)
                    )
                    .map((page, index, array) => (
                      <span key={page} className="flex items-center">
                        {index > 0 && array[index - 1] !== page - 1 && (
                          <span className="px-2 text-slate-400">...</span>
                        )}
                        <button
                          onClick={() => setCurrentPage(page)}
                          className={`min-w-[40px] h-10 rounded-xl text-sm font-medium transition-all ${
                            currentPage === page
                              ? "bg-emerald-500 text-white shadow-md shadow-emerald-500/25"
                              : "bg-white border border-slate-200 text-slate-600 hover:bg-slate-50"
                          }`}
                        >
                          {page}
                        </button>
                      </span>
                    ))}
                </div>

                <Button
                  onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                  disabled={currentPage === totalPages}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        )}

        {/* Driver Dialog */}
        <DriverDialog
          open={dialogOpen}
          onOpenChange={setDialogOpen}
          mode={viewMode}
          driver={selectedDriver}
          onSuccess={loadDrivers}
        />

        {/* Image Preview Dialog */}
        {imageDialogOpen && selectedImageUrl && (
          <div 
            className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4"
            onClick={() => setImageDialogOpen(false)}
          >
            <div className="relative max-w-4xl max-h-[90vh]">
              <button
                onClick={() => setImageDialogOpen(false)}
                className="absolute -top-12 right-0 p-2 rounded-full bg-white/10 text-white hover:bg-white/20 transition-colors"
              >
                <X className="w-6 h-6" />
              </button>
              <img
                src={selectedImageUrl}
                alt="Preview"
                className="max-w-full max-h-[85vh] rounded-2xl shadow-2xl"
              />
            </div>
          </div>
        )}

        {/* Delete Confirmation Dialog */}
        {deleteDialogOpen && (
          <div className="fixed inset-0 z-50 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 animate-in zoom-in-95 duration-200">
              <div className="flex items-center gap-4 mb-4">
                <div className="p-3 rounded-2xl bg-rose-100">
                  <AlertCircle className="h-6 w-6 text-rose-600" />
                </div>
                <div>
                  <h3 className="text-lg font-bold text-slate-800">Xác nhận xóa lái xe</h3>
                  <p className="text-sm text-slate-500">Thao tác này không thể hoàn tác</p>
                </div>
              </div>
              <p className="text-slate-600 mb-6">
                Bạn có chắc chắn muốn xóa lái xe <strong className="text-slate-800">{driverToDelete?.fullName}</strong>?
              </p>
              <div className="flex justify-end gap-3">
                <Button
                  onClick={() => {
                    setDeleteDialogOpen(false)
                    setDriverToDelete(null)
                  }}
                  className="px-5 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 transition-all"
                >
                  Hủy
                </Button>
                <Button
                  onClick={confirmDelete}
                  className="px-5 py-2.5 rounded-xl bg-gradient-to-r from-rose-500 to-red-500 text-white hover:from-rose-600 hover:to-red-600 shadow-lg shadow-rose-500/25 transition-all"
                >
                  Xóa lái xe
                </Button>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* CSS Animation */}
      <style>{`
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(8px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      `}</style>
    </div>
  )
}
</file>

<file path="client/src/services/province.service.ts">
// Province Service - Using backend proxy to fetch data from addresskit.cas.so
// Dữ liệu từ Tổng cục Thống kê, hỗ trợ cả trước và sau sáp nhập 2025

import api from '@/lib/api'

export interface Province {
  code: string
  name: string
}

export interface District {
  code: string
  name: string
}

export interface Ward {
  code: string
  name: string
}

// Cache for API responses
interface CacheEntry<T> {
  data: T
  timestamp: number
}

const CACHE_TTL = 60 * 60 * 1000 // 60 minutes - tăng cache để giảm API calls
let provincesV1Cache: CacheEntry<Province[]> | null = null
let provincesV2Cache: CacheEntry<Province[]> | null = null
const districtsCache: Map<string, CacheEntry<District[]>> = new Map()
const wardsCache: Map<string, CacheEntry<Ward[]>> = new Map()

function isCacheValid<T>(cache: CacheEntry<T> | null | undefined): cache is CacheEntry<T> {
  if (!cache) return false
  return Date.now() - cache.timestamp < CACHE_TTL
}

// ============= PROVINCE SERVICE =============

export const provinceService = {
  // ============= V1 METHODS (Trước sáp nhập - 63 tỉnh) =============

  // Lấy danh sách tỉnh/thành phố
  getProvincesV1: async (): Promise<Province[]> => {
    if (isCacheValid(provincesV1Cache)) {
      return provincesV1Cache.data
    }

    try {
      const response = await api.get<Province[]>('/provinces/v1')
      const provinces = response.data
      provincesV1Cache = { data: provinces, timestamp: Date.now() }
      return provinces
    } catch (error) {
      console.error('Error fetching provinces V1:', error)
      return []
    }
  },

  // Lấy quận/huyện của tỉnh
  getDistrictsByProvinceV1: async (provinceCode: string): Promise<District[]> => {
    if (!provinceCode) return []

    const cacheKey = `districts_${provinceCode}`
    const cached = districtsCache.get(cacheKey)
    if (isCacheValid(cached)) {
      return cached.data
    }

    try {
      const response = await api.get<District[]>(`/provinces/v1/${provinceCode}/districts`)
      const districts = response.data
      districtsCache.set(cacheKey, { data: districts, timestamp: Date.now() })
      return districts
    } catch (error) {
      console.error('Error fetching districts:', error)
      return []
    }
  },

  // Lấy phường/xã của quận/huyện
  getWardsByDistrictV1: async (provinceCode: string, districtCode: string): Promise<Ward[]> => {
    if (!provinceCode || !districtCode) return []

    const cacheKey = `wards_${provinceCode}_${districtCode}`
    const cached = wardsCache.get(cacheKey)
    if (isCacheValid(cached)) {
      return cached.data
    }

    try {
      const response = await api.get<Ward[]>(`/provinces/v1/${provinceCode}/districts/${districtCode}/wards`)
      const wards = response.data
      wardsCache.set(cacheKey, { data: wards, timestamp: Date.now() })
      return wards
    } catch (error) {
      console.error('Error fetching wards:', error)
      return []
    }
  },

  // ============= V2 METHODS (Sau sáp nhập 2025 - 34 tỉnh) =============

  // Lấy danh sách tỉnh/thành phố (sau sáp nhập)
  getProvincesV2: async (): Promise<Province[]> => {
    if (isCacheValid(provincesV2Cache)) {
      return provincesV2Cache.data
    }

    try {
      const response = await api.get<Province[]>('/provinces/v2')
      const provinces = response.data
      provincesV2Cache = { data: provinces, timestamp: Date.now() }
      return provinces
    } catch (error) {
      console.error('Error fetching provinces V2:', error)
      return []
    }
  },

  // Lấy phường/xã trực tiếp từ tỉnh (V2 không có cấp quận/huyện)
  getWardsByProvinceV2: async (provinceCode: string): Promise<Ward[]> => {
    if (!provinceCode) return []

    const cacheKey = `wards_v2_${provinceCode}`
    const cached = wardsCache.get(cacheKey)
    if (isCacheValid(cached)) {
      return cached.data
    }

    try {
      const response = await api.get<Ward[]>(`/provinces/v2/${provinceCode}/wards`)
      const wards = response.data
      wardsCache.set(cacheKey, { data: wards, timestamp: Date.now() })
      return wards
    } catch (error) {
      console.error('Error fetching wards V2:', error)
      return []
    }
  },

  // ============= SEARCH METHODS =============

  searchProvincesV1: async (query: string): Promise<Province[]> => {
    const provinces = await provinceService.getProvincesV1()
    const normalizedQuery = query.toLowerCase()
    return provinces.filter(p => p.name.toLowerCase().includes(normalizedQuery))
  },

  searchProvincesV2: async (query: string): Promise<Province[]> => {
    const provinces = await provinceService.getProvincesV2()
    const normalizedQuery = query.toLowerCase()
    return provinces.filter(p => p.name.toLowerCase().includes(normalizedQuery))
  },

  // ============= UTILITY METHODS =============

  clearCache: () => {
    provincesV1Cache = null
    provincesV2Cache = null
    districtsCache.clear()
    wardsCache.clear()
  },
}
</file>

<file path="client/src/services/shift.service.ts">
import api from '@/lib/api'
import type { Shift } from '@/types'

// Re-export Shift type for convenience
export type { Shift } from '@/types'

// Default shifts for fallback
const DEFAULT_SHIFTS: Shift[] = [
  { id: 'shift-1', name: 'Ca 1', startTime: '06:00:00', endTime: '14:00:00', isActive: true },
  { id: 'shift-2', name: 'Ca 2', startTime: '14:00:00', endTime: '22:00:00', isActive: true },
  { id: 'shift-3', name: 'Ca 3', startTime: '22:00:00', endTime: '06:00:00', isActive: true },
  { id: 'shift-4', name: 'Hành chính', startTime: '07:30:00', endTime: '17:00:00', isActive: true },
]

export const shiftService = {
  getAll: async (): Promise<Shift[]> => {
    try {
      const response = await api.get<Shift[]>('/shifts')
      if (!response.data || response.data.length === 0) {
        return DEFAULT_SHIFTS
      }
      return response.data
    } catch {
      // Shifts API not available, using default shifts
      return DEFAULT_SHIFTS
    }
  },

  getById: async (id: string): Promise<Shift> => {
    try {
      const response = await api.get<Shift>(`/shifts/${id}`)
      return response.data
    } catch (error) {
      const defaultShift = DEFAULT_SHIFTS.find(s => s.id === id)
      if (defaultShift) return defaultShift
      throw new Error('Shift not found')
    }
  },

  create: async (input: { name: string; startTime: string; endTime: string }): Promise<Shift> => {
    const response = await api.post<Shift>('/shifts', input)
    return response.data
  },

  update: async (
    id: string,
    input: Partial<{ name: string; startTime: string; endTime: string; isActive: boolean }>
  ): Promise<Shift> => {
    const response = await api.put<Shift>(`/shifts/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/shifts/${id}`)
  },
}
</file>

<file path="client/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      fontFamily: {
        display: ['"Playfair Display"', 'Georgia', 'serif'],
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "#3B82F6",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "#EF4444",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        success: {
          DEFAULT: "#10B981",
        },
        warning: {
          DEFAULT: "#F59E0B",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "fade-in": {
          from: { opacity: "0", transform: "translateY(10px)" },
          to: { opacity: "1", transform: "translateY(0)" },
        },
        "slide-in-right": {
          from: { opacity: "0", transform: "translateX(20px)" },
          to: { opacity: "1", transform: "translateX(0)" },
        },
        "scale-in": {
          from: { opacity: "0", transform: "scale(0.95)" },
          to: { opacity: "1", transform: "scale(1)" },
        },
        "pulse-soft": {
          "0%, 100%": { opacity: "1" },
          "50%": { opacity: "0.8" },
        },
        "float": {
          "0%, 100%": { transform: "translateY(0px)" },
          "50%": { transform: "translateY(-10px)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in": "fade-in 0.5s ease-out forwards",
        "slide-in-right": "slide-in-right 0.4s ease-out forwards",
        "scale-in": "scale-in 0.3s ease-out forwards",
        "pulse-soft": "pulse-soft 2s ease-in-out infinite",
        "float": "float 3s ease-in-out infinite",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
</file>

<file path="server/database.rules.json">
{
  "rules": {
    ".read": false,
    ".write": false,
    "users": {
      ".indexOn": ["username", "email", "role", "created_at"]
    },
    "operators": {
      ".indexOn": ["code", "name", "is_active", "created_at"]
    },
    "vehicles": {
      ".indexOn": ["plate_number", "operator_id", "vehicle_type_id", "is_active", "created_at"]
    },
    "drivers": {
      ".indexOn": ["operator_id", "full_name", "license_number", "is_active", "created_at"]
    },
    "routes": {
      ".indexOn": ["route_code", "route_name", "origin_id", "destination_id", "is_active", "created_at"]
    },
    "route_stops": {
      ".indexOn": ["route_id", "stop_order"]
    },
    "locations": {
      ".indexOn": ["code", "name", "province", "is_active", "created_at"]
    },
    "schedules": {
      ".indexOn": ["route_id", "operator_id", "schedule_code", "is_active", "created_at"]
    },
    "dispatch_records": {
      ".indexOn": ["vehicle_id", "driver_id", "route_id", "operator_id", "current_status", "entry_time", "exit_time", "created_at"]
    },
    "invoices": {
      ".indexOn": ["operator_id", "dispatch_record_id", "payment_status", "issue_date", "created_at"]
    },
    "services": {
      ".indexOn": ["code", "is_active", "created_at"]
    },
    "shifts": {
      ".indexOn": ["name", "is_active", "created_at"]
    },
    "vehicle_types": {
      ".indexOn": ["name", "created_at"]
    },
    "vehicle_documents": {
      ".indexOn": ["vehicle_id", "document_type", "expiry_date"]
    },
    "violations": {
      ".indexOn": ["dispatch_record_id", "vehicle_id", "driver_id", "created_at"]
    },
    "service_charges": {
      ".indexOn": ["dispatch_record_id", "service_id", "created_at"]
    },
    "driver_operators": {
      ".indexOn": ["driver_id", "operator_id", "is_primary"]
    },
    "audit_logs": {
      ".indexOn": ["entity_type", "entity_id", "user_id", "created_at"]
    }
  }
}
</file>

<file path="server/firebase.json">
{
  "functions": [
    {
      "source": ".",
      "codebase": "default",
      "runtime": "nodejs20",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local",
        ".env",
        ".env.*",
        "src/**/__tests__/**",
        "src/**/*.test.ts",
        "jest.config.js",
        "tsconfig.build.json"
      ],
      "predeploy": [
        "npm run build"
      ]
    }
  ],
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "database": {
    "rules": "database.rules.json"
  }
}
</file>

<file path="server/src/controllers/province.controller.ts">
import { Request, Response } from 'express'

// API Base URL - addresskit.cas.so (Dữ liệu từ Tổng cục Thống kê)
const API_BASE_URL = 'https://production.cas.so/address-kit'

// Type definitions for API responses
interface ProvincesResponse {
  provinces?: Array<{ code: string; name: string }>
}

interface CommunesResponse {
  communes?: Array<{
    code: string
    name: string
    districtCode?: string
    districtName?: string
  }>
}

// Effective dates
const V1_EFFECTIVE_DATE = '2024-01-01' // Trước sáp nhập - 63 tỉnh
const V2_EFFECTIVE_DATE = 'latest'      // Sau sáp nhập 2025 - 34 tỉnh

// Cache for API responses (server-side cache)
interface CacheEntry {
  data: any
  timestamp: number
}

const CACHE_TTL = 24 * 60 * 60 * 1000 // 24 hours - dữ liệu địa chính ít thay đổi
const cache: Map<string, CacheEntry> = new Map()

function getCached(key: string): any | null {
  const entry = cache.get(key)
  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.data
  }
  return null
}

function setCache(key: string, data: any): void {
  cache.set(key, { data, timestamp: Date.now() })
}

// ============= V1 ENDPOINTS (Trước sáp nhập - 63 tỉnh) =============

// GET /provinces/v1 - Lấy danh sách tỉnh/thành phố
export const getProvincesV1 = async (_req: Request, res: Response): Promise<void> => {
  try {
    const cacheKey = 'provinces_v1'
    const cached = getCached(cacheKey)
    if (cached) {
      res.json(cached)
      return
    }

    const response = await fetch(`${API_BASE_URL}/${V1_EFFECTIVE_DATE}/provinces`)

    if (!response.ok) {
      throw new Error(`Provinces API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json() as ProvincesResponse
    const provinces = (data.provinces || []).map((p) => ({
      code: p.code,
      name: p.name,
    }))

    setCache(cacheKey, provinces)
    res.json(provinces)
  } catch (error) {
    console.error('Error fetching provinces V1:', error)
    res.status(500).json({
      error: 'Failed to fetch provinces',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// GET /provinces/v1/:code/districts - Lấy quận/huyện của tỉnh
export const getDistrictsByProvinceV1 = async (req: Request, res: Response): Promise<void> => {
  try {
    const { code } = req.params

    if (!code) {
      res.status(400).json({ error: 'Province code is required' })
      return
    }

    const cacheKey = `districts_v1_${code}`
    const cached = getCached(cacheKey)
    if (cached) {
      res.json(cached)
      return
    }

    // Fetch all communes for the province
    const response = await fetch(`${API_BASE_URL}/${V1_EFFECTIVE_DATE}/provinces/${code}/communes`)

    if (!response.ok) {
      throw new Error(`Districts API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json() as CommunesResponse
    const communes = data.communes || []

    // Extract unique districts from communes
    const districtMap = new Map<string, { code: string; name: string }>()
    for (const commune of communes) {
      if (commune.districtCode && commune.districtName && !districtMap.has(commune.districtCode)) {
        districtMap.set(commune.districtCode, {
          code: commune.districtCode,
          name: commune.districtName,
        })
      }
    }

    const districts = Array.from(districtMap.values()).sort((a, b) =>
      a.name.localeCompare(b.name, 'vi')
    )

    setCache(cacheKey, districts)
    res.json(districts)
  } catch (error) {
    console.error('Error fetching districts:', error)
    res.status(500).json({
      error: 'Failed to fetch districts',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// GET /provinces/v1/:provinceCode/districts/:districtCode/wards - Lấy phường/xã của quận/huyện
export const getWardsByDistrictV1 = async (req: Request, res: Response): Promise<void> => {
  try {
    const { provinceCode, districtCode } = req.params

    if (!provinceCode || !districtCode) {
      res.status(400).json({ error: 'Province code and district code are required' })
      return
    }

    const cacheKey = `wards_v1_${provinceCode}_${districtCode}`
    const cached = getCached(cacheKey)
    if (cached) {
      res.json(cached)
      return
    }

    // Fetch all communes for the province
    const response = await fetch(`${API_BASE_URL}/${V1_EFFECTIVE_DATE}/provinces/${provinceCode}/communes`)

    if (!response.ok) {
      throw new Error(`Wards API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json() as CommunesResponse
    const communes = data.communes || []

    // Filter wards by district code
    const wards = communes
      .filter((c) => c.districtCode === districtCode)
      .map((c) => ({
        code: c.code,
        name: c.name,
      }))

    setCache(cacheKey, wards)
    res.json(wards)
  } catch (error) {
    console.error('Error fetching wards:', error)
    res.status(500).json({
      error: 'Failed to fetch wards',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// ============= V2 ENDPOINTS (Sau sáp nhập 2025 - 34 tỉnh) =============

// GET /provinces/v2 - Lấy danh sách tỉnh/thành phố (sau sáp nhập)
export const getProvincesV2 = async (_req: Request, res: Response): Promise<void> => {
  try {
    const cacheKey = 'provinces_v2'
    const cached = getCached(cacheKey)
    if (cached) {
      res.json(cached)
      return
    }

    const response = await fetch(`${API_BASE_URL}/${V2_EFFECTIVE_DATE}/provinces`)

    if (!response.ok) {
      throw new Error(`Provinces API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json() as ProvincesResponse
    const provinces = (data.provinces || []).map((p) => ({
      code: p.code,
      name: p.name,
    }))

    setCache(cacheKey, provinces)
    res.json(provinces)
  } catch (error) {
    console.error('Error fetching provinces V2:', error)
    res.status(500).json({
      error: 'Failed to fetch provinces',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// GET /provinces/v2/:code/wards - Lấy phường/xã trực tiếp từ tỉnh (V2 không có cấp quận/huyện)
export const getWardsByProvinceV2 = async (req: Request, res: Response): Promise<void> => {
  try {
    const { code } = req.params

    if (!code) {
      res.status(400).json({ error: 'Province code is required' })
      return
    }

    const cacheKey = `wards_v2_${code}`
    const cached = getCached(cacheKey)
    if (cached) {
      res.json(cached)
      return
    }

    const response = await fetch(`${API_BASE_URL}/${V2_EFFECTIVE_DATE}/provinces/${code}/communes`)

    if (!response.ok) {
      throw new Error(`Wards API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json() as CommunesResponse
    const wards = (data.communes || []).map((c) => ({
      code: c.code,
      name: c.name,
    }))

    setCache(cacheKey, wards)
    res.json(wards)
  } catch (error) {
    console.error('Error fetching wards V2:', error)
    res.status(500).json({
      error: 'Failed to fetch wards',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// ============= UTILITY =============

// Clear cache (for admin use)
export const clearCache = (_req: Request, res: Response): void => {
  cache.clear()
  res.json({ message: 'Cache cleared successfully' })
}
</file>

<file path="server/src/db/seed-firebase-rest.ts">
import bcrypt from 'bcryptjs'
import dotenv from 'dotenv'

dotenv.config()

// Use RTDB_URL instead of FIREBASE_DATABASE_URL (reserved prefix in Firebase Functions)
const RTDB_URL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/'
// Remove trailing slash if present
const baseUrl = RTDB_URL.replace(/\/$/, '')

// Helper function to generate ID
function generateId(): string {
  const timestamp = Date.now().toString(36)
  const randomPart = Math.random().toString(36).substring(2, 15)
  return `${timestamp}-${randomPart}`
}

// Helper function to get current timestamp
function now(): string {
  return new Date().toISOString()
}

// Helper function to get date string
function dateString(daysFromNow: number = 0): string {
  const date = new Date()
  date.setDate(date.getDate() + daysFromNow)
  return date.toISOString().split('T')[0]
}

// Helper function to get time string
function timeString(hours: number, minutes: number = 0): string {
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`
}

// Firebase REST API helper
async function firebaseSet(path: string, data: any): Promise<void> {
  const url = `${baseUrl}/${path}.json`
  const response = await fetch(url, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data)
  })
  
  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`Firebase REST API error: ${response.status} ${response.statusText} - ${errorText}`)
  }
}

async function seedFirebaseRest() {
  try {
    console.log('🌱 Bắt đầu seed data vào Firebase qua REST API...\n')
    console.log(`📡 Database URL: ${baseUrl}\n`)

    // ============================================
    // 1. VEHICLE TYPES
    // ============================================
    console.log('📦 Đang tạo Vehicle Types...')
    const vehicleTypes = [
      { id: generateId(), name: 'Xe khách 16 chỗ', description: 'Xe khách loại nhỏ', created_at: now() },
      { id: generateId(), name: 'Xe khách 29 chỗ', description: 'Xe khách trung bình', created_at: now() },
      { id: generateId(), name: 'Xe khách 45 chỗ', description: 'Xe khách lớn', created_at: now() },
      { id: generateId(), name: 'Xe giường nằm', description: 'Xe khách giường nằm', created_at: now() },
    ]

    const vehicleTypeIds: Record<string, string> = {}
    for (const vt of vehicleTypes) {
      await firebaseSet(`vehicle_types/${vt.id}`, vt)
      vehicleTypeIds[vt.name] = vt.id
    }
    console.log(`✅ Đã tạo ${vehicleTypes.length} vehicle types\n`)

    // ============================================
    // 2. USERS
    // ============================================
    console.log('👥 Đang tạo Users...')
    const passwordHash = await bcrypt.hash('123456', 10)
    
    const users = [
      {
        id: generateId(),
        username: 'admin',
        password_hash: passwordHash,
        full_name: 'System Administrator',
        email: 'admin@benxe.com',
        role: 'admin',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        username: 'dieudo',
        password_hash: passwordHash,
        full_name: 'Nguyễn Văn Điều Độ',
        email: 'dieudo@benxe.com',
        role: 'dispatcher',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        username: 'ketoan',
        password_hash: passwordHash,
        full_name: 'Trần Thị Kế Toán',
        email: 'ketoan@benxe.com',
        role: 'accountant',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        username: 'baocao',
        password_hash: passwordHash,
        full_name: 'Lê Văn Báo Cáo',
        email: 'baocao@benxe.com',
        role: 'reporter',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const userIds: Record<string, string> = {}
    for (const user of users) {
      await firebaseSet(`users/${user.id}`, user)
      userIds[user.username] = user.id
    }
    console.log(`✅ Đã tạo ${users.length} users\n`)

    // ============================================
    // 3. OPERATORS
    // ============================================
    console.log('🚌 Đang tạo Operators...')
    const operators = [
      {
        id: generateId(),
        name: 'Công ty CP Xe khách Phương Trang',
        code: 'FUTA',
        tax_code: '0301234567',
        phone: '19006067',
        email: 'lienhe@futabus.vn',
        address: '80 Trần Hưng Đạo, Q.1, TP.HCM',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận 1',
        representative_name: 'Nguyễn Hữu Luân',
        representative_position: 'Giám đốc',
        is_ticket_delegated: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        name: 'Công ty TNHH Thành Bưởi',
        code: 'THANHBUOI',
        tax_code: '0309876543',
        phone: '19006079',
        email: 'lienhe@thanhbuoi.com.vn',
        address: '266 Lê Hồng Phong, Q.5, TP.HCM',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận 5',
        representative_name: 'Lê Đức Thành',
        representative_position: 'Giám đốc',
        is_ticket_delegated: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        name: 'Công ty TNHH Vận tải Kumho Samco',
        code: 'KUMHO',
        tax_code: '0305556667',
        phone: '19006065',
        email: 'lienhe@kumhosamco.com.vn',
        address: '292 Đinh Bộ Lĩnh, Q.Bình Thạnh, TP.HCM',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận Bình Thạnh',
        representative_name: 'Park Song Hwa',
        representative_position: 'Giám đốc',
        is_ticket_delegated: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const operatorIds: Record<string, string> = {}
    for (const op of operators) {
      await firebaseSet(`operators/${op.id}`, op)
      operatorIds[op.code] = op.id
    }
    console.log(`✅ Đã tạo ${operators.length} operators\n`)

    // ============================================
    // 4. VEHICLES
    // ============================================
    console.log('🚗 Đang tạo Vehicles...')
    const vehicles = [
      {
        id: generateId(),
        plate_number: '51B-123.45',
        vehicle_type_id: vehicleTypeIds['Xe giường nằm'],
        operator_id: operatorIds['FUTA'],
        seat_capacity: 0,
        bed_capacity: 40,
        province: 'TP. Hồ Chí Minh',
        insurance_expiry_date: dateString(180),
        inspection_expiry_date: dateString(90),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        plate_number: '51B-678.90',
        vehicle_type_id: vehicleTypeIds['Xe giường nằm'],
        operator_id: operatorIds['FUTA'],
        seat_capacity: 0,
        bed_capacity: 44,
        province: 'TP. Hồ Chí Minh',
        insurance_expiry_date: dateString(200),
        inspection_expiry_date: dateString(120),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        plate_number: '51B-111.22',
        vehicle_type_id: vehicleTypeIds['Xe giường nằm'],
        operator_id: operatorIds['THANHBUOI'],
        seat_capacity: 0,
        bed_capacity: 34,
        province: 'TP. Hồ Chí Minh',
        insurance_expiry_date: dateString(150),
        inspection_expiry_date: dateString(60),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        plate_number: '51B-333.44',
        vehicle_type_id: vehicleTypeIds['Xe khách 45 chỗ'],
        operator_id: operatorIds['KUMHO'],
        seat_capacity: 45,
        bed_capacity: 0,
        province: 'TP. Hồ Chí Minh',
        insurance_expiry_date: dateString(100),
        inspection_expiry_date: dateString(30),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const vehicleIds: string[] = []
    for (const veh of vehicles) {
      await firebaseSet(`vehicles/${veh.id}`, veh)
      vehicleIds.push(veh.id)
    }
    console.log(`✅ Đã tạo ${vehicles.length} vehicles\n`)

    // ============================================
    // 5. VEHICLE DOCUMENTS
    // ============================================
    console.log('📄 Đang tạo Vehicle Documents...')
    const vehicleDocuments = [
      {
        id: generateId(),
        vehicle_id: vehicleIds[0],
        document_type: 'registration',
        document_number: 'DK-12345',
        issue_date: dateString(-365),
        expiry_date: dateString(365),
        issuing_authority: 'Cục Đăng kiểm Việt Nam',
        updated_by: userIds['admin'],
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        vehicle_id: vehicleIds[0],
        document_type: 'inspection',
        document_number: 'DK-12345-2024',
        issue_date: dateString(-90),
        expiry_date: dateString(90),
        issuing_authority: 'Trung tâm Đăng kiểm',
        updated_by: userIds['admin'],
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        vehicle_id: vehicleIds[0],
        document_type: 'insurance',
        document_number: 'BH-12345',
        issue_date: dateString(-180),
        expiry_date: dateString(180),
        issuing_authority: 'Bảo Việt',
        updated_by: userIds['admin'],
        created_at: now(),
        updated_at: now()
      },
    ]

    for (const doc of vehicleDocuments) {
      await firebaseSet(`vehicle_documents/${doc.id}`, doc)
    }
    console.log(`✅ Đã tạo ${vehicleDocuments.length} vehicle documents\n`)

    // ============================================
    // 5B. VEHICLE BADGES (Phù hiệu xe)
    // ============================================
    console.log('🏷️  Đang tạo Vehicle Badges...')
    const vehicleBadges = [
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-001',
        BienSoXe: '51B-123.45',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-180),
        NgayHetHan: dateString(180),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-001',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-002',
        BienSoXe: '51B-678.90',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-120),
        NgayHetHan: dateString(240),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-002',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Vũng Tàu',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-003',
        BienSoXe: '51B-111.22',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Vàng',
        NgayCap: dateString(-90),
        NgayHetHan: dateString(270),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-003',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-TB-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2024-004',
        BienSoXe: '51B-333.44',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Xanh',
        NgayCap: dateString(-60),
        NgayHetHan: dateString(25),
        TrangThai: 'Còn hiệu lực',
        MaHoSo: 'HS-004',
        LoaiCap: 'Gia hạn',
        Ref_GPKD: 'GPKD-KUMHO-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Cần Thơ',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
      {
        ID_PhuHieu: generateId(),
        SoPhuHieu: 'PH-2023-099',
        BienSoXe: '51B-999.88',
        LoaiPH: 'Xe buýt tuyến cố định',
        MauPhuHieu: 'Đỏ',
        NgayCap: dateString(-400),
        NgayHetHan: dateString(-30),
        TrangThai: 'Hết hiệu lực',
        MaHoSo: 'HS-099',
        LoaiCap: 'Cấp mới',
        Ref_GPKD: 'GPKD-FUTA-001',
        Ref_DonViCapPhuHieu: 'Sở GTVT TP.HCM',
        TuyenDuong: 'TP.HCM - Đà Lạt',
        LoaiXe: 'Xe buýt',
        created_at: now()
      },
    ]

    for (const badge of vehicleBadges) {
      await firebaseSet(`vehicle_badges/${badge.ID_PhuHieu}`, badge)
    }
    console.log(`✅ Đã tạo ${vehicleBadges.length} vehicle badges\n`)

    // ============================================
    // 6. DRIVERS
    // ============================================
    console.log('👨‍✈️ Đang tạo Drivers...')
    const drivers = [
      {
        id: generateId(),
        operator_id: operatorIds['FUTA'],
        full_name: 'Nguyễn Văn Tài',
        id_number: '079090123456',
        phone: '0909123456',
        email: 'nguyenvantai@example.com',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận 1',
        address: '123 Nguyễn Huệ, Q.1',
        license_number: '790123456789',
        license_class: 'E',
        license_issue_date: dateString(-365 * 2),
        license_expiry_date: dateString(365 * 4),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        operator_id: operatorIds['FUTA'],
        full_name: 'Trần Văn Xế',
        id_number: '079090654321',
        phone: '0909654321',
        email: 'tranvanxe@example.com',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận 2',
        address: '456 Võ Văn Tần, Q.2',
        license_number: '790987654321',
        license_class: 'E',
        license_issue_date: dateString(-365 * 3),
        license_expiry_date: dateString(365 * 3),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        operator_id: operatorIds['THANHBUOI'],
        full_name: 'Lê Văn Lái',
        id_number: '079090112233',
        phone: '0909112233',
        email: 'levanlai@example.com',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận 3',
        address: '789 Điện Biên Phủ, Q.3',
        license_number: '790112233445',
        license_class: 'E',
        license_issue_date: dateString(-365 * 4),
        license_expiry_date: dateString(365 * 5),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const driverIds: string[] = []
    for (const driver of drivers) {
      await firebaseSet(`drivers/${driver.id}`, driver)
      driverIds.push(driver.id)
    }
    console.log(`✅ Đã tạo ${drivers.length} drivers\n`)

    // ============================================
    // 7. LOCATIONS
    // ============================================
    console.log('📍 Đang tạo Locations...')
    const locations = [
      {
        id: generateId(),
        name: 'Bến xe Miền Đông Mới',
        code: 'BXMDI',
        station_type: 'Bến xe khách loại 1',
        province: 'TP. Hồ Chí Minh',
        district: 'TP. Thủ Đức',
        address: '501 Hoàng Hữu Nam, P. Long Bình',
        phone: '02838488888',
        email: 'info@benxemiendong.vn',
        latitude: 10.8416,
        longitude: 106.8099,
        is_active: true,
        created_at: now()
      },
      {
        id: generateId(),
        name: 'Bến xe Liên tỉnh Đà Lạt',
        code: 'BXDL',
        station_type: 'Bến xe khách loại 2',
        province: 'Lâm Đồng',
        district: 'TP. Đà Lạt',
        address: '01 Tô Hiến Thành, P.3',
        phone: '02633822222',
        email: 'info@benxedalat.vn',
        latitude: 11.9404,
        longitude: 108.4583,
        is_active: true,
        created_at: now()
      },
      {
        id: generateId(),
        name: 'Bến xe Vũng Tàu',
        code: 'BXVT',
        station_type: 'Bến xe khách loại 2',
        province: 'Bà Rịa - Vũng Tàu',
        district: 'TP. Vũng Tàu',
        address: '192 Nam Kỳ Khởi Nghĩa, P. Thắng Tam',
        phone: '02543855555',
        email: 'info@benxevungtau.vn',
        latitude: 10.3460,
        longitude: 107.0843,
        is_active: true,
        created_at: now()
      },
      {
        id: generateId(),
        name: 'Bến xe Trung tâm Cần Thơ',
        code: 'BXCT',
        station_type: 'Bến xe khách loại 1',
        province: 'Cần Thơ',
        district: 'Q. Cái Răng',
        address: 'QL1A, P. Hưng Thạnh',
        phone: '02923833333',
        email: 'info@benxecantho.vn',
        latitude: 10.0452,
        longitude: 105.7469,
        is_active: true,
        created_at: now()
      },
      {
        id: generateId(),
        name: 'Bến xe Miền Tây',
        code: 'BXMT',
        station_type: 'Bến xe khách loại 1',
        province: 'TP. Hồ Chí Minh',
        district: 'Quận Bình Tân',
        address: '395 Kinh Dương Vương, P. An Lạc',
        phone: '02838766666',
        email: 'info@benxemientay.vn',
        latitude: 10.7289,
        longitude: 106.6034,
        is_active: true,
        created_at: now()
      },
    ]

    const locationIds: Record<string, string> = {}
    for (const loc of locations) {
      await firebaseSet(`locations/${loc.id}`, loc)
      locationIds[loc.code] = loc.id
    }
    console.log(`✅ Đã tạo ${locations.length} locations\n`)

    // ============================================
    // 8. ROUTES
    // ============================================
    console.log('🛣️  Đang tạo Routes...')
    const routes = [
      {
        id: generateId(),
        route_code: 'HCM-DL',
        route_name: 'TP.HCM - Đà Lạt',
        origin_id: locationIds['BXMDI'],
        destination_id: locationIds['BXDL'],
        distance_km: 308,
        estimated_duration_minutes: 480,
        route_type: 'Intercity',
        planned_frequency: '30 phút/chuyến',
        boarding_point: 'Bến xe Miền Đông',
        journey_description: 'Tuyến đường cao tốc, qua các tỉnh Đồng Nai, Bình Thuận, Lâm Đồng',
        departure_times_description: 'Từ 5:00 đến 23:00 hàng ngày',
        rest_stops: 'Trạm dừng nghỉ tại Bình Thuận',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        route_code: 'HCM-VT',
        route_name: 'TP.HCM - Vũng Tàu',
        origin_id: locationIds['BXMDI'],
        destination_id: locationIds['BXVT'],
        distance_km: 96,
        estimated_duration_minutes: 150,
        route_type: 'Intercity',
        planned_frequency: '15 phút/chuyến',
        boarding_point: 'Bến xe Miền Đông',
        journey_description: 'Tuyến đường quốc lộ 51',
        departure_times_description: 'Từ 4:00 đến 22:00 hàng ngày',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        route_code: 'HCM-CT',
        route_name: 'TP.HCM - Cần Thơ',
        origin_id: locationIds['BXMT'],
        destination_id: locationIds['BXCT'],
        distance_km: 169,
        estimated_duration_minutes: 240,
        route_type: 'Intercity',
        planned_frequency: '30 phút/chuyến',
        boarding_point: 'Bến xe Miền Tây',
        journey_description: 'Tuyến đường quốc lộ 1A',
        departure_times_description: 'Từ 4:30 đến 23:30 hàng ngày',
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const routeIds: Record<string, string> = {}
    for (const route of routes) {
      await firebaseSet(`routes/${route.id}`, route)
      routeIds[route.route_code] = route.id
    }
    console.log(`✅ Đã tạo ${routes.length} routes\n`)

    // ============================================
    // 9. ROUTE STOPS
    // ============================================
    console.log('🚏 Đang tạo Route Stops...')
    const routeStops = [
      {
        id: generateId(),
        route_id: routeIds['HCM-DL'],
        location_id: locationIds['BXMDI'],
        stop_order: 1,
        distance_from_origin_km: 0,
        estimated_minutes_from_origin: 0,
        created_at: now()
      },
      {
        id: generateId(),
        route_id: routeIds['HCM-DL'],
        location_id: locationIds['BXDL'],
        stop_order: 2,
        distance_from_origin_km: 308,
        estimated_minutes_from_origin: 480,
        created_at: now()
      },
      {
        id: generateId(),
        route_id: routeIds['HCM-VT'],
        location_id: locationIds['BXMDI'],
        stop_order: 1,
        distance_from_origin_km: 0,
        estimated_minutes_from_origin: 0,
        created_at: now()
      },
      {
        id: generateId(),
        route_id: routeIds['HCM-VT'],
        location_id: locationIds['BXVT'],
        stop_order: 2,
        distance_from_origin_km: 96,
        estimated_minutes_from_origin: 150,
        created_at: now()
      },
    ]

    for (const stop of routeStops) {
      await firebaseSet(`route_stops/${stop.id}`, stop)
    }
    console.log(`✅ Đã tạo ${routeStops.length} route stops\n`)

    // ============================================
    // 10. SHIFTS
    // ============================================
    console.log('⏰ Đang tạo Shifts...')
    const shifts = [
      { 
        id: generateId(), 
        name: 'Ca 1', 
        start_time: timeString(6, 0), 
        end_time: timeString(14, 0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      { 
        id: generateId(), 
        name: 'Ca 2', 
        start_time: timeString(14, 0), 
        end_time: timeString(22, 0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      { 
        id: generateId(), 
        name: 'Ca 3', 
        start_time: timeString(22, 0), 
        end_time: timeString(6, 0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      { 
        id: generateId(), 
        name: 'Hành chính', 
        start_time: timeString(7, 30), 
        end_time: timeString(17, 0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const shiftIds: Record<string, string> = {}
    for (const shift of shifts) {
      await firebaseSet(`shifts/${shift.id}`, shift)
      shiftIds[shift.name] = shift.id
    }
    console.log(`✅ Đã tạo ${shifts.length} shifts\n`)

    // ============================================
    // 11. SERVICES
    // ============================================
    console.log('💼 Đang tạo Services...')
    const services = [
      {
        id: generateId(),
        code: 'STOP_FEE',
        name: 'Phí dừng đỗ',
        base_price: 50000,
        unit: 'per_trip',
        material_type: 'Dịch vụ',
        tax_percentage: 0,
        display_order: 1,
        is_default: false,
        use_quantity_formula: false,
        use_price_formula: false,
        auto_calculate_quantity: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        code: 'CLEANING',
        name: 'Phí vệ sinh',
        base_price: 20000,
        unit: 'per_trip',
        material_type: 'Dịch vụ',
        tax_percentage: 0,
        display_order: 2,
        is_default: false,
        use_quantity_formula: false,
        use_price_formula: false,
        auto_calculate_quantity: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        code: 'MANAGEMENT',
        name: 'Phí quản lý',
        base_price: 30000,
        unit: 'per_trip',
        material_type: 'Dịch vụ',
        tax_percentage: 0,
        display_order: 3,
        is_default: false,
        use_quantity_formula: false,
        use_price_formula: false,
        auto_calculate_quantity: false,
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const serviceIds: Record<string, string> = {}
    for (const service of services) {
      await firebaseSet(`services/${service.id}`, service)
      serviceIds[service.code] = service.id
    }
    console.log(`✅ Đã tạo ${services.length} services\n`)

    // ============================================
    // 12. VIOLATION TYPES
    // ============================================
    console.log('⚠️  Đang tạo Violation Types...')
    const violationTypes = [
      {
        id: generateId(),
        code: 'OVERLOAD',
        name: 'Chở quá số lượng khách quy định',
        description: 'Xe chở vượt quá số lượng khách được phép',
        severity: 'high',
        created_at: now()
      },
      {
        id: generateId(),
        code: 'NO_LICENSE',
        name: 'Thiếu giấy tờ xe/lái xe',
        description: 'Xe hoặc lái xe thiếu giấy tờ hợp lệ',
        severity: 'critical',
        created_at: now()
      },
      {
        id: generateId(),
        code: 'LATE_DEPARTURE',
        name: 'Xuất bến trễ giờ',
        description: 'Xe xuất bến sau giờ quy định',
        severity: 'low',
        created_at: now()
      },
    ]

    for (const vt of violationTypes) {
      await firebaseSet(`violation_types/${vt.id}`, vt)
    }
    console.log(`✅ Đã tạo ${violationTypes.length} violation types\n`)

    // ============================================
    // 13. SCHEDULES
    // ============================================
    console.log('📅 Đang tạo Schedules...')
    const schedules = [
      {
        id: generateId(),
        schedule_code: 'FUTA-HCM-DL-08:00',
        route_id: routeIds['HCM-DL'],
        operator_id: operatorIds['FUTA'],
        departure_time: timeString(8, 0),
        frequency_type: 'daily',
        effective_from: dateString(0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
      {
        id: generateId(),
        schedule_code: 'TB-HCM-DL-09:00',
        route_id: routeIds['HCM-DL'],
        operator_id: operatorIds['THANHBUOI'],
        departure_time: timeString(9, 0),
        frequency_type: 'daily',
        effective_from: dateString(0),
        is_active: true,
        created_at: now(),
        updated_at: now()
      },
    ]

    const scheduleIds: string[] = []
    for (const schedule of schedules) {
      await firebaseSet(`schedules/${schedule.id}`, schedule)
      scheduleIds.push(schedule.id)
    }
    console.log(`✅ Đã tạo ${schedules.length} schedules\n`)

    // ============================================
    // 14. DISPATCH RECORDS
    // ============================================
    console.log('📋 Đang tạo Dispatch Records...')
    const nowTime = new Date()
    const fourHoursAgo = new Date(nowTime.getTime() - 4 * 60 * 60 * 1000)
    const threeHoursAgo = new Date(nowTime.getTime() - 3 * 60 * 60 * 1000)
    const oneHourAgo = new Date(nowTime.getTime() - 1 * 60 * 60 * 1000)
    const tenMinutesAgo = new Date(nowTime.getTime() - 10 * 60 * 1000)

    const dispatchRecords = [
      {
        id: generateId(),
        vehicle_id: vehicleIds[0],
        driver_id: driverIds[0],
        schedule_id: scheduleIds[0],
        route_id: routeIds['HCM-DL'],
        entry_time: fourHoursAgo.toISOString(),
        entry_by: userIds['dieudo'],
        entry_shift_id: shiftIds['Ca 1'],
        passenger_drop_time: new Date(fourHoursAgo.getTime() + 10 * 60 * 1000).toISOString(),
        passengers_arrived: 15,
        passenger_drop_by: userIds['dieudo'],
        boarding_permit_time: new Date(fourHoursAgo.getTime() + 30 * 60 * 1000).toISOString(),
        planned_departure_time: new Date(fourHoursAgo.getTime() + 60 * 60 * 1000).toISOString(),
        transport_order_code: 'LENH-001',
        seat_count: 40,
        permit_status: 'approved',
        boarding_permit_by: userIds['dieudo'],
        permit_shift_id: shiftIds['Ca 1'],
        payment_time: new Date(fourHoursAgo.getTime() + 40 * 60 * 1000).toISOString(),
        payment_amount: 150000,
        payment_method: 'cash',
        invoice_number: 'HD-001',
        payment_by: userIds['ketoan'],
        payment_shift_id: shiftIds['Ca 1'],
        departure_order_time: new Date(fourHoursAgo.getTime() + 55 * 60 * 1000).toISOString(),
        passengers_departing: 35,
        departure_order_by: userIds['dieudo'],
        departure_order_shift_id: shiftIds['Ca 1'],
        exit_time: threeHoursAgo.toISOString(),
        exit_by: userIds['dieudo'],
        exit_shift_id: shiftIds['Ca 1'],
        current_status: 'departed',
        created_at: fourHoursAgo.toISOString(),
        updated_at: threeHoursAgo.toISOString()
      },
      {
        id: generateId(),
        vehicle_id: vehicleIds[2],
        driver_id: driverIds[2],
        schedule_id: scheduleIds[1],
        route_id: routeIds['HCM-DL'],
        entry_time: oneHourAgo.toISOString(),
        entry_by: userIds['dieudo'],
        entry_shift_id: shiftIds['Ca 2'],
        passenger_drop_time: new Date(oneHourAgo.getTime() + 10 * 60 * 1000).toISOString(),
        passengers_arrived: 10,
        passenger_drop_by: userIds['dieudo'],
        boarding_permit_time: new Date(oneHourAgo.getTime() + 30 * 60 * 1000).toISOString(),
        planned_departure_time: new Date(nowTime.getTime() + 30 * 60 * 1000).toISOString(),
        transport_order_code: 'LENH-002',
        seat_count: 34,
        permit_status: 'approved',
        boarding_permit_by: userIds['dieudo'],
        permit_shift_id: shiftIds['Ca 2'],
        current_status: 'permit_issued',
        created_at: oneHourAgo.toISOString(),
        updated_at: new Date(oneHourAgo.getTime() + 30 * 60 * 1000).toISOString()
      },
      {
        id: generateId(),
        vehicle_id: vehicleIds[1],
        driver_id: driverIds[1],
        route_id: routeIds['HCM-VT'],
        entry_time: tenMinutesAgo.toISOString(),
        entry_by: userIds['dieudo'],
        entry_shift_id: shiftIds['Ca 2'],
        current_status: 'entered',
        created_at: tenMinutesAgo.toISOString(),
        updated_at: tenMinutesAgo.toISOString()
      },
    ]

    const dispatchRecordIds: string[] = []
    for (const dr of dispatchRecords) {
      await firebaseSet(`dispatch_records/${dr.id}`, dr)
      dispatchRecordIds.push(dr.id)
    }
    console.log(`✅ Đã tạo ${dispatchRecords.length} dispatch records\n`)

    // ============================================
    // 15. SERVICE CHARGES
    // ============================================
    console.log('💰 Đang tạo Service Charges...')
    const serviceCharges = [
      {
        id: generateId(),
        dispatch_record_id: dispatchRecordIds[0],
        service_id: serviceIds['STOP_FEE'],
        quantity: 1,
        unit_price: 50000,
        total_amount: 50000,
        created_at: now()
      },
      {
        id: generateId(),
        dispatch_record_id: dispatchRecordIds[0],
        service_id: serviceIds['CLEANING'],
        quantity: 1,
        unit_price: 20000,
        total_amount: 20000,
        created_at: now()
      },
      {
        id: generateId(),
        dispatch_record_id: dispatchRecordIds[0],
        service_id: serviceIds['MANAGEMENT'],
        quantity: 1,
        unit_price: 30000,
        total_amount: 30000,
        created_at: now()
      },
    ]

    for (const sc of serviceCharges) {
      await firebaseSet(`service_charges/${sc.id}`, sc)
    }
    console.log(`✅ Đã tạo ${serviceCharges.length} service charges\n`)

    // ============================================
    // 16. INVOICES
    // ============================================
    console.log('🧾 Đang tạo Invoices...')
    const invoices = [
      {
        id: generateId(),
        invoice_number: 'HD-001',
        dispatch_record_id: dispatchRecordIds[0],
        operator_id: operatorIds['FUTA'],
        shift_id: shiftIds['Ca 1'],
        issue_date: dateString(0),
        due_date: dateString(30),
        subtotal: 100000,
        tax_amount: 0,
        total_amount: 100000,
        payment_status: 'paid',
        payment_date: dateString(0),
        notes: 'Thanh toán đầy đủ',
        created_at: now(),
        updated_at: now()
      },
    ]

    for (const invoice of invoices) {
      await firebaseSet(`invoices/${invoice.id}`, invoice)
    }
    console.log(`✅ Đã tạo ${invoices.length} invoices\n`)

    // ============================================
    // 17. SYSTEM SETTINGS
    // ============================================
    console.log('⚙️  Đang tạo System Settings...')
    const systemSettings = [
      {
        key: 'station_name',
        value: 'Bến xe Miền Đông Mới',
        data_type: 'string',
        description: 'Tên bến xe',
        updated_at: now(),
        updated_by: userIds['admin']
      },
      {
        key: 'station_address',
        value: '501 Hoàng Hữu Nam, P. Long Bình, TP. Thủ Đức, TP.HCM',
        data_type: 'string',
        description: 'Địa chỉ bến xe',
        updated_at: now(),
        updated_by: userIds['admin']
      },
      {
        key: 'default_currency',
        value: 'VND',
        data_type: 'string',
        description: 'Đơn vị tiền tệ mặc định',
        updated_at: now(),
        updated_by: userIds['admin']
      },
    ]

    for (const setting of systemSettings) {
      await firebaseSet(`system_settings/${setting.key}`, setting)
    }
    console.log(`✅ Đã tạo ${systemSettings.length} system settings\n`)

    console.log('🎉 Hoàn thành seed data đầy đủ vào Firebase!')
    console.log('\n📝 Thông tin đăng nhập:')
    console.log('   - Username: admin | Password: 123456 (Admin)')
    console.log('   - Username: dieudo | Password: 123456 (Dispatcher)')
    console.log('   - Username: ketoan | Password: 123456 (Accountant)')
    console.log('   - Username: baocao | Password: 123456 (Reporter)')
    console.log('\n📊 Tổng kết dữ liệu đã tạo:')
    console.log(`   - ${vehicleTypes.length} vehicle types`)
    console.log(`   - ${users.length} users`)
    console.log(`   - ${operators.length} operators`)
    console.log(`   - ${vehicles.length} vehicles`)
    console.log(`   - ${vehicleDocuments.length} vehicle documents`)
    console.log(`   - ${vehicleBadges.length} vehicle badges`)
    console.log(`   - ${drivers.length} drivers`)
    console.log(`   - ${locations.length} locations`)
    console.log(`   - ${routes.length} routes`)
    console.log(`   - ${routeStops.length} route stops`)
    console.log(`   - ${shifts.length} shifts`)
    console.log(`   - ${services.length} services`)
    console.log(`   - ${violationTypes.length} violation types`)
    console.log(`   - ${schedules.length} schedules`)
    console.log(`   - ${dispatchRecords.length} dispatch records`)
    console.log(`   - ${serviceCharges.length} service charges`)
    console.log(`   - ${invoices.length} invoices`)
    console.log(`   - ${systemSettings.length} system settings`)

  } catch (error: any) {
    console.error('❌ Lỗi khi seed data:', error.message)
    if (error.message.includes('401') || error.message.includes('403')) {
      console.error('\n⚠️  Lỗi authentication!')
      console.error('Vui lòng kiểm tra Firebase Database Rules:')
      console.error('1. Vào Firebase Console > Realtime Database > Rules')
      console.error('2. Đảm bảo rules cho phép đọc/ghi (chỉ cho development):')
      console.error('   {')
      console.error('     "rules": {')
      console.error('       ".read": true,')
      console.error('       ".write": true')
      console.error('     }')
      console.error('   }')
    }
    process.exit(1)
  }
}

seedFirebaseRest()
</file>

<file path="server/src/lib/firebase-rest.ts">
/**
 * Firebase REST API wrapper using Firebase Admin SDK
 * This provides authenticated access to Firebase Realtime Database
 */

import { firebaseDb } from '../config/database.js'

export class FirebaseREST {
  async get(path: string): Promise<any> {
    try {
      const snapshot = await firebaseDb.ref(path).once('value')
      return snapshot.val()
    } catch (error: any) {
      console.error(`[FirebaseREST] GET ${path} error:`, error.message)
      throw new Error(`Firebase error: ${error.message}`)
    }
  }

  async set(path: string, data: any): Promise<void> {
    try {
      await firebaseDb.ref(path).set(data)
    } catch (error: any) {
      console.error(`[FirebaseREST] SET ${path} error:`, error.message)
      throw new Error(`Firebase error: ${error.message}`)
    }
  }

  async update(path: string, data: any): Promise<void> {
    try {
      await firebaseDb.ref(path).update(data)
    } catch (error: any) {
      console.error(`[FirebaseREST] UPDATE ${path} error:`, error.message)
      throw new Error(`Firebase error: ${error.message}`)
    }
  }

  async remove(path: string): Promise<void> {
    try {
      await firebaseDb.ref(path).remove()
    } catch (error: any) {
      console.error(`[FirebaseREST] REMOVE ${path} error:`, error.message)
      throw new Error(`Firebase error: ${error.message}`)
    }
  }
}

export const firebaseREST = new FirebaseREST()
</file>

<file path="server/src/modules/dispatch/dispatch.routes.ts">
/**
 * Dispatch Routes
 * API endpoints for dispatch operations
 */

import { Router } from 'express'
import { authenticate } from '../../middleware/auth.js'
import {
  getAllDispatchRecords,
  getDispatchRecordById,
  createDispatchRecord,
  recordPassengerDrop,
  issuePermit,
  processPayment,
  issueDepartureOrder,
  recordExit,
  updateEntryImage,
  updateDispatchStatus,
  depart,
  deleteDispatchRecord,
  cancelDispatchRecord,
} from './controllers/dispatch.controller.js'

const router = Router()

// Apply authentication to all routes
router.use(authenticate)

// GET routes
router.get('/', getAllDispatchRecords)
router.get('/:id', getDispatchRecordById)

// Workflow endpoints
router.post('/', createDispatchRecord)
router.delete('/:id', deleteDispatchRecord)
router.post('/:id/cancel', cancelDispatchRecord)
router.post('/:id/passenger-drop', recordPassengerDrop)
router.post('/:id/permit', issuePermit)
router.post('/:id/payment', processPayment)
router.post('/:id/departure-order', issueDepartureOrder)
router.post('/:id/exit', recordExit)
router.patch('/:id/entry-image', updateEntryImage)

// Legacy deprecated endpoints
router.put('/:id/status', updateDispatchStatus)
router.post('/:id/depart', depart)

export default router
</file>

<file path="server/src/modules/fleet/services/vehicle.service.ts">
/**
 * Vehicle Service
 * Business logic layer for Vehicle entity with legacy/badge support
 */

import { VehicleAPI } from '../../../shared/mappers/entity-mappers.js';
import { AlreadyExistsError, ValidationError } from '../../../shared/errors/app-error.js';
import { vehicleRepository, VehicleRepository } from '../repositories/vehicle.repository.js';
import { vehicleCacheService, LegacyVehicleData, BadgeVehicleData } from './vehicle-cache.service.js';

export interface CreateVehicleDTO {
  plateNumber: string;
  vehicleTypeId?: string;
  operatorId?: string;
  seatCapacity: number;
  bedCapacity?: number;
  chassisNumber?: string;
  engineNumber?: string;
  imageUrl?: string;
  insuranceExpiryDate?: string;
  inspectionExpiryDate?: string;
  cargoLength?: number;
  cargoWidth?: number;
  cargoHeight?: number;
  gpsProvider?: string;
  gpsUsername?: string;
  gpsPassword?: string;
  province?: string;
  notes?: string;
  isActive?: boolean;
}

export interface UpdateVehicleDTO extends Partial<CreateVehicleDTO> {}

export interface VehicleFilters {
  operatorId?: string;
  isActive?: boolean | 'all';
  includeLegacy?: boolean;
}

export type CombinedVehicle = VehicleAPI | LegacyVehicleData | BadgeVehicleData;

export class VehicleService {
  constructor(private repository: VehicleRepository) {}

  async getAll(filters?: VehicleFilters): Promise<CombinedVehicle[]> {
    const { operatorId, isActive, includeLegacy = true } = filters || {};
    const isLegacyOperator = operatorId?.startsWith('legacy_');

    // For legacy operators, skip DB queries
    let dbVehicles: VehicleAPI[] = [];
    if (!isLegacyOperator) {
      dbVehicles = await this.getDbVehicles(operatorId, isActive);
    }

    // Build plate set for deduplication (normalize: remove dots, dashes, spaces, uppercase)
    const normalizeplate = (plate: string) => plate.replace(/[.\-\s]/g, '').toUpperCase();
    const existingPlates = new Set(dbVehicles.map((v) => normalizeplate(v.plateNumber)));

    // Merge with legacy/badge if needed
    let result: CombinedVehicle[] = [...dbVehicles];

    if (includeLegacy && (!operatorId || isLegacyOperator)) {
      // Add badge vehicles FIRST (they have phù hiệu - more authoritative)
      if (!isLegacyOperator) {
        const badgeVehicles = await this.getBadgeVehicles(existingPlates);
        result = [...result, ...badgeVehicles];
      }

      // Then add legacy vehicles (dedup against badge plates too)
      const legacyVehicles = await this.getLegacyVehicles(operatorId, isLegacyOperator ?? false, existingPlates);
      result = [...result, ...legacyVehicles];
    }

    // Sort by plate number for consistent display
    result.sort((a, b) => a.plateNumber.localeCompare(b.plateNumber));

    return result;
  }

  private async getDbVehicles(operatorId?: string, isActive?: boolean | 'all'): Promise<VehicleAPI[]> {
    let vehicles = await this.repository.findAllWithRelations();

    // Filter out test/invalid vehicles (plate number should be 7-10 chars with proper format)
    vehicles = vehicles.filter((v) => {
      const plate = v.plateNumber?.trim();
      if (!plate) return false;
      // Valid Vietnamese plate: 2 digits + letter(s) + dash/hyphen + 4-5 digits (e.g., 98H-02514, 29A-12345)
      // or old format without dash
      const isValidFormat = /^\d{2}[A-Z]{1,2}[-.]?\d{4,5}$/.test(plate.toUpperCase());
      return isValidFormat;
    });

    if (operatorId) {
      vehicles = vehicles.filter((v) => v.operatorId === operatorId);
    }

    if (isActive !== 'all' && isActive !== undefined) {
      vehicles = vehicles.filter((v) => v.isActive === isActive);
    } else if (isActive === undefined) {
      // Default: only active vehicles
      vehicles = vehicles.filter((v) => v.isActive === true);
    }

    return vehicles;
  }

  private async getLegacyVehicles(
    operatorId: string | undefined,
    isLegacyOperator: boolean,
    existingPlates: Set<string>
  ): Promise<LegacyVehicleData[]> {
    const legacyVehicles = await vehicleCacheService.getLegacyVehicles();
    const result: LegacyVehicleData[] = [];
    const normalizePlate = (plate: string) => plate.replace(/[.\-\s]/g, '').toUpperCase();

    if (isLegacyOperator && operatorId) {
      const operatorName = await vehicleCacheService.getLegacyOperatorName(operatorId);
      if (operatorName) {
        const filtered = vehicleCacheService.filterLegacyByOperator(legacyVehicles, operatorName);
        for (const v of filtered) {
          const plate = normalizePlate(v.plateNumber);
          if (!existingPlates.has(plate)) {
            result.push(v);
            existingPlates.add(plate);
          }
        }
      }
    } else {
      for (const v of legacyVehicles) {
        const plate = normalizePlate(v.plateNumber);
        if (!existingPlates.has(plate)) {
          result.push(v);
          existingPlates.add(plate);
        }
      }
    }

    return result;
  }

  private async getBadgeVehicles(existingPlates: Set<string>): Promise<BadgeVehicleData[]> {
    const badgeVehicles = await vehicleCacheService.getBadgeVehicles();
    const result: BadgeVehicleData[] = [];
    const normalizePlate = (plate: string) => plate.replace(/[.\-\s]/g, '').toUpperCase();

    for (const v of badgeVehicles) {
      const plate = normalizePlate(v.plateNumber);
      if (!existingPlates.has(plate)) {
        result.push(v);
        existingPlates.add(plate);
      }
    }

    return result;
  }

  async getById(id: string): Promise<CombinedVehicle> {
    // Handle legacy vehicles
    if (id.startsWith('legacy_')) {
      const key = id.replace('legacy_', '');
      const vehicle = await vehicleCacheService.getLegacyVehicleById(key);
      if (!vehicle) {
        throw new ValidationError('Legacy vehicle not found');
      }
      return vehicle;
    }

    // Handle badge vehicles
    if (id.startsWith('badge_')) {
      const key = id.replace('badge_', '');
      const vehicle = await vehicleCacheService.getBadgeVehicleById(key);
      if (!vehicle) {
        throw new ValidationError('Badge vehicle not found');
      }
      return vehicle;
    }

    // Normal vehicle
    const vehicle = await this.repository.findByIdWithRelations(id);
    if (!vehicle) {
      throw new ValidationError(`Vehicle with ID '${id}' not found`);
    }
    return vehicle;
  }

  async create(data: CreateVehicleDTO): Promise<VehicleAPI> {
    if (!data.plateNumber?.trim()) {
      throw new ValidationError('Plate number is required');
    }
    if (data.seatCapacity === undefined || data.seatCapacity < 0) {
      throw new ValidationError('Valid seat capacity is required');
    }

    const plateExists = await this.repository.plateNumberExists(data.plateNumber);
    if (plateExists) {
      throw new AlreadyExistsError('Vehicle', 'plateNumber', data.plateNumber);
    }

    return this.repository.create({
      ...data,
      isActive: data.isActive ?? true,
    });
  }

  async update(id: string, data: UpdateVehicleDTO): Promise<VehicleAPI> {
    await this.getById(id);

    if (data.plateNumber) {
      const plateExists = await this.repository.plateNumberExists(data.plateNumber, id);
      if (plateExists) {
        throw new AlreadyExistsError('Vehicle', 'plateNumber', data.plateNumber);
      }
    }

    await this.repository.updateById(id, data);
    const vehicle = await this.repository.findByIdWithRelations(id);
    if (!vehicle) {
      throw new ValidationError('Vehicle not found after update');
    }
    return vehicle;
  }

  async delete(id: string): Promise<void> {
    await this.repository.deleteById(id);
  }

  async toggleActive(id: string): Promise<VehicleAPI> {
    const vehicle = await this.getById(id);
    if ('source' in vehicle) {
      throw new ValidationError('Cannot toggle active status of legacy/badge vehicles');
    }
    await this.repository.updateById(id, { isActive: !vehicle.isActive });
    const updated = await this.repository.findByIdWithRelations(id);
    if (!updated) {
      throw new ValidationError('Vehicle not found after update');
    }
    return updated;
  }

  async getByOperator(operatorId: string): Promise<VehicleAPI[]> {
    return this.repository.findByOperatorId(operatorId);
  }
}

export const vehicleService = new VehicleService(vehicleRepository);
</file>

<file path="server/src/modules/fleet/vehicle.routes.ts">
/**
 * Vehicle Routes
 * API endpoints for vehicle operations
 */

import { Router, Request, Response } from 'express'
import { authenticate } from '../../middleware/auth.js'
import {
  getAllVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  getVehicleDocumentAuditLogs,
  getAllDocumentAuditLogs,
} from './controllers/vehicle.controller.js'
import { getVehicleSyncStatus, syncVehiclesFromSheets } from '../../services/vehicle-sync.service.js'

const router = Router()

// Apply authentication to all routes
router.use(authenticate)

// Sync status and trigger endpoints
router.get('/sync/status', (_req: Request, res: Response) => {
  const status = getVehicleSyncStatus()
  res.json(status)
})

router.post('/sync/trigger', async (_req: Request, res: Response) => {
  try {
    const result = await syncVehiclesFromSheets()
    res.json(result)
  } catch (error: any) {
    res.status(500).json({ success: false, error: error.message })
  }
})

// Vehicle CRUD
router.get('/', getAllVehicles)
router.get('/document-audit-logs/all', getAllDocumentAuditLogs)
router.get('/:id/document-audit-logs', getVehicleDocumentAuditLogs)
router.get('/:id', getVehicleById)
router.post('/', createVehicle)
router.put('/:id', updateVehicle)
router.delete('/:id', deleteVehicle)

export default router
</file>

<file path="server/src/routes/route.routes.ts">
import { Router, Request, Response } from 'express'
import {
  getAllRoutes,
  getRouteById,
  createRoute,
  updateRoute,
  deleteRoute,
  getLegacyRoutes,
} from '../controllers/route.controller.js'
import { authenticate } from '../middleware/auth.js'
import { getRouteSyncStatus, syncRoutesFromSheets } from '../services/route-sync.service.js'

const router = Router()

router.use(authenticate)

// Sync status and trigger endpoints
router.get('/sync/status', (_req: Request, res: Response) => {
  const status = getRouteSyncStatus()
  res.json(status)
})

router.post('/sync/trigger', async (_req: Request, res: Response) => {
  try {
    const result = await syncRoutesFromSheets()
    res.json(result)
  } catch (error: any) {
    res.status(500).json({ success: false, error: error.message })
  }
})

router.get('/', getAllRoutes)
router.get('/legacy', getLegacyRoutes)
router.get('/:id', getRouteById)
router.post('/', createRoute)
router.put('/:id', updateRoute)
router.delete('/:id', deleteRoute)

export default router
</file>

<file path="server/src/services/dashboard.service.ts">
/**
 * Dashboard Service
 * Business logic for dashboard data aggregation
 * Optimized: Single query per table + caching
 */

import { firebase } from '../config/database.js';
import type { DispatchDBRecord } from '../modules/dispatch/dispatch-types.js';
import type { VehicleDBRecord, VehicleDocumentDB, DriverDBRecord } from '../modules/fleet/fleet-types.js';
import type { FirebaseQueryResult } from '../types/common.js';

// Route DB record (minimal for dashboard needs)
interface RouteDBRecord {
  id: string;
  route_name: string;
}

// Cache structure
interface DashboardCache {
  data: DashboardAllData | null;
  timestamp: number;
}

interface DashboardAllData {
  stats: DashboardStats;
  chartData: ChartDataPoint[];
  recentActivity: RecentActivity[];
  warnings: Warning[];
  weeklyStats: WeeklyStat[];
  monthlyStats: MonthlyStat[];
  routeBreakdown: RouteBreakdown[];
}

// Cache with 1 minute TTL (dashboard needs fresh data)
let dashboardCache: DashboardCache = { data: null, timestamp: 0 };
const CACHE_TTL = 60 * 1000; // 1 minute

// Helper function to get today's date string in Vietnam timezone (YYYY-MM-DD)
function getVietnamTodayStr(): string {
  const now = new Date();
  // Convert to Vietnam time (UTC+7)
  const vietnamTime = new Date(now.getTime() + (7 * 60 + now.getTimezoneOffset()) * 60000);
  const year = vietnamTime.getFullYear();
  const month = String(vietnamTime.getMonth() + 1).padStart(2, '0');
  const day = String(vietnamTime.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// Helper to check if a datetime string is from today (Vietnam time)
function isToday(dateTimeStr: string | undefined, todayStr: string): boolean {
  if (!dateTimeStr) return false;
  const dateStr = dateTimeStr.split('T')[0];
  return dateStr === todayStr;
}

interface DashboardStats {
  totalVehiclesToday: number;
  vehiclesInStation: number;
  vehiclesDepartedToday: number;
  revenueToday: number;
  invalidVehicles: number;
}

interface ChartDataPoint {
  hour: string;
  count: number;
}

interface RecentActivity {
  id: string;
  vehiclePlateNumber: string;
  route: string;
  entryTime: string;
  status: string;
}

interface Warning {
  type: 'vehicle' | 'driver';
  plateNumber?: string;
  name?: string;
  document: string;
  expiryDate: string;
}

interface WeeklyStat {
  day: string;
  dayName: string;
  departed: number;
  inStation: number;
  total: number;
}

interface MonthlyStat {
  month: string;
  monthName: string;
  departed: number;
  waiting: number;
  other: number;
}

interface RouteBreakdown {
  routeId: string;
  routeName: string;
  count: number;
  percentage: number;
}

// Raw data from database
interface RawData {
  dispatchRecords: DispatchDBRecord[];
  vehicles: Record<string, VehicleDBRecord>;
  routes: Record<string, RouteDBRecord>;
  documents: VehicleDocumentDB[];
  drivers: DriverDBRecord[];
  todayStr: string;
}

export class DashboardService {
  /**
   * Load all raw data from database in parallel (ONE query per table)
   */
  private async loadRawData(): Promise<RawData> {
    const todayStr = getVietnamTodayStr();
    const startTime = Date.now();

    // Query all tables in PARALLEL - only 5 queries total
    const [dispatchResult, vehiclesResult, routesResult, documentsResult, driversResult] = await Promise.all([
      firebase.from('dispatch_records').select('*').order('entry_time', { ascending: false }) as Promise<FirebaseQueryResult<DispatchDBRecord>>,
      firebase.from('vehicles').select('*') as Promise<FirebaseQueryResult<VehicleDBRecord>>,
      firebase.from('routes').select('*') as Promise<FirebaseQueryResult<RouteDBRecord>>,
      firebase.from('vehicle_documents').select('*') as Promise<FirebaseQueryResult<VehicleDocumentDB>>,
      firebase.from('drivers').select('*') as Promise<FirebaseQueryResult<DriverDBRecord>>,
    ]);

    // Convert to lookup maps
    const vehicles: Record<string, VehicleDBRecord> = {};
    (vehiclesResult.data || []).forEach((v) => { vehicles[v.id] = v; });

    const routes: Record<string, RouteDBRecord> = {};
    (routesResult.data || []).forEach((r) => { routes[r.id] = r; });

    console.log(`[Dashboard] Loaded raw data in ${Date.now() - startTime}ms`);

    return {
      dispatchRecords: dispatchResult.data || [],
      vehicles,
      routes,
      documents: documentsResult.data || [],
      drivers: driversResult.data || [],
      todayStr,
    };
  }

  /**
   * Calculate stats from raw data (no DB query)
   */
  private calculateStats(raw: RawData): DashboardStats {
    const { dispatchRecords, documents, todayStr } = raw;

    // Filter to today's records
    const todayRecords = dispatchRecords.filter((r) => isToday(r.entry_time, todayStr));

    const vehiclesInStation = todayRecords.filter(
      (r) => ['entered', 'passengers_dropped', 'permit_issued', 'paid', 'departure_ordered'].includes(r.current_status) && !r.exit_time
    ).length;

    const vehiclesDepartedToday = todayRecords.filter((r) => r.current_status === 'departed' && r.exit_time).length;

    const totalVehiclesToday = vehiclesInStation + vehiclesDepartedToday;

    const paidRecords = todayRecords.filter((r) => (r.current_status === 'paid' || r.current_status === 'departed') && r.payment_amount);
    const revenueToday = paidRecords.reduce((sum, r) => sum + (parseFloat(String(r.payment_amount)) || 0), 0);

    const invalidVehicles = documents.filter((doc) => {
      const expiryDate = doc.expiry_date?.split('T')[0] || doc.expiry_date;
      return expiryDate && expiryDate < todayStr;
    }).length;

    return { totalVehiclesToday, vehiclesInStation, vehiclesDepartedToday, revenueToday, invalidVehicles };
  }

  /**
   * Calculate chart data from raw data (no DB query)
   */
  private calculateChartData(raw: RawData): ChartDataPoint[] {
    const { dispatchRecords, todayStr } = raw;
    const hours = Array.from({ length: 12 }, (_, i) => i + 6);
    const todayRecords = dispatchRecords.filter((r) => isToday(r.entry_time, todayStr));

    return hours.map((hour) => {
      const hourStr = hour.toString().padStart(2, '0');
      const count = todayRecords.filter((r) => {
        if (!r.entry_time) return false;
        const timeStr = r.entry_time.split('T')[1];
        const recordHour = timeStr ? timeStr.substring(0, 2) : '';
        return recordHour === hourStr;
      }).length;
      return { hour: `${hourStr}:00`, count };
    });
  }

  /**
   * Calculate recent activity from raw data (no DB query)
   */
  private calculateRecentActivity(raw: RawData): RecentActivity[] {
    const { dispatchRecords, vehicles, routes, todayStr } = raw;

    return dispatchRecords
      .filter((r) => isToday(r.entry_time, todayStr))
      .slice(0, 10)
      .map((record) => {
        const vehicle = vehicles[record.vehicle_id];
        const route = record.route_id ? routes[record.route_id] : undefined;
        return {
          id: record.id,
          vehiclePlateNumber: vehicle?.plate_number || record.vehicle_plate_number || '',
          route: route?.route_name || '',
          entryTime: record.entry_time,
          status: record.current_status,
        };
      });
  }

  /**
   * Calculate warnings from raw data (no DB query)
   */
  private calculateWarnings(raw: RawData): Warning[] {
    const { documents, vehicles, drivers, todayStr } = raw;
    const warnings: Warning[] = [];

    // Calculate 30 days from today
    const now = new Date();
    const vietnamTime = new Date(now.getTime() + (7 * 60 + now.getTimezoneOffset()) * 60000);
    vietnamTime.setDate(vietnamTime.getDate() + 30);
    const thirtyDaysFromNowStr = `${vietnamTime.getFullYear()}-${String(vietnamTime.getMonth() + 1).padStart(2, '0')}-${String(vietnamTime.getDate()).padStart(2, '0')}`;

    const docTypeMap: Record<string, string> = {
      registration: 'Đăng kiểm',
      inspection: 'Đăng kiểm',
      insurance: 'Bảo hiểm',
      operation_permit: 'Phù hiệu',
      emblem: 'Phù hiệu',
    };

    for (const doc of documents) {
      if (!doc.expiry_date) continue;
      const expiryDate = doc.expiry_date.split('T')[0] || doc.expiry_date;
      if (expiryDate >= todayStr && expiryDate <= thirtyDaysFromNowStr) {
        const vehicle = vehicles[doc.vehicle_id];
        warnings.push({
          type: 'vehicle',
          plateNumber: vehicle?.plate_number || '',
          document: docTypeMap[doc.document_type] || doc.document_type,
          expiryDate,
        });
      }
    }

    for (const driver of drivers) {
      if (!driver.license_expiry_date) continue;
      const expiryDate = driver.license_expiry_date.split('T')[0] || driver.license_expiry_date;
      if (expiryDate >= todayStr && expiryDate <= thirtyDaysFromNowStr) {
        warnings.push({
          type: 'driver',
          name: driver.full_name || '',
          document: 'Bằng lái',
          expiryDate,
        });
      }
    }

    return warnings.sort((a, b) => new Date(a.expiryDate).getTime() - new Date(b.expiryDate).getTime());
  }

  /**
   * Calculate weekly stats from raw data (no DB query)
   */
  private calculateWeeklyStats(raw: RawData): WeeklyStat[] {
    const { dispatchRecords } = raw;
    const dayNames = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
    const days: { dateStr: string; dayName: string }[] = [];

    for (let i = 6; i >= 0; i--) {
      const now = new Date();
      const vietnamTime = new Date(now.getTime() + (7 * 60 + now.getTimezoneOffset()) * 60000);
      vietnamTime.setDate(vietnamTime.getDate() - i);
      const dateStr = `${vietnamTime.getFullYear()}-${String(vietnamTime.getMonth() + 1).padStart(2, '0')}-${String(vietnamTime.getDate()).padStart(2, '0')}`;
      days.push({ dateStr, dayName: dayNames[vietnamTime.getDay()] });
    }

    return days.map(({ dateStr, dayName }) => {
      const dayRecords = dispatchRecords.filter((r) => isToday(r.entry_time, dateStr));
      const departed = dayRecords.filter((r) => r.current_status === 'departed' && r.exit_time).length;
      const inStation = dayRecords.filter((r) =>
        ['entered', 'passengers_dropped', 'permit_issued', 'paid', 'departure_ordered'].includes(r.current_status) && !r.exit_time
      ).length;
      return { day: dateStr, dayName, departed, inStation, total: departed + inStation };
    });
  }

  /**
   * Calculate monthly stats from raw data (no DB query)
   */
  private calculateMonthlyStats(raw: RawData): MonthlyStat[] {
    const { dispatchRecords } = raw;
    const now = new Date();
    const vietnamTime = new Date(now.getTime() + (7 * 60 + now.getTimezoneOffset()) * 60000);
    const currentYear = vietnamTime.getFullYear();
    const currentMonth = vietnamTime.getMonth();
    const monthNames = ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'];

    return monthNames.slice(0, currentMonth + 1).map((monthName, index) => {
      const yearMonthPrefix = `${currentYear}-${String(index + 1).padStart(2, '0')}`;
      const monthRecords = dispatchRecords.filter((r) => r.entry_time?.startsWith(yearMonthPrefix));
      const departed = monthRecords.filter((r) => r.current_status === 'departed').length;
      const waiting = monthRecords.filter((r) => ['entered', 'passengers_dropped', 'permit_issued', 'paid'].includes(r.current_status)).length;
      const other = monthRecords.length - departed - waiting;
      return { month: yearMonthPrefix, monthName, departed, waiting, other: Math.max(0, other) };
    });
  }

  /**
   * Calculate route breakdown from raw data (no DB query)
   */
  private calculateRouteBreakdown(raw: RawData): RouteBreakdown[] {
    const { dispatchRecords, routes, todayStr } = raw;
    const todayRecords = dispatchRecords.filter((r) => isToday(r.entry_time, todayStr));
    const total = todayRecords.length || 1;

    const routeCounts: Record<string, { routeName: string; count: number }> = {};
    for (const record of todayRecords) {
      const routeId = record.route_id || 'unknown';
      const routeName = routes[routeId]?.route_name || 'Khác';
      if (!routeCounts[routeId]) routeCounts[routeId] = { routeName, count: 0 };
      routeCounts[routeId].count++;
    }

    return Object.entries(routeCounts)
      .map(([routeId, data]) => ({
        routeId,
        routeName: data.routeName,
        count: data.count,
        percentage: Math.round((data.count / total) * 100),
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 6);
  }

  /**
   * Get all dashboard data - OPTIMIZED: single load + caching
   */
  async getAllData(): Promise<DashboardAllData> {
    const now = Date.now();

    // Return cached data if valid
    if (dashboardCache.data && (now - dashboardCache.timestamp) < CACHE_TTL) {
      console.log('[Dashboard] Returning cached data');
      return dashboardCache.data;
    }

    const startTime = Date.now();

    // Load all raw data in ONE parallel batch (5 queries instead of 15+)
    const raw = await this.loadRawData();

    // Calculate all metrics from raw data (no more DB queries)
    const data: DashboardAllData = {
      stats: this.calculateStats(raw),
      chartData: this.calculateChartData(raw),
      recentActivity: this.calculateRecentActivity(raw),
      warnings: this.calculateWarnings(raw),
      weeklyStats: this.calculateWeeklyStats(raw),
      monthlyStats: this.calculateMonthlyStats(raw),
      routeBreakdown: this.calculateRouteBreakdown(raw),
    };

    // Update cache
    dashboardCache = { data, timestamp: now };

    console.log(`[Dashboard] Generated all data in ${Date.now() - startTime}ms`);
    return data;
  }

  // Individual getters for backward compatibility (use cached data)
  async getStats(): Promise<DashboardStats> {
    const data = await this.getAllData();
    return data.stats;
  }

  async getChartData(): Promise<ChartDataPoint[]> {
    const data = await this.getAllData();
    return data.chartData;
  }

  async getRecentActivity(): Promise<RecentActivity[]> {
    const data = await this.getAllData();
    return data.recentActivity;
  }

  async getWarnings(): Promise<Warning[]> {
    const data = await this.getAllData();
    return data.warnings;
  }

  async getWeeklyStats(): Promise<WeeklyStat[]> {
    const data = await this.getAllData();
    return data.weeklyStats;
  }

  async getMonthlyStats(): Promise<MonthlyStat[]> {
    const data = await this.getAllData();
    return data.monthlyStats;
  }

  async getRouteBreakdown(): Promise<RouteBreakdown[]> {
    const data = await this.getAllData();
    return data.routeBreakdown;
  }

  // Clear cache (for manual refresh)
  clearCache(): void {
    dashboardCache = { data: null, timestamp: 0 };
  }
}

export const dashboardService = new DashboardService();
</file>

<file path="client/src/components/driver/DriverForm.tsx">
import { useState, useEffect, useRef } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { toast } from "react-toastify"
import { QrCode, Search, Upload, X } from "lucide-react"

import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Select } from "@/components/ui/select"
import { QRScanner } from "@/components/QRScanner"
import { DatePicker } from "@/components/DatePicker"
import { driverService } from "@/services/driver.service"
import { operatorService } from "@/services/operator.service"
import api from "@/lib/api"
import { Driver, DriverInput, Operator } from "@/types"
import { provinceService, type Province, type District, type Ward } from "@/services/province.service"

const LICENSE_CLASSES = [
  "A", "A1", "A2", "A3", "A4", "B", "B1", "B2", "BE", "C", "C1", "C1E",
  "CE", "D", "D1", "D1E", "D2", "D2E", "DE", "D,FC", "E", "E,FC", "F",
  "FB2", "FC", "FD", "FE"
]

const driverSchema = z.object({
  operatorIds: z.array(z.string().min(1, "Invalid operator ID")).min(1, "Vui lòng chọn ít nhất một nhà xe"),
  fullName: z.string().min(1, "Họ tên là bắt buộc"),
  idNumber: z.string().min(1, "Số CMND/CCCD là bắt buộc"),
  phone: z.string().optional(),
  licenseNumber: z.string().min(1, "Số bằng lái là bắt buộc"),
  licenseClass: z.string().min(1, "Hạng bằng lái là bắt buộc"),
  licenseExpiryDate: z.string().min(1, "Ngày hết hạn bằng lái là bắt buộc"),
  province: z.string().optional(), // Optional - có thể không có khi edit
  district: z.string().optional(), // Optional - có thể không có khi edit
  ward: z.string().optional(), // Phường/Xã (chỉ dùng cho v1)
  address: z.string().optional(),
  imageUrl: z.string().url().optional().or(z.literal("")),
})

type DriverFormData = z.infer<typeof driverSchema>

interface DriverFormProps {
  driver: Driver | null
  mode: "create" | "edit"
  onClose: () => void
}

export function DriverForm({ driver, mode, onClose }: DriverFormProps) {
  const [qrScannerOpen, setQrScannerOpen] = useState(false)
  const [operators, setOperators] = useState<Operator[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [selectedOperatorIds, setSelectedOperatorIds] = useState<string[]>([])
  const [imageUrl, setImageUrl] = useState<string>("")
  const [uploading, setUploading] = useState(false)
  const [licenseExpiryDate, setLicenseExpiryDate] = useState<Date | null>(
    driver?.licenseExpiryDate ? new Date(driver.licenseExpiryDate) : null
  )
  
  const [useApiV2, setUseApiV2] = useState(false) // false = v1 (trước sáp nhập), true = v2 (sau sáp nhập)
  const [provinces, setProvinces] = useState<Province[]>([])
  const [districts, setDistricts] = useState<District[]>([])
  const [wards, setWards] = useState<Ward[]>([]) // Phường/Xã cho v1
  const [isLoadingProvinces, setIsLoadingProvinces] = useState(false)
  const [isLoadingDistricts, setIsLoadingDistricts] = useState(false)
  const [isLoadingWards, setIsLoadingWards] = useState(false)
  const [selectedProvinceCode, setSelectedProvinceCode] = useState<string | null>(null)
  const [selectedDistrictCode, setSelectedDistrictCode] = useState<string | null>(null)
  const isInitialMount = useRef(true)
  
  const {
    register,
    handleSubmit,
    setValue,
    watch,
    formState: { errors },
  } = useForm<DriverFormData>({
    resolver: zodResolver(driverSchema),
    defaultValues: driver
      ? {
          operatorIds: driver.operatorIds || (driver.operatorId ? [driver.operatorId] : []),
          fullName: driver.fullName,
          idNumber: driver.idNumber,
          phone: driver.phone || "",
          licenseNumber: driver.licenseNumber,
          licenseClass: driver.licenseClass,
          licenseExpiryDate: driver.licenseExpiryDate
            ? new Date(driver.licenseExpiryDate).toISOString().split("T")[0]
            : "",
          province: driver.province || "",
          district: driver.district || "",
          ward: "",
          address: driver.address || "",
          imageUrl: driver.imageUrl || "",
        }
      : undefined,
  })

  const watchProvince = watch("province")
  const watchDistrict = watch("district")

  // Load provinces từ API
  const loadProvinces = async (apiVersion: boolean): Promise<Province[]> => {
    setIsLoadingProvinces(true)
    try {
      const data = apiVersion
        ? await provinceService.getProvincesV2()
        : await provinceService.getProvincesV1()
      setProvinces(data)
      return data
    } catch (error) {
      console.error("Failed to load provinces:", error)
      toast.error("Không thể tải danh sách tỉnh thành. Vui lòng thử lại sau.")
      return []
    } finally {
      setIsLoadingProvinces(false)
    }
  }

  // Load districts khi chọn province
  const loadDistricts = async (provinceCode: string, apiVersion: boolean): Promise<District[]> => {
    if (!provinceCode) {
      setDistricts([])
      return []
    }

    setIsLoadingDistricts(true)
    try {
      let result: District[] = []
      if (apiVersion) {
        // V2: Lấy phường/xã trực tiếp từ province (không có cấp quận/huyện)
        const wards = await provinceService.getWardsByProvinceV2(provinceCode)
        result = wards.map(w => ({ code: w.code, name: w.name }))
        setDistricts(result)
      } else {
        // V1: Lấy quận/huyện từ province
        result = await provinceService.getDistrictsByProvinceV1(provinceCode)
        setDistricts(result)
      }
      return result
    } catch (error) {
      console.error("Failed to load districts:", error)
      toast.error("Không thể tải danh sách quận/huyện. Vui lòng thử lại sau.")
      setDistricts([])
      return []
    } finally {
      setIsLoadingDistricts(false)
    }
  }

  // Load wards khi chọn district (chỉ cho v1)
  // Sử dụng API từ addresskit.cas.so để lấy dữ liệu chính xác từ Cục Thống Kê
  const loadWards = async (provinceCode: string, districtCode: string) => {
    if (!provinceCode || !districtCode) {
      setWards([])
      return
    }

    setIsLoadingWards(true)
    try {
      const data = await provinceService.getWardsByDistrictV1(provinceCode, districtCode)
      setWards(data)
    } catch (error) {
      console.error("Failed to load wards:", error)
      toast.error("Không thể tải danh sách phường/xã. Vui lòng thử lại sau.")
      setWards([])
    } finally {
      setIsLoadingWards(false)
    }
  }

  useEffect(() => {
    // Load operators và provinces song song để tăng tốc
    const initData = async () => {
      // Start all loads in parallel - cần await cả hai
      const [loadedProvinces] = await Promise.all([
        loadProvinces(useApiV2),
        loadOperators()
      ])

      if (driver) {
        const operatorIds = driver.operatorIds || (driver.operatorId ? [driver.operatorId] : [])
        setSelectedOperatorIds(operatorIds)
        setValue("operatorIds", operatorIds)
        setImageUrl(driver.imageUrl || "")

        // Load districts và wards dựa trên dữ liệu driver đã có
        if (driver.province && loadedProvinces.length > 0) {
          const province = loadedProvinces.find(p => p.name === driver.province)
          if (province) {
            setSelectedProvinceCode(province.code)
            const loadedDistricts = await loadDistricts(province.code, useApiV2)

            // V1: Load wards nếu có district
            if (!useApiV2 && driver.district && loadedDistricts.length > 0) {
              const district = loadedDistricts.find(d => d.name === driver.district)
              if (district) {
                setSelectedDistrictCode(district.code)
                await loadWards(province.code, district.code)
              }
            }
          }
        }
      }
    }
    initData()
  }, [driver])

  // Reload provinces khi đổi API version (skip initial mount)
  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false
      return
    }
    loadProvinces(useApiV2)
    setDistricts([])
    setWards([])
    setValue("province", "")
    setValue("district", "")
    setValue("ward", "")
    setSelectedProvinceCode(null)
    setSelectedDistrictCode(null)
  }, [useApiV2, setValue])

  // Khi chọn province từ dropdown
  useEffect(() => {
    if (watchProvince) {
      const province = provinces.find(p => p.name === watchProvince)
      if (province && province.code !== selectedProvinceCode) {
        setSelectedProvinceCode(province.code)
        loadDistricts(province.code, useApiV2)
        setValue("district", "")
        setValue("ward", "")
        setWards([])
        setSelectedDistrictCode(null)
      }
    } else {
      setDistricts([])
      setWards([])
      setSelectedProvinceCode(null)
      setSelectedDistrictCode(null)
    }
  }, [watchProvince, provinces, selectedProvinceCode, useApiV2, setValue])

  // Khi chọn district từ dropdown (chỉ cho v1)
  useEffect(() => {
    if (!useApiV2 && watchDistrict && selectedProvinceCode) {
      const district = districts.find(d => d.name === watchDistrict)
      if (district && district.code !== selectedDistrictCode) {
        setSelectedDistrictCode(district.code)
        loadWards(selectedProvinceCode, district.code)
        setValue("ward", "")
      }
    } else if (useApiV2) {
      setWards([])
      setSelectedDistrictCode(null)
    }
  }, [watchDistrict, selectedProvinceCode, districts, selectedDistrictCode, useApiV2, setValue])

  const loadOperators = async (): Promise<Operator[]> => {
    try {
      // Use legacy endpoint to get operators from RTDB (2943 records)
      // instead of Supabase (only 3 records)
      const data = await operatorService.getLegacy()
      setOperators(data)
      return data
    } catch (error) {
      console.error("Failed to load operators:", error)
      toast.error("Không thể tải danh sách đơn vị vận tải")
      return []
    }
  }

  const filteredOperators = operators.filter((operator) => {
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      return operator.name.toLowerCase().includes(query) || 
             operator.code.toLowerCase().includes(query)
    }
    return true
  })

  const handleOperatorToggle = (operatorId: string) => {
    setSelectedOperatorIds(prev => {
      const isSelected = prev.includes(operatorId)
      const newIds = isSelected
        ? prev.filter(id => id !== operatorId)
        : [...prev, operatorId]
      setValue("operatorIds", newIds)
      return newIds
    })
  }

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    // Validate file type
    if (!file.type.startsWith('image/')) {
      toast.error('Vui lòng chọn file ảnh')
      return
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      toast.error('Kích thước ảnh không được vượt quá 5MB')
      return
    }

    setUploading(true)
    const formData = new FormData()
    formData.append('image', file)

    try {
      const response = await api.post<{ url: string }>('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      })
      setImageUrl(response.data.url)
      setValue("imageUrl", response.data.url)
      toast.success('Upload ảnh thành công')
    } catch (error) {
      console.error('Failed to upload image:', error)
      toast.error('Không thể upload ảnh. Vui lòng thử lại.')
    } finally {
      setUploading(false)
    }
  }

  const handleRemoveImage = () => {
    setImageUrl("")
    setValue("imageUrl", "")
  }

  const parseQRData = (qrText: string) => {
    try {
      const parts = qrText.split(";")
      if (parts.length < 7) {
        throw new Error("Định dạng QR code không hợp lệ")
      }

      const licenseNumber = parts[0].trim()
      const fullName = parts[1].trim()
      const licenseExpiryText = parts[5].trim()

      // Parse ngày hết hạn (có thể là "Không thời hạn" hoặc ddmmyyyy)
      let licenseExpiry = ""
      if (licenseExpiryText !== "Không thời hạn" && licenseExpiryText.length === 8) {
        // Convert ddmmyyyy to yyyy-mm-dd
        const day = licenseExpiryText.substring(0, 2)
        const month = licenseExpiryText.substring(2, 4)
        const year = licenseExpiryText.substring(4, 8)
        licenseExpiry = `${year}-${month}-${day}`
      } else if (licenseExpiryText === "Không thời hạn") {
        // Set a far future date for "no expiry"
        licenseExpiry = "2099-12-31"
      }

      // Điền vào form
      setValue("licenseNumber", licenseNumber)
      setValue("fullName", fullName)
      if (licenseExpiry) {
        setValue("licenseExpiryDate", licenseExpiry)
      }

      return true
    } catch (error) {
      console.error("Error parsing QR data:", error)
      toast.error("Không thể đọc dữ liệu từ QR code. Vui lòng thử lại.")
      return false
    }
  }

  const onSubmit = async (data: DriverFormData) => {
    try {
      // Ghép tất cả thành address theo format: "Địa chỉ cụ thể, phường xã, quận huyện, tỉnh thành phố"
      const addressParts: string[] = []
      
      if (data.address) {
        addressParts.push(data.address)
      }
      
      if (useApiV2) {
        // V2: district đã là phường/xã
        if (data.district) {
          addressParts.push(data.district)
        }
        if (data.province) {
          addressParts.push(data.province)
        }
      } else {
        // V1: có ward (phường/xã), district (quận/huyện), province (tỉnh)
        if (data.ward) {
          addressParts.push(data.ward)
        }
        if (data.district) {
          addressParts.push(data.district)
        }
        if (data.province) {
          addressParts.push(data.province)
        }
      }
      
      const fullAddress = addressParts.length > 0 ? addressParts.join(", ") : undefined

      const driverData: DriverInput = {
        operatorIds: data.operatorIds,
        fullName: data.fullName,
        idNumber: data.idNumber,
        phone: data.phone || undefined,
        licenseNumber: data.licenseNumber,
        licenseClass: data.licenseClass,
        licenseExpiryDate: data.licenseExpiryDate,
        province: data.province || undefined,
        district: data.district || undefined,
        address: fullAddress,
        imageUrl: data.imageUrl || undefined,
      }

      if (mode === "create") {
        await driverService.create(driverData)
        toast.success("Thêm lái xe thành công")
      } else if (driver) {
        await driverService.update(driver.id, driverData)
        toast.success("Cập nhật lái xe thành công")
      }
      onClose()
    } catch (error) {
      console.error("Failed to save driver:", error)
      toast.error("Có lỗi xảy ra khi lưu thông tin lái xe")
    }
  }

  return (
    <>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        <div className="space-y-6">
          {/* Header with title and QR button */}
          <div className="flex items-center justify-between">
            <h3 className="text-xl font-semibold">Thông tin lái xe</h3>
            {mode === "create" && (
              <Button
                type="button"
                variant="outline"
                onClick={() => setQrScannerOpen(true)}
                className="flex items-center gap-2"
              >
                <QrCode className="h-4 w-4" />
                Quét QR bằng lái
              </Button>
            )}
          </div>

          {/* Main 2 column layout */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Left Column */}
            <div className="space-y-6">
              {/* Sub-columns for ID and License info */}
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                {/* Column 1a - ID Info */}
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="idNumber">Số CMND/CCCD <span className="text-red-500">*</span></Label>
                    <Input
                      id="idNumber"
                      placeholder="Số CMND/CCCD"
                      {...register("idNumber")}
                    />
                    {errors.idNumber && (
                      <p className="text-sm text-red-600">{errors.idNumber.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="fullName">Họ tên <span className="text-red-500">*</span></Label>
                    <Input
                      id="fullName"
                      placeholder="Họ tên (*)"
                      {...register("fullName")}
                    />
                    {errors.fullName && (
                      <p className="text-sm text-red-600">{errors.fullName.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="phone">Số điện thoại <span className="text-red-500">*</span></Label>
                    <Input
                      id="phone"
                      placeholder="Số điện thoại (*)"
                      {...register("phone")}
                    />
                    {errors.phone && (
                      <p className="text-sm text-red-600">{errors.phone.message}</p>
                    )}
                  </div>

                </div>

                {/* Column 1b - License Info */}
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="licenseNumber">Số GPLX <span className="text-red-500">*</span></Label>
                    <Input
                      id="licenseNumber"
                      placeholder="Số GPLX (*)"
                      {...register("licenseNumber")}
                    />
                    {errors.licenseNumber && (
                      <p className="text-sm text-red-600">{errors.licenseNumber.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="licenseClass">Hạng GPLX <span className="text-red-500">*</span></Label>
                    <Select 
                      id="licenseClass"
                      defaultValue={driver?.licenseClass || ""}
                      {...register("licenseClass")}
                      className="max-h-[200px]"
                    >
                      <option value="">Chọn hạng GPLX</option>
                      {LICENSE_CLASSES.map((license) => (
                        <option key={license} value={license}>
                          {license}
                        </option>
                      ))}
                    </Select>
                    {errors.licenseClass && (
                      <p className="text-sm text-red-600">{errors.licenseClass.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="licenseExpiryDate">Hạn hiệu lực GPLX <span className="text-red-500">*</span></Label>
                    <DatePicker
                      date={licenseExpiryDate}
                      onDateChange={(date) => {
                        setLicenseExpiryDate(date || null)
                        if (date) {
                          const dateString = date.toISOString().split("T")[0]
                          setValue("licenseExpiryDate", dateString)
                        }
                      }}
                      placeholder="Chọn hạn GPLX"
                    />
                    {errors.licenseExpiryDate && (
                      <p className="text-sm text-red-600">{errors.licenseExpiryDate.message}</p>
                    )}
                  </div>
                </div>
              </div>

              {/* Địa chỉ với checkbox */}
              <div className="space-y-3 sm:space-y-4">
                <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 border-b pb-2">
                  <h3 className="text-base sm:text-lg font-semibold text-gray-800">
                    Thông tin địa chỉ
                  </h3>
                  {/* Checkbox chọn API version */}
                  <div className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      id="useApiV2"
                      checked={useApiV2}
                      onChange={(e) => setUseApiV2(e.target.checked)}
                      className="h-4 w-4"
                    />
                    <Label htmlFor="useApiV2" className="cursor-pointer text-xs sm:text-sm">
                      Sử dụng dữ liệu sau sáp nhập.
                    </Label>
                  </div>
                </div>

                {useApiV2 ? (
                  // V2: 2 cột (Tỉnh và Phường/Xã)
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                    <div>
                      <Label htmlFor="province">
                        Tỉnh/Thành phố <span className="text-red-500">(*)</span>
                      </Label>
                      <Select
                        id="province"
                        {...register("province")}
                        disabled={isLoadingProvinces}
                        className={errors.province ? "border-red-500" : ""}
                      >
                        <option value="">
                          {isLoadingProvinces ? "Đang tải..." : "Tỉnh/Thành phố"}
                        </option>
                        {provinces.map((province) => (
                          <option key={province.code} value={province.name}>
                            {province.name}
                          </option>
                        ))}
                      </Select>
                      {errors.province && (
                        <p className="text-sm text-red-500 mt-1">
                          {errors.province.message}
                        </p>
                      )}
                    </div>

                    <div>
                      <Label htmlFor="district">
                        Phường/Xã <span className="text-red-500">(*)</span>
                      </Label>
                      <Select
                        id="district"
                        {...register("district")}
                        disabled={!watchProvince || isLoadingDistricts}
                        className={errors.district ? "border-red-500" : ""}
                      >
                        <option value="">
                          {isLoadingDistricts ? "Đang tải..." : "Phường/Xã"}
                        </option>
                        {districts.map((district) => (
                          <option key={district.code} value={district.name}>
                            {district.name}
                          </option>
                        ))}
                      </Select>
                      {errors.district && (
                        <p className="text-sm text-red-500 mt-1">
                          {errors.district.message}
                        </p>
                      )}
                      {watchProvince && !isLoadingDistricts && districts.length === 0 && (
                        <p className="text-sm text-gray-500 mt-1">
                          Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                        </p>
                      )}
                    </div>
                  </div>
                ) : (
                  // V1: 3 cột (Tỉnh, Quận/Huyện, Phường/Xã)
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                    <div>
                      <Label htmlFor="province">
                        Tỉnh/Thành phố <span className="text-red-500">(*)</span>
                      </Label>
                      <Select
                        id="province"
                        {...register("province")}
                        disabled={isLoadingProvinces}
                        className={errors.province ? "border-red-500" : ""}
                      >
                        <option value="">
                          {isLoadingProvinces ? "Đang tải..." : "Tỉnh/Thành phố"}
                        </option>
                        {provinces.map((province) => (
                          <option key={province.code} value={province.name}>
                            {province.name}
                          </option>
                        ))}
                      </Select>
                      {errors.province && (
                        <p className="text-sm text-red-500 mt-1">
                          {errors.province.message}
                        </p>
                      )}
                    </div>

                    <div>
                      <Label htmlFor="district">
                        Quận/Huyện/Thị xã <span className="text-red-500">(*)</span>
                      </Label>
                      <Select
                        id="district"
                        {...register("district")}
                        disabled={!watchProvince || isLoadingDistricts}
                        className={errors.district ? "border-red-500" : ""}
                      >
                        <option value="">
                          {isLoadingDistricts ? "Đang tải..." : "Quận/Huyện/Thị xã"}
                        </option>
                        {districts.map((district) => (
                          <option key={district.code} value={district.name}>
                            {district.name}
                          </option>
                        ))}
                      </Select>
                      {errors.district && (
                        <p className="text-sm text-red-500 mt-1">
                          {errors.district.message}
                        </p>
                      )}
                      {watchProvince && !isLoadingDistricts && districts.length === 0 && (
                        <p className="text-sm text-gray-500 mt-1">
                          Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                        </p>
                      )}
                    </div>

                    <div>
                      <Label htmlFor="ward">Phường/Xã</Label>
                      <Select
                        id="ward"
                        {...register("ward")}
                        disabled={!watchDistrict || isLoadingWards}
                      >
                        <option value="">
                          {isLoadingWards ? "Đang tải..." : "Phường/Xã"}
                        </option>
                        {wards.map((ward) => (
                          <option key={ward.code} value={ward.name}>
                            {ward.name}
                          </option>
                        ))}
                      </Select>
                      {watchDistrict && !isLoadingWards && wards.length === 0 && (
                        <p className="text-sm text-gray-500 mt-1">
                          Không có dữ liệu. Vui lòng thử lại hoặc nhập thủ công.
                        </p>
                      )}
                    </div>
                  </div>
                )}

                {/* Địa chỉ cụ thể */}
                <div>
                  <Label htmlFor="fullAddress">Địa chỉ cụ thể</Label>
                  <Input
                    id="fullAddress"
                    placeholder="Địa chỉ cụ thể"
                    {...register("address")}
                  />
                </div>
              </div>
            </div>

            {/* Right Column */}
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              {/* Column 2a - Operator selection */}
              <div className="space-y-2">
                <Label>Doanh nghiệp vận tải <span className="text-red-500">*</span></Label>
                <div className="border rounded-md p-4 space-y-2 h-[400px] overflow-y-auto">
                  <div className="relative">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Tìm kiếm..."
                      className="w-full pl-10"
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                    />
                  </div>
                  <div className="space-y-2">
                    {filteredOperators.length === 0 ? (
                      <p className="text-sm text-gray-500 text-center py-4">
                        Không có dữ liệu
                      </p>
                    ) : (
                      filteredOperators.map((operator) => (
                        <div 
                          key={operator.id}
                          className="flex items-center space-x-2 p-2 hover:bg-gray-50 rounded"
                        >
                          <input 
                            type="checkbox" 
                            id={`operator-${operator.id}`}
                            className="h-4 w-4"
                            checked={selectedOperatorIds.includes(operator.id)}
                            onChange={() => handleOperatorToggle(operator.id)}
                          />
                          <Label 
                            htmlFor={`operator-${operator.id}`}
                            className="font-normal flex-1 cursor-pointer text-sm"
                          >
                            {operator.name}
                            {operator.code && (
                              <span className="text-gray-500 ml-2">({operator.code})</span>
                            )}
                          </Label>
                        </div>
                      ))
                    )}
                  </div>
                  <div className="pt-2 border-t text-sm text-gray-600">
                    <div>Tổng: {filteredOperators.length}</div>
                    <div>Đã chọn: {selectedOperatorIds.length}</div>
                  </div>
                </div>
                {errors.operatorIds && (
                  <p className="text-sm text-red-600">{errors.operatorIds.message}</p>
                )}
              </div>

              {/* Column 2b - Image Upload */}
              <div className="space-y-2">
                <Label>Ảnh lái xe</Label>
                {imageUrl ? (
                  <div className="relative border rounded-md p-2 bg-gray-50">
                    <img 
                      src={imageUrl} 
                      alt="Driver" 
                      className="w-full aspect-[3/4] object-cover rounded"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      className="absolute top-1 right-1 bg-white/80 hover:bg-white"
                      onClick={handleRemoveImage}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                ) : (
                  <div className="border-2 border-dashed rounded-md p-4 text-center aspect-[3/4] flex flex-col items-center justify-center">
                    <input
                      type="file"
                      id="imageUpload"
                      className="hidden"
                      accept="image/*"
                      onChange={handleImageUpload}
                      disabled={uploading}
                    />
                    <label htmlFor="imageUpload" className="cursor-pointer flex flex-col items-center justify-center w-full h-full">
                      <Upload className="h-8 w-8 mb-2 text-gray-400" />
                      <p className="text-sm text-gray-600">
                        {uploading ? "Đang upload..." : "Click để upload ảnh"}
                      </p>
                    </label>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        <div className="flex justify-end gap-3 pt-4 border-t">
          <Button type="button" variant="outline" onClick={onClose} className="min-w-[100px]">
            Hủy
          </Button>
          <Button type="submit" className="min-w-[100px]">
            Lưu
          </Button>
        </div>
      </form>

      {/* QR Scanner Dialog */}
      <Dialog open={qrScannerOpen} onOpenChange={setQrScannerOpen}>
        <DialogContent className="w-[95vw] max-w-[600px] max-h-[95vh] overflow-y-auto p-6">
          <DialogHeader>
            <DialogTitle className="text-2xl">Quét QR code bằng lái xe</DialogTitle>
          </DialogHeader>
        <div className="mt-4">
          <QRScanner
            onScanSuccess={(text) => {
              if (parseQRData(text)) {
                setQrScannerOpen(false)
              }
            }}
          />
        </div>
      </DialogContent>
    </Dialog>
    </>
  )
}
</file>

<file path="client/src/features/fleet/vehicles/components/VehicleForm.tsx">
import { useForm, Controller } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { toast } from "react-toastify"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { Autocomplete } from "@/components/ui/autocomplete"
import { vehicleService } from "../api"
import { vehicleTypeService } from "../api/vehicleTypeApi"
import { operatorService } from "@/features/fleet/operators/api"
import { provinceService, type Province } from "@/services/province.service"
import { vehicleBadgeService, type VehicleBadge } from "@/services/vehicle-badge.service"
import type { Vehicle, VehicleInput, VehicleType } from "../types"
import type { Operator } from "@/features/fleet/operators/types"
import { Eye, EyeOff, Upload } from "lucide-react"
import { useState, useEffect, useMemo } from "react"
import api from "@/lib/api"

const vehicleSchema = z.object({
  plateNumber: z.string().min(1, "Biển số là bắt buộc"),
  operatorId: z.string().optional(),
  vehicleTypeId: z.string().optional(),
  seatCapacity: z.number().min(1, "Số ghế phải lớn hơn 0"),
  bedCapacity: z.number().min(0, "Số giường không hợp lệ"),
  chassisNumber: z.string().optional(),
  engineNumber: z.string().optional(),
  insuranceExpiryDate: z.string().optional(),
  inspectionExpiryDate: z.string().optional(),
  cargoLength: z.preprocess(
    (val) => {
      if (val === "" || val === null || val === undefined) return undefined
      if (typeof val === 'number' && isNaN(val)) return undefined
      const num = Number(val)
      return isNaN(num) ? undefined : num
    },
    z.number().optional()
  ),
  cargoWidth: z.preprocess(
    (val) => {
      if (val === "" || val === null || val === undefined) return undefined
      if (typeof val === 'number' && isNaN(val)) return undefined
      const num = Number(val)
      return isNaN(num) ? undefined : num
    },
    z.number().optional()
  ),
  cargoHeight: z.preprocess(
    (val) => {
      if (val === "" || val === null || val === undefined) return undefined
      if (typeof val === 'number' && isNaN(val)) return undefined
      const num = Number(val)
      return isNaN(num) ? undefined : num
    },
    z.number().optional()
  ),
  gpsProvider: z.string().optional(),
  gpsUsername: z.string().optional(),
  gpsPassword: z.string().optional(),
  province: z.string().optional(),
  imageUrl: z.string().url().optional().or(z.literal("")),
})

type VehicleFormData = z.infer<typeof vehicleSchema>

interface VehicleFormProps {
  vehicle: Vehicle | null
  mode: "create" | "edit"
  onClose: () => void
}

export function VehicleForm({
  vehicle,
  mode,
  onClose,
}: VehicleFormProps) {
  const [autoRegister, setAutoRegister] = useState(true)
  const [showPassword, setShowPassword] = useState(false)
  const [vehicleImage, setVehicleImage] = useState<string | null>(null)
  const [isUploading, setIsUploading] = useState(false)
  const [operators, setOperators] = useState<Operator[]>([])
  const [provinces, setProvinces] = useState<Province[]>([])
  const [vehicleBadges, setVehicleBadges] = useState<VehicleBadge[]>([])
  const [vehicleTypes, setVehicleTypes] = useState<VehicleType[]>([])

  useEffect(() => {
    loadOperators()
    loadProvinces()
    loadVehicleBadges()
    loadVehicleTypes()
  }, [])

  useEffect(() => {
    if (vehicle) {
      setVehicleImage(vehicle.imageUrl || null)
    }
  }, [vehicle])

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true)
      setOperators(data)
    } catch (error) {
      console.error("Failed to load operators:", error)
    }
  }

  const loadProvinces = async () => {
    try {
      const data = await provinceService.getProvincesV2()
      setProvinces(data)
    } catch (error) {
      console.error("Failed to load provinces:", error)
      toast.error("Không thể tải danh sách tỉnh/thành phố")
    }
  }

  const loadVehicleBadges = async () => {
    try {
      const data = await vehicleBadgeService.getAll()
      setVehicleBadges(data)
    } catch (error) {
      console.error("Failed to load vehicle badges:", error)
    }
  }

  const loadVehicleTypes = async () => {
    try {
      const data = await vehicleTypeService.getAll()
      setVehicleTypes(data)
    } catch (error) {
      console.error("Failed to load vehicle types:", error)
    }
  }

  // Convert operators to autocomplete options
  const operatorOptions = useMemo(() => {
    return operators.map(op => ({
      value: op.id,
      label: op.name
    }))
  }, [operators])

  // Convert vehicle badges to plate number autocomplete options
  const plateNumberOptions = useMemo(() => {
    // Get unique plate numbers and include badge info in label
    const uniquePlates = new Map<string, VehicleBadge>()
    vehicleBadges.forEach(badge => {
      if (badge.license_plate_sheet && !uniquePlates.has(badge.license_plate_sheet)) {
        uniquePlates.set(badge.license_plate_sheet, badge)
      }
    })
    
    return Array.from(uniquePlates.entries()).map(([plate, badge]) => ({
      value: plate,
      label: badge.badge_type 
        ? `${plate} (${badge.badge_type}${badge.badge_color ? ' - ' + badge.badge_color : ''})`
        : plate
    }))
  }, [vehicleBadges])

  // Helper function to format date for input type="date"
  const formatDateForInput = (dateString: string | undefined | null): string => {
    if (!dateString) return ""
    try {
      const date = new Date(dateString)
      if (isNaN(date.getTime())) return ""
      return date.toISOString().split("T")[0]
    } catch {
      return ""
    }
  }

  const handleImageClick = async () => {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = 'image/*'
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0]
      if (file) {
        // Validate file type
        if (!file.type.startsWith('image/')) {
          toast.error('Vui lòng chọn file ảnh')
          return
        }

        // Validate file size (max 5MB)
        if (file.size > 5 * 1024 * 1024) {
          toast.error('Kích thước ảnh không được vượt quá 5MB')
          return
        }

        setIsUploading(true)
        try {
          // Upload to Cloudinary via backend
          const formData = new FormData()
          formData.append('image', file) // Changed from 'file' to 'image'

          const response = await api.post<{ url: string }>('/upload', formData, {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
          })

          setVehicleImage(response.data.url)
          setValue("imageUrl", response.data.url)
          toast.success('Upload ảnh thành công')
        } catch (error) {
          console.error('Failed to upload image:', error)
          toast.error('Không thể tải ảnh lên. Vui lòng thử lại.')
        } finally {
          setIsUploading(false)
        }
      }
    }
    input.click()
  }

  const {
    register,
    handleSubmit,
    setValue,
    reset,
    control,
    watch,
    formState: { errors },
  } = useForm<VehicleFormData>({
    resolver: zodResolver(vehicleSchema),
    defaultValues: vehicle ? {
      plateNumber: vehicle.plateNumber || "",
      operatorId: vehicle.operatorId || "",
      vehicleTypeId: vehicle.vehicleTypeId || "",
      seatCapacity: vehicle.seatCapacity || 1,
      bedCapacity: vehicle.bedCapacity || 0,
      chassisNumber: vehicle.chassisNumber || "",
      engineNumber: vehicle.engineNumber || "",
      insuranceExpiryDate: formatDateForInput(vehicle.insuranceExpiryDate),
      inspectionExpiryDate: formatDateForInput(vehicle.inspectionExpiryDate),
      cargoLength: vehicle.cargoLength || undefined,
      cargoWidth: vehicle.cargoWidth || undefined,
      cargoHeight: vehicle.cargoHeight || undefined,
      gpsProvider: vehicle.gpsProvider || "",
      gpsUsername: vehicle.gpsUsername || "",
      gpsPassword: vehicle.gpsPassword || "",
      province: vehicle.province || "",
      imageUrl: vehicle.imageUrl || "",
    } : {
      operatorId: "",
      seatCapacity: 1,
      bedCapacity: 0,
      imageUrl: "",
    },
  })

  // Reset form values when vehicle prop changes (for edit mode)
  useEffect(() => {
    if (vehicle) {
      const operatorId = vehicle.operatorId ? String(vehicle.operatorId) : ""
      const vehicleTypeId = vehicle.vehicleTypeId ? String(vehicle.vehicleTypeId) : ""

      const formValues = {
        plateNumber: vehicle.plateNumber || "",
        operatorId: operatorId,
        vehicleTypeId: vehicleTypeId,
        seatCapacity: vehicle.seatCapacity || 1,
        bedCapacity: vehicle.bedCapacity ?? 0,
        chassisNumber: vehicle.chassisNumber || "",
        engineNumber: vehicle.engineNumber || "",
        insuranceExpiryDate: formatDateForInput(vehicle.insuranceExpiryDate),
        inspectionExpiryDate: formatDateForInput(vehicle.inspectionExpiryDate),
        cargoLength: vehicle.cargoLength || undefined,
        cargoWidth: vehicle.cargoWidth || undefined,
        cargoHeight: vehicle.cargoHeight || undefined,
        gpsProvider: vehicle.gpsProvider || "",
        gpsUsername: vehicle.gpsUsername || "",
        gpsPassword: vehicle.gpsPassword || "",
        province: vehicle.province || "",
        imageUrl: vehicle.imageUrl || "",
      }

      // Reset form values
      reset(formValues)
      setVehicleImage(vehicle.imageUrl || null)

    } else {
      // Reset to default for create mode
      reset({
        operatorId: "",
        seatCapacity: 1,
        bedCapacity: 0,
        imageUrl: "",
      })
      setVehicleImage(null)
    }
  }, [vehicle, reset, setValue, operators.length])

  // Watch vehicleTypeId and auto-fill seat/bed capacity when changed (only in create mode)
  const watchedVehicleTypeId = watch("vehicleTypeId")
  useEffect(() => {
    // Only auto-fill in create mode to avoid overwriting user edits
    if (mode === "create" && watchedVehicleTypeId && vehicleTypes.length > 0) {
      const selectedType = vehicleTypes.find(vt => vt.id === watchedVehicleTypeId)
      if (selectedType) {
        if (selectedType.defaultSeatCapacity !== null && selectedType.defaultSeatCapacity !== undefined) {
          setValue("seatCapacity", selectedType.defaultSeatCapacity)
        }
        if (selectedType.defaultBedCapacity !== null && selectedType.defaultBedCapacity !== undefined) {
          setValue("bedCapacity", selectedType.defaultBedCapacity)
        }
      }
    }
  }, [watchedVehicleTypeId, vehicleTypes, mode, setValue])

  const onSubmit = async (data: VehicleFormData) => {
    try {
      // Clean up data: remove undefined values for optional fields
      const submitData: any = {
        ...data,
        imageUrl: vehicleImage || "",
      }

      // Remove undefined cargo dimensions
      if (submitData.cargoLength === undefined) delete submitData.cargoLength
      if (submitData.cargoWidth === undefined) delete submitData.cargoWidth
      if (submitData.cargoHeight === undefined) delete submitData.cargoHeight

      // Note: operatorId và vehicleTypeId cần được gửi đi kể cả khi rỗng để backend có thể cập nhật/xóa
      // Không xóa các field này như các optional fields khác

      // Remove empty strings for optional fields
      if (submitData.chassisNumber === "") delete submitData.chassisNumber
      if (submitData.engineNumber === "") delete submitData.engineNumber
      if (submitData.insuranceExpiryDate === "") delete submitData.insuranceExpiryDate
      if (submitData.inspectionExpiryDate === "") delete submitData.inspectionExpiryDate
      if (submitData.gpsProvider === "") delete submitData.gpsProvider
      if (submitData.gpsUsername === "") delete submitData.gpsUsername
      if (submitData.gpsPassword === "") delete submitData.gpsPassword
      if (submitData.province === "") delete submitData.province

      if (mode === "create") {
        await vehicleService.create(submitData as VehicleInput)
        toast.success("Thêm xe thành công!")
      } else if (vehicle) {
        await vehicleService.update(vehicle.id, submitData)
        toast.success("Cập nhật xe thành công!")
      }
      onClose()
    } catch (error: any) {
      console.error("Failed to save vehicle:", error)
      console.error("Error response:", error.response?.data)
      const errorMsg = error.response?.data?.message || error.response?.data?.error || "Có lỗi xảy ra khi lưu thông tin xe"
      toast.error(errorMsg)
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div className="grid grid-cols-12 gap-6">
        {/* Cột trái - Form thông tin */}
        <div className="col-span-8 space-y-6">
          {/* Thông tin xe đăng ký */}
          <div>
            <div className="flex items-center gap-2 mb-4">
              <h3 className="text-base font-semibold">Thông tin xe đăng ký</h3>
              <label className="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
                <input
                  type="checkbox"
                  checked={autoRegister}
                  onChange={(e) => setAutoRegister(e.target.checked)}
                  className="w-4 h-4 accent-blue-600"
                />
                Tiếp tục đăng ký hoạt động cho xe
              </label>
            </div>

            <div className="space-y-4">
              {/* Hàng 0: Nhà xe + Loại xe */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="operatorId" className="text-sm">
                    Nhà xe
                  </Label>
                  <Controller
                    name="operatorId"
                    control={control}
                    render={({ field }) => (
                      <Autocomplete
                        id="operatorId"
                        options={operatorOptions}
                        value={field.value || ""}
                        onChange={field.onChange}
                        placeholder="Chọn hoặc nhập tên nhà xe..."
                        className="h-11"
                      />
                    )}
                  />
                  {errors.operatorId && (
                    <p className="text-sm text-red-600">{errors.operatorId.message}</p>
                  )}
                </div>
                <div className="space-y-2">
                  <Label htmlFor="vehicleTypeId" className="text-sm">
                    Loại xe
                  </Label>
                  <Select
                    id="vehicleTypeId"
                    className="h-11"
                    {...register("vehicleTypeId")}
                  >
                    <option value="">Chọn loại xe</option>
                    {vehicleTypes.map((vt) => (
                      <option key={vt.id} value={vt.id}>
                        {vt.name}
                      </option>
                    ))}
                  </Select>
                  {errors.vehicleTypeId && (
                    <p className="text-sm text-red-600">{errors.vehicleTypeId.message}</p>
                  )}
                </div>
              </div>

              {/* Hàng 1: Biển kiểm soát, Số ghế, Số giường */}
              <div className="grid grid-cols-12 gap-4">
                {/* Biển kiểm soát - Autocomplete từ phù hiệu xe */}
                <div className="space-y-2 col-span-6">
                  <Label htmlFor="plateNumber" className="text-sm">
                    Biển kiểm soát (*)
                  </Label>
                  <Controller
                    name="plateNumber"
                    control={control}
                    render={({ field }) => (
                      <Autocomplete
                        id="plateNumber"
                        options={plateNumberOptions}
                        value={field.value || ""}
                        onChange={field.onChange}
                        placeholder="Nhập hoặc chọn biển số..."
                        className="h-11"
                      />
                    )}
                  />
                  {errors.plateNumber && (
                    <p className="text-sm text-red-600">{errors.plateNumber.message}</p>
                  )}
                </div>

                {/* Số ghế - nhỏ */}
                <div className="space-y-2 col-span-3">
                  <Label htmlFor="seatCapacity" className="text-sm">
                    Số ghế (*)
                  </Label>
                  <Input
                    id="seatCapacity"
                    type="number"
                    className="h-11"
                    placeholder="1"
                    {...register("seatCapacity", { valueAsNumber: true })}
                  />
                  {errors.seatCapacity && (
                    <p className="text-sm text-red-600">{errors.seatCapacity.message}</p>
                  )}
                </div>

                {/* Số giường - nhỏ */}
                <div className="space-y-2 col-span-3">
                  <Label htmlFor="bedCapacity" className="text-sm">
                    Số giường (*)
                  </Label>
                  <Input
                    id="bedCapacity"
                    type="number"
                    className="h-11"
                    placeholder="0"
                    {...register("bedCapacity", { valueAsNumber: true })}
                  />
                </div>
              </div>

              {/* Hàng 2: Số khung và Số máy */}
              <div className="grid grid-cols-2 gap-4">
                {/* Số khung */}
                <div className="space-y-2">
                  <Label htmlFor="chassisNumber" className="text-sm">
                    Số khung
                  </Label>
                  <Input
                    id="chassisNumber"
                    className="h-11"
                    placeholder="Số khung"
                    {...register("chassisNumber")}
                  />
                </div>

                {/* Số máy */}
                <div className="space-y-2">
                  <Label htmlFor="engineNumber" className="text-sm">
                    Số máy
                  </Label>
                  <Input
                    id="engineNumber"
                    className="h-11"
                    placeholder="Số máy"
                    {...register("engineNumber")}
                  />
                </div>
              </div>

              {/* Hàng 3: Tỉnh */}
              <div className="grid grid-cols-12 gap-4">
                <div className="space-y-2 col-span-6">
                  <Label htmlFor="province" className="text-sm">
                    Tỉnh/Thành phố
                  </Label>
                  <Select
                    id="province"
                    className="h-11"
                    {...register("province")}
                  >
                    <option value="">Chọn tỉnh/thành phố</option>
                    {provinces.map((province) => (
                      <option key={province.code} value={province.name}>
                        {province.name}
                      </option>
                    ))}
                  </Select>
                </div>
              </div>
            </div>
          </div>

          {/* Thông tin hạn hiệu lực */}
          <div>
            <h3 className="text-base font-semibold mb-4">Thông tin hạn hiệu lực</h3>
            <div className="grid grid-cols-2 gap-4">
              {/* Hạn bảo hiểm xe */}
              <div className="space-y-2">
                <Label htmlFor="insuranceExpiryDate" className="text-sm">
                  Hạn bảo hiểm xe (*)
                </Label>
                <Input
                  id="insuranceExpiryDate"
                  type="date"
                  className="h-11"
                  placeholder="Hạn bảo hiểm xe (*)"
                  {...register("insuranceExpiryDate")}
                />
              </div>

              {/* Hạn đăng kiểm xe */}
              <div className="space-y-2">
                <Label htmlFor="inspectionExpiryDate" className="text-sm">
                  Hạn đăng kiểm xe (*)
                </Label>
                <Input
                  id="inspectionExpiryDate"
                  type="date"
                  className="h-11"
                  placeholder="Hạn đăng kiểm xe (*)"
                  {...register("inspectionExpiryDate")}
                />
              </div>
            </div>
          </div>

          {/* Khoang chứa hàng */}
          <div>
            <h3 className="text-base font-semibold mb-4">Khoang chứa hàng</h3>
            <div className="grid grid-cols-3 gap-4">
              {/* Chiều dài */}
              <div className="space-y-2">
                <Label htmlFor="cargoLength" className="text-sm">
                  Chiều dài (m)
                </Label>
                <Input
                  id="cargoLength"
                  type="number"
                  step="0.1"
                  className="h-11"
                  placeholder="Chiều dài (m)"
                  {...register("cargoLength", { setValueAs: (v) => {
                    if (v === "" || v === null || v === undefined) return undefined
                    const num = Number(v)
                    return isNaN(num) ? undefined : num
                  }})}
                />
              </div>

              {/* Chiều rộng */}
              <div className="space-y-2">
                <Label htmlFor="cargoWidth" className="text-sm">
                  Chiều rộng (m)
                </Label>
                <Input
                  id="cargoWidth"
                  type="number"
                  step="0.1"
                  className="h-11"
                  placeholder="Chiều rộng (m)"
                  {...register("cargoWidth", { setValueAs: (v) => {
                    if (v === "" || v === null || v === undefined) return undefined
                    const num = Number(v)
                    return isNaN(num) ? undefined : num
                  }})}
                />
              </div>

              {/* Chiều cao */}
              <div className="space-y-2">
                <Label htmlFor="cargoHeight" className="text-sm">
                  Chiều cao (m)
                </Label>
                <Input
                  id="cargoHeight"
                  type="number"
                  step="0.1"
                  className="h-11"
                  placeholder="Chiều cao (m)"
                  {...register("cargoHeight", { setValueAs: (v) => {
                    if (v === "" || v === null || v === undefined) return undefined
                    const num = Number(v)
                    return isNaN(num) ? undefined : num
                  }})}
                />
              </div>
            </div>
          </div>

          {/* Thông tin giám sát hành trình */}
          <div>
            <h3 className="text-base font-semibold mb-4">Thông tin giám sát hành trình</h3>
            <div className="grid grid-cols-3 gap-4">
              {/* Hãng GSHT */}
              <div className="space-y-2">
                <Label htmlFor="gpsProvider" className="text-sm">
                  Hãng GSHT
                </Label>
                <Select
                  id="gpsProvider"
                  className="h-11"
                  {...register("gpsProvider")}
                >
                  <option value="">Hãng GSHT</option>
                  <option value="VietMap">VietMap</option>
                  <option value="NaviGo">NaviGo</option>
                  <option value="VIETTEL">VIETTEL</option>
                </Select>
              </div>

              {/* Tài khoản */}
              <div className="space-y-2">
                <Label htmlFor="gpsUsername" className="text-sm">
                  Tài khoản
                </Label>
                <Input
                  id="gpsUsername"
                  className="h-11"
                  placeholder="Tài khoản"
                  {...register("gpsUsername")}
                />
              </div>

              {/* Mật khẩu */}
              <div className="space-y-2">
                <Label htmlFor="gpsPassword" className="text-sm">
                  Mật khẩu
                </Label>
                <div className="relative">
                  <Input
                    id="gpsPassword"
                    type={showPassword ? "text" : "password"}
                    className="h-11 pr-10"
                    placeholder="Mật khẩu"
                    {...register("gpsPassword")}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700"
                  >
                    {showPassword ? <EyeOff size={20} /> : <Eye size={20} />}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Cột phải - Ảnh chụp của xe */}
        <div className="col-span-4">
          <div>
            <h3 className="text-base font-semibold mb-4">Ảnh chụp của xe</h3>
            <div
              className="w-full h-[300px] bg-gray-100 rounded-lg flex flex-col items-center justify-center text-gray-400 relative overflow-hidden cursor-pointer hover:bg-gray-200 transition-colors"
              onClick={handleImageClick}
            >
              {isUploading ? (
                <div className="flex flex-col items-center gap-2">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                  <p className="text-sm">Đang tải ảnh...</p>
                </div>
              ) : vehicleImage ? (
                <img src={vehicleImage} alt="Vehicle" className="w-full h-full object-cover" />
              ) : (
                <div className="flex flex-col items-center gap-2">
                  <Upload size={40} className="text-gray-400" />
                  <p>Click để chọn ảnh</p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      <div className="flex justify-end gap-3 pt-4 border-t">
        <Button type="button" variant="outline" onClick={onClose} className="min-w-[100px]">
          Hủy
        </Button>
        <Button type="submit" className="min-w-[100px]">Lưu</Button>
      </div>
    </form>
  )
}
</file>

<file path="client/src/hooks/useDieuDo.ts">
import { useState, useEffect, useMemo, useCallback } from "react";
import { useSearchParams } from "react-router-dom";
import { toast } from "react-toastify";
import { useDispatchStore } from "@/store/dispatch.store";
import { dispatchService } from "@/services/dispatch.service";
import { quanlyDataService } from "@/services/quanly-data.service";
import { useUIStore } from "@/store/ui.store";
import type { DispatchRecord, DispatchStatus, Vehicle } from "@/types";
import type { DisplayStatus } from "@/components/dispatch/common";

export type DialogType =
  | "entry"
  | "edit"
  | "return"
  | "permit"
  | "payment"
  | "depart"
  | "departure-order"
  | "monthly-payment"
  | "depart-multiple";

export function useDieuDo() {
  const [searchParams, setSearchParams] = useSearchParams();
  const { records, setRecords } = useDispatchStore();
  const [searchQuery, setSearchQuery] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [selectedRecord, setSelectedRecord] = useState<DispatchRecord | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogType, setDialogType] = useState<DialogType>("entry");
  const [isReadOnly, setIsReadOnly] = useState(false);
  const setTitle = useUIStore((state) => state.setTitle);

  // Restore dialog state from URL params
  useEffect(() => {
    const dispatchId = searchParams.get("dispatch");
    const action = searchParams.get("action") as DialogType | null;
    const readonly = searchParams.get("readonly") === "true";

    if (dispatchId && records.length > 0) {
      const record = records.find((r) => r.id === dispatchId);
      if (record) {
        setSelectedRecord(record);
        setDialogType(action || "permit");
        setIsReadOnly(readonly);
        setDialogOpen(true);
      }
    }
  }, [searchParams, records]);

  useEffect(() => {
    setTitle("Điều độ xe");
    loadVehicles();
    loadRecords();
    const interval = setInterval(loadRecords, 30000);
    return () => clearInterval(interval);
  }, [setTitle]);

  const loadVehicles = async () => {
    try {
      // Use cached quanlyDataService (5 min FE cache + 30 min BE cache)
      const data = await quanlyDataService.getVehicles();
      // Map to Vehicle type (only need id + plateNumber for vehicleOptions)
      const vehicles: Vehicle[] = data.map((v) => ({
        id: v.id,
        plateNumber: v.plateNumber,
        seatCapacity: v.seatCapacity,
        operatorId: '',
        operatorName: v.operatorName,
        isActive: v.isActive,
      }));
      setVehicles(vehicles);
    } catch (error) {
      console.error("Failed to load vehicles:", error);
    }
  };

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      // Filter out cancelled records
      const activeRecords = data.filter(r => r.currentStatus !== 'cancelled');
      setRecords(activeRecords);
    } catch (error) {
      console.error("Failed to load records:", error);
      toast.error("Không thể tải danh sách điều độ");
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async (record: DispatchRecord) => {
    console.log("[handleDelete] Called for record:", record.id, record.vehiclePlateNumber);
    if (!window.confirm(`Xóa xe ${record.vehiclePlateNumber} khỏi danh sách?`)) {
      console.log("[handleDelete] User cancelled");
      return;
    }
    try {
      console.log("[handleDelete] Calling API delete for:", record.id);
      await dispatchService.delete(record.id);
      console.log("[handleDelete] Delete successful");
      toast.success("Đã xóa xe khỏi danh sách");
      loadRecords();
    } catch (error: unknown) {
      console.error("[handleDelete] Error:", error);
      const err = error as { response?: { data?: { error?: string } } };
      toast.error(err.response?.data?.error || "Không thể xóa");
    }
  };

  const updateUrlParams = useCallback((record: DispatchRecord | null, type: DialogType, readonly = false) => {
    if (record) {
      const params = new URLSearchParams();
      params.set("dispatch", record.id);
      params.set("action", type);
      if (readonly) params.set("readonly", "true");
      setSearchParams(params, { replace: true });
    } else {
      setSearchParams({}, { replace: true });
    }
  }, [setSearchParams]);

  const closeDialog = useCallback(() => {
    setDialogOpen(false);
    setSearchParams({}, { replace: true });
  }, [setSearchParams]);

  const handleEdit = (record: DispatchRecord) => {
    setSelectedRecord(record);
    setDialogType("edit");
    setIsReadOnly(false);
    setDialogOpen(true);
    updateUrlParams(record, "edit");
  };

  const handleAction = (record: DispatchRecord, type: DialogType) => {
    setSelectedRecord(record);
    setDialogType(type);
    setDialogOpen(true);
    setIsReadOnly(false);
    updateUrlParams(record, type);
  };

  const handleOpenPermitReadOnly = (record: DispatchRecord) => {
    setSelectedRecord(record);
    setDialogType("permit");
    setIsReadOnly(true);
    setDialogOpen(true);
    updateUrlParams(record, "permit", true);
  };

  const handleRecordExit = async (record: DispatchRecord) => {
    if (window.confirm("Cho xe ra bến?")) {
      try {
        await dispatchService.recordExit(record.id);
        toast.success("Cho xe ra bến thành công!");
        loadRecords();
      } catch {
        toast.error("Không thể cho xe ra bến");
      }
    }
  };

  const getDisplayStatus = useCallback((currentStatus: DispatchStatus): DisplayStatus => {
    const statusMap: Record<DispatchStatus, DisplayStatus> = {
      entered: "in-station",
      passengers_dropped: "in-station",
      permit_issued: "permit-issued",
      permit_rejected: "in-station",
      paid: "paid",
      departure_ordered: "departed",
      departed: "departed",
      cancelled: "departed", // Cancelled records shown as departed (but filtered out in loadRecords)
    };
    return statusMap[currentStatus] || "in-station";
  }, []);

  const getRecordsByStatus = useCallback((status: DisplayStatus) => {
    return records
      .filter((record) => {
        if (record.currentStatus === "departed") return false;
        const displayStatus = getDisplayStatus(record.currentStatus);
        if (status === "in-station") return displayStatus === "in-station";
        if (status === "permit-issued") return displayStatus === "permit-issued";
        if (status === "paid") return displayStatus === "paid";
        if (status === "departed") return record.currentStatus === "departure_ordered";
        return false;
      })
      .filter((record) => {
        if (!searchQuery) return true;
        const query = searchQuery.toLowerCase();
        return (
          record.vehiclePlateNumber.toLowerCase().includes(query) ||
          (record.routeName || "").toLowerCase().includes(query) ||
          record.driverName.toLowerCase().includes(query)
        );
      });
  }, [records, searchQuery, getDisplayStatus]);

  const stats = useMemo(() => ({
    "in-station": getRecordsByStatus("in-station").length,
    "permit-issued": getRecordsByStatus("permit-issued").length,
    paid: getRecordsByStatus("paid").length,
    departed: getRecordsByStatus("departed").length,
  }), [getRecordsByStatus]);

  const totalActive = stats["in-station"] + stats["permit-issued"] + stats.paid + stats.departed;

  // Track active vehicles by PLATE NUMBER (not ID) to handle legacy/badge ID inconsistency
  const activePlateNumbers = useMemo(() => {
    const plates = new Set<string>();
    for (const record of records) {
      if (record.currentStatus !== "departed" && record.currentStatus !== "departure_ordered") {
        // Normalize plate number for comparison
        const plate = record.vehiclePlateNumber?.replace(/[.\-\s]/g, '').toUpperCase();
        if (plate) {
          plates.add(plate);
        }
      }
    }
    return plates;
  }, [records]);

  const vehicleOptions = useMemo(() => {
    const options = vehicles
      .filter((v) => {
        const normalizedPlate = v.plateNumber?.replace(/[.\-\s]/g, '').toUpperCase();
        const isEditingThisVehicle = dialogType === "edit" && 
          selectedRecord?.vehiclePlateNumber?.replace(/[.\-\s]/g, '').toUpperCase() === normalizedPlate;
        return !activePlateNumbers.has(normalizedPlate) || isEditingThisVehicle;
      })
      .map((v) => ({ id: v.id, plateNumber: v.plateNumber }));
    
    // When editing, ensure the current vehicle's plateNumber is in the options
    if (dialogType === "edit" && selectedRecord?.vehicleId && selectedRecord?.vehiclePlateNumber) {
      const normalizedEditPlate = selectedRecord.vehiclePlateNumber.replace(/[.\-\s]/g, '').toUpperCase();
      const existsInOptions = options.some(
        (o) => o.plateNumber?.replace(/[.\-\s]/g, '').toUpperCase() === normalizedEditPlate
      );
      if (!existsInOptions) {
        options.unshift({
          id: selectedRecord.vehicleId,
          plateNumber: selectedRecord.vehiclePlateNumber,
        });
      }
    }
    
    return options;
  }, [vehicles, activePlateNumbers, dialogType, selectedRecord]);

  const isMonthlyPaymentVehicle = useCallback((record: DispatchRecord): boolean => {
    if (record.metadata?.paymentType === "monthly") return true;
    const displayStatus = getDisplayStatus(record.currentStatus);
    if (record.transportOrderCode && displayStatus === "in-station") return true;
    return false;
  }, [getDisplayStatus]);

  const getVehicleStatus = useCallback((record: DispatchRecord, status: DisplayStatus): 'eligible' | 'ineligible' | 'returned' | 'irregular' | null => {
    if (record.metadata?.type === "irregular") return 'irregular';
    if (record.currentStatus === "passengers_dropped") return 'returned';
    if (record.permitStatus === "rejected" || (status === "paid" && !record.permitStatus)) return 'ineligible';
    if (record.permitStatus === "approved") return 'eligible';
    return null;
  }, []);

  return {
    records,
    searchQuery,
    setSearchQuery,
    isLoading,
    vehicles,
    selectedRecord,
    setSelectedRecord,
    dialogOpen,
    setDialogOpen,
    closeDialog,
    dialogType,
    setDialogType,
    isReadOnly,
    setIsReadOnly,
    vehicleOptions,
    stats,
    totalActive,
    loadRecords,
    handleDelete,
    handleEdit,
    handleAction,
    handleOpenPermitReadOnly,
    handleRecordExit,
    getDisplayStatus,
    getRecordsByStatus,
    isMonthlyPaymentVehicle,
    getVehicleStatus,
  };
}
</file>

<file path="client/src/pages/HomePage.tsx">
import { Link } from "react-router-dom"
import { useState, useEffect, useRef } from "react"
import {
  CheckCircle,
  ArrowRight,
  Play,
  Shield,
  Building2,
  FileCheck,
  CreditCard,
  Smartphone,
  ChevronRight,
  Quote,
  Star,
  Bus,
  FileText,
  Lock,
  Layers,
  TrendingUp,
  Globe
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"

// Animated counter hook
function useCountUp(end: number, duration: number = 2000) {
  const [count, setCount] = useState(0)
  const [hasStarted, setHasStarted] = useState(false)
  const ref = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting && !hasStarted) {
          setHasStarted(true)
        }
      },
      { threshold: 0.3 }
    )

    if (ref.current) {
      observer.observe(ref.current)
    }

    return () => observer.disconnect()
  }, [hasStarted])

  useEffect(() => {
    if (!hasStarted) return

    let startTime: number
    const step = (timestamp: number) => {
      if (!startTime) startTime = timestamp
      const progress = Math.min((timestamp - startTime) / duration, 1)
      setCount(Math.floor(progress * end))
      if (progress < 1) {
        requestAnimationFrame(step)
      }
    }
    requestAnimationFrame(step)
  }, [hasStarted, end, duration])

  return { count, ref }
}

// Data
const stats = [
  { value: 600, suffix: "+", label: "Doanh nghiệp vận tải", icon: Building2 },
  { value: 500, suffix: "+", label: "Bến xe kết nối", icon: Bus },
  { value: 10000, suffix: "+", label: "Xe khách trong hệ thống", icon: TrendingUp },
  { value: 9000, suffix: "+", label: "Lệnh điện tử/ngày", icon: FileText }
]

const features = [
  {
    icon: FileCheck,
    title: "Lệnh vận chuyển điện tử",
    description: "Ký số lệnh vận chuyển theo chuẩn pháp lý, lưu trữ 3 năm, không giới hạn số lượng.",
    color: "bg-emerald-600"
  },
  {
    icon: CreditCard,
    title: "Thanh toán tự động",
    description: "Hệ thống thanh toán điện tử đa kênh, tích hợp mọi phương thức thanh toán hiện đại.",
    color: "bg-teal-600"
  },
  {
    icon: Shield,
    title: "Cổng vào ra tự động",
    description: "Nhận diện biển số, kiểm tra lệnh điện tử real-time, quản lý xe vào ra tự động.",
    color: "bg-emerald-700"
  },
  {
    icon: Smartphone,
    title: "Vé xe điện tử",
    description: "Vé điện tử hợp pháp, kết nối 400+ bến xe, đồng bộ dữ liệu lệnh điện tử tức thì.",
    color: "bg-teal-700"
  }
]

const solutions = [
  {
    title: "Phần mềm Quản lý Bến xe",
    subtitle: "Giải pháp toàn diện",
    description: "Hệ thống quản lý vận hành bến xe hiện đại, tự động hóa quy trình từ điều độ đến thanh toán.",
    image: "https://images.unsplash.com/photo-1544620347-c4fd4a3d5957?w=800&q=80",
    features: ["Điều độ xe tự động", "Quản lý lệnh điện tử", "Báo cáo real-time", "Tích hợp API"]
  },
  {
    title: "Hệ thống Bán vé Ủy thác",
    subtitle: "Mở rộng kênh bán",
    description: "Kết nối mạng lưới bán vé rộng khắp, tăng doanh thu thông qua hệ sinh thái đại lý.",
    image: "https://images.unsplash.com/photo-1570125909232-eb263c188f7e?w=800&q=80",
    features: ["400+ điểm bán", "Đối soát tự động", "Hoa hồng linh hoạt", "App đại lý"]
  }
]

const testimonials = [
  {
    content: "ABC C&T đã giúp chúng tôi số hóa hoàn toàn quy trình vận hành. Hiệu quả tăng 40%, chi phí giảm đáng kể.",
    author: "Nguyễn Văn Minh",
    role: "Giám đốc Bến xe Miền Đông",
    avatar: "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop"
  },
  {
    content: "Hệ thống lệnh điện tử hoạt động ổn định, hỗ trợ kỹ thuật nhanh chóng. Rất hài lòng với dịch vụ.",
    author: "Trần Thị Hương",
    role: "Phó GĐ Công ty Vận tải Phương Trang",
    avatar: "https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=100&h=100&fit=crop"
  }
]

const pricingPlans = [
  {
    name: "Lệnh vận chuyển điện tử",
    price: "500.000",
    unit: "₫/tháng",
    description: "Dành cho doanh nghiệp vận tải",
    features: [
      "Ký số lệnh vận chuyển",
      "Lưu trữ dữ liệu 03 năm",
      "Miễn phí phần mềm",
      "Không giới hạn số lượng",
      "Hỗ trợ kỹ thuật 24/7"
    ],
    popular: false,
    cta: "Bắt đầu ngay"
  },
  {
    name: "Vé xe khách điện tử",
    price: "100.000",
    unit: "₫/vé",
    description: "Giải pháp bán vé hiện đại",
    features: [
      "Đảm bảo yêu cầu pháp lý",
      "Đồng bộ lệnh điện tử",
      "Kết nối 400+ bến xe",
      "Tích hợp kế toán",
      "Hệ sinh thái bán vé"
    ],
    popular: true,
    cta: "Đăng ký ngay"
  },
  {
    name: "Chữ ký số HSM",
    price: "600.000",
    unit: "₫/năm",
    description: "Chứng thư số server",
    features: [
      "Không giới hạn lần ký",
      "Truy cập mọi lúc mọi nơi",
      "Tốc độ ký cao",
      "Bảo mật chuẩn quốc tế",
      "Dùng cho lệnh và vé"
    ],
    popular: false,
    cta: "Tìm hiểu thêm"
  }
]

// Floating Dashboard Mockup Component
export default function HomePage() {
  return (
    <div className="w-full overflow-x-hidden bg-stone-50 pt-16 lg:pt-[72px]">
      {/* Hero Section - Modern Cinematic */}
      <section className="relative min-h-screen flex items-center overflow-hidden">
        {/* Professional Background Image */}
        <div className="absolute inset-0">
          <img
            src="https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=1920&q=80"
            alt="City skyline transportation"
            className="w-full h-full object-cover"
          />
          {/* Gradient Overlay - Sage Green Tint */}
          <div className="absolute inset-0 bg-gradient-to-r from-stone-900/95 via-stone-900/80 to-stone-900/40" />
          <div className="absolute inset-0 bg-gradient-to-t from-stone-900/60 via-transparent to-stone-900/30" />
        </div>

        <div className="container mx-auto px-4 lg:px-8 relative z-10 py-24 lg:py-32">
          <div className="max-w-3xl">
            {/* Badge */}
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-white/10 backdrop-blur-sm border border-white/20 rounded-full mb-8">
              <span className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse" />
              <span className="text-sm text-white/90 font-medium">
                10 vạn+ doanh nghiệp đang sử dụng
              </span>
            </div>

            {/* Heading - Elegant Serif Typography */}
            <h1 className="font-display text-4xl sm:text-5xl lg:text-6xl xl:text-7xl font-medium text-white tracking-tight mb-8 space-y-2">
              <span className="block leading-tight">Giải pháp</span>
              <span className="block leading-tight italic text-emerald-300">Chuyển đổi số</span>
              <span className="block leading-tight">cho Bến xe.</span>
            </h1>

            <p className="text-lg lg:text-xl text-white/70 max-w-xl leading-relaxed mb-10">
              Nền tảng công nghệ toàn diện giúp bến xe và doanh nghiệp vận tải
              tối ưu vận hành, tăng doanh thu.
            </p>

            {/* CTA Buttons */}
            <div className="flex flex-col sm:flex-row gap-4 mb-12">
              <Link to="/lien-he">
                <Button size="lg" className="bg-white text-stone-900 hover:bg-white/90 px-8 h-14 text-base font-semibold shadow-2xl rounded-full group">
                  Bắt đầu miễn phí
                  <ArrowRight className="ml-2 w-5 h-5 group-hover:translate-x-1 transition-transform" />
                </Button>
              </Link>
              <Link to="/products">
                <Button size="lg" variant="outline" className="border-white/30 text-white hover:bg-white/10 h-14 text-base rounded-full bg-transparent backdrop-blur-sm">
                  <Play className="mr-2 w-5 h-5 fill-white" />
                  Xem demo
                </Button>
              </Link>
            </div>

            {/* Trust Indicators */}
            <div className="flex items-center gap-8">
              <div className="flex -space-x-3">
                {[
                  'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=80&h=80&fit=crop',
                  'https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=80&h=80&fit=crop',
                  'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=80&h=80&fit=crop',
                  'https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=80&h=80&fit=crop'
                ].map((img, i) => (
                  <img key={i} src={img} alt="" className="w-10 h-10 rounded-full border-2 border-stone-900 object-cover" />
                ))}
              </div>
              <div className="text-white/80">
                <div className="flex items-center gap-1">
                  {[1,2,3,4,5].map(i => <Star key={i} className="w-4 h-4 text-amber-400 fill-amber-400" />)}
                  <span className="font-semibold text-white ml-2">4.9</span>
                </div>
                <span className="text-sm text-white/60">12,000+ đánh giá</span>
              </div>
            </div>
          </div>
        </div>

        {/* Scroll Indicator */}
        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 text-white/50">
          <span className="text-xs uppercase tracking-widest">Cuộn xuống</span>
          <div className="w-6 h-10 border-2 border-white/30 rounded-full flex justify-center pt-2">
            <div className="w-1.5 h-1.5 bg-white/50 rounded-full animate-bounce" />
          </div>
        </div>
      </section>

      {/* Logos Section */}
      <section className="py-12 bg-white border-y border-stone-100">
        <div className="container mx-auto px-4 lg:px-8">
          <p className="text-center text-sm text-stone-500 mb-8">Được tin tưởng bởi các đối tác hàng đầu</p>
          <div className="flex flex-wrap justify-center items-center gap-8 lg:gap-16 opacity-60 grayscale">
            {['Bến xe Miền Đông', 'Phương Trang', 'Thành Bưởi', 'Mai Linh', 'Hoàng Long'].map((name, i) => (
              <div key={i} className="flex items-center gap-2 text-stone-600 font-semibold">
                <Building2 className="w-5 h-5" />
                <span>{name}</span>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Stats Section - Clean Cards */}
      <section className="py-20 bg-white">
        <div className="container mx-auto px-4 lg:px-8">
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-6">
            {stats.map((stat, index) => {
              const { count, ref } = useCountUp(stat.value)
              return (
                <div
                  key={index}
                  ref={ref}
                  className="bg-stone-50 rounded-2xl p-6 border border-stone-100 hover:shadow-lg hover:shadow-stone-200/50 transition-all duration-300 group"
                >
                  <div className="w-12 h-12 bg-gradient-to-br from-emerald-500 to-teal-500 rounded-xl flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                    <stat.icon className="w-6 h-6 text-white" />
                  </div>
                  <div className="text-3xl lg:text-4xl font-bold text-stone-900 mb-1">
                    {count.toLocaleString()}
                    <span className="text-emerald-500">{stat.suffix}</span>
                  </div>
                  <p className="text-stone-500 text-sm">{stat.label}</p>
                </div>
              )
            })}
          </div>
        </div>
      </section>

      {/* Features Section - Card Grid */}
      <section className="py-24 bg-stone-50">
        <div className="container mx-auto px-4 lg:px-8">
          <div className="text-center mb-16">
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-emerald-50 rounded-full mb-6 border border-emerald-100">
              <Layers className="w-4 h-4 text-emerald-600" />
              <span className="text-sm text-emerald-700 font-medium">Tính năng nổi bật</span>
            </div>
            <h2 className="font-display text-3xl lg:text-5xl font-medium text-stone-800 mb-4">
              Công nghệ <span className="italic">dẫn đầu</span> ngành
            </h2>
            <p className="text-lg text-stone-600 max-w-2xl mx-auto">
              Các giải pháp được thiết kế riêng cho bến xe và doanh nghiệp vận tải Việt Nam
            </p>
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-6">
            {features.map((feature, index) => (
              <div
                key={index}
                className="bg-white rounded-2xl p-6 border border-stone-100 shadow-sm hover:shadow-xl hover:shadow-stone-200/50 transition-all duration-300 hover:-translate-y-1 group"
              >
                <div className={cn(
                  "w-14 h-14 rounded-2xl flex items-center justify-center mb-5 transition-transform group-hover:scale-110",
                  feature.color
                )}>
                  <feature.icon className="w-7 h-7 text-white" />
                </div>
                <h3 className="text-xl font-bold text-stone-900 mb-3">{feature.title}</h3>
                <p className="text-stone-600 leading-relaxed text-sm">{feature.description}</p>
                <div className="mt-5 flex items-center text-emerald-600 font-medium text-sm group-hover:text-emerald-700">
                  Tìm hiểu thêm
                  <ChevronRight className="w-4 h-4 ml-1 group-hover:translate-x-1 transition-transform" />
                </div>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* About Section */}
      <section className="py-24 bg-white">
        <div className="container mx-auto px-4 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-16 items-center">
            <div className="space-y-8">
              <div className="inline-flex items-center gap-2 px-4 py-2 bg-emerald-50 rounded-full border border-emerald-100">
                <Globe className="w-4 h-4 text-emerald-600" />
                <span className="text-sm text-emerald-700 font-medium">Về ABC C&T</span>
              </div>

              <h2 className="font-display text-3xl lg:text-5xl font-medium text-stone-800 leading-tight">
                Đồng hành cùng ngành
                <span className="italic"> vận tải Việt Nam</span>
              </h2>

              <div className="space-y-4 text-stone-600 text-lg leading-relaxed">
                <p>
                  Công ty ABC C&T bắt đầu hành trình với sự thấu hiểu sâu sắc các khó khăn
                  và nhu cầu của lĩnh vực bến xe khách và vận tải hành khách.
                </p>
                <p>
                  Bằng cách đặt khách hàng làm trung tâm, chúng tôi đã đưa ra những giải pháp
                  công nghệ tối ưu để nâng cao hiệu quả vận hành.
                </p>
              </div>

              <div className="flex items-center gap-4 pt-4">
                <Link to="/products">
                  <Button size="lg" className="bg-stone-900 hover:bg-stone-800 text-white rounded-xl">
                    Khám phá giải pháp
                    <ArrowRight className="ml-2 w-5 h-5" />
                  </Button>
                </Link>
              </div>
            </div>

            <div className="relative">
              <div className="relative rounded-3xl overflow-hidden shadow-2xl shadow-stone-300/30">
                <img
                  src="https://images.unsplash.com/photo-1557804506-669a67965ba0?w=800&q=80"
                  alt="Team meeting"
                  className="w-full h-[500px] object-cover"
                />
                <div className="absolute inset-0 bg-gradient-to-t from-stone-900/40 to-transparent" />

                {/* Floating Card */}
                <div className="absolute bottom-6 left-6 right-6 bg-white/95 backdrop-blur-sm rounded-2xl p-6 shadow-xl border border-white/50">
                  <div className="flex items-center gap-4">
                    <div className="flex -space-x-3">
                      {[1, 2, 3].map((i) => (
                        <div key={i} className="w-10 h-10 rounded-full bg-gradient-to-br from-emerald-400 to-teal-500 border-2 border-white" />
                      ))}
                    </div>
                    <div>
                      <p className="font-semibold text-stone-900">500+ đối tác tin cậy</p>
                      <p className="text-sm text-stone-500">Bến xe & Doanh nghiệp vận tải</p>
                    </div>
                  </div>
                </div>
              </div>

              {/* Decorative Elements */}
              <div className="absolute -top-4 -right-4 w-24 h-24 bg-emerald-100 rounded-2xl -z-10" />
              <div className="absolute -bottom-4 -left-4 w-32 h-32 bg-orange-100 rounded-2xl -z-10" />
            </div>
          </div>
        </div>
      </section>

      {/* Solutions Section */}
      <section className="py-24 bg-stone-50">
        <div className="container mx-auto px-4 lg:px-8">
          <div className="text-center mb-16">
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-white rounded-full shadow-sm mb-6 border border-stone-100">
              <Lock className="w-4 h-4 text-emerald-600" />
              <span className="text-sm text-stone-600 font-medium">Giải pháp toàn diện</span>
            </div>
            <h2 className="font-display text-3xl lg:text-5xl font-medium text-stone-800 mb-4">
              Hệ sinh thái <span className="italic">hoàn chỉnh</span>
            </h2>
            <p className="text-lg text-stone-600 max-w-2xl mx-auto">
              Các giải pháp được thiết kế riêng cho bến xe và doanh nghiệp vận tải Việt Nam
            </p>
          </div>

          <div className="grid lg:grid-cols-2 gap-8">
            {solutions.map((solution, index) => (
              <div
                key={index}
                className="group bg-white rounded-3xl overflow-hidden shadow-sm hover:shadow-xl hover:shadow-stone-200/50 transition-all duration-500 border border-stone-100"
              >
                <div className="relative h-64 overflow-hidden">
                  <img
                    src={solution.image}
                    alt={solution.title}
                    className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500"
                  />
                  <div className="absolute inset-0 bg-gradient-to-t from-stone-900/80 to-transparent" />
                  <div className="absolute bottom-6 left-6">
                    <span className="text-emerald-400 text-sm font-semibold">{solution.subtitle}</span>
                    <h3 className="text-2xl font-bold text-white mt-1">{solution.title}</h3>
                  </div>
                </div>
                <div className="p-8">
                  <p className="text-stone-600 mb-6">{solution.description}</p>
                  <div className="grid grid-cols-2 gap-3 mb-6">
                    {solution.features.map((feature, i) => (
                      <div key={i} className="flex items-center gap-2">
                        <CheckCircle className="w-4 h-4 text-emerald-500 flex-shrink-0" />
                        <span className="text-sm text-stone-700">{feature}</span>
                      </div>
                    ))}
                  </div>
                  <Link to="/products">
                    <Button variant="outline" className="w-full rounded-xl border-stone-200 group-hover:bg-emerald-500 group-hover:text-white group-hover:border-emerald-500 transition-colors">
                      Tìm hiểu chi tiết
                      <ArrowRight className="ml-2 w-4 h-4" />
                    </Button>
                  </Link>
                </div>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Testimonials Section */}
      <section className="py-24 bg-stone-900 relative overflow-hidden">
        <div className="absolute inset-0">
          <div className="absolute top-0 left-1/4 w-96 h-96 bg-emerald-500/10 rounded-full blur-3xl" />
          <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-teal-500/10 rounded-full blur-3xl" />
        </div>

        <div className="container mx-auto px-4 lg:px-8 relative">
          <div className="text-center mb-16">
            <h2 className="font-display text-3xl lg:text-5xl font-medium text-white mb-4">
              Khách hàng nói gì về <span className="italic">chúng tôi</span>
            </h2>
            <p className="text-lg text-white/60">
              Hơn 500 bến xe và doanh nghiệp vận tải đã tin tưởng
            </p>
          </div>

          <div className="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
            {testimonials.map((testimonial, index) => (
              <div
                key={index}
                className="bg-white/5 backdrop-blur-sm border border-white/10 rounded-3xl p-8 hover:bg-white/10 transition-colors"
              >
                <Quote className="w-10 h-10 text-emerald-400/30 mb-4" />
                <p className="text-white/80 text-lg leading-relaxed mb-6">
                  "{testimonial.content}"
                </p>
                <div className="flex items-center gap-4">
                  <img
                    src={testimonial.avatar}
                    alt={testimonial.author}
                    className="w-12 h-12 rounded-full object-cover border-2 border-emerald-500/30"
                  />
                  <div>
                    <p className="font-semibold text-white">{testimonial.author}</p>
                    <p className="text-sm text-white/50">{testimonial.role}</p>
                  </div>
                </div>
                <div className="flex gap-1 mt-4">
                  {[1, 2, 3, 4, 5].map((star) => (
                    <Star key={star} className="w-4 h-4 fill-amber-400 text-amber-400" />
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Pricing Section */}
      <section className="py-24 bg-white">
        <div className="container mx-auto px-4 lg:px-8">
          <div className="text-center mb-16">
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-orange-50 rounded-full mb-6 border border-orange-100">
              <CreditCard className="w-4 h-4 text-orange-600" />
              <span className="text-sm text-orange-700 font-medium">Bảng giá minh bạch</span>
            </div>
            <h2 className="font-display text-3xl lg:text-5xl font-medium text-stone-800 mb-4">
              Chọn gói phù hợp <span className="italic">với bạn</span>
            </h2>
            <p className="text-lg text-stone-600 max-w-2xl mx-auto">
              Các giải pháp linh hoạt, phù hợp mọi quy mô doanh nghiệp
            </p>
          </div>

          <div className="grid md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            {pricingPlans.map((plan, index) => (
              <div
                key={index}
                className={cn(
                  "relative rounded-3xl p-8 transition-all duration-300 hover:-translate-y-2",
                  plan.popular
                    ? "bg-stone-900 text-white shadow-2xl shadow-stone-400/20 scale-105"
                    : "bg-stone-50 hover:shadow-xl border border-stone-100"
                )}
              >
                {plan.popular && (
                  <div className="absolute -top-4 left-1/2 -translate-x-1/2 px-4 py-1 bg-gradient-to-r from-orange-500 to-orange-600 text-white text-sm font-semibold rounded-full shadow-lg">
                    Phổ biến nhất
                  </div>
                )}

                <h3 className={cn(
                  "text-xl font-bold mb-2",
                  plan.popular ? "text-white" : "text-stone-900"
                )}>
                  {plan.name}
                </h3>
                <p className={cn(
                  "text-sm mb-6",
                  plan.popular ? "text-white/60" : "text-stone-500"
                )}>
                  {plan.description}
                </p>

                <div className="mb-6">
                  <span className={cn(
                    "text-4xl font-bold",
                    plan.popular ? "text-white" : "text-stone-900"
                  )}>
                    {plan.price}
                  </span>
                  <span className={cn(
                    "text-lg ml-1",
                    plan.popular ? "text-white/60" : "text-stone-500"
                  )}>
                    {plan.unit}
                  </span>
                </div>

                <ul className="space-y-4 mb-8">
                  {plan.features.map((feature, i) => (
                    <li key={i} className="flex items-start gap-3">
                      <CheckCircle className={cn(
                        "w-5 h-5 flex-shrink-0 mt-0.5",
                        plan.popular ? "text-emerald-400" : "text-emerald-500"
                      )} />
                      <span className={plan.popular ? "text-white/80" : "text-stone-600"}>
                        {feature}
                      </span>
                    </li>
                  ))}
                </ul>

                <Link to="/lien-he">
                  <Button
                    className={cn(
                      "w-full h-12 font-semibold rounded-xl",
                      plan.popular
                        ? "bg-gradient-to-r from-orange-500 to-orange-600 hover:from-orange-600 hover:to-orange-700 text-white shadow-lg"
                        : "bg-stone-900 hover:bg-stone-800 text-white"
                    )}
                  >
                    {plan.cta}
                    <ArrowRight className="ml-2 w-4 h-4" />
                  </Button>
                </Link>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-24 bg-gradient-to-br from-emerald-600 via-emerald-500 to-teal-500 relative overflow-hidden">
        {/* Background Pattern */}
        <div className="absolute inset-0 opacity-10">
          <div className="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxnIGZpbGw9IiNmZmYiIGZpbGwtb3BhY2l0eT0iMC40Ij48cGF0aCBkPSJNMzYgMzRjMC0yLjIwOS0xLjc5MS00LTQtNHMtNCAxLjc5MS00IDQgMS43OTEgNCA0IDQgNC0xLjc5MSA0LTR6bTAtMThjMC0yLjIwOS0xLjc5MS00LTQtNHMtNCAxLjc5MS00IDQgMS43OTEgNCA0IDQgNC0xLjc5MSA0LTR6bTE4IDBjMC0yLjIwOS0xLjc5MS00LTQtNHMtNCAxLjc5MS00IDQgMS43OTEgNCA0IDQgNC0xLjc5MSA0LTR6Ii8+PC9nPjwvZz48L3N2Zz4=')]" />
        </div>

        <div className="container mx-auto px-4 lg:px-8 relative">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="font-display text-3xl lg:text-5xl font-medium text-white mb-6">
              Sẵn sàng <span className="italic">chuyển đổi số?</span>
            </h2>
            <p className="text-xl text-white/80 mb-10 max-w-2xl mx-auto">
              Hơn 500 bến xe và 20.000+ phương tiện đã tin tưởng sử dụng.
              Hãy là người tiếp theo tham gia cuộc cách mạng số.
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <Link to="/lien-he">
                <Button size="lg" className="bg-white text-emerald-600 hover:bg-white/90 px-8 h-14 text-base font-semibold shadow-xl rounded-xl">
                  Liên hệ tư vấn ngay
                  <ArrowRight className="ml-2 w-5 h-5" />
                </Button>
              </Link>
              <Link to="/pricing">
                <Button size="lg" variant="outline" className="border-white/30 text-white hover:bg-white/10 h-14 text-base bg-transparent rounded-xl">
                  Xem bảng giá
                </Button>
              </Link>
            </div>
          </div>
        </div>
      </section>

      {/* CSS for animations */}
      <style>{`
        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-10px); }
        }
        .animate-float {
          animation: float 3s ease-in-out infinite;
        }
        .animate-float-delayed {
          animation: float 3s ease-in-out infinite;
          animation-delay: 1.5s;
        }
      `}</style>
    </div>
  )
}
</file>

<file path="client/src/pages/Login.tsx">
import { useState } from "react"
import { useNavigate, Link } from "react-router-dom"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { User, Lock, ArrowRight } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import { useAuthStore } from "@/store/auth.store"
import logo from "@/assets/logo.png"

const loginSchema = z.object({
  usernameOrEmail: z.string().min(1, "Vui lòng nhập tên đăng nhập"),
  password: z.string().min(1, "Vui lòng nhập mật khẩu"),
  rememberMe: z.boolean().optional(),
})

type LoginFormData = z.infer<typeof loginSchema>

// Modern transportation - highway with vehicles
const BACKGROUND_IMAGE = "https://images.unsplash.com/photo-1494515843206-f3117d3f51b7?w=1920&q=80"

export default function Login() {
  const navigate = useNavigate()
  const login = useAuthStore((state) => state.login)
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      rememberMe: false,
    },
  })

  const onSubmit = async (data: LoginFormData) => {
    try {
      setIsLoading(true)
      setError("")
      await login(data.usernameOrEmail, data.password, data.rememberMe)
      navigate("/dashboard")
    } catch {
      setError("Thông tin đăng nhập không chính xác")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex">
      {/* Left Side - Cinematic Hero */}
      <div className="hidden lg:flex lg:w-[55%] xl:w-[60%] relative overflow-hidden">
        {/* Background Image */}
        <img
          src={BACKGROUND_IMAGE}
          alt="Modern architecture"
          className="absolute inset-0 w-full h-full object-cover"
        />

        {/* Gradient Overlay */}
        <div className="absolute inset-0 bg-gradient-to-br from-stone-900/95 via-stone-900/85 to-stone-800/80" />
        <div className="absolute inset-0 bg-gradient-to-t from-stone-900/60 via-transparent to-stone-900/40" />

        {/* Content */}
        <div className="relative z-10 flex flex-col justify-between p-12 xl:p-16 w-full">
          {/* Logo */}
          <Link to="/" className="inline-flex items-center gap-3 group">
            <img src={logo} alt="ABC C&T" className="h-12 w-auto" />
            <span className="font-display text-2xl text-white">ABC C&T</span>
          </Link>

          {/* Main Content */}
          <div className="max-w-lg space-y-8">
            <div className="space-y-6">
              <h1 className="font-display text-4xl xl:text-5xl text-white leading-tight">
                <span className="block">Hệ thống</span>
                <span className="block italic text-emerald-400">Quản lý Bến xe</span>
                <span className="block">thông minh.</span>
              </h1>
              <p className="text-lg text-stone-400 leading-relaxed">
                Nền tảng số hóa toàn diện cho vận hành bến xe và doanh nghiệp vận tải hành khách.
              </p>
            </div>

            {/* Stats */}
            <div className="flex items-center gap-12 pt-8 border-t border-stone-700/50">
              <div>
                <div className="text-3xl font-semibold text-white">600<span className="text-emerald-400">+</span></div>
                <div className="text-sm text-stone-500 mt-1">Doanh nghiệp</div>
              </div>
              <div>
                <div className="text-3xl font-semibold text-white">500<span className="text-emerald-400">+</span></div>
                <div className="text-sm text-stone-500 mt-1">Bến xe</div>
              </div>
              <div>
                <div className="text-3xl font-semibold text-white">99.9<span className="text-emerald-400">%</span></div>
                <div className="text-sm text-stone-500 mt-1">Uptime</div>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="text-sm text-stone-600">
            © 2025 ABC C&T. Đồng hành cùng ngành vận tải Việt Nam.
          </div>
        </div>
      </div>

      {/* Right Side - Login Form */}
      <div className="w-full lg:w-[45%] xl:w-[40%] flex items-center justify-center p-6 sm:p-12 bg-stone-50">
        <div className="w-full max-w-[400px]">
          {/* Mobile Logo */}
          <div className="lg:hidden flex justify-center mb-10">
            <Link to="/" className="inline-flex items-center gap-2.5">
              <img src={logo} alt="ABC C&T" className="h-10 w-auto" />
              <span className="font-display text-xl text-stone-800">ABC C&T</span>
            </Link>
          </div>

          {/* Form Header */}
          <div className="mb-10">
            <h2 className="font-display text-3xl text-stone-800 mb-2">
              Đăng nhập
            </h2>
            <p className="text-stone-500">
              Chào mừng trở lại. Vui lòng nhập thông tin.
            </p>
          </div>

          {/* Login Form */}
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
            {error && (
              <div className="p-4 bg-red-50 border border-red-100 rounded-xl text-sm text-red-600">
                {error}
              </div>
            )}

            <div className="space-y-5">
              {/* Username/Email */}
              <div className="space-y-2">
                <Label htmlFor="usernameOrEmail" className="text-stone-700 text-sm font-medium">
                  Tên đăng nhập
                </Label>
                <div className="relative">
                  <User className="absolute left-4 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-stone-400" />
                  <Input
                    id="usernameOrEmail"
                    type="text"
                    placeholder="Nhập tên đăng nhập hoặc email"
                    className="pl-11 h-12 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 transition-colors"
                    {...register("usernameOrEmail")}
                  />
                </div>
                {errors.usernameOrEmail && (
                  <p className="text-sm text-red-500">{errors.usernameOrEmail.message}</p>
                )}
              </div>

              {/* Password */}
              <div className="space-y-2">
                <Label htmlFor="password" className="text-stone-700 text-sm font-medium">
                  Mật khẩu
                </Label>
                <div className="relative">
                  <Lock className="absolute left-4 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-stone-400" />
                  <Input
                    id="password"
                    type="password"
                    placeholder="Nhập mật khẩu"
                    className="pl-11 h-12 bg-white border-stone-200 rounded-xl text-stone-800 placeholder:text-stone-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 transition-colors"
                    {...register("password")}
                  />
                </div>
                {errors.password && (
                  <p className="text-sm text-red-500">{errors.password.message}</p>
                )}
              </div>
            </div>

            {/* Remember & Forgot */}
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Checkbox
                  id="rememberMe"
                  className="border-stone-300 data-[state=checked]:bg-emerald-500 data-[state=checked]:border-emerald-500"
                  {...register("rememberMe")}
                />
                <Label
                  htmlFor="rememberMe"
                  className="text-sm text-stone-600 cursor-pointer"
                >
                  Ghi nhớ đăng nhập
                </Label>
              </div>
              <Link
                to="/forgot-password"
                className="text-sm text-emerald-600 hover:text-emerald-700 font-medium transition-colors"
              >
                Quên mật khẩu?
              </Link>
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              className="w-full h-12 bg-stone-800 hover:bg-stone-900 text-white font-medium rounded-xl transition-colors group"
              disabled={isLoading}
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Đang xử lý...</span>
                </div>
              ) : (
                <span className="flex items-center justify-center gap-2">
                  Đăng nhập
                  <ArrowRight className="w-4 h-4 group-hover:translate-x-0.5 transition-transform" />
                </span>
              )}
            </Button>

            {/* Register Link */}
            <p className="text-center text-stone-500 text-sm">
              Chưa có tài khoản?{" "}
              <Link
                to="/register"
                className="text-emerald-600 hover:text-emerald-700 font-medium transition-colors"
              >
                Đăng ký ngay
              </Link>
            </p>
          </form>

          {/* Footer - Mobile */}
          <div className="lg:hidden mt-12 pt-6 border-t border-stone-200 text-center text-xs text-stone-400">
            © 2025 ABC C&T. Bảo lưu mọi quyền.
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/XeKhongDuDieuKien.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { operatorService } from "@/services/operator.service";
import type { DispatchRecord, DispatchStatus, Operator } from "@/types";
import { useUIStore } from "@/store/ui.store";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { DatePickerRange } from "@/components/DatePickerRange";

const statusLabelMap: Record<DispatchStatus, string> = {
  entered: "Đã vào bến",
  passengers_dropped: "Đã trả khách",
  permit_issued: "Đã cấp phép",
  permit_rejected: "Từ chối phép",
  paid: "Đã thanh toán",
  departure_ordered: "Đã cấp lệnh",
  departed: "Đã xuất bến",
  cancelled: "Đã hủy",
};

export default function XeKhongDuDieuKien() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [records, setRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");

  useEffect(() => {
    setTitle("Truyền tải > Xe không đủ điều kiện");
    loadRecords();
    loadOperators();
  }, [setTitle]);

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      
      // Filter to only show TODAY's records
      // This allows multiple trips per vehicle in a single day
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const todayRecords = data.filter(record => {
        const entryTime = new Date(record.entryTime);
        return entryTime >= today && entryTime < tomorrow;
      });
      
      // Chỉ lấy các xe bị từ chối phép (không đủ điều kiện)
      const filtered = todayRecords.filter((item) =>
        item.currentStatus === "permit_rejected"
      );
      setRecords(filtered);
    } catch (error) {
      console.error("Failed to load dispatch records:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const filteredRecords = useMemo(() => {
    return records.filter((item) => {
      // Full text search - search in both plate number and route name
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        const plateMatch = item.vehiclePlateNumber
          .toLowerCase()
          .includes(query);
        const routeMatch = (item.routeName || "")
          .toLowerCase()
          .includes(query);
        matchesSearch = plateMatch || routeMatch;
      }
      
      // Filter by operator
      let matchesOperator = true;
      if (selectedOperatorId) {
        matchesOperator = item.vehicle?.operatorId === selectedOperatorId;
      }
      
      // Filter by date range (using entryTime)
      let matchesDate = true;
      if (dateRange?.from && dateRange?.to) {
        const filterDate = item.entryTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          const toDate = new Date(dateRange.to);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = itemDate >= fromDate && itemDate <= toDate;
        } else {
          matchesDate = false;
        }
      } else if (dateRange?.from) {
        const filterDate = item.entryTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = itemDate >= fromDate;
        } else {
          matchesDate = false;
        }
      }
      
      return matchesSearch && matchesOperator && matchesDate;
    });
  }, [records, searchQuery, dateRange, selectedOperatorId]);

  const renderTime = (value?: string) => (value ? formatVietnamDateTime(value) : "-");

  const handleExportExcel = () => {
    if (filteredRecords.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredRecords.map((item, index) => {
        const itemMetadata = (item.metadata || {}) as Record<string, unknown>;
        const syncTimeStr = itemMetadata.syncTime as string | undefined;
        return {
          "STT": index + 1,
          "Biển số xe": item.vehiclePlateNumber || "-",
          "Tên luồng tuyến": item.routeName || "-",
          "Thời gian vào bến": item.entryTime ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") : "-",
          "Giờ XB kế hoạch": item.plannedDepartureTime ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm") : "-",
          "Giờ cấp phép lên nốt": item.boardingPermitTime ? format(new Date(item.boardingPermitTime), "dd/MM/yyyy HH:mm") : "-",
          "Người cấp lệnh": item.departureOrderBy || item.boardingPermitBy || "-",
          "Số khách": item.passengersDeparting ?? item.passengersArrived ?? item.seatCount ?? "-",
          "Thời gian ra bến": item.exitTime ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm") : "-",
          "Thời gian đồng bộ": syncTimeStr ? format(new Date(syncTimeStr), "dd/MM/yyyy HH:mm") : "-",
          "Người đồng bộ dữ liệu": String(itemMetadata.syncBy || "-"),
          "Thông tin đồng bộ dữ liệu": String(itemMetadata.syncInfo || "-"),
          "Trạng thái": statusLabelMap[item.currentStatus] || item.currentStatus || "-",
        };
      });

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe không đủ điều kiện");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số xe
        { wch: 25 },  // Tên luồng tuyến
        { wch: 20 },  // Thời gian vào bến
        { wch: 20 },  // Giờ XB kế hoạch
        { wch: 20 },  // Giờ cấp phép lên nốt
        { wch: 20 },  // Người cấp lệnh
        { wch: 10 },  // Số khách
        { wch: 20 },  // Thời gian ra bến
        { wch: 20 },  // Thời gian đồng bộ
        { wch: 20 },  // Người đồng bộ dữ liệu
        { wch: 25 },  // Thông tin đồng bộ dữ liệu
        { wch: 15 },  // Trạng thái
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Xe-khong-du-dieu-kien_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredRecords.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadRecords}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số xe, luồng tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Chọn doanh nghiệp vận tải</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Biển số xe</TableHead>
                  <TableHead>Tên luồng tuyến</TableHead>
                  <TableHead>Thời gian vào bến</TableHead>
                  <TableHead>Giờ XB kế hoạch</TableHead>
                  <TableHead>Giờ cấp phép lên nốt</TableHead>
                  <TableHead>Người cấp lệnh</TableHead>
                  <TableHead>Số khách</TableHead>
                  <TableHead>Thời gian ra bến</TableHead>
                  <TableHead>Thời gian đồng bộ</TableHead>
                  <TableHead>Người đồng bộ dữ liệu</TableHead>
                  <TableHead>Thông tin đồng bộ dữ liệu</TableHead>
                  <TableHead>Trạng thái</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={12} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredRecords.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={12} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredRecords.map((item) => {
                      const meta = (item.metadata || {}) as Record<string, unknown>;
                      const syncTimeStr = meta.syncTime as string | undefined;
                      return (
                        <TableRow key={item.id}>
                          <TableCell className="font-semibold">
                            {item.vehiclePlateNumber || "-"}
                          </TableCell>
                          <TableCell>{item.routeName || "-"}</TableCell>
                          <TableCell>{renderTime(item.entryTime)}</TableCell>
                          <TableCell>{renderTime(item.plannedDepartureTime)}</TableCell>
                          <TableCell>{renderTime(item.boardingPermitTime)}</TableCell>
                          <TableCell>
                            {item.departureOrderBy || item.boardingPermitBy || "-"}
                          </TableCell>
                          <TableCell>
                            {item.passengersDeparting ??
                              item.passengersArrived ??
                              item.seatCount ??
                              "-"}
                          </TableCell>
                          <TableCell>{renderTime(item.exitTime)}</TableCell>
                          <TableCell>{renderTime(syncTimeStr)}</TableCell>
                          <TableCell>{String(meta.syncBy || "-")}</TableCell>
                          <TableCell>{String(meta.syncInfo || "-")}</TableCell>
                          <TableCell>
                            {statusLabelMap[item.currentStatus] || item.currentStatus || "-"}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell colSpan={12}>{`Tổng: ${filteredRecords.length} xe`}</TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/XeTraKhach.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { operatorService } from "@/services/operator.service";
import type { DispatchRecord, DispatchStatus, Operator } from "@/types";
import { useUIStore } from "@/store/ui.store";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { DatePickerRange } from "@/components/DatePickerRange";

const statusLabelMap: Record<DispatchStatus, string> = {
  entered: "Đã vào bến",
  passengers_dropped: "Đã trả khách",
  permit_issued: "Đã cấp phép",
  permit_rejected: "Từ chối phép",
  paid: "Đã thanh toán",
  departure_ordered: "Đã cấp lệnh",
  departed: "Đã xuất bến",
  cancelled: "Đã hủy",
};

export default function XeTraKhach() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [records, setRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");

  useEffect(() => {
    setTitle("Truyền tải > Xe trả khách");
    loadRecords();
    loadOperators();
  }, [setTitle]);

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      
      // Filter to only show TODAY's records
      // This allows multiple trips per vehicle in a single day
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const todayRecords = data.filter(record => {
        const entryTime = new Date(record.entryTime);
        return entryTime >= today && entryTime < tomorrow;
      });
      
      // Chỉ lấy các xe đã trả khách
      const filtered = todayRecords.filter((item) =>
        item.currentStatus === "passengers_dropped"
      );
      setRecords(filtered);
    } catch (error) {
      console.error("Failed to load dispatch records:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const filteredRecords = useMemo(() => {
    return records.filter((item) => {
      // Full text search - search in both plate number and route name
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        const plateMatch = item.vehiclePlateNumber
          .toLowerCase()
          .includes(query);
        const routeMatch = (item.routeName || "")
          .toLowerCase()
          .includes(query);
        matchesSearch = plateMatch || routeMatch;
      }
      
      // Filter by operator
      let matchesOperator = true;
      if (selectedOperatorId) {
        matchesOperator = item.vehicle?.operatorId === selectedOperatorId;
      }
      
      // Filter by date range (using passengerDropTime)
      let matchesDate = true;
      if (dateRange?.from && dateRange?.to) {
        const filterDate = item.passengerDropTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          const toDate = new Date(dateRange.to);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = itemDate >= fromDate && itemDate <= toDate;
        } else {
          matchesDate = false;
        }
      } else if (dateRange?.from) {
        const filterDate = item.passengerDropTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = itemDate >= fromDate;
        } else {
          matchesDate = false;
        }
      }
      
      return matchesSearch && matchesOperator && matchesDate;
    });
  }, [records, searchQuery, dateRange, selectedOperatorId]);

  const renderTime = (value?: string) => (value ? formatVietnamDateTime(value) : "-");

  const handleExportExcel = () => {
    if (filteredRecords.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredRecords.map((item, index) => {
        const itemMetadata = (item.metadata || {}) as Record<string, unknown>;
        const syncTimeStr = itemMetadata.syncTime as string | undefined;
        return {
          "STT": index + 1,
          "Biển số xe": item.vehiclePlateNumber || "-",
          "Tên luồng tuyến": item.routeName || "-",
          "Số khách": item.passengersArrived ?? item.seatCount ?? "-",
          "Thời gian xác nhận trả khách": item.passengerDropTime ? format(new Date(item.passengerDropTime), "dd/MM/yyyy HH:mm") : "-",
          "Thời gian đồng bộ dữ liệu": syncTimeStr ? format(new Date(syncTimeStr), "dd/MM/yyyy HH:mm") : "-",
          "Người đồng bộ dữ liệu": String(itemMetadata.syncBy || "-"),
          "Thông tin đồng bộ dữ liệu": String(itemMetadata.syncInfo || "-"),
          "Trạng thái": statusLabelMap[item.currentStatus] || item.currentStatus || "-",
        };
      });

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe trả khách");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số xe
        { wch: 25 },  // Tên luồng tuyến
        { wch: 10 },  // Số khách
        { wch: 25 },  // Thời gian xác nhận trả khách
        { wch: 25 },  // Thời gian đồng bộ dữ liệu
        { wch: 20 },  // Người đồng bộ dữ liệu
        { wch: 25 },  // Thông tin đồng bộ dữ liệu
        { wch: 15 },  // Trạng thái
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Xe-tra-khach_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredRecords.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadRecords}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số xe, luồng tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Chọn doanh nghiệp vận tải</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Biển số xe</TableHead>
                  <TableHead>Tên luồng tuyến</TableHead>
                  <TableHead>Số khách</TableHead>
                  <TableHead>Thời gian xác nhận trả khách</TableHead>
                  <TableHead>Thời gian đồng bộ dữ liệu</TableHead>
                  <TableHead>Người đồng bộ dữ liệu</TableHead>
                  <TableHead>Thông tin đồng bộ dữ liệu</TableHead>
                  <TableHead>Trạng thái</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={8} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredRecords.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={8} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredRecords.map((item) => {
                      const meta = (item.metadata || {}) as Record<string, unknown>;
                      const syncTimeStr = meta.syncTime as string | undefined;
                      return (
                        <TableRow key={item.id}>
                          <TableCell className="font-semibold">
                            {item.vehiclePlateNumber || "-"}
                          </TableCell>
                          <TableCell>{item.routeName || "-"}</TableCell>
                          <TableCell>
                            {item.passengersArrived ?? item.seatCount ?? "-"}
                          </TableCell>
                          <TableCell>{renderTime(item.passengerDropTime)}</TableCell>
                          <TableCell>{renderTime(syncTimeStr)}</TableCell>
                          <TableCell>{String(meta.syncBy || "-")}</TableCell>
                          <TableCell>{String(meta.syncInfo || "-")}</TableCell>
                          <TableCell>
                            {statusLabelMap[item.currentStatus] || item.currentStatus || "-"}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell colSpan={8}>{`Tổng: ${filteredRecords.length} xe`}</TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/XeXuatBen.tsx">
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Search, FileSpreadsheet } from "lucide-react";
import { type DateRange } from "react-day-picker";
import { toast } from "react-toastify";
import { format } from "date-fns";
import * as XLSX from "xlsx";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select } from "@/components/ui/select";
import { dispatchService } from "@/services/dispatch.service";
import { operatorService } from "@/services/operator.service";
import type { DispatchRecord, DispatchStatus, Operator } from "@/types";
import { useUIStore } from "@/store/ui.store";
import { formatVietnamDateTime } from "@/lib/vietnam-time";
import { DatePickerRange } from "@/components/DatePickerRange";

const statusLabelMap: Record<DispatchStatus, string> = {
  entered: "Đã vào bến",
  passengers_dropped: "Đã trả khách",
  permit_issued: "Đã cấp phép",
  permit_rejected: "Từ chối phép",
  paid: "Đã thanh toán",
  departure_ordered: "Đã cấp lệnh",
  departed: "Đã xuất bến",
  cancelled: "Đã hủy",
};

export default function XeXuatBen() {
  const setTitle = useUIStore((state) => state.setTitle);
  const [records, setRecords] = useState<DispatchRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");

  useEffect(() => {
    setTitle("Truyền tải > Xe xuất bến");
    loadRecords();
    loadOperators();
  }, [setTitle]);

  const loadRecords = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      
      // Filter to only show TODAY's records
      // This allows multiple trips per vehicle in a single day
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const todayRecords = data.filter(record => {
        const entryTime = new Date(record.entryTime);
        return entryTime >= today && entryTime < tomorrow;
      });
      
      // Chỉ lấy các xe đã được cấp lệnh hoặc đã xuất bến
      const filtered = todayRecords.filter((item) =>
        ["departure_ordered", "departed"].includes(item.currentStatus)
      );
      setRecords(filtered);
    } catch (error) {
      console.error("Failed to load dispatch records:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadOperators = async () => {
    try {
      const data = await operatorService.getAll(true);
      setOperators(data);
    } catch (error) {
      console.error("Failed to load operators:", error);
    }
  };

  const filteredRecords = useMemo(() => {
    return records.filter((item) => {
      // Full text search - search in both plate number and route name
      let matchesSearch = true;
      if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        const plateMatch = item.vehiclePlateNumber
          .toLowerCase()
          .includes(query);
        const routeMatch = (item.routeName || "")
          .toLowerCase()
          .includes(query);
        matchesSearch = plateMatch || routeMatch;
      }
      
      // Filter by operator
      let matchesOperator = true;
      if (selectedOperatorId) {
        matchesOperator = item.vehicle?.operatorId === selectedOperatorId;
      }
      
      // Filter by date range (using exitTime or entryTime if exitTime is not available)
      let matchesDate = true;
      if (dateRange?.from && dateRange?.to) {
        const filterDate = item.exitTime || item.entryTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          const toDate = new Date(dateRange.to);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = itemDate >= fromDate && itemDate <= toDate;
        } else {
          matchesDate = false;
        }
      } else if (dateRange?.from) {
        const filterDate = item.exitTime || item.entryTime;
        if (filterDate) {
          const itemDate = new Date(filterDate);
          const fromDate = new Date(dateRange.from);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = itemDate >= fromDate;
        } else {
          matchesDate = false;
        }
      }
      
      return matchesSearch && matchesOperator && matchesDate;
    });
  }, [records, searchQuery, dateRange, selectedOperatorId]);

  const renderTime = (value?: string) => (value ? formatVietnamDateTime(value) : "-");

  const handleExportExcel = () => {
    if (filteredRecords.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      // Prepare data for Excel
      const excelData = filteredRecords.map((item, index) => {
        const itemMetadata = (item.metadata || {}) as Record<string, unknown>;
        const syncTimeStr = itemMetadata.syncTime as string | undefined;
        return {
          "STT": index + 1,
          "Biển số xe": item.vehiclePlateNumber || "-",
          "Tên luồng tuyến": item.routeName || "-",
          "Thời gian vào bến": item.entryTime ? format(new Date(item.entryTime), "dd/MM/yyyy HH:mm") : "-",
          "Giờ XB kế hoạch": item.plannedDepartureTime ? format(new Date(item.plannedDepartureTime), "dd/MM/yyyy HH:mm") : "-",
          "Giờ cấp phép lên nốt": item.boardingPermitTime ? format(new Date(item.boardingPermitTime), "dd/MM/yyyy HH:mm") : "-",
          "Người cấp lệnh": item.departureOrderBy || item.boardingPermitBy || "-",
          "Số khách": item.passengersDeparting ?? item.passengersArrived ?? item.seatCount ?? "-",
          "Thời gian ra bến": item.exitTime ? format(new Date(item.exitTime), "dd/MM/yyyy HH:mm") : "-",
          "Thời gian đồng bộ dữ liệu": syncTimeStr ? format(new Date(syncTimeStr), "dd/MM/yyyy HH:mm") : "-",
          "Người đồng bộ dữ liệu": String(itemMetadata.syncBy || "-"),
          "Thông tin đồng bộ dữ liệu": String(itemMetadata.syncInfo || "-"),
          "Trạng thái": statusLabelMap[item.currentStatus] || item.currentStatus || "-",
        };
      });

      // Create workbook and worksheet
      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Xe xuất bến");

      // Set column widths
      const colWidths = [
        { wch: 5 },   // STT
        { wch: 15 },  // Biển số xe
        { wch: 25 },  // Tên luồng tuyến
        { wch: 20 },  // Thời gian vào bến
        { wch: 20 },  // Giờ XB kế hoạch
        { wch: 20 },  // Giờ cấp phép lên nốt
        { wch: 20 },  // Người cấp lệnh
        { wch: 10 },  // Số khách
        { wch: 20 },  // Thời gian ra bến
        { wch: 25 },  // Thời gian đồng bộ dữ liệu
        { wch: 20 },  // Người đồng bộ dữ liệu
        { wch: 25 },  // Thông tin đồng bộ dữ liệu
        { wch: 15 },  // Trạng thái
      ];
      ws['!cols'] = colWidths;

      // Generate filename with current date
      const currentDate = format(new Date(), "dd-MM-yyyy");
      const filename = `Xe-xuat-ben_${currentDate}.xlsx`;

      // Write file
      XLSX.writeFile(wb, filename);
      
      toast.success(`Đã xuất Excel thành công: ${filename}`);
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel. Vui lòng thử lại sau.");
    }
  };

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportExcel}
              disabled={isLoading || filteredRecords.length === 0}
              className="gap-2"
            >
              <FileSpreadsheet className="h-4 w-4" />
              Xuất Excel
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={loadRecords}
              disabled={isLoading}
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Làm mới
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-500" />
              <Input
                placeholder="Tìm kiếm biển số xe, luồng tuyến..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <DatePickerRange
              range={dateRange}
              onRangeChange={setDateRange}
              placeholder="Chọn khoảng thời gian"
              label=""
              className="w-full space-y-0"
            />
            <div className="space-y-0">
              <Select
                id="operator"
                value={selectedOperatorId}
                onChange={(e) => setSelectedOperatorId(e.target.value)}
              >
                <option value="">Chọn doanh nghiệp vận tải</option>
                {operators.map((op) => (
                  <option key={op.id} value={op.id}>
                    {op.name}
                  </option>
                ))}
              </Select>
            </div>
          </div>

          <div className="border rounded-lg overflow-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Biển số xe</TableHead>
                  <TableHead>Tên luồng tuyến</TableHead>
                  <TableHead>Thời gian vào bến</TableHead>
                  <TableHead>Giờ XB kế hoạch</TableHead>
                  <TableHead>Giờ cấp phép lên nốt</TableHead>
                  <TableHead>Người cấp lệnh</TableHead>
                  <TableHead>Số khách</TableHead>
                  <TableHead>Thời gian ra bến</TableHead>
                  <TableHead>Thời gian đồng bộ dữ liệu</TableHead>
                  <TableHead>Người đồng bộ dữ liệu</TableHead>
                  <TableHead>Thông tin đồng bộ dữ liệu</TableHead>
                  <TableHead>Trạng thái</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={12} className="text-center text-gray-500">
                      Đang tải dữ liệu...
                    </TableCell>
                  </TableRow>
                ) : filteredRecords.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={12} className="text-center text-gray-500">
                      Không có dữ liệu
                    </TableCell>
                  </TableRow>
                ) : (
                  <>
                    {filteredRecords.map((item) => {
                      const meta = (item.metadata || {}) as Record<string, unknown>;
                      const syncTimeStr = meta.syncTime as string | undefined;
                      return (
                        <TableRow key={item.id}>
                          <TableCell className="font-semibold">
                            {item.vehiclePlateNumber || "-"}
                          </TableCell>
                          <TableCell>{item.routeName || "-"}</TableCell>
                          <TableCell>{renderTime(item.entryTime)}</TableCell>
                          <TableCell>{renderTime(item.plannedDepartureTime)}</TableCell>
                          <TableCell>{renderTime(item.boardingPermitTime)}</TableCell>
                          <TableCell>
                            {item.departureOrderBy || item.boardingPermitBy || "-"}
                          </TableCell>
                          <TableCell>
                            {item.passengersDeparting ??
                              item.passengersArrived ??
                              item.seatCount ??
                              "-"}
                          </TableCell>
                          <TableCell>{renderTime(item.exitTime)}</TableCell>
                          <TableCell>{renderTime(syncTimeStr)}</TableCell>
                          <TableCell>{String(meta.syncBy || "-")}</TableCell>
                          <TableCell>{String(meta.syncInfo || "-")}</TableCell>
                          <TableCell>
                            {statusLabelMap[item.currentStatus] || item.currentStatus || "-"}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                    <TableRow className="bg-gray-50 font-semibold">
                      <TableCell colSpan={12}>{`Tổng: ${filteredRecords.length} xe`}</TableCell>
                    </TableRow>
                  </>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/services/dashboard.service.ts">
import api from '@/lib/api'

export interface DashboardStats {
  totalVehiclesToday: number    // Total unique vehicles entered today
  vehiclesInStation: number     // Currently in station
  vehiclesDepartedToday: number // Already departed
  revenueToday: number
  invalidVehicles: number
}

export interface ChartDataPoint {
  hour: string
  count: number
}

export interface RecentActivity {
  id: string
  vehiclePlateNumber: string
  route: string
  entryTime: string
  status: string
}

export interface Warning {
  type: 'vehicle' | 'driver'
  plateNumber?: string
  name?: string
  document: string
  expiryDate: string
}

export interface WeeklyStat {
  day: string
  dayName: string
  departed: number
  inStation: number
  total: number
}

export interface MonthlyStat {
  month: string
  monthName: string
  departed: number
  waiting: number
  other: number
}

export interface RouteBreakdown {
  routeId: string
  routeName: string
  count: number
  percentage: number
}

export interface DashboardData {
  stats: DashboardStats
  chartData: ChartDataPoint[]
  recentActivity: RecentActivity[]
  warnings: Warning[]
  weeklyStats: WeeklyStat[]
  monthlyStats: MonthlyStat[]
  routeBreakdown: RouteBreakdown[]
}

export const dashboardService = {
  getStats: async (): Promise<DashboardStats> => {
    try {
      const response = await api.get<DashboardStats>('/dashboard/stats')
      return response.data
    } catch (error) {
      console.error('Error fetching dashboard stats:', error)
      return {
        totalVehiclesToday: 0,
        vehiclesInStation: 0,
        vehiclesDepartedToday: 0,
        revenueToday: 0,
        invalidVehicles: 0,
      }
    }
  },

  getChartData: async (): Promise<ChartDataPoint[]> => {
    try {
      const response = await api.get<ChartDataPoint[]>('/dashboard/chart-data')
      return response.data
    } catch (error) {
      console.error('Error fetching chart data:', error)
      return []
    }
  },

  getRecentActivity: async (): Promise<RecentActivity[]> => {
    try {
      const response = await api.get<RecentActivity[]>('/dashboard/recent-activity')
      return response.data
    } catch (error) {
      console.error('Error fetching recent activity:', error)
      return []
    }
  },

  getWarnings: async (): Promise<Warning[]> => {
    try {
      const response = await api.get<Warning[]>('/dashboard/warnings')
      return response.data
    } catch (error) {
      console.error('Error fetching warnings:', error)
      return []
    }
  },

  getDashboardData: async (): Promise<DashboardData> => {
    try {
      const response = await api.get<DashboardData>('/dashboard')
      return response.data
    } catch (error) {
      console.error('Error fetching dashboard data:', error)
      // Fallback to individual calls
      const [stats, chartData, recentActivity, warnings] = await Promise.all([
        dashboardService.getStats(),
        dashboardService.getChartData(),
        dashboardService.getRecentActivity(),
        dashboardService.getWarnings(),
      ])

      return {
        stats,
        chartData,
        recentActivity,
        warnings,
        weeklyStats: [],
        monthlyStats: [],
        routeBreakdown: [],
      }
    }
  },
}
</file>

<file path="client/src/services/operator.service.ts">
import api from '@/lib/api'
import type { Operator, OperatorInput } from '@/types'

export const operatorService = {
  getAll: async (isActive?: boolean): Promise<Operator[]> => {
    try {
      const params = new URLSearchParams()
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/operators?${queryString}` : '/operators'

      const response = await api.get<Operator[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching operators:', error)
      return []
    }
  },

  /**
   * Get all operators including legacy ones from datasheet
   * Returns 1154+ operators from datasheet/Xe unique owner_names
   */
  getLegacy: async (): Promise<Operator[]> => {
    try {
      const response = await api.get<Operator[]>('/operators/legacy')
      return response.data
    } catch (error) {
      console.error('Error fetching legacy operators:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Operator> => {
    const response = await api.get<Operator>(`/operators/${id}`)
    return response.data
  },

  create: async (input: OperatorInput): Promise<Operator> => {
    const response = await api.post<Operator>('/operators', input)
    return response.data
  },

  update: async (id: string, input: Partial<OperatorInput>): Promise<Operator> => {
    const response = await api.put<Operator>(`/operators/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/operators/${id}`)
  },

  // Legacy (RTDB/Google Sheets) operators
  updateLegacy: async (id: string, input: Partial<OperatorInput>): Promise<Operator> => {
    const response = await api.put<Operator>(`/operators/legacy/${id}`, input)
    return response.data
  },

  deleteLegacy: async (id: string): Promise<void> => {
    await api.delete(`/operators/legacy/${id}`)
  },
}
</file>

<file path="client/src/services/route.service.ts">
import api from '@/lib/api'
import type { Route, RouteInput } from '@/types'

export interface LegacyRoute {
  id: string
  routeCode: string
  routeCodeOld: string
  routeCodeFixed: string
  routeClass: string
  routeType: string
  routePath: string
  departureStation: string
  departureStationRef: string
  departureProvince: string
  departureProvinceOld: string
  arrivalStation: string
  arrivalStationRef: string
  arrivalProvince: string
  arrivalProvinceOld: string
  distanceKm: number
  minIntervalMinutes: number
  totalTripsMonth: number
  tripsInOperation: number
  remainingCapacity: number
  operationStatus: string
  calendarType: string
  decisionNumber: string
  decisionDate: string
  issuingAuthority: string
  notes: string
  filePath: string
  _source: string
}

// Cache for legacy routes
let legacyRoutesCache: { data: LegacyRoute[]; timestamp: number } | null = null
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

export const routeService = {
  getAll: async (_operatorId?: string, _limit?: number, isActive?: boolean): Promise<Route[]> => {
    try {
      const params = new URLSearchParams()
      if (isActive !== undefined) params.append('isActive', String(isActive))

      const queryString = params.toString()
      const url = queryString ? `/routes?${queryString}` : '/routes'

      const response = await api.get<Route[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching routes:', error)
      return []
    }
  },

  getLegacy: async (forceRefresh = false): Promise<LegacyRoute[]> => {
    try {
      // Check cache
      if (!forceRefresh && legacyRoutesCache && Date.now() - legacyRoutesCache.timestamp < CACHE_TTL) {
        return legacyRoutesCache.data
      }

      const url = forceRefresh ? '/routes/legacy?refresh=true' : '/routes/legacy'
      const response = await api.get<LegacyRoute[]>(url)
      
      // Update cache
      legacyRoutesCache = { data: response.data, timestamp: Date.now() }
      
      return response.data
    } catch (error) {
      console.error('Error fetching legacy routes:', error)
      if (legacyRoutesCache) {
        return legacyRoutesCache.data
      }
      return []
    }
  },

  getById: async (id: string): Promise<Route> => {
    const response = await api.get<Route>(`/routes/${id}`)
    return response.data
  },

  create: async (input: RouteInput): Promise<Route> => {
    const response = await api.post<Route>('/routes', input)
    return response.data
  },

  update: async (id: string, input: Partial<RouteInput>): Promise<Route> => {
    const response = await api.put<Route>(`/routes/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/routes/${id}`)
  },
}
</file>

<file path="client/src/types/dispatch.types.ts">
// Dispatch Feature Types
import type { Vehicle, Driver } from './fleet.types'
import type { Route, Schedule } from './common.types'

export type DispatchStatus =
  | 'entered'
  | 'passengers_dropped'
  | 'permit_issued'
  | 'permit_rejected'
  | 'paid'
  | 'departure_ordered'
  | 'departed'
  | 'cancelled'

export type PermitStatus = 'approved' | 'rejected' | 'pending'
export type PaymentMethod = 'cash' | 'bank_transfer' | 'card'

export interface DispatchRecord {
  id: string
  vehicleId: string
  vehicle?: Vehicle
  vehiclePlateNumber: string
  driverId: string
  driver?: Driver
  driverName: string
  scheduleId?: string
  schedule?: Schedule
  routeId: string
  route?: Route
  routeName: string

  // Entry
  entryTime: string
  entryBy?: string
  entryImageUrl?: string

  // Passenger drop-off
  passengerDropTime?: string
  passengersArrived?: number
  passengerDropBy?: string

  // Boarding permit
  boardingPermitTime?: string
  plannedDepartureTime?: string
  transportOrderCode?: string
  seatCount?: number
  permitStatus?: PermitStatus
  rejectionReason?: string
  boardingPermitBy?: string

  // Payment
  paymentTime?: string
  paymentAmount?: number
  paymentMethod?: PaymentMethod
  invoiceNumber?: string
  paymentBy?: string

  // Departure order
  departureOrderTime?: string
  passengersDeparting?: number
  departureOrderBy?: string

  // Exit
  exitTime?: string
  exitBy?: string

  // Status
  currentStatus: DispatchStatus
  notes?: string
  metadata?: Record<string, unknown>
  createdAt?: string
  updatedAt?: string
}

export interface DispatchInput {
  vehicleId: string
  driverId?: string  // Optional - bypass driver requirement
  scheduleId?: string
  routeId?: string
  entryTime: string
  notes?: string
  entryShiftId?: string
}
</file>

<file path="client/src/types/fleet.types.ts">
// Fleet Feature Types - Vehicle, Driver, Operator, Vehicle Badge

// ==================== Operator Types ====================

export interface Operator {
  id: string
  name: string
  code: string
  taxCode?: string

  isTicketDelegated: boolean
  province?: string
  district?: string
  address?: string

  phone?: string
  email?: string
  representativeName?: string
  representativePosition?: string

  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export interface OperatorInput {
  name: string
  code: string
  taxCode?: string

  isTicketDelegated?: boolean
  province?: string
  district?: string
  address?: string

  phone?: string
  email?: string
  representativeName?: string
  representativePosition?: string
}

// ==================== Vehicle Type Types ====================

export interface VehicleType {
  id: string
  name: string
  description?: string
  defaultSeatCapacity?: number | null
  defaultBedCapacity?: number | null
  createdAt?: string
}

export interface VehicleTypeInput {
  name: string
  description?: string
}

// ==================== Vehicle Types ====================

export interface DocumentInfo {
  number: string
  issueDate: string
  expiryDate: string
  issuingAuthority?: string
  documentUrl?: string
  notes?: string
  isValid: boolean
}

export interface VehicleDocuments {
  registration?: DocumentInfo
  inspection?: DocumentInfo
  insurance?: DocumentInfo
  operation_permit?: DocumentInfo
  emblem?: DocumentInfo
}

export interface Vehicle {
  id: string
  plateNumber: string
  vehicleTypeId?: string
  vehicleType?: VehicleType
  operatorId: string
  operator?: Operator
  operatorName?: string  // For legacy vehicles without operatorId
  seatCapacity: number
  bedCapacity?: number
  manufactureYear?: number
  chassisNumber?: string
  engineNumber?: string
  color?: string
  imageUrl?: string

  insuranceExpiryDate?: string
  inspectionExpiryDate?: string

  cargoLength?: number
  cargoWidth?: number
  cargoHeight?: number

  gpsProvider?: string
  gpsUsername?: string
  gpsPassword?: string

  province?: string

  isActive: boolean
  notes?: string
  documents?: VehicleDocuments
  createdAt?: string
  updatedAt?: string
}

export interface VehicleInput {
  plateNumber: string
  vehicleTypeId?: string
  operatorId: string
  seatCapacity: number
  bedCapacity?: number
  manufactureYear?: number
  chassisNumber?: string
  engineNumber?: string
  color?: string
  imageUrl?: string

  insuranceExpiryDate?: string
  inspectionExpiryDate?: string

  cargoLength?: number
  cargoWidth?: number
  cargoHeight?: number

  gpsProvider?: string
  gpsUsername?: string
  gpsPassword?: string

  province?: string

  notes?: string
  documents?: VehicleDocuments
}

// ==================== Driver Types ====================

export interface Driver {
  id: string
  operatorId: string // Keep for backward compatibility
  operator?: Operator // Keep for backward compatibility
  operatorIds?: string[] // Array of operator IDs
  operators?: Array<Operator & { isPrimary?: boolean }> // Array of operators with primary flag
  fullName: string
  idNumber: string
  phone?: string
  province?: string
  district?: string
  address?: string
  licenseNumber: string
  licenseClass: string
  licenseExpiryDate: string
  imageUrl?: string
  isActive: boolean
  createdAt?: string
  updatedAt?: string
}

export interface DriverInput {
  operatorIds: string[] // Array of operator IDs (at least one required)
  fullName: string
  idNumber: string
  phone?: string
  province?: string
  district?: string
  address?: string
  licenseNumber: string
  licenseClass: string
  licenseExpiryDate: string
  imageUrl?: string
}

// ==================== Vehicle Badge Types ====================

export type OperationalStatus = 'trong_ben' | 'dang_chay'

export interface VehicleBadge {
  id: string
  badge_color: string
  badge_number: string
  badge_type: string
  bus_route_ref: string
  business_license_ref: string
  created_at: string
  created_by: string
  email_notification_sent: boolean
  expiry_date: string
  file_code: string
  issue_date: string
  issue_type: string
  license_plate_sheet: string
  notes: string
  notification_ref: string
  previous_badge_number: string
  renewal_due_date: string
  renewal_reason: string
  renewal_reminder_shown: boolean
  replacement_vehicle_id: string
  revocation_date: string
  revocation_decision: string
  revocation_reason: string
  route_id: string
  status: string
  vehicle_id: string
  warn_duplicate_plate: boolean
  operational_status: OperationalStatus  // 'trong_ben' (in station) or 'dang_chay' (running)
}
</file>

<file path="server/package.json">
{
  "name": "ben-xe-backend",
  "version": "1.0.0",
  "description": "Backend API for Bus Station Management System",
  "main": "dist/functions.js",
  "type": "module",
  "engines": {
    "node": "20"
  },
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.build.json",
    "start": "node dist/index.js",
    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest",
    "test:watch": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --watch",
    "test:coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --coverage",
    "create-admin": "tsx src/scripts/create-admin.ts",
    "seed": "tsx src/db/seed-firebase-rest.ts",
    "sync:operators": "node src/scripts/sync-operators-from-sheets.cjs",
    "sync:vehicles": "node src/scripts/sync-vehicles-from-sheets.cjs",
    "sync:badges": "node src/scripts/sync-badges-from-sheets.cjs",
    "sync:all": "node src/scripts/sync-vehicles-from-sheets.cjs && node src/scripts/sync-badges-from-sheets.cjs && node src/scripts/sync-operators-from-sheets.cjs",
    "migrate:denormalize": "tsx src/scripts/migrate-denormalize-dispatch.ts",
    "migrate:to-firestore": "tsx src/scripts/migrate-rtdb-to-firestore.ts",
    "migrate:to-firestore:dry": "tsx src/scripts/migrate-rtdb-to-firestore.ts --dry-run",
    "rollback:to-rtdb": "tsx src/scripts/rollback-firestore-to-rtdb.ts",
    "rollback:to-rtdb:dry": "tsx src/scripts/rollback-firestore-to-rtdb.ts --dry-run",
    "deploy": "npm run build && firebase deploy --only functions",
    "deploy:preview": "npm run build && firebase deploy --only functions --project webbenxe"
  },
  "keywords": [
    "express",
    "firebase",
    "realtime-database",
    "api"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@types/multer": "^2.0.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.8.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "firebase-admin": "^12.7.0",
    "firebase-functions": "^7.0.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^30.0.0",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20.10.5",
    "cross-env": "^10.1.0",
    "jest": "^30.2.0",
    "ts-jest": "^29.4.6",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="server/src/controllers/dashboard.controller.ts">
/**
 * Dashboard Controller
 * Handles HTTP requests for dashboard data
 */

import { Response } from 'express';
import { AuthRequest } from '../middleware/auth.js';
import { dashboardService } from '../services/dashboard.service.js';

export const getDashboardData = async (_req: AuthRequest, res: Response) => {
  try {
    const data = await dashboardService.getAllData();
    return res.json(data);
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    return res.status(500).json({ error: 'Failed to fetch dashboard data' });
  }
};

export const getStats = async (_req: AuthRequest, res: Response) => {
  try {
    const stats = await dashboardService.getStats();
    return res.json(stats);
  } catch (error) {
    console.error('Error fetching stats:', error);
    return res.status(500).json({ error: 'Failed to fetch stats' });
  }
};

export const getChartData = async (_req: AuthRequest, res: Response) => {
  try {
    const chartData = await dashboardService.getChartData();
    return res.json(chartData);
  } catch (error) {
    console.error('Error fetching chart data:', error);
    return res.status(500).json({ error: 'Failed to fetch chart data' });
  }
};

export const getRecentActivity = async (_req: AuthRequest, res: Response) => {
  try {
    const activity = await dashboardService.getRecentActivity();
    return res.json(activity);
  } catch (error) {
    console.error('Error fetching recent activity:', error);
    return res.status(500).json({ error: 'Failed to fetch recent activity' });
  }
};

export const getWarnings = async (_req: AuthRequest, res: Response) => {
  try {
    const warnings = await dashboardService.getWarnings();
    return res.json(warnings);
  } catch (error) {
    console.error('Error fetching warnings:', error);
    return res.status(500).json({ error: 'Failed to fetch warnings' });
  }
};
</file>

<file path="server/src/controllers/driver.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'
import { syncDriverChanges } from '../utils/denormalization-sync.js'
import { cachedData } from '../services/cached-data.service.js'

const driverSchema = z.object({
  operatorIds: z.array(z.string().min(1, 'Invalid operator ID')).min(1, 'At least one operator is required'),
  fullName: z.string().min(1, 'Full name is required'),
  idNumber: z.string().min(1, 'ID number is required'),
  phone: z.string().optional(),
  province: z.string().optional(),
  district: z.string().optional(),
  address: z.string().optional(),
  licenseNumber: z.string().min(1, 'License number is required'),
  licenseClass: z.string().min(1, 'License class is required'),
  licenseExpiryDate: z.string().min(1, 'License expiry date is required'),
  imageUrl: z.string().url().optional().or(z.literal('')),
})

export const getAllDrivers = async (req: Request, res: Response) => {
  try {
    const { operatorId, isActive } = req.query

    // Use cached drivers and operators (parallel fetch)
    let [driversData, operatorsMap] = await Promise.all([
      cachedData.getAllDrivers(),
      cachedData.getOperatorsMap(),
    ])

    // Filter by isActive if specified
    if (isActive !== undefined) {
      const active = isActive === 'true'
      driversData = driversData.filter((d: any) => d.is_active === active)
    }

    // Load junction table for multi-operator relationships
    const { data: junctionData, error: junctionError } = await firebase
      .from('driver_operators')
      .select('*')

    // DEBUG LOG - remove after fixing
    console.log('[getAllDrivers] Junction data count:', junctionData?.length || 0)
    console.log('[getAllDrivers] Junction error:', junctionError)
    console.log('[getAllDrivers] Junction data sample:', junctionData?.slice(0, 2))

    // Create a map of driver_id -> operator relationships
    const driverOperatorsMap = new Map<string, any[]>()
    ;(junctionData || []).forEach((junction: any) => {
      const list = driverOperatorsMap.get(junction.driver_id) || []
      list.push(junction)
      driverOperatorsMap.set(junction.driver_id, list)
    })
    
    // DEBUG LOG
    console.log('[getAllDrivers] driverOperatorsMap keys:', Array.from(driverOperatorsMap.keys()))

    // Map drivers with operator info
    let drivers = (driversData || []).map((driver: any) => {
      // Get primary operator from operator_id
      const primaryOperatorData = driver.operator_id ? operatorsMap.get(driver.operator_id) as any : null
      const primaryOperator = primaryOperatorData ? {
        id: primaryOperatorData.id,
        name: primaryOperatorData.name,
        code: primaryOperatorData.code,
      } : undefined

      // Get all operators from junction table
      const junctionRecords = driverOperatorsMap.get(driver.id) || []
      const allOperators = junctionRecords.map((junction: any) => {
        const opData = operatorsMap.get(junction.operator_id) as any
        return opData ? {
          id: opData.id,
          name: opData.name,
          code: opData.code,
          isPrimary: junction.is_primary,
        } : null
      }).filter((op: any) => op !== null)

      // Merge operators: use junction table if available, otherwise use primary
      const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

      return {
        id: driver.id,
        operatorId: driver.operator_id,
        operator: primaryOperator,
        operatorIds: operators.map((op: any) => op.id),
        operators: operators,
        fullName: driver.full_name,
        idNumber: driver.id_number,
        phone: driver.phone,
        province: driver.province,
        district: driver.district,
        address: driver.address,
        licenseNumber: driver.license_number,
        licenseClass: driver.license_class,
        licenseExpiryDate: driver.license_expiry_date,
        imageUrl: driver.image_url,
        isActive: driver.is_active,
        createdAt: driver.created_at,
        updatedAt: driver.updated_at,
      }
    })

    // Filter by operatorId if provided
    if (operatorId) {
      const opId = operatorId as string
      drivers = drivers.filter((driver: any) => {
        // Check direct operator_id
        if (driver.operatorId === opId) return true
        // Check junction table operators
        if (driver.operatorIds.includes(opId)) return true
        return false
      })
    }

    return res.json(drivers)
  } catch (error) {
    console.error('Error fetching drivers:', error)
    return res.status(500).json({ error: 'Failed to fetch drivers' })
  }
}

export const getDriverById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Get driver (without join - Firebase RTDB doesn't support joins)
    const { data: driverData, error: driverError } = await firebase
      .from('drivers')
      .select('*')
      .eq('id', id)
      .single()

    if (driverError) throw driverError
    if (!driverData) {
      return res.status(404).json({ error: 'Driver not found' })
    }

    // Manual join: Fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (driverData.operator_id) {
      const { data: operatorData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', driverData.operator_id)
        .single()
      if (operatorData) {
        primaryOperator = {
          id: operatorData.id,
          name: operatorData.name,
          code: operatorData.code,
        }
      }
    }

    // Manual join: Get all operators from junction table
    const { data: junctionData, error: junctionError } = await firebase
      .from('driver_operators')
      .select('*')
      .eq('driver_id', id)

    if (junctionError) throw junctionError

    // Fetch all operators for junction records
    let allOperators: Array<{ id: string; name: string; code: string; isPrimary: boolean }> = []
    if (junctionData && junctionData.length > 0) {
      const { data: operatorsData } = await firebase
        .from('operators')
        .select('id, name, code')
      
      if (operatorsData) {
        const operatorsMap = new Map(operatorsData.map((op: any) => [op.id, op]))
        allOperators = junctionData
          .map((j: any) => {
            const op = operatorsMap.get(j.operator_id) as any
            return op ? {
              id: op.id,
              name: op.name,
              code: op.code,
              isPrimary: j.is_primary,
            } : null
          })
          .filter((op: any) => op !== null)
      }
    }

    const operators = allOperators.length > 0 ? allOperators : (primaryOperator ? [{ ...primaryOperator, isPrimary: true }] : [])

    return res.json({
      id: driverData.id,
      operatorId: driverData.operator_id, // Keep for backward compatibility
      operator: primaryOperator, // Keep for backward compatibility
      operatorIds: operators.map((op: any) => op.id),
      operators: operators,
      fullName: driverData.full_name,
      idNumber: driverData.id_number,
      phone: driverData.phone,
      province: driverData.province,
      district: driverData.district,
      address: driverData.address,
      licenseNumber: driverData.license_number,
      licenseClass: driverData.license_class,
      licenseExpiryDate: driverData.license_expiry_date,
      imageUrl: driverData.image_url,
      isActive: driverData.is_active,
      createdAt: driverData.created_at,
      updatedAt: driverData.updated_at,
    })
  } catch (error) {
    console.error('Error fetching driver:', error)
    return res.status(500).json({ error: 'Failed to fetch driver' })
  }
}

export const createDriver = async (req: Request, res: Response) => {
  try {
    const validated = driverSchema.parse(req.body)
    const {
      operatorIds,
      fullName,
      idNumber,
      phone,
      province,
      district,
      address,
      licenseNumber,
      licenseClass,
      licenseExpiryDate,
      imageUrl,
    } = validated

    // Use first operator as primary (for backward compatibility)
    const primaryOperatorId = operatorIds[0]

    // Create driver with primary operator (without join - Firebase RTDB doesn't support joins)
    const { data: driverData, error: driverError } = await firebase
      .from('drivers')
      .insert({
        operator_id: primaryOperatorId,
        full_name: fullName,
        id_number: idNumber,
        phone: phone || null,
        province: province || null,
        district: district || null,
        address: address || null,
        license_number: licenseNumber,
        license_class: licenseClass,
        license_expiry_date: licenseExpiryDate,
        image_url: imageUrl || null,
        is_active: true,
      })
      .select('*')
      .single()

    if (driverError) throw driverError

    // Create junction records for all operators
    const junctionRecords = operatorIds.map((opId, index) => ({
      driver_id: driverData.id,
      operator_id: opId,
      is_primary: index === 0, // First one is primary
    }))

    const { error: junctionError } = await firebase
      .from('driver_operators')
      .insert(junctionRecords)

    if (junctionError) throw junctionError

    // Manual join: Fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (driverData.operator_id) {
      const { data: operatorData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', driverData.operator_id)
        .single()
      if (operatorData) {
        primaryOperator = {
          id: operatorData.id,
          name: operatorData.name,
          code: operatorData.code,
        }
      }
    }

    // Manual join: Get all operators from junction table
    const { data: junctionData } = await firebase
      .from('driver_operators')
      .select('*')
      .eq('driver_id', driverData.id)

    // Fetch all operators for junction records
    let allOperators: Array<{ id: string; name: string; code: string; isPrimary: boolean }> = []
    if (junctionData && junctionData.length > 0) {
      const { data: operatorsData } = await firebase
        .from('operators')
        .select('id, name, code')
      
      if (operatorsData) {
        const operatorsMap = new Map(operatorsData.map((op: any) => [op.id, op]))
        allOperators = junctionData
          .map((j: any) => {
            const op = operatorsMap.get(j.operator_id) as any
            return op ? {
              id: op.id,
              name: op.name,
              code: op.code,
              isPrimary: j.is_primary,
            } : null
          })
          .filter((op: any) => op !== null)
      }
    }

    // Invalidate driver cache after create
    cachedData.invalidateDrivers()

    return res.status(201).json({
      id: driverData.id,
      operatorId: driverData.operator_id, // Keep for backward compatibility
      operator: primaryOperator, // Keep for backward compatibility
      operatorIds: allOperators.map((op: any) => op.id),
      operators: allOperators,
      fullName: driverData.full_name,
      idNumber: driverData.id_number,
      phone: driverData.phone,
      email: driverData.email,
      province: driverData.province,
      district: driverData.district,
      address: driverData.address,
      licenseNumber: driverData.license_number,
      licenseClass: driverData.license_class,
      licenseIssueDate: driverData.license_issue_date,
      licenseExpiryDate: driverData.license_expiry_date,
      imageUrl: driverData.image_url,
      isActive: driverData.is_active,
      createdAt: driverData.created_at,
      updatedAt: driverData.updated_at,
    })
  } catch (error: any) {
    console.error('Error creating driver:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Driver with this ID number or license already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create driver' })
  }
}

export const updateDriver = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = driverSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.fullName) updateData.full_name = validated.fullName
    if (validated.idNumber) updateData.id_number = validated.idNumber
    if (validated.phone !== undefined) updateData.phone = validated.phone || null
    if (validated.province !== undefined) updateData.province = validated.province || null
    if (validated.district !== undefined) updateData.district = validated.district || null
    if (validated.address !== undefined) updateData.address = validated.address || null
    if (validated.licenseNumber) updateData.license_number = validated.licenseNumber
    if (validated.licenseClass) updateData.license_class = validated.licenseClass
    if (validated.licenseExpiryDate) updateData.license_expiry_date = validated.licenseExpiryDate
    if (validated.imageUrl !== undefined) updateData.image_url = validated.imageUrl || null

    // Update operators if provided
    if (validated.operatorIds && validated.operatorIds.length > 0) {
      const primaryOperatorId = validated.operatorIds[0]
      updateData.operator_id = primaryOperatorId

      // Delete existing junction records
      await firebase
        .from('driver_operators')
        .delete()
        .eq('driver_id', id)

      // Create new junction records
      const junctionRecords = validated.operatorIds.map((opId, index) => ({
        driver_id: id,
        operator_id: opId,
        is_primary: index === 0,
      }))

      const { error: junctionError } = await firebase
        .from('driver_operators')
        .insert(junctionRecords)

      if (junctionError) throw junctionError
    }

    // Update driver data (without join - Firebase RTDB doesn't support joins)
    const { data, error } = await firebase
      .from('drivers')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Driver not found' })
    }

    // Sync denormalized data to dispatch_records if full_name changed
    if (updateData.full_name) {
      // Run sync in background (non-blocking)
      syncDriverChanges(id, data.full_name).catch((err) => {
        console.error('[Driver Update] Failed to sync denormalized data:', err)
      })
    }

    // Manual join: Fetch primary operator
    let primaryOperator: { id: string; name: string; code: string } | undefined
    if (data.operator_id) {
      const { data: operatorData } = await firebase
        .from('operators')
        .select('id, name, code')
        .eq('id', data.operator_id)
        .single()
      if (operatorData) {
        primaryOperator = {
          id: operatorData.id,
          name: operatorData.name,
          code: operatorData.code,
        }
      }
    }

    // Manual join: Get all operators from junction table
    const { data: junctionData } = await firebase
      .from('driver_operators')
      .select('*')
      .eq('driver_id', id)

    // Fetch all operators for junction records
    let allOperators: Array<{ id: string; name: string; code: string; isPrimary: boolean }> = []
    if (junctionData && junctionData.length > 0) {
      const { data: operatorsData } = await firebase
        .from('operators')
        .select('id, name, code')
      
      if (operatorsData) {
        const operatorsMap = new Map(operatorsData.map((op: any) => [op.id, op]))
        allOperators = junctionData
          .map((j: any) => {
            const op = operatorsMap.get(j.operator_id) as any
            return op ? {
              id: op.id,
              name: op.name,
              code: op.code,
              isPrimary: j.is_primary,
            } : null
          })
          .filter((op: any) => op !== null)
      }
    }

    // Invalidate driver cache after update
    cachedData.invalidateDrivers()

    return res.json({
      id: data.id,
      operatorId: data.operator_id, // Keep for backward compatibility
      operator: primaryOperator, // Keep for backward compatibility
      operatorIds: allOperators.map((op: any) => op.id),
      operators: allOperators,
      fullName: data.full_name,
      idNumber: data.id_number,
      phone: data.phone,
      province: data.province,
      district: data.district,
      address: data.address,
      licenseNumber: data.license_number,
      licenseClass: data.license_class,
      licenseExpiryDate: data.license_expiry_date,
      imageUrl: data.image_url,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error updating driver:', error)
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update driver' })
  }
}

export const deleteDriver = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('drivers')
      .delete()
      .eq('id', id)

    if (error) throw error

    // Invalidate driver cache after delete
    cachedData.invalidateDrivers()

    return res.status(204).send()
  } catch (error) {
    console.error('Error deleting driver:', error)
    return res.status(500).json({ error: 'Failed to delete driver' })
  }
}
</file>

<file path="server/src/controllers/operator.controller.ts">
import { Request, Response } from 'express'
import { firebase, firebaseDb } from '../config/database.js'
import { z } from 'zod'

// Cache for legacy operators
let legacyOperatorsCache: { data: any[]; timestamp: number } | null = null
const LEGACY_CACHE_TTL = 30 * 60 * 1000 // 30 minutes

// Export function to invalidate cache (called by sync service)
export const invalidateOperatorCache = () => {
  legacyOperatorsCache = null
}

const operatorSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  code: z.string().min(1, 'Code is required'),
  taxCode: z.string().optional(),
  
  isTicketDelegated: z.boolean().optional(),
  province: z.string().optional(),
  district: z.string().optional(),
  address: z.string().optional(),
  
  phone: z.string().optional(),
  email: z.string().email().optional().or(z.literal('')),
  representativeName: z.string().optional(),
  representativePosition: z.string().optional(),
})

export const getAllOperators = async (req: Request, res: Response) => {
  try {
    const { isActive } = req.query

    let query = firebase
      .from('operators')
      .select('*')
      .order('created_at', { ascending: false })

    if (isActive !== undefined) {
      query = query.eq('is_active', isActive === 'true')
    }

    const { data, error } = await query

    if (error) throw error

    const operators = data.map((op: any) => ({
      id: op.id,
      name: op.name,
      code: op.code,
      taxCode: op.tax_code,
      
      isTicketDelegated: op.is_ticket_delegated,
      province: op.province,
      district: op.district,
      address: op.address,
      
      phone: op.phone,
      email: op.email,
      representativeName: op.representative_name,
      representativePosition: op.representative_position,
      
      isActive: op.is_active,
      createdAt: op.created_at,
      updatedAt: op.updated_at,
    }))

    return res.json(operators)
  } catch (error) {
    console.error('Error fetching operators:', error)
    return res.status(500).json({ error: 'Failed to fetch operators' })
  }
}

/**
 * Get all operators from Google Sheets (datasheet/DONVIVANTAI)
 * Filtered to only include operators that have badges of type "Buýt" or "Tuyến cố định"
 * Uses Ref_DonViCapPhuHieu from badges to match operators
 */
export const getLegacyOperators = async (req: Request, res: Response) => {
  try {
    const forceRefresh = req.query.refresh === 'true'
    
    // Check cache
    if (!forceRefresh && legacyOperatorsCache && Date.now() - legacyOperatorsCache.timestamp < LEGACY_CACHE_TTL) {
      return res.json(legacyOperatorsCache.data)
    }
    
    // Allowed badge types
    const allowedBadgeTypes = ['Buýt', 'Tuyến cố định']
    
    // Load badges and operators data in parallel
    const [badgeSnapshot, operatorSnapshot] = await Promise.all([
      firebaseDb.ref('datasheet/PHUHIEUXE').once('value'),
      firebaseDb.ref('datasheet/DONVIVANTAI').once('value')
    ])
    
    const badgeData = badgeSnapshot.val()
    const sheetData = operatorSnapshot.val()
    
    // Find unique operator IDs from badges with allowed types (via Ref_DonViCapPhuHieu)
    const operatorIdsWithBadges = new Set<string>()
    if (badgeData) {
      for (const [, badge] of Object.entries(badgeData)) {
        const b = badge as Record<string, unknown>
        if (!b) continue
        
        const badgeType = (b.badge_type || b.LoaiPH || '') as string
        if (!allowedBadgeTypes.includes(badgeType)) continue
        
        // Get the operator ref from badge
        const operatorRef = (b.issuing_authority_ref || b.Ref_DonViCapPhuHieu || '') as string
        if (operatorRef) {
          operatorIdsWithBadges.add(operatorRef)
        }
      }
    }
    
    console.log(`[getLegacyOperators] Found ${operatorIdsWithBadges.size} unique operators with Buýt/Tuyến cố định badges`)
    
    // Convert sheet operators to standard format, filtering by operator IDs from badges
    const operators: any[] = []
    let totalCount = 0
    
    if (sheetData) {
      Object.entries(sheetData).forEach(([key, v]: [string, any]) => {
        totalCount++
        const operatorId = v.id || key
        
        // Only include operators that have badges with allowed types
        if (!operatorIdsWithBadges.has(operatorId)) {
          return
        }
        
        // Normalize province name
        let province = (v.province || '').trim()
        province = province.replace(/^\s*→\s*"?/g, '').replace(/"$/g, '').trim()
        if (province.includes('Tỉnh Tỉnh')) province = province.replace('Tỉnh Tỉnh', 'Tỉnh')
        
        operators.push({
          id: operatorId,
          name: v.name || '',
          code: '',
          province: province,
          district: v.district || '',
          ward: v.ward || '',
          address: v.address || '',
          fullAddress: v.full_address || '',
          phone: v.phone || '',
          email: v.email || '',
          taxCode: v.tax_code || '',
          businessLicense: v.business_license || '',
          representativeName: v.representative_name || '',
          businessType: v.business_type || '',
          registrationProvince: v.registration_province || '',
          isActive: true,
          source: 'google_sheets',
        })
      })
    }
    
    console.log(`[getLegacyOperators] Filtered to ${operators.length} operators (out of ${totalCount} total)`)
    
    // Sort by name
    operators.sort((a, b) => a.name.localeCompare(b.name, 'vi'))
    
    // Update cache
    legacyOperatorsCache = { data: operators, timestamp: Date.now() }
    
    return res.json(operators)
  } catch (error) {
    console.error('Error fetching operators:', error)
    // Return stale cache if available
    if (legacyOperatorsCache) {
      return res.json(legacyOperatorsCache.data)
    }
    return res.status(500).json({ error: 'Failed to fetch operators' })
  }
}

export const getOperatorById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data, error } = await firebase
      .from('operators')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Operator not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      code: data.code,
      taxCode: data.tax_code,
      
      isTicketDelegated: data.is_ticket_delegated,
      province: data.province,
      district: data.district,
      address: data.address,
      
      phone: data.phone,
      email: data.email,
      representativeName: data.representative_name,
      representativePosition: data.representative_position,
      
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error) {
    console.error('Error fetching operator:', error)
    return res.status(500).json({ error: 'Failed to fetch operator' })
  }
}

export const createOperator = async (req: Request, res: Response) => {
  try {
    const validated = operatorSchema.parse(req.body)

    const { data, error } = await firebase
      .from('operators')
      .insert({
        name: validated.name,
        code: validated.code,
        tax_code: validated.taxCode || null,
        
        is_ticket_delegated: validated.isTicketDelegated || false,
        province: validated.province && validated.province.trim() !== '' ? validated.province.trim() : null,
        district: validated.district && validated.district.trim() !== '' ? validated.district.trim() : null,
        address: validated.address || null,
        
        phone: validated.phone || null,
        email: validated.email || null,
        representative_name: validated.representativeName || null,
        representative_position: validated.representativePosition || null,
        
        is_active: true,
      })
      .select()
      .single()

    if (error) throw error

    return res.status(201).json({
      id: data.id,
      name: data.name,
      code: data.code,
      taxCode: data.tax_code,
      
      isTicketDelegated: data.is_ticket_delegated,
      province: data.province,
      district: data.district,
      address: data.address,
      
      phone: data.phone,
      email: data.email,
      representativeName: data.representative_name,
      representativePosition: data.representative_position,
      
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error creating operator:', error)
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Operator with this code already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create operator' })
  }
}

export const updateOperator = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const validated = operatorSchema.partial().parse(req.body)

    const updateData: any = {}
    if (validated.name) updateData.name = validated.name
    if (validated.code) updateData.code = validated.code
    if (validated.taxCode !== undefined) updateData.tax_code = validated.taxCode || null
    
    if (validated.isTicketDelegated !== undefined) updateData.is_ticket_delegated = validated.isTicketDelegated
    if (validated.province !== undefined) updateData.province = validated.province && validated.province.trim() !== '' ? validated.province.trim() : null
    if (validated.district !== undefined) updateData.district = validated.district && validated.district.trim() !== '' ? validated.district.trim() : null
    if (validated.address !== undefined) updateData.address = validated.address || null
    
    if (validated.phone !== undefined) updateData.phone = validated.phone || null
    if (validated.email !== undefined) updateData.email = validated.email || null
    if (validated.representativeName !== undefined) updateData.representative_name = validated.representativeName || null
    if (validated.representativePosition !== undefined) updateData.representative_position = validated.representativePosition || null

    const { data, error } = await firebase
      .from('operators')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Operator not found' })
    }

    return res.json({
      id: data.id,
      name: data.name,
      code: data.code,
      taxCode: data.tax_code,
      
      isTicketDelegated: data.is_ticket_delegated,
      province: data.province,
      district: data.district,
      address: data.address,
      
      phone: data.phone,
      email: data.email,
      representativeName: data.representative_name,
      representativePosition: data.representative_position,
      
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error updating operator:', error)
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update operator' })
  }
}

export const deleteOperator = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { error } = await firebase
      .from('operators')
      .delete()
      .eq('id', id)

    if (error) throw error

    return res.status(204).send()
  } catch (error) {
    console.error('Error deleting operator:', error)
    return res.status(500).json({ error: 'Failed to delete operator' })
  }
}

/**
 * Update operator in RTDB (Google Sheets data)
 */
export const updateLegacyOperator = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const updates = req.body

    // Get existing operator
    const snapshot = await firebaseDb.ref(`datasheet/DONVIVANTAI/${id}`).once('value')
    if (!snapshot.exists()) {
      return res.status(404).json({ error: 'Operator not found' })
    }

    // Update operator in RTDB
    const updateData: any = {}
    if (updates.name !== undefined) updateData.name = updates.name
    if (updates.phone !== undefined) updateData.phone = updates.phone
    if (updates.email !== undefined) updateData.email = updates.email
    if (updates.address !== undefined) updateData.address = updates.address
    if (updates.province !== undefined) updateData.province = updates.province
    if (updates.district !== undefined) updateData.district = updates.district
    if (updates.representativeName !== undefined) updateData.representative_name = updates.representativeName
    if (updates.taxCode !== undefined) updateData.tax_code = updates.taxCode
    if (updates.businessLicense !== undefined) updateData.business_license = updates.businessLicense
    updateData.updated_at = new Date().toISOString()

    await firebaseDb.ref(`datasheet/DONVIVANTAI/${id}`).update(updateData)

    // Invalidate cache
    invalidateOperatorCache()

    // Return updated operator
    const updatedSnapshot = await firebaseDb.ref(`datasheet/DONVIVANTAI/${id}`).once('value')
    const data = updatedSnapshot.val()

    return res.json({
      id: id,
      name: data.name || '',
      phone: data.phone || '',
      email: data.email || '',
      address: data.address || '',
      province: data.province || '',
      district: data.district || '',
      representativeName: data.representative_name || '',
      taxCode: data.tax_code || '',
      businessLicense: data.business_license || '',
      businessType: data.business_type || '',
      isActive: true,
      source: 'google_sheets',
    })
  } catch (error: any) {
    console.error('Error updating legacy operator:', error)
    return res.status(500).json({ error: error.message || 'Failed to update operator' })
  }
}

/**
 * Delete operator from RTDB (Google Sheets data)
 */
export const deleteLegacyOperator = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Check if operator exists
    const snapshot = await firebaseDb.ref(`datasheet/DONVIVANTAI/${id}`).once('value')
    if (!snapshot.exists()) {
      return res.status(404).json({ error: 'Operator not found' })
    }

    // Delete from RTDB
    await firebaseDb.ref(`datasheet/DONVIVANTAI/${id}`).remove()

    // Invalidate cache
    invalidateOperatorCache()

    return res.status(204).send()
  } catch (error) {
    console.error('Error deleting legacy operator:', error)
    return res.status(500).json({ error: 'Failed to delete operator' })
  }
}
</file>

<file path="server/src/modules/dispatch/controllers/dispatch.controller.ts">
/**
 * Dispatch Controller
 * Thin controller that delegates to repository and helpers
 *
 * Target: < 200 lines (from 585 lines original)
 */

import { Request, Response } from 'express'
import { AuthRequest } from '../../../middleware/auth.js'
import { getCurrentVietnamTime, convertVietnamISOToUTCForStorage } from '../../../utils/timezone.js'
import { getErrorMessage, isValidationError } from '../../../types/common.js'
import {
  fetchDenormalizedData,
  buildDenormalizedFields,
  fetchUserName,
  fetchRouteData,
  buildRouteDenormalizedFields
} from '../../../utils/denormalization.js'
import { dispatchRepository } from '../dispatch-repository.js'
import { mapDispatchToAPI, mapDispatchListToAPI } from '../dispatch-mappers.js'
import {
  validateCreateDispatch,
  validatePassengerDrop,
  validateIssuePermit,
  validatePayment,
  validateDepartureOrder,
  validateExit,
  DISPATCH_STATUS,
} from '../dispatch-validation.js'

/**
 * Get all dispatch records with optional filters
 */
export const getAllDispatchRecords = async (req: Request, res: Response) => {
  try {
    const { status, vehicleId, driverId, routeId } = req.query
    const records = await dispatchRepository.findAll({
      status: status as string,
      vehicleId: vehicleId as string,
      driverId: driverId as string,
      routeId: routeId as string,
    })
    return res.json(mapDispatchListToAPI(records))
  } catch (error) {
    console.error('Error fetching dispatch records:', error)
    return res.status(500).json({ error: 'Failed to fetch dispatch records' })
  }
}

/**
 * Get single dispatch record by ID
 */
export const getDispatchRecordById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const record = await dispatchRepository.findById(id)

    if (!record) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json(mapDispatchToAPI(record))
  } catch (error) {
    console.error('Error fetching dispatch record:', error)
    return res.status(500).json({ error: 'Failed to fetch dispatch record' })
  }
}

/**
 * Create new dispatch record (vehicle entry)
 */
export const createDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const input = validateCreateDispatch(req.body)
    const userId = req.user?.id

    const entryTimeForDB = convertVietnamISOToUTCForStorage(input.entryTime)
    const denormData = await fetchDenormalizedData({
      vehicleId: input.vehicleId,
      driverId: input.driverId,
      routeId: input.routeId,
      userId,
    })

    const insertData = {
      vehicle_id: input.vehicleId,
      driver_id: input.driverId,
      schedule_id: input.scheduleId || null,
      route_id: input.routeId || null,
      entry_time: entryTimeForDB,
      entry_by: userId || null,
      entry_shift_id: input.entryShiftId || null,
      current_status: DISPATCH_STATUS.ENTERED,
      notes: input.notes || null,
      ...buildDenormalizedFields(denormData),
      entry_by_name: denormData.user?.fullName || null,
    }

    const record = await dispatchRepository.create(insertData)
    return res.status(201).json(mapDispatchToAPI(record))
  } catch (error: unknown) {
    console.error('Error creating dispatch record:', error)
    if (isValidationError(error)) {
      return res.status(400).json({ error: getErrorMessage(error) })
    }
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to create dispatch record') })
  }
}

/**
 * Record passenger drop
 */
export const recordPassengerDrop = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const input = validatePassengerDrop(req.body)
    const userId = req.user?.id
    const userName = await fetchUserName(userId)

    const updateData: Record<string, unknown> = {
      passenger_drop_time: getCurrentVietnamTime(),
      passengers_arrived: input.passengersArrived ?? null,
      passenger_drop_by: userId || null,
      passenger_drop_by_name: userName,
      current_status: DISPATCH_STATUS.PASSENGERS_DROPPED,
    }

    if (input.routeId) {
      updateData.route_id = input.routeId
      const routeData = await fetchRouteData(input.routeId)
      if (routeData) Object.assign(updateData, buildRouteDenormalizedFields(routeData))
    }

    const record = await dispatchRepository.update(id, updateData)
    if (!record) return res.status(404).json({ error: 'Dispatch record not found' })

    return res.json({ message: 'Passenger drop recorded', dispatch: record })
  } catch (error: unknown) {
    console.error('Error recording passenger drop:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to record passenger drop') })
  }
}

/**
 * Issue boarding permit
 */
export const issuePermit = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const input = validateIssuePermit(req.body)
    const userId = req.user?.id
    const userName = await fetchUserName(userId)

    const currentRecord = await dispatchRepository.findById(id)
    if (!currentRecord) return res.status(404).json({ error: 'Dispatch record not found' })

    const metadata = { ...(currentRecord.metadata || {}) }
    if (input.replacementVehicleId) metadata.replacementVehicleId = input.replacementVehicleId
    else if (input.replacementVehicleId === '') delete metadata.replacementVehicleId

    const updateData: Record<string, unknown> = {
      boarding_permit_time: getCurrentVietnamTime(),
      boarding_permit_by: userId || null,
      boarding_permit_by_name: userName,
      permit_status: input.permitStatus,
      metadata,
      permit_shift_id: input.permitShiftId || null,
    }

    if (input.routeId) {
      updateData.route_id = input.routeId
      const routeData = await fetchRouteData(input.routeId)
      if (routeData) Object.assign(updateData, buildRouteDenormalizedFields(routeData))
    }
    if (input.scheduleId) updateData.schedule_id = input.scheduleId

    if (input.permitStatus === 'approved') {
      updateData.transport_order_code = input.transportOrderCode
      updateData.planned_departure_time = input.plannedDepartureTime
      updateData.seat_count = input.seatCount
      updateData.current_status = DISPATCH_STATUS.PERMIT_ISSUED
      updateData.rejection_reason = input.rejectionReason || null
    } else {
      updateData.transport_order_code = input.transportOrderCode || null
      updateData.planned_departure_time = input.plannedDepartureTime || null
      updateData.seat_count = input.seatCount || null
      updateData.current_status = DISPATCH_STATUS.PERMIT_REJECTED
      updateData.rejection_reason = input.rejectionReason || null
    }

    const record = await dispatchRepository.update(id, updateData)
    return res.json({ message: 'Permit processed', dispatch: record })
  } catch (error: unknown) {
    console.error('Error issuing permit:', error)
    if (isValidationError(error)) return res.status(400).json({ error: getErrorMessage(error) })
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to issue permit') })
  }
}

/**
 * Process payment
 */
export const processPayment = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const input = validatePayment(req.body)
    const userId = req.user?.id
    const userName = await fetchUserName(userId)

    const updateData = {
      payment_time: getCurrentVietnamTime(),
      payment_amount: input.paymentAmount,
      payment_method: input.paymentMethod || 'cash',
      invoice_number: input.invoiceNumber || null,
      payment_by: userId || null,
      payment_by_name: userName,
      payment_shift_id: input.paymentShiftId || null,
      current_status: DISPATCH_STATUS.PAID,
    }

    const record = await dispatchRepository.update(id, updateData)
    if (!record) return res.status(404).json({ error: 'Dispatch record not found' })

    return res.json({ message: 'Payment processed', dispatch: record })
  } catch (error: unknown) {
    console.error('Error processing payment:', error)
    if (isValidationError(error)) return res.status(400).json({ error: getErrorMessage(error) })
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to process payment') })
  }
}

/**
 * Issue departure order
 */
export const issueDepartureOrder = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const input = validateDepartureOrder(req.body)
    const userId = req.user?.id
    const userName = await fetchUserName(userId)

    const updateData = {
      departure_order_time: getCurrentVietnamTime(),
      passengers_departing: input.passengersDeparting ?? null,
      departure_order_by: userId || null,
      departure_order_by_name: userName,
      departure_order_shift_id: input.departureOrderShiftId || null,
      current_status: DISPATCH_STATUS.DEPARTURE_ORDERED,
    }

    const record = await dispatchRepository.update(id, updateData)
    if (!record) return res.status(404).json({ error: 'Dispatch record not found' })

    return res.json({ message: 'Departure order issued', dispatch: record })
  } catch (error: unknown) {
    console.error('Error issuing departure order:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to issue departure order') })
  }
}

/**
 * Record vehicle exit
 */
export const recordExit = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const input = validateExit(req.body)
    const userId = req.user?.id
    const userName = await fetchUserName(userId)

    const updateData: Record<string, unknown> = {
      exit_time: input.exitTime ? convertVietnamISOToUTCForStorage(input.exitTime) : getCurrentVietnamTime(),
      exit_by: userId || null,
      exit_by_name: userName,
      exit_shift_id: input.exitShiftId || null,
      current_status: DISPATCH_STATUS.DEPARTED,
    }

    if (input.passengersDeparting !== undefined) {
      updateData.passengers_departing = input.passengersDeparting
    }

    const record = await dispatchRepository.update(id, updateData)
    if (!record) return res.status(404).json({ error: 'Dispatch record not found' })

    return res.json({ message: 'Exit recorded', dispatch: record })
  } catch (error: unknown) {
    console.error('Error recording exit:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to record exit') })
  }
}

/**
 * Update entry image URL (set or remove)
 */
export const updateEntryImage = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { entryImageUrl } = req.body

    // Allow null to remove image, or string to set image
    if (entryImageUrl !== null && typeof entryImageUrl !== 'string') {
      return res.status(400).json({ error: 'entryImageUrl must be a string or null' })
    }

    const record = await dispatchRepository.update(id, {
      entry_image_url: entryImageUrl,
    })

    if (!record) return res.status(404).json({ error: 'Dispatch record not found' })

    const message = entryImageUrl ? 'Entry image updated' : 'Entry image removed'
    return res.json({ message, dispatch: mapDispatchToAPI(record) })
  } catch (error: unknown) {
    console.error('Error updating entry image:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to update entry image') })
  }
}

/**
 * Delete dispatch record (only for records that haven't departed)
 */
export const deleteDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    
    const existingRecord = await dispatchRepository.findById(id)
    if (!existingRecord) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    // Only allow deletion of records that haven't departed yet
    if (existingRecord.current_status === 'departed') {
      return res.status(400).json({ error: 'Không thể xóa record đã xuất bến. Hãy sử dụng chức năng Hủy bỏ.' })
    }

    await dispatchRepository.delete(id)
    return res.json({ message: 'Dispatch record deleted successfully' })
  } catch (error: unknown) {
    console.error('Error deleting dispatch record:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to delete dispatch record') })
  }
}

/**
 * Cancel dispatch record (soft delete - mark as cancelled)
 * Used for records that have already departed but need to be voided
 */
export const cancelDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { reason } = req.body
    const userId = req.user?.id

    const existingRecord = await dispatchRepository.findById(id)
    if (!existingRecord) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    // Already cancelled
    if (existingRecord.current_status === 'cancelled') {
      return res.status(400).json({ error: 'Record đã được hủy bỏ trước đó' })
    }

    const userName = await fetchUserName(userId)

    // Update status to cancelled and store cancellation info in metadata
    const updatedRecord = await dispatchRepository.update(id, {
      current_status: 'cancelled',
      metadata: {
        ...existingRecord.metadata,
        cancelled_at: new Date().toISOString(),
        cancelled_by: userId,
        cancelled_by_name: userName,
        cancellation_reason: reason || 'Hủy bỏ bởi người dùng',
        previous_status: existingRecord.current_status,
      }
    })

    if (!updatedRecord) {
      return res.status(500).json({ error: 'Failed to update record' })
    }

    return res.json({ 
      message: 'Record đã được hủy bỏ thành công',
      dispatch: mapDispatchToAPI(updatedRecord)
    })
  } catch (error: unknown) {
    console.error('Error cancelling dispatch record:', error)
    return res.status(500).json({ error: getErrorMessage(error, 'Failed to cancel dispatch record') })
  }
}

// Legacy endpoints
export const updateDispatchStatus = async (_req: Request, res: Response) => {
  return res.status(400).json({ error: 'This endpoint is deprecated. Use specific workflow endpoints instead.' })
}

export const depart = async (_req: Request, res: Response) => {
  return res.status(400).json({ error: 'This endpoint is deprecated. Use /depart endpoint instead.' })
}
</file>

<file path="server/src/modules/fleet/services/vehicle-cache.service.ts">
/**
 * Vehicle Cache Service
 * Handles legacy and badge vehicles from Firebase RTDB with caching
 */

import { firebaseDb } from '../../../config/database.js';

export interface LegacyVehicleData {
  id: string;
  plateNumber: string;
  vehicleType: { id: null; name: string };
  vehicleTypeName: string;
  vehicleCategory: string;
  seatCapacity: number;
  bedCapacity: number;
  manufacturer: string;
  modelCode: string;
  manufactureYear: number | null;
  color: string;
  chassisNumber: string;
  engineNumber: string;
  operatorId: null;
  operator: { id: null; name: string; code: string };
  operatorName: string;
  isActive: boolean;
  notes: string;
  source: 'legacy';
  inspectionExpiryDate: string | null;
  insuranceExpiryDate: string | null;
  documents: Record<string, never>;
}

export interface BadgeVehicleData {
  id: string;
  plateNumber: string;
  vehicleType: { id: null; name: string };
  vehicleTypeName: string;
  vehicleCategory: string;
  seatCapacity: number;
  bedCapacity: number;
  manufacturer: string;
  modelCode: string;
  manufactureYear: number | null;
  color: string;
  chassisNumber: string;
  engineNumber: string;
  operatorId: null;
  operator: { id: null; name: string; code: string };
  operatorName: string;
  isActive: boolean;
  notes: string;
  source: 'badge';
  badgeNumber: string;
  badgeType: string;
  badgeExpiryDate: string | null;
  documents: Record<string, never>;
}

interface CacheEntry<T> {
  data: T | null;
  timestamp: number;
}

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

// Helper to check if vehicle category indicates sleeper/bed vehicle
function isBedVehicle(vehicleCategory: string): boolean {
  if (!vehicleCategory) return false;
  // Normalize: lowercase, remove diacritics, extra spaces
  const normalized = vehicleCategory
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
    .replace(/đ/g, 'd')
    .replace(/Đ/g, 'D')
    .replace(/\s+/g, ' ')
    .trim();
  // Check for "giuong nam" variations
  return normalized.includes('giuong nam') || 
         normalized.includes('giuong') ||
         normalized.includes('sleeper');
}

class VehicleCacheService {
  private legacyCache: CacheEntry<LegacyVehicleData[]> = { data: null, timestamp: 0 };
  private operatorIndex: Map<string, number[]> | null = null;
  private badgeCache: CacheEntry<BadgeVehicleData[]> = { data: null, timestamp: 0 };

  private isCacheValid<T>(cache: CacheEntry<T>): boolean {
    return cache.data !== null && Date.now() - cache.timestamp < CACHE_TTL;
  }

  async getLegacyVehicles(): Promise<LegacyVehicleData[]> {
    if (this.isCacheValid(this.legacyCache)) {
      return this.legacyCache.data!;
    }

    const snapshot = await firebaseDb.ref('datasheet/Xe').once('value');
    const data = snapshot.val();
    const vehicles: LegacyVehicleData[] = [];
    const operatorIndex = new Map<string, number[]>();

    if (data) {
      let idx = 0;
      for (const [key, xe] of Object.entries(data)) {
        const x = xe as Record<string, unknown>;
        if (!x) continue;

        const plateNumber = (x.plate_number || x.BienSo || '') as string;
        if (!plateNumber) continue;

        const operatorName = ((x.owner_name || x.TenDangKyXe || '') as string).trim().toLowerCase();
        const vehicleCategory = (x.vehicle_category || x.LoaiPhuongTien || '') as string;
        const seatCount = parseInt(String(x.seat_count || x.SoCho)) || 0;
        // If vehicle category contains "giường nằm", seatCount is actually bedCount
        const hasBeds = isBedVehicle(vehicleCategory);

        vehicles.push({
          id: `legacy_${key}`,
          plateNumber,
          vehicleType: { id: null, name: (x.vehicle_type || x.LoaiXe || '') as string },
          vehicleTypeName: (x.vehicle_type || x.LoaiXe || '') as string,
          vehicleCategory,
          seatCapacity: hasBeds ? 0 : seatCount,
          bedCapacity: hasBeds ? seatCount : 0,
          manufacturer: (x.manufacturer || x.NhanHieu || '') as string,
          modelCode: (x.model_code || x.SoLoai || '') as string,
          manufactureYear: (x.manufacture_year || x.NamSanXuat)
            ? parseInt(String(x.manufacture_year || x.NamSanXuat))
            : null,
          color: (x.color || x.MauSon || '') as string,
          chassisNumber: (x.chassis_number || x.SoKhung || '') as string,
          engineNumber: (x.engine_number || x.SoMay || '') as string,
          operatorId: null,
          operator: { id: null, name: (x.owner_name || x.TenDangKyXe || '') as string, code: '' },
          operatorName: (x.owner_name || x.TenDangKyXe || '') as string,
          isActive: true,
          notes: (x.notes || x.GhiChu || '') as string,
          source: 'legacy',
          inspectionExpiryDate: (x.inspection_expiry || x.NgayHetHanKiemDinh || null) as string | null,
          insuranceExpiryDate: (x.insurance_expiry || x.NgayHetHanBaoHiem || null) as string | null,
          documents: {},
        });

        if (operatorName) {
          if (!operatorIndex.has(operatorName)) {
            operatorIndex.set(operatorName, []);
          }
          operatorIndex.get(operatorName)!.push(idx);
        }
        idx++;
      }
    }

    this.legacyCache = { data: vehicles, timestamp: Date.now() };
    this.operatorIndex = operatorIndex;
    return vehicles;
  }

  async getBadgeVehicles(): Promise<BadgeVehicleData[]> {
    if (this.isCacheValid(this.badgeCache)) {
      return this.badgeCache.data!;
    }

    const allowedTypes = ['Buýt', 'Tuyến cố định'];
    
    // Load both badges and vehicles data for joining
    const [badgeSnapshot, vehicleSnapshot] = await Promise.all([
      firebaseDb.ref('datasheet/PHUHIEUXE').once('value'),
      firebaseDb.ref('datasheet/Xe').once('value')
    ]);
    
    const badgeData = badgeSnapshot.val();
    const vehicleData = vehicleSnapshot.val();
    
    // Build vehicle lookup map by plate number (normalized)
    const vehicleByPlate = new Map<string, Record<string, unknown>>();
    if (vehicleData) {
      for (const [, v] of Object.entries(vehicleData)) {
        const vehicle = v as Record<string, unknown>;
        const plate = ((vehicle.plate_number || vehicle.BienSo || '') as string).replace(/[.\-\s]/g, '').toUpperCase();
        if (plate) {
          vehicleByPlate.set(plate, vehicle);
        }
      }
    }
    
    const vehicles: BadgeVehicleData[] = [];

    if (badgeData) {
      for (const [key, badge] of Object.entries(badgeData)) {
        const b = badge as Record<string, unknown>;
        if (!b) continue;
        
        // Support both old field names and new field names from sync
        const plateNumber = (b.license_plate_sheet || b.BienSoXe || '') as string;
        if (!plateNumber) continue;
        
        const badgeType = (b.badge_type || b.LoaiPH || '') as string;
        if (!allowedTypes.includes(badgeType)) continue;

        const badgeNumber = (b.badge_number || b.SoPhuHieu || '') as string;
        const status = (b.status || b.TrangThai || '') as string;
        const expiryDate = (b.expiry_date || b.NgayHetHan || null) as string | null;
        
        // Try to find matching vehicle for additional info
        const normalizedPlate = plateNumber.replace(/[.\-\s]/g, '').toUpperCase();
        const matchingVehicle = vehicleByPlate.get(normalizedPlate);
        
        // Get operator and seat count from vehicle if available
        let operatorName = (b.operator_name || '') as string;
        let seatCount = parseInt(String(b.seat_count || 0)) || 0;
        let vehicleCategory = '';
        let manufacturer = '';
        let modelCode = '';
        let manufactureYear: number | null = null;
        let color = '';
        let chassisNumber = '';
        let engineNumber = '';
        
        if (matchingVehicle) {
          operatorName = operatorName || (matchingVehicle.owner_name || matchingVehicle.TenDangKyXe || '') as string;
          seatCount = seatCount || parseInt(String(matchingVehicle.seat_count || matchingVehicle.SoCho || 0)) || 0;
          vehicleCategory = (matchingVehicle.vehicle_category || matchingVehicle.LoaiPhuongTien || '') as string;
          manufacturer = (matchingVehicle.manufacturer || matchingVehicle.NhanHieu || '') as string;
          modelCode = (matchingVehicle.model_code || matchingVehicle.SoLoai || '') as string;
          manufactureYear = (matchingVehicle.manufacture_year || matchingVehicle.NamSanXuat)
            ? parseInt(String(matchingVehicle.manufacture_year || matchingVehicle.NamSanXuat))
            : null;
          color = (matchingVehicle.color || matchingVehicle.MauSon || '') as string;
          chassisNumber = (matchingVehicle.chassis_number || matchingVehicle.SoKhung || '') as string;
          engineNumber = (matchingVehicle.engine_number || matchingVehicle.SoMay || '') as string;
        }
        
        // If vehicle category contains "giường nằm", seatCount is actually bedCount
        const hasBeds = isBedVehicle(vehicleCategory);

        vehicles.push({
          id: `badge_${key}`,
          plateNumber,
          vehicleType: { id: null, name: badgeType },
          vehicleTypeName: badgeType,
          vehicleCategory,
          seatCapacity: hasBeds ? 0 : seatCount,
          bedCapacity: hasBeds ? seatCount : 0,
          manufacturer,
          modelCode,
          manufactureYear,
          color,
          chassisNumber,
          engineNumber,
          operatorId: null,
          operator: { id: null, name: operatorName, code: '' },
          operatorName,
          isActive: status !== 'Thu hồi',
          notes: `Phù hiệu: ${badgeNumber}`,
          source: 'badge',
          badgeNumber,
          badgeType,
          badgeExpiryDate: expiryDate,
          documents: {},
        });
      }
    }

    this.badgeCache = { data: vehicles, timestamp: Date.now() };
    return vehicles;
  }

  async getLegacyVehicleById(key: string): Promise<LegacyVehicleData | null> {
    const snapshot = await firebaseDb.ref(`datasheet/Xe/${key}`).once('value');
    const data = snapshot.val();
    if (!data) return null;

    const vehicleCategory = data.vehicle_category || data.LoaiPhuongTien || '';
    const seatCount = parseInt(data.seat_count || data.SoCho) || 0;
    const hasBeds = isBedVehicle(vehicleCategory);

    return {
      id: `legacy_${key}`,
      plateNumber: data.plate_number || data.BienSo || '',
      vehicleType: { id: null, name: data.vehicle_type || data.LoaiXe || '' },
      vehicleTypeName: data.vehicle_type || data.LoaiXe || '',
      vehicleCategory,
      seatCapacity: hasBeds ? 0 : seatCount,
      bedCapacity: hasBeds ? seatCount : 0,
      manufacturer: data.manufacturer || data.NhanHieu || '',
      modelCode: data.model_code || data.SoLoai || '',
      manufactureYear: (data.manufacture_year || data.NamSanXuat)
        ? parseInt(data.manufacture_year || data.NamSanXuat)
        : null,
      color: data.color || data.MauSon || '',
      chassisNumber: data.chassis_number || data.SoKhung || '',
      engineNumber: data.engine_number || data.SoMay || '',
      operatorId: null,
      operator: { id: null, name: data.owner_name || data.TenDangKyXe || '', code: '' },
      operatorName: data.owner_name || data.TenDangKyXe || '',
      isActive: true,
      notes: '',
      source: 'legacy',
      inspectionExpiryDate: null,
      insuranceExpiryDate: null,
      documents: {},
    };
  }

  async getBadgeVehicleById(key: string): Promise<BadgeVehicleData | null> {
    const snapshot = await firebaseDb.ref(`datasheet/PHUHIEUXE/${key}`).once('value');
    const data = snapshot.val();
    if (!data) return null;

    // Support both old and new field names
    const plateNumber = data.license_plate_sheet || data.BienSoXe || '';
    const badgeType = data.badge_type || data.LoaiPH || '';
    const badgeNumber = data.badge_number || data.SoPhuHieu || '';
    const status = data.status || data.TrangThai || '';
    const expiryDate = data.expiry_date || data.NgayHetHan || null;
    const operatorName = data.operator_name || '';
    const seatCount = parseInt(String(data.seat_count || 0)) || 0;
    const vehicleCategory = data.vehicle_category || '';
    const hasBeds = isBedVehicle(vehicleCategory);

    return {
      id: `badge_${key}`,
      plateNumber,
      vehicleType: { id: null, name: badgeType },
      vehicleTypeName: badgeType,
      vehicleCategory,
      seatCapacity: hasBeds ? 0 : seatCount,
      bedCapacity: hasBeds ? seatCount : 0,
      manufacturer: '',
      modelCode: '',
      manufactureYear: null,
      color: '',
      chassisNumber: '',
      engineNumber: '',
      operatorId: null,
      operator: { id: null, name: operatorName, code: '' },
      operatorName,
      isActive: status !== 'Thu hồi',
      notes: `Phù hiệu: ${badgeNumber}`,
      source: 'badge',
      badgeNumber,
      badgeType,
      badgeExpiryDate: expiryDate,
      documents: {},
    };
  }

  async getLegacyOperatorName(operatorId: string): Promise<string | null> {
    const vehicleKey = operatorId.replace('legacy_op_', '').replace('legacy_', '');
    const snapshot = await firebaseDb.ref(`datasheet/Xe/${vehicleKey}`).once('value');
    const data = snapshot.val();
    if (!data) return null;
    return ((data.owner_name || data.TenDangKyXe || '') as string).trim();
  }

  filterLegacyByOperator(vehicles: LegacyVehicleData[], operatorName: string): LegacyVehicleData[] {
    const targetName = operatorName.trim().toLowerCase();

    // Try exact match from index
    let indices = this.operatorIndex?.get(targetName) || [];

    // Partial match fallback
    if (indices.length === 0) {
      const normalizedTarget = targetName.replace(/^(ông|bà|anh|chị|mr\.|mrs\.|ms\.)\s*/i, '').trim();

      for (let i = 0; i < vehicles.length; i++) {
        const vehicleOpName = (vehicles[i].operatorName || '').trim().toLowerCase();
        if (!vehicleOpName) continue;

        const isMatch =
          vehicleOpName.includes(targetName) ||
          targetName.includes(vehicleOpName) ||
          vehicleOpName.includes(normalizedTarget) ||
          normalizedTarget.includes(vehicleOpName);

        if (isMatch) {
          indices.push(i);
        }
      }
    }

    return indices.map((i) => vehicles[i]).filter(Boolean);
  }

  clearCache(): void {
    this.legacyCache = { data: null, timestamp: 0 };
    this.operatorIndex = null;
    this.badgeCache = { data: null, timestamp: 0 };
  }

  /**
   * Lookup vehicle by plate number using cached data
   * Returns vehicle info for permit dialog (much faster than RTDB query)
   */
  async lookupByPlate(plate: string): Promise<{
    id: string;
    plateNumber: string;
    seatCapacity: number;
    bedCapacity: number;
    operatorName: string;
    vehicleType: string;
    source: 'legacy' | 'badge';
  } | null> {
    const normalizedSearch = plate.replace(/[.\-\s]/g, '').toUpperCase();

    // Search in cached legacy vehicles first (most common)
    const legacyVehicles = await this.getLegacyVehicles();
    for (const v of legacyVehicles) {
      const normalizedPlate = v.plateNumber.replace(/[.\-\s]/g, '').toUpperCase();
      if (normalizedPlate === normalizedSearch) {
        return {
          id: v.id,
          plateNumber: v.plateNumber,
          seatCapacity: v.seatCapacity,
          bedCapacity: v.bedCapacity,
          operatorName: v.operatorName,
          vehicleType: v.vehicleCategory || v.vehicleTypeName,
          source: 'legacy',
        };
      }
    }

    // Search in badge vehicles as fallback
    const badgeVehicles = await this.getBadgeVehicles();
    for (const v of badgeVehicles) {
      const normalizedPlate = v.plateNumber.replace(/[.\-\s]/g, '').toUpperCase();
      if (normalizedPlate === normalizedSearch) {
        return {
          id: v.id,
          plateNumber: v.plateNumber,
          seatCapacity: v.seatCapacity,
          bedCapacity: v.bedCapacity,
          operatorName: v.operatorName,
          vehicleType: v.vehicleCategory || v.vehicleTypeName,
          source: 'badge',
        };
      }
    }

    return null;
  }

  // Pre-warm cache on server startup
  async preWarm(): Promise<void> {
    const startTime = Date.now();
    console.log('[VehicleCache] Pre-warming cache...');
    
    try {
      // Load both caches in parallel
      const [legacy, badge] = await Promise.all([
        this.getLegacyVehicles(),
        this.getBadgeVehicles(),
      ]);
      
      const elapsed = Date.now() - startTime;
      console.log(`[VehicleCache] Pre-warmed: ${legacy.length} legacy + ${badge.length} badge vehicles in ${elapsed}ms`);
    } catch (error) {
      console.error('[VehicleCache] Pre-warm failed:', error);
    }
  }
}

export const vehicleCacheService = new VehicleCacheService();
</file>

<file path="server/src/routes/operator.routes.ts">
import { Router, Request, Response } from 'express'
import {
  getAllOperators,
  getLegacyOperators,
  getOperatorById,
  createOperator,
  updateOperator,
  deleteOperator,
  updateLegacyOperator,
  deleteLegacyOperator,
} from '../controllers/operator.controller.js'
import { authenticate } from '../middleware/auth.js'
import {
  syncOperatorsFromSheets,
  getOperatorSyncStatus,
} from '../services/operator-sync.service.js'

const router = Router()

router.use(authenticate)

// Sync status endpoint
router.get('/sync/status', async (_req: Request, res: Response) => {
  try {
    const status = getOperatorSyncStatus()
    res.json(status)
  } catch (error: any) {
    res.status(500).json({ error: error.message })
  }
})

// Manual sync trigger endpoint
router.post('/sync/trigger', async (_req: Request, res: Response) => {
  try {
    const result = await syncOperatorsFromSheets()
    res.json(result)
  } catch (error: any) {
    res.status(500).json({ error: error.message })
  }
})

router.get('/', getAllOperators)
router.get('/legacy', getLegacyOperators)
router.get('/:id', getOperatorById)
router.post('/', createOperator)
router.put('/:id', updateOperator)
router.delete('/:id', deleteOperator)

// Legacy (RTDB) operator routes
router.put('/legacy/:id', updateLegacyOperator)
router.delete('/legacy/:id', deleteLegacyOperator)

export default router
</file>

<file path="server/src/routes/vehicle-badge.routes.ts">
import { Router, Request, Response } from 'express'
import {
  getAllVehicleBadges,
  getVehicleBadgeById,
  getVehicleBadgeByPlateNumber,
  getVehicleBadgeStats,
  createVehicleBadge,
  updateVehicleBadge,
  deleteVehicleBadge,
} from '../controllers/vehicle-badge.controller.js'
import { authenticate } from '../middleware/auth.js'
import { getBadgeSyncStatus, syncBadgesFromSheets } from '../services/badge-sync.service.js'

const router = Router()

router.use(authenticate)

// Sync status and trigger endpoints
router.get('/sync/status', (_req: Request, res: Response) => {
  const status = getBadgeSyncStatus()
  res.json(status)
})

router.post('/sync/trigger', async (_req: Request, res: Response) => {
  try {
    const result = await syncBadgesFromSheets()
    res.json(result)
  } catch (error: any) {
    res.status(500).json({ success: false, error: error.message })
  }
})

router.get('/stats', getVehicleBadgeStats)
router.get('/by-plate/:plateNumber', getVehicleBadgeByPlateNumber)
router.get('/', getAllVehicleBadges)
router.get('/:id', getVehicleBadgeById)
router.post('/', createVehicleBadge)
router.put('/:id', updateVehicleBadge)
router.delete('/:id', deleteVehicleBadge)

export default router
</file>

<file path="client/src/components/operator/OperatorDetailDialog.tsx">
import { createPortal } from "react-dom";
import { X, Building2, Truck, CheckCircle2, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { StatusBadge } from "@/components/layout/StatusBadge";
import { VehicleCard, EmptyVehicles, VehiclesSkeleton, SummaryCards } from "./detail";
import { useOperatorDetail } from "@/hooks/useOperatorDetail";
import type { Operator } from "@/types";

interface OperatorDetailDialogProps {
  open: boolean;
  onClose: () => void;
  operator: Operator | null;
}

export function OperatorDetailDialog({
  open,
  onClose,
  operator,
}: OperatorDetailDialogProps) {
  const {
    activeTab,
    setActiveTab,
    vehicles,
    invoices,
    allDispatchRecords,
    paidDispatchRecords,
    unpaidDispatchRecords,
    isLoading,
    error,
    loadData,
    unpaidInvoices,
    totalDebt,
    paidInvoices,
    allPaymentHistory,
    totalPaid,
    formatDate,
    formatCurrency,
    resetTab,
  } = useOperatorDetail(operator, open);

  const handleClose = () => {
    resetTab();
    onClose();
  };

  if (!open || !operator) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center"
      onClick={handleClose}
    >
      <div
        className="bg-white w-full h-full overflow-y-auto overflow-x-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="max-w-[1920px] mx-auto p-8">
          {/* Header */}
          <div className="flex justify-between items-center pb-4 border-b mb-6">
            <div className="flex items-center gap-4">
              <div className="p-3 bg-blue-100 rounded-lg">
                <Building2 className="h-6 w-6 text-blue-600" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-900">
                  {operator.name}
                </h1>
                <p className="text-sm text-gray-500">Mã: {operator.code}</p>
              </div>
            </div>
            <Button type="button" variant="ghost" size="icon" onClick={handleClose}>
              <X className="h-5 w-5" />
            </Button>
          </div>

          {/* Summary Cards */}
          <SummaryCards
            vehicleCount={vehicles.length}
            totalDebt={totalDebt}
            totalPaid={totalPaid}
            invoiceCount={allDispatchRecords.length}
            formatCurrency={formatCurrency}
          />

          {/* Tabs */}
          <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-4">
              <TabsTrigger value="vehicles">
                Xe trực thuộc ({vehicles.length})
              </TabsTrigger>
              <TabsTrigger value="debt">
                Công nợ ({unpaidDispatchRecords.length + unpaidInvoices.length})
              </TabsTrigger>
              <TabsTrigger value="payment-info">Thông tin thanh toán</TabsTrigger>
              <TabsTrigger value="payment-history">
                Lịch sử thanh toán ({allPaymentHistory.length})
              </TabsTrigger>
            </TabsList>

            {/* Vehicles Tab */}
            <TabsContent value="vehicles" className="mt-6">
              <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6">
                <div className="flex items-center gap-3">
                  <div className="p-3 rounded-2xl bg-gradient-to-br from-blue-500 to-cyan-500 text-white shadow-lg shadow-blue-500/25">
                    <Truck className="w-6 h-6" />
                  </div>
                  <div>
                    <h2 className="text-xl font-bold text-gray-900">
                      Danh sách xe trực thuộc
                    </h2>
                    <p className="text-sm text-gray-500">
                      {vehicles.length > 0
                        ? `Tổng cộng ${vehicles.length} xe đang được quản lý`
                        : "Chưa có xe nào được đăng ký"}
                    </p>
                  </div>
                </div>

                {vehicles.length > 0 && (
                  <div className="flex items-center gap-2">
                    <span className="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-emerald-50 text-emerald-700 text-sm font-medium">
                      <CheckCircle2 className="w-4 h-4" />
                      {vehicles.filter((v) => v.isActive).length} hoạt động
                    </span>
                    {vehicles.filter((v) => !v.isActive).length > 0 && (
                      <span className="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-gray-100 text-gray-600 text-sm font-medium">
                        <AlertCircle className="w-4 h-4" />
                        {vehicles.filter((v) => !v.isActive).length} ngừng
                      </span>
                    )}
                  </div>
                )}
              </div>

              {isLoading ? (
                <VehiclesSkeleton />
              ) : vehicles.length === 0 ? (
                <EmptyVehicles />
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                  {vehicles.map((vehicle, index) => (
                    <VehicleCard key={vehicle.id} vehicle={vehicle} index={index} />
                  ))}
                </div>
              )}

              <style>{`
                @keyframes slideUp {
                  from { opacity: 0; transform: translateY(20px); }
                  to { opacity: 1; transform: translateY(0); }
                }
              `}</style>
            </TabsContent>

            {/* Debt Tab */}
            <TabsContent value="debt" className="mt-6">
              <Card>
                <CardHeader>
                  <CardTitle>Công nợ chưa thanh toán ({unpaidDispatchRecords.length + unpaidInvoices.length})</CardTitle>
                </CardHeader>
                <CardContent>
                  {isLoading ? (
                    <div className="text-center py-8">Đang tải...</div>
                  ) : (unpaidDispatchRecords.length === 0 && unpaidInvoices.length === 0) ? (
                    <div className="text-center py-8 text-gray-500">Không có công nợ</div>
                  ) : (
                    <>
                      <div className="mb-4 p-4 bg-red-50 rounded-lg">
                        <p className="text-sm text-gray-600">
                          Tổng công nợ:{" "}
                          <span className="text-xl font-bold text-red-600">
                            {formatCurrency(totalDebt)}
                          </span>
                        </p>
                      </div>
                      
                      {/* Dispatch Records chưa thanh toán */}
                      {unpaidDispatchRecords.length > 0 && (
                        <>
                          <h4 className="font-medium text-gray-700 mb-3">Đơn hàng chưa thanh toán ({unpaidDispatchRecords.length})</h4>
                          <Table className="mb-6">
                            <TableHeader>
                              <TableRow>
                                <TableHead className="text-center">Mã đơn</TableHead>
                                <TableHead className="text-center">Biển số xe</TableHead>
                                <TableHead className="text-center">Ngày vào bến</TableHead>
                                <TableHead className="text-center">Tuyến</TableHead>
                                <TableHead className="text-center">Trạng thái</TableHead>
                              </TableRow>
                            </TableHeader>
                            <TableBody>
                              {unpaidDispatchRecords.map((record) => (
                                <TableRow key={record.id}>
                                  <TableCell className="font-medium text-center">
                                    ĐH-{record.id.substring(0, 8).toUpperCase()}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {record.vehiclePlateNumber || "-"}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {formatDate(record.entryTime)}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {record.routeName || "-"}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    <span className="px-2 py-1 rounded-full text-xs bg-yellow-100 text-yellow-800">
                                      Chưa thanh toán
                                    </span>
                                  </TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </>
                      )}
                      
                      {/* Legacy: Invoices chưa thanh toán */}
                      {unpaidInvoices.length > 0 && (
                        <>
                          <h4 className="font-medium text-gray-700 mb-3">Hóa đơn chưa thanh toán ({unpaidInvoices.length})</h4>
                          <Table>
                            <TableHeader>
                              <TableRow>
                                <TableHead className="text-center">Số hóa đơn</TableHead>
                                <TableHead className="text-center">Ngày phát hành</TableHead>
                                <TableHead className="text-center">Hạn thanh toán</TableHead>
                                <TableHead className="text-center">Tổng tiền</TableHead>
                                <TableHead className="text-center">Trạng thái</TableHead>
                              </TableRow>
                            </TableHeader>
                            <TableBody>
                              {unpaidInvoices.map((invoice) => (
                                <TableRow key={invoice.id}>
                                  <TableCell className="font-medium text-center">
                                    {invoice.invoiceNumber}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {formatDate(invoice.issueDate)}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {formatDate(invoice.dueDate)}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {formatCurrency(invoice.totalAmount)}
                                  </TableCell>
                                  <TableCell className="text-center">
                                    {invoice.paymentStatus === "overdue" ? (
                                      <StatusBadge status="inactive" />
                                    ) : (
                                      <span className="px-2 py-1 rounded-full text-xs bg-yellow-100 text-yellow-800">
                                        Chưa thanh toán
                                      </span>
                                    )}
                                  </TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </>
                      )}
                    </>
                  )}
                </CardContent>
              </Card>
            </TabsContent>

            {/* Payment Info Tab */}
            <TabsContent value="payment-info" className="mt-6">
              <Card>
                <CardHeader>
                  <CardTitle>Thông tin thanh toán</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="space-y-4">
                      <h3 className="font-semibold text-lg">Tổng quan đơn hàng</h3>
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-gray-600">Tổng số đơn hàng:</span>
                          <span className="font-medium">{allDispatchRecords.length}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-gray-600">Đã thanh toán:</span>
                          <span className="font-medium text-green-600">
                            {paidDispatchRecords.length}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-gray-600">Chưa thanh toán:</span>
                          <span className="font-medium text-red-600">
                            {unpaidDispatchRecords.length}
                          </span>
                        </div>
                      </div>
                    </div>
                    <div className="space-y-4">
                      <h3 className="font-semibold text-lg">Tổng tiền</h3>
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-gray-600">Tổng công nợ:</span>
                          <span className="font-medium text-red-600">
                            {formatCurrency(totalDebt)}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-gray-600">Đã thanh toán:</span>
                          <span className="font-medium text-green-600">
                            {formatCurrency(totalPaid)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>

            {/* Payment History Tab */}
            <TabsContent value="payment-history" className="mt-6">
              <Card>
                <CardHeader>
                  <div className="flex justify-between items-center">
                    <CardTitle>
                      Lịch sử thanh toán ({allPaymentHistory.length})
                    </CardTitle>
                    {error && (
                      <Button variant="outline" size="sm" onClick={loadData}>
                        Tải lại
                      </Button>
                    )}
                  </div>
                </CardHeader>
                <CardContent>
                  {isLoading ? (
                    <div className="text-center py-8">Đang tải...</div>
                  ) : error ? (
                    <div className="text-center py-8">
                      <p className="text-red-600 mb-4">{error}</p>
                      <Button variant="outline" onClick={loadData}>
                        Thử lại
                      </Button>
                    </div>
                  ) : allPaymentHistory.length === 0 ? (
                    <div className="text-center py-8 text-gray-500">
                      <p>Chưa có lịch sử thanh toán</p>
                      <p className="text-sm mt-2">
                        Tổng số hóa đơn: {invoices.length} | Đã thanh toán (invoice):{" "}
                        {paidInvoices.length} | Đã thanh toán (dispatch):{" "}
                        {paidDispatchRecords.length} | Chưa thanh toán:{" "}
                        {unpaidInvoices.length}
                      </p>
                    </div>
                  ) : (
                    <>
                      <div className="mb-4 p-4 bg-green-50 rounded-lg">
                        <p className="text-sm text-gray-600">
                          Tổng đã thanh toán:{" "}
                          <span className="text-xl font-bold text-green-600">
                            {formatCurrency(totalPaid)}
                          </span>
                        </p>
                        <p className="text-xs text-gray-500 mt-1">
                          Bao gồm: {paidInvoices.length} hóa đơn và{" "}
                          {paidDispatchRecords.length} đơn hàng đã thanh toán
                        </p>
                      </div>
                      <Table>
                        <TableHeader>
                          <TableRow>
                            <TableHead className="text-center">Số hóa đơn/Mã đơn</TableHead>
                            <TableHead className="text-center">Ngày phát hành</TableHead>
                            <TableHead className="text-center">Ngày thanh toán</TableHead>
                            <TableHead className="text-center">Tổng tiền</TableHead>
                            <TableHead className="text-center">Nguồn</TableHead>
                            <TableHead className="text-center">Trạng thái</TableHead>
                          </TableRow>
                        </TableHeader>
                        <TableBody>
                          {allPaymentHistory.map((item) => (
                            <TableRow key={item.id}>
                              <TableCell className="font-medium text-center">
                                {item.invoiceNumber}
                                {item.source === "dispatch" && item.vehiclePlateNumber && (
                                  <span className="ml-1 text-xs text-gray-500">
                                    ({item.vehiclePlateNumber})
                                  </span>
                                )}
                              </TableCell>
                              <TableCell className="text-center">
                                {formatDate(item.issueDate)}
                              </TableCell>
                              <TableCell className="text-center">
                                {formatDate(item.paymentDate)}
                              </TableCell>
                              <TableCell className="text-center">
                                {formatCurrency(item.totalAmount)}
                              </TableCell>
                              <TableCell className="text-center">
                                <span
                                  className={`px-2 py-1 rounded-full text-xs ${
                                    item.source === "invoice"
                                      ? "bg-blue-100 text-blue-700"
                                      : "bg-purple-100 text-purple-700"
                                  }`}
                                >
                                  {item.source === "invoice" ? "Hóa đơn" : "Đơn hàng"}
                                </span>
                              </TableCell>
                              <TableCell className="text-center">
                                <StatusBadge status="active" />
                              </TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    </>
                  )}
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </div>,
    document.body
  );
}
</file>

<file path="client/src/hooks/useCapPhepDialog.ts">
import { useState, useEffect, useCallback, useMemo } from "react";
import { toast } from "react-toastify";
import { format, startOfMonth, endOfMonth } from "date-fns";
import { scheduleService } from "@/services/schedule.service";
import { dispatchService } from "@/services/dispatch.service";
import { vehicleService } from "@/services/vehicle.service";
import { type VehicleBadge } from "@/services/vehicle-badge.service";
import { serviceChargeService } from "@/services/service-charge.service";
import { quanlyDataService, type QuanLyVehicle, type QuanLyRoute, type QuanLyOperator, type QuanLyBadge } from "@/services/quanly-data.service";
import { useUIStore } from "@/store/ui.store";
import type { Shift } from "@/services/shift.service";
import type { DispatchRecord, Route, Schedule, Vehicle, Driver, ServiceCharge, Operator } from "@/types";

type DocumentStatus = 'valid' | 'expired' | 'expiring_soon' | 'missing';

interface DocumentCheckResult {
  name: string;
  status: DocumentStatus;
  expiryDate?: string;
  daysRemaining?: number;
}

export function useCapPhepDialog(record: DispatchRecord, onClose: () => void, onSuccess?: () => void) {
  const [permitType, setPermitType] = useState("fixed");
  const [transportOrderCode, setTransportOrderCode] = useState(record.transportOrderCode || "");
  const [replacementVehicleId, setReplacementVehicleId] = useState("");
  const [seatCount, setSeatCount] = useState(() => record.seatCount?.toString() || "");
  const [bedCount, setBedCount] = useState("0");
  const [hhTicketCount, setHhTicketCount] = useState("0");
  const [hhPercentage, setHhPercentage] = useState("0");
  const [entryPlateNumber, setEntryPlateNumber] = useState(record.vehiclePlateNumber || "");
  const [registeredPlateNumber, setRegisteredPlateNumber] = useState(record.vehiclePlateNumber || "");
  const [routeId, setRouteId] = useState(record.routeId || "");
  const [scheduleId, setScheduleId] = useState(record.scheduleId || "");
  const [departureTime, setDepartureTime] = useState("");
  const [departureDate, setDepartureDate] = useState(
    record.plannedDepartureTime
      ? format(new Date(record.plannedDepartureTime), "yyyy-MM-dd")
      : format(new Date(), "yyyy-MM-dd")
  );

  const [routes, setRoutes] = useState<Route[]>([]);
  const [schedules, setSchedules] = useState<Schedule[]>([]);
  const [vehicleBadges, setVehicleBadges] = useState<VehicleBadge[]>([]);
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [drivers, setDrivers] = useState<Driver[]>([]);
  const [serviceCharges, setServiceCharges] = useState<ServiceCharge[]>([]);
  const [selectedVehicle, setSelectedVehicle] = useState<Vehicle | null>(null);
  const [operators, setOperators] = useState<Operator[]>([]);
  const [selectedOperatorId, setSelectedOperatorId] = useState<string>("");
  const [operatorNameFromVehicle, setOperatorNameFromVehicle] = useState<string>("");
  const [totalAmount, setTotalAmount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const [serviceDetailsExpanded, setServiceDetailsExpanded] = useState(true);
  const [showZeroAmountConfirm, setShowZeroAmountConfirm] = useState(false);
  const [dailyTripCounts, setDailyTripCounts] = useState<Record<number, number>>({});
  const [tripCountsLoaded, setTripCountsLoaded] = useState(false);
  const [schedulesCache, setSchedulesCache] = useState<Record<string, Schedule[]>>({});
  const [cachedDispatchRecords, setCachedDispatchRecords] = useState<DispatchRecord[] | null>(null);

  const { currentShift } = useUIStore();

  const loadSchedules = useCallback(async (rid: string) => {
    try {
      if (schedulesCache[rid]) {
        setSchedules(schedulesCache[rid]);
        return;
      }
      const data = await scheduleService.getAll(rid, undefined, true);
      setSchedules(data);
      setSchedulesCache(prev => ({ ...prev, [rid]: data }));
    } catch (error) {
      console.error("Failed to load schedules:", error);
    }
  }, [schedulesCache]);

  const calculateTotal = useCallback(() => {
    const total = serviceCharges.reduce((sum, charge) => sum + charge.totalAmount, 0);
    setTotalAmount(total);
  }, [serviceCharges]);

  const getShiftIdFromCurrentShift = useCallback((): string | undefined => {
    if (!currentShift || currentShift === '<Trống>') return undefined;
    const currentShifts = useUIStore.getState().shifts;
    if (currentShifts.length === 0) return undefined;
    const match = currentShift.match(/^(.+?)\s*\(/);
    if (!match) return undefined;
    const shiftName = match[1].trim();
    const foundShift = currentShifts.find((shift: Shift) => shift.name === shiftName);
    return foundShift?.id;
  }, [currentShift]);

  const loadDailyTripCounts = useCallback(async () => {
    try {
      if (!departureDate) {
        setDailyTripCounts({});
        return;
      }

      const monthDate = new Date(departureDate);
      const monthStart = startOfMonth(monthDate);
      const monthEnd = endOfMonth(monthDate);

      let dispatchRecords = cachedDispatchRecords;
      if (!dispatchRecords) {
        dispatchRecords = await dispatchService.getAll();
        setCachedDispatchRecords(dispatchRecords);
      }

      const counts: Record<number, number> = {};
      const vehiclesByDay: Record<number, Set<string>> = {};

      dispatchRecords.forEach((dispatchRecord) => {
        const recordDate = dispatchRecord.plannedDepartureTime
          ? new Date(dispatchRecord.plannedDepartureTime)
          : dispatchRecord.entryTime
          ? new Date(dispatchRecord.entryTime)
          : null;

        if (recordDate && recordDate >= monthStart && recordDate <= monthEnd) {
          const day = recordDate.getDate();
          if (!vehiclesByDay[day]) vehiclesByDay[day] = new Set();
          if (dispatchRecord.vehicleId) vehiclesByDay[day].add(dispatchRecord.vehicleId);
        }
      });

      Object.keys(vehiclesByDay).forEach((dayStr) => {
        const day = parseInt(dayStr, 10);
        counts[day] = vehiclesByDay[day].size;
      });

      setDailyTripCounts(counts);
    } catch (error) {
      console.error("Failed to load daily trip counts:", error);
      setDailyTripCounts({});
    }
  }, [departureDate, cachedDispatchRecords]);

  const loadInitialData = useCallback(async () => {
    try {
      // Use unified endpoint - 1 request instead of 4, with frontend caching
      const [quanlyData, schedulesData, chargesData] = await Promise.all([
        quanlyDataService.getAll(), // Gets routes, operators, vehicles, badges in 1 call
        record.routeId ? scheduleService.getAll(record.routeId, undefined, true) : Promise.resolve([]),
        record.id ? serviceChargeService.getAll(record.id) : Promise.resolve([]),
      ]);

      // Map routes from quanly-data format to dropdown format
      const routesForDropdown = (quanlyData.routes || []).map((r: QuanLyRoute) => ({
        id: r.id,
        routeName: r.name || `${r.startPoint} - ${r.endPoint}`,
        routeCode: r.code,
        routeType: '',
        distanceKm: r.distance ? parseFloat(r.distance) : undefined,
        destinationId: null,
        destination: { id: null, name: r.endPoint, code: '' },
      }));

      // Map vehicles from quanly-data format
      const vehiclesData = (quanlyData.vehicles || []).map((v: QuanLyVehicle) => ({
        id: v.id,
        plateNumber: v.plateNumber,
        seatCapacity: v.seatCapacity,
        operatorName: v.operatorName,
        vehicleType: v.vehicleType,
        isActive: v.isActive,
        source: v.source,
        operatorId: null,
        operator: { id: null, name: v.operatorName, code: '' },
      })) as unknown as Vehicle[];

      // Map operators from quanly-data format
      const operatorsData = (quanlyData.operators || []).map((o: QuanLyOperator) => ({
        id: o.id,
        name: o.name,
        province: o.province,
        phone: o.phone,
        email: o.email,
        address: o.address,
        representativeName: o.representativeName,
        isActive: o.isActive,
      })) as Operator[];

      // Map badges from quanly-data format
      const badgesData = (quanlyData.badges || []).map((b: QuanLyBadge) => ({
        id: b.id,
        badge_number: b.badge_number,
        license_plate_sheet: b.license_plate_sheet,
        badge_type: b.badge_type,
        badge_color: b.badge_color,
        issue_date: b.issue_date,
        expiry_date: b.expiry_date,
        status: b.status,
        vehicle_id: b.id,
      })) as VehicleBadge[];

      setRoutes(routesForDropdown as unknown as Route[]);
      setOperators(operatorsData);
      setVehicles(vehiclesData);
      setVehicleBadges(badgesData);

      if (record.routeId) {
        setRouteId(record.routeId);
        setSchedules(schedulesData);
        if (record.scheduleId) setScheduleId(record.scheduleId);
      }

      if (record.id && chargesData) setServiceCharges(chargesData);

      let vehicleFound = false;
      if (record.vehicleId && vehiclesData.length > 0) {
        const vehicle = vehiclesData.find((v: Vehicle) => v.id === record.vehicleId);
        if (vehicle) {
          vehicleFound = true;
          setSelectedVehicle(vehicle);
          if ((!record.seatCount || record.seatCount === 0) && vehicle.seatCapacity) {
            setSeatCount(vehicle.seatCapacity.toString());
          }
          if (vehicle.bedCapacity !== undefined && vehicle.bedCapacity !== null) {
            setBedCount(vehicle.bedCapacity.toString());
          }
          if (!registeredPlateNumber && vehicle.plateNumber) setRegisteredPlateNumber(vehicle.plateNumber);
          if (!entryPlateNumber && vehicle.plateNumber) setEntryPlateNumber(vehicle.plateNumber);
          if (vehicle.operatorId) {
            setSelectedOperatorId(vehicle.operatorId);
            if (record.driver) setDrivers([record.driver]);
          } else {
            // For legacy vehicles, try to match operator by name
            const opName = vehicle.operatorName || vehicle.operator?.name;
            if (opName && operatorsData.length > 0) {
              const normalizedOpName = opName.trim().toLowerCase();
              const matchedOp = operatorsData.find((op: Operator) => 
                op.name?.trim().toLowerCase() === normalizedOpName ||
                op.id?.includes(normalizedOpName.substring(0, 10))
              );
              if (matchedOp) {
                setSelectedOperatorId(matchedOp.id);
              }
            }
          }
          if (vehicle.operatorName) setOperatorNameFromVehicle(vehicle.operatorName);
          else if (vehicle.operator?.name) setOperatorNameFromVehicle(vehicle.operator.name);
        }
      }

      if (!vehicleFound && record.vehicleId) {
        try {
          const matchingBadge = badgesData.find((b: VehicleBadge) => b.vehicle_id === record.vehicleId);
          if (matchingBadge?.license_plate_sheet) {
            if (!registeredPlateNumber) setRegisteredPlateNumber(matchingBadge.license_plate_sheet);
            if (!entryPlateNumber) setEntryPlateNumber(matchingBadge.license_plate_sheet);
          }
        } catch (badgeError) {
          console.warn("Could not load vehicle badges:", badgeError);
        }
      }

      // Fallback: Try to get seatCapacity from RTDB lookup if not found from Supabase
      const plateToCheck = record.vehiclePlateNumber;
      const foundVehicleSeatCapacity = vehiclesData.find((v: Vehicle) => v.id === record.vehicleId)?.seatCapacity;
      const needSeatCapacity = !vehicleFound || !foundVehicleSeatCapacity;
      
      if (plateToCheck && needSeatCapacity && (!record.seatCount || record.seatCount === 0)) {
        try {
          // Use direct RTDB lookup - works for ALL vehicles, not just those with badges
          const lookupResult = await vehicleService.lookupByPlate(plateToCheck);
          if (lookupResult?.seatCapacity && lookupResult.seatCapacity > 0) {
            setSeatCount(lookupResult.seatCapacity.toString());
          }
        } catch (lookupError) {
          console.warn("Could not lookup vehicle seat capacity:", lookupError);
        }
      }

      if (record.seatCount && record.seatCount > 0) setSeatCount(record.seatCount.toString());
    } catch (error) {
      console.error("Failed to load initial data:", error);
    }
  }, [record, registeredPlateNumber, entryPlateNumber]);

  const normalizePlate = (plate: string): string => plate.replace(/[.\-\s]/g, '').toUpperCase();

  const getMatchingBadge = useCallback((): VehicleBadge | undefined => {
    const plateNumber = registeredPlateNumber || entryPlateNumber || selectedVehicle?.plateNumber;
    if (!plateNumber || !vehicleBadges.length) return undefined;
    const normalizedPlate = normalizePlate(plateNumber);
    return vehicleBadges.find(badge =>
      badge.license_plate_sheet && normalizePlate(badge.license_plate_sheet) === normalizedPlate
    );
  }, [registeredPlateNumber, entryPlateNumber, selectedVehicle, vehicleBadges]);

  const getDocumentStatus = (expiryDate?: string): { status: DocumentStatus; daysRemaining?: number } => {
    if (!expiryDate) return { status: 'missing' };
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const expiry = new Date(expiryDate);
    expiry.setHours(0, 0, 0, 0);
    const diffTime = expiry.getTime() - today.getTime();
    const daysRemaining = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (daysRemaining < 0) return { status: 'expired', daysRemaining };
    if (daysRemaining <= 30) return { status: 'expiring_soon', daysRemaining };
    return { status: 'valid', daysRemaining };
  };

  const getDocumentsCheckResults = useCallback((): DocumentCheckResult[] => {
    const matchingBadge = getMatchingBadge();
    const results: DocumentCheckResult[] = [];

    if (matchingBadge) {
      const { status, daysRemaining } = getDocumentStatus(matchingBadge.expiry_date);
      results.push({ name: 'Phù hiệu xe', status, expiryDate: matchingBadge.expiry_date, daysRemaining });
    } else {
      results.push({ name: 'Phù hiệu xe', status: 'valid', expiryDate: undefined, daysRemaining: 999 });
    }

    results.push({ name: 'Đăng ký xe', status: 'valid', expiryDate: undefined, daysRemaining: 999 });
    results.push({ name: 'Đăng kiểm xe', status: 'valid', expiryDate: undefined, daysRemaining: 999 });
    results.push({ name: 'Bảo hiểm xe', status: 'valid', expiryDate: undefined, daysRemaining: 999 });

    return results;
  }, [getMatchingBadge]);

  const checkAllDocumentsValid = useCallback((): boolean => {
    const results = getDocumentsCheckResults();
    return results.every(r => r.status === 'valid' || r.status === 'expiring_soon');
  }, [getDocumentsCheckResults]);

  const getOverallStatus = useCallback((): { isValid: boolean; validCount: number; totalCount: number } => {
    const results = getDocumentsCheckResults();
    const validCount = results.filter(r => r.status === 'valid' || r.status === 'expiring_soon').length;
    return { isValid: validCount === results.length, validCount, totalCount: results.length };
  }, [getDocumentsCheckResults]);

  const submitPermit = useCallback(async () => {
    setIsLoading(true);
    try {
      const plannedDepartureTime = departureTime
        ? new Date(`${departureDate}T${departureTime}`).toISOString()
        : record.plannedDepartureTime || new Date().toISOString();

      const permitShiftId = getShiftIdFromCurrentShift();

      await dispatchService.issuePermit(record.id, {
        transportOrderCode,
        plannedDepartureTime,
        seatCount: parseInt(seatCount),
        permitStatus: "approved",
        routeId: routeId || undefined,
        scheduleId: scheduleId || undefined,
        replacementVehicleId: replacementVehicleId || undefined,
        permitShiftId,
      });

      toast.success("Cấp phép lên nốt thành công!");
      onSuccess?.();
      onClose();
    } catch (error: unknown) {
      console.error("Failed to issue permit:", error);
      const axiosError = error as { response?: { data?: { code?: string; error?: string } } };
      const errorData = axiosError.response?.data;
      if (errorData?.code === '23505' || errorData?.error?.includes('đã tồn tại') || errorData?.error?.includes('duplicate key')) {
        toast.error(`Mã lệnh vận chuyển "${transportOrderCode}" đã tồn tại. Vui lòng chọn mã khác.`);
      } else {
        toast.error(errorData?.error || "Không thể cấp phép. Vui lòng thử lại sau.");
      }
    } finally {
      setIsLoading(false);
    }
  }, [departureTime, departureDate, record, transportOrderCode, seatCount, routeId, scheduleId, replacementVehicleId, getShiftIdFromCurrentShift, onSuccess, onClose]);

  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
  const [hasAttemptedSubmit, setHasAttemptedSubmit] = useState(false);

  const validatePermitFields = useCallback((): { isValid: boolean; errors: string[]; fieldErrors: Record<string, string> } => {
    const errors: string[] = [];
    const fieldErrors: Record<string, string> = {};
    
    if (!transportOrderCode?.trim()) {
      errors.push("Mã lệnh vận chuyển");
      fieldErrors.transportOrderCode = "Vui lòng nhập mã lệnh vận chuyển";
    }
    if (!routeId) {
      errors.push("Tuyến đường");
      fieldErrors.routeId = "Vui lòng chọn tuyến đường";
    }
    if (!departureDate) {
      errors.push("Ngày xuất bến");
      fieldErrors.departureDate = "Vui lòng chọn ngày xuất bến";
    }
    if (!scheduleId && !departureTime) {
      errors.push("Biểu đồ giờ hoặc Giờ xuất bến");
      fieldErrors.departureTime = "Vui lòng chọn biểu đồ giờ hoặc nhập giờ xuất bến";
    }
    if (!seatCount || parseInt(seatCount) <= 0) {
      errors.push("Số ghế (phải lớn hơn 0)");
      fieldErrors.seatCount = "Số ghế phải lớn hơn 0";
    }
    
    return { isValid: errors.length === 0, errors, fieldErrors };
  }, [transportOrderCode, routeId, departureDate, scheduleId, departureTime, seatCount]);

  const handleEligible = useCallback(async () => {
    setHasAttemptedSubmit(true);
    const { isValid, errors, fieldErrors } = validatePermitFields();
    setValidationErrors(fieldErrors);
    
    if (!isValid) {
      const errorMessage = errors.length === 1
        ? `Vui lòng điền: ${errors[0]}`
        : `Vui lòng điền các trường sau:\n• ${errors.join("\n• ")}`;
      toast.error(errorMessage, {
        autoClose: 5000,
        style: { whiteSpace: 'pre-line' }
      });
      return;
    }
    
    if (totalAmount === 0) {
      setShowZeroAmountConfirm(true);
      return;
    }
    await submitPermit();
  }, [validatePermitFields, totalAmount, submitPermit]);

  // Clear validation error when field value changes
  useEffect(() => {
    if (hasAttemptedSubmit) {
      const { fieldErrors } = validatePermitFields();
      setValidationErrors(fieldErrors);
    }
  }, [transportOrderCode, routeId, departureDate, scheduleId, departureTime, seatCount, hasAttemptedSubmit, validatePermitFields]);

  const handleNotEligibleConfirm = useCallback(async (
    selectedReasons: string[],
    _options: { createOrder: boolean; signAndTransmit: boolean; printDisplay: boolean }
  ) => {
    setIsLoading(true);
    try {
      const reasonDescriptions: Record<string, string> = {
        driver_license_insufficient: "Không có hoặc có nhưng không đủ số lượng giấy phép lái xe so với số lái xe ghi trên lệnh vận chuyển",
        driver_license_expired: "Giấy phép lái xe đã hết hạn hoặc sử dụng giấy phép lái xe giả",
        driver_license_class_mismatch: "Hạng giấy phép lái xe không phù hợp với các loại xe được phép điều khiển",
        driver_info_mismatch: "Thông tin của lái xe không đúng với thông tin được ghi trên lệnh vận chuyển",
        driver_alcohol: "Lái xe sử dụng rượu bia",
        driver_drugs: "Lái xe sử dụng chất ma tuý",
      };

      const rejectionReason = selectedReasons.map((id) => reasonDescriptions[id] || id).join("; ");
      const plannedDepartureTime = departureTime && departureDate
        ? new Date(`${departureDate}T${departureTime}`).toISOString()
        : record.plannedDepartureTime || new Date().toISOString();

      const permitShiftId = getShiftIdFromCurrentShift();

      await dispatchService.issuePermit(record.id, {
        transportOrderCode: transportOrderCode || undefined,
        plannedDepartureTime,
        seatCount: parseInt(seatCount) || 0,
        permitStatus: "rejected",
        rejectionReason,
        routeId: routeId || undefined,
        scheduleId: scheduleId || undefined,
        replacementVehicleId: replacementVehicleId || undefined,
        permitShiftId,
      });

      toast.success("Cấp phép thành công!");
      onSuccess?.();
      onClose();
    } catch (error: unknown) {
      console.error("Failed to issue permit:", error);
      const axiosError = error as { response?: { data?: { code?: string; error?: string } } };
      const errorData = axiosError.response?.data;
      if (errorData?.code === '23505' || errorData?.error?.includes('đã tồn tại') || errorData?.error?.includes('duplicate key')) {
        toast.error(`Mã lệnh vận chuyển "${transportOrderCode}" đã tồn tại. Vui lòng chọn mã khác.`);
      } else {
        toast.error(errorData?.error || "Không thể cấp phép. Vui lòng thử lại sau.");
      }
    } finally {
      setIsLoading(false);
    }
  }, [departureTime, departureDate, record, transportOrderCode, seatCount, routeId, scheduleId, replacementVehicleId, getShiftIdFromCurrentShift, onSuccess, onClose]);

  const handleDocumentDialogSuccess = useCallback(() => {
    if (record.vehicleId) loadInitialData();
  }, [record.vehicleId, loadInitialData]);

  const handleAddServiceSuccess = useCallback(() => {
    if (record.id) {
      serviceChargeService.getAll(record.id).then(setServiceCharges);
      loadDailyTripCounts();
    }
  }, [record.id, loadDailyTripCounts]);

  const handleAddDriverSuccess = useCallback((driver: Driver) => {
    if (!drivers.find((d) => d.id === driver.id)) {
      setDrivers([...drivers, driver]);
    }
  }, [drivers]);

  // Effects
  useEffect(() => {
    const init = async () => {
      setIsInitialLoading(true);
      await loadInitialData();
      setIsInitialLoading(false);
    };
    init();
    const { shifts: currentShifts, loadShifts } = useUIStore.getState();
    if (currentShifts.length === 0) loadShifts();
  }, [loadInitialData]);

  useEffect(() => {
    if (routeId) loadSchedules(routeId);
  }, [routeId, loadSchedules]);

  useEffect(() => {
    calculateTotal();
  }, [calculateTotal]);

  useEffect(() => {
    if (departureDate && !tripCountsLoaded) {
      loadDailyTripCounts();
      setTripCountsLoaded(true);
    }
  }, [departureDate, tripCountsLoaded, loadDailyTripCounts]);

  useEffect(() => {
    if (selectedVehicle) {
      if ((!record.seatCount || record.seatCount === 0) && selectedVehicle.seatCapacity) {
        setSeatCount(selectedVehicle.seatCapacity.toString());
      } else if (record.seatCount && record.seatCount > 0) {
        setSeatCount(record.seatCount.toString());
      }
      if (selectedVehicle.bedCapacity !== undefined && selectedVehicle.bedCapacity !== null) {
        setBedCount(selectedVehicle.bedCapacity.toString());
      }
      if (!registeredPlateNumber && selectedVehicle.plateNumber) setRegisteredPlateNumber(selectedVehicle.plateNumber);
      if (!entryPlateNumber && selectedVehicle.plateNumber) setEntryPlateNumber(selectedVehicle.plateNumber);
    }
  }, [selectedVehicle, record.seatCount, entryPlateNumber, registeredPlateNumber]);

  useEffect(() => {
    const plateNumber = registeredPlateNumber || entryPlateNumber;
    if (!plateNumber || vehicles.length === 0) return;
    const normalizedPlate = plateNumber.replace(/[.\-\s]/g, '').toUpperCase();
    const matchedVehicle = vehicles.find(v => v.plateNumber && v.plateNumber.replace(/[.\-\s]/g, '').toUpperCase() === normalizedPlate);
    if (matchedVehicle && matchedVehicle.id !== selectedVehicle?.id) {
      setSelectedVehicle(matchedVehicle);
      if (matchedVehicle.operatorId && !selectedOperatorId) setSelectedOperatorId(matchedVehicle.operatorId);
      if (matchedVehicle.operatorName) setOperatorNameFromVehicle(matchedVehicle.operatorName);
      else if (matchedVehicle.operator?.name) setOperatorNameFromVehicle(matchedVehicle.operator.name);
    }
  }, [registeredPlateNumber, entryPlateNumber, vehicles, selectedVehicle, selectedOperatorId]);

  // Compute busy vehicle plates from active dispatch records
  const busyVehiclePlates = useMemo(() => {
    if (!cachedDispatchRecords) return new Set<string>();
    const normalizeplate = (p: string) => p.replace(/[.\-\s]/g, '').toUpperCase();
    const busy = new Set<string>();
    for (const dr of cachedDispatchRecords) {
      // Xe đang bận = chưa xuất bến (departed) và chưa bị hủy (cancelled)
      if (dr.currentStatus !== 'departed' && dr.currentStatus !== 'cancelled' && dr.vehiclePlateNumber) {
        busy.add(normalizeplate(dr.vehiclePlateNumber));
      }
    }
    return busy;
  }, [cachedDispatchRecords]);

  // Vehicles with availability status for replacement vehicle dropdown
  const vehiclesWithStatus = useMemo(() => {
    const normalizeplate = (p: string) => p.replace(/[.\-\s]/g, '').toUpperCase();
    return vehicles.map(v => ({
      ...v,
      isBusy: v.plateNumber ? busyVehiclePlates.has(normalizeplate(v.plateNumber)) : false
    }));
  }, [vehicles, busyVehiclePlates]);

  return {
    // State
    permitType, setPermitType,
    transportOrderCode, setTransportOrderCode,
    replacementVehicleId, setReplacementVehicleId,
    seatCount, setSeatCount,
    bedCount, setBedCount,
    hhTicketCount, setHhTicketCount,
    hhPercentage, setHhPercentage,
    entryPlateNumber, setEntryPlateNumber,
    registeredPlateNumber, setRegisteredPlateNumber,
    routeId, setRouteId,
    scheduleId, setScheduleId,
    departureTime, setDepartureTime,
    departureDate, setDepartureDate,
    routes, schedules, vehicleBadges, vehicles, vehiclesWithStatus, drivers, serviceCharges,
    selectedVehicle, operators, selectedOperatorId, setSelectedOperatorId,
    operatorNameFromVehicle, totalAmount, isLoading, isInitialLoading,
    serviceDetailsExpanded, setServiceDetailsExpanded,
    showZeroAmountConfirm, setShowZeroAmountConfirm,
    dailyTripCounts,
    validationErrors,
    // Methods
    submitPermit, handleEligible, handleNotEligibleConfirm,
    handleDocumentDialogSuccess, handleAddServiceSuccess, handleAddDriverSuccess,
    getDocumentsCheckResults, checkAllDocumentsValid, getOverallStatus,
  };
}
</file>

<file path="client/src/pages/QuanLyPhuHieuXe.tsx">
import { useState, useEffect, useRef } from "react"
import { toast } from "react-toastify"
import { Search, Eye, Download, Plus, Edit, Trash2, Upload, FileSpreadsheet } from "lucide-react"
import * as XLSX from "xlsx"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent } from "@/components/ui/card"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { StatusBadge } from "@/components/layout/StatusBadge"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Select } from "@/components/ui/select"
import { vehicleBadgeService, type VehicleBadge, type CreateVehicleBadgeInput } from "@/services/vehicle-badge.service"
import { quanlyDataService } from "@/services/quanly-data.service"
import { useUIStore } from "@/store/ui.store"

// Helper function to format date
const formatDate = (dateString: string | undefined | null): string => {
  if (!dateString) return "N/A"
  // Handle DD/MM/YYYY format
  if (dateString.includes("/")) {
    return dateString
  }
  // Try to parse ISO date
  try {
    const date = new Date(dateString)
    if (isNaN(date.getTime())) return "N/A"
    return date.toLocaleDateString("vi-VN")
  } catch {
    return dateString
  }
}

// Helper function to get status badge variant based on Vietnamese status text
const getStatusVariant = (status: string): "active" | "inactive" | "maintenance" => {
  if (!status) return "inactive"
  const statusLower = status.toLowerCase()
  // "Còn hiệu lực", "Cấp mới" etc. are active
  if (statusLower.includes("hiệu lực") || statusLower.includes("cấp mới") || statusLower.includes("cap moi")) {
    return "active"
  }
  // "Hết hạn" is expired/inactive
  if (statusLower.includes("hết") || statusLower.includes("het")) {
    return "inactive"
  }
  // "Thu hồi" is revoked/maintenance
  if (statusLower.includes("thu hồi") || statusLower.includes("thu hoi")) {
    return "maintenance"
  }
  return "active" // Default to active for other statuses
}

export default function QuanLyPhuHieuXe() {
  const [badges, setBadges] = useState<VehicleBadge[]>([])
  const [searchQuery, setSearchQuery] = useState("")
  const [filterStatus, setFilterStatus] = useState("")
  const [filterBadgeType, setFilterBadgeType] = useState("")
  const [filterBadgeColor, setFilterBadgeColor] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedBadge, setSelectedBadge] = useState<VehicleBadge | null>(null)
  const [viewDialogOpen, setViewDialogOpen] = useState(false)
  const [formDialogOpen, setFormDialogOpen] = useState(false)
  const [formMode, setFormMode] = useState<"create" | "edit">("create")
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const [badgeToDelete, setBadgeToDelete] = useState<VehicleBadge | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [importDialogOpen, setImportDialogOpen] = useState(false)
  const [importData, setImportData] = useState<CreateVehicleBadgeInput[]>([])
  const [isImporting, setIsImporting] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [formData, setFormData] = useState<CreateVehicleBadgeInput>({
    badge_number: "",
    license_plate_sheet: "",
    badge_type: "",
    badge_color: "",
    issue_date: "",
    expiry_date: "",
    status: "Còn hiệu lực",
    file_code: "",
    issue_type: "Cấp mới",
    bus_route_ref: "",
    vehicle_type: "",
    notes: "",
  })
  const [currentPage, setCurrentPage] = useState(1)
  const itemsPerPage = 10
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý phù hiệu xe")
    loadBadges()
  }, [setTitle])

  const loadBadges = async (forceRefresh = false) => {
    setIsLoading(true)
    try {
      // Use optimized unified endpoint for faster loading
      const data = await quanlyDataService.getBadges(forceRefresh)
      // Convert to VehicleBadge format
      const badgeData: VehicleBadge[] = data.map(b => ({
        ...b,
        vehicle_id: b.license_plate_sheet,
        operational_status: 'trong_ben' as const,
        // Add missing optional fields with defaults
        bus_route_ref: '',
        business_license_ref: '',
        created_at: '',
        created_by: '',
        email_notification_sent: false,
        notes: '',
        notification_ref: '',
        previous_badge_number: '',
        renewal_due_date: '',
        renewal_reason: '',
        renewal_reminder_shown: false,
        replacement_vehicle_id: '',
        revocation_date: '',
        revocation_decision: '',
        revocation_reason: '',
        warn_duplicate_plate: false,
      } as VehicleBadge))
      setBadges(badgeData)
    } catch (error) {
      console.error("Failed to load vehicle badges:", error)
      toast.error("Không thể tải danh sách phù hiệu xe. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  // Get unique values for filters - only from allowed badge types
  const allowedTypesForFilters = ["Buýt", "Tuyến cố định"]
  const filteredByTypeOnly = badges.filter(b => allowedTypesForFilters.includes(b.badge_type || ""))
  const badgeStatuses = Array.from(new Set(filteredByTypeOnly.map((b) => b.status).filter(Boolean))).sort()
  const badgeTypes = allowedTypesForFilters // Only show allowed types in dropdown
  const badgeColors = Array.from(new Set(filteredByTypeOnly.map((b) => b.badge_color).filter(Boolean))).sort()

  // Only show "Buýt" and "Tuyến cố định" badge types
  const allowedBadgeTypes = ["Buýt", "Tuyến cố định"]
  
  const filteredBadges = badges.filter((badge) => {
    // Filter by allowed badge types (Buýt and Tuyến cố định only)
    if (!allowedBadgeTypes.includes(badge.badge_type || "")) {
      return false
    }
    
    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      const matchesSearch =
        badge.badge_number.toLowerCase().includes(query) ||
        badge.license_plate_sheet.toLowerCase().includes(query) ||
        badge.file_code.toLowerCase().includes(query) ||
        (badge.vehicle_id && badge.vehicle_id.toLowerCase().includes(query))
      if (!matchesSearch) return false
    }

    // Status filter (based on status: active/expired/revoked)
    if (filterStatus && badge.status !== filterStatus) {
      return false
    }

    // Badge type filter
    if (filterBadgeType && badge.badge_type !== filterBadgeType) {
      return false
    }

    // Badge color filter
    if (filterBadgeColor && badge.badge_color !== filterBadgeColor) {
      return false
    }

    return true
  })

  // Pagination calculations
  const totalPages = Math.ceil(filteredBadges.length / itemsPerPage)
  const startIndex = (currentPage - 1) * itemsPerPage
  const endIndex = startIndex + itemsPerPage
  const paginatedBadges = filteredBadges.slice(startIndex, endIndex)

  // Reset to page 1 when filters change
  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, filterStatus, filterBadgeType, filterBadgeColor])

  const handleView = (badge: VehicleBadge) => {
    setSelectedBadge(badge)
    setViewDialogOpen(true)
  }

  const handleCreate = () => {
    setFormMode("create")
    setFormData({
      badge_number: "",
      license_plate_sheet: "",
      badge_type: "",
      badge_color: "",
      issue_date: "",
      expiry_date: "",
      status: "Còn hiệu lực",
      file_code: "",
      issue_type: "Cấp mới",
      bus_route_ref: "",
      vehicle_type: "",
      notes: "",
    })
    setFormDialogOpen(true)
  }

  const handleEdit = (badge: VehicleBadge) => {
    setFormMode("edit")
    setSelectedBadge(badge)
    setFormData({
      badge_number: badge.badge_number,
      license_plate_sheet: badge.license_plate_sheet,
      badge_type: badge.badge_type || "",
      badge_color: badge.badge_color || "",
      issue_date: badge.issue_date || "",
      expiry_date: badge.expiry_date || "",
      status: badge.status || "Còn hiệu lực",
      file_code: badge.file_code || "",
      issue_type: badge.issue_type || "Cấp mới",
      bus_route_ref: badge.bus_route_ref || "",
      vehicle_type: badge.vehicle_type || "",
      notes: badge.notes || "",
    })
    setFormDialogOpen(true)
  }

  const handleDelete = (badge: VehicleBadge) => {
    setBadgeToDelete(badge)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = async () => {
    if (!badgeToDelete) return

    try {
      await vehicleBadgeService.delete(badgeToDelete.id)
      toast.success("Xóa phù hiệu thành công")
      loadBadges(true)
      setDeleteDialogOpen(false)
      setBadgeToDelete(null)
    } catch (error) {
      console.error("Failed to delete badge:", error)
      toast.error("Không thể xóa phù hiệu. Vui lòng thử lại sau.")
    }
  }

  const handleFormSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.badge_number || !formData.license_plate_sheet) {
      toast.error("Vui lòng nhập số phù hiệu và biển số xe")
      return
    }

    setIsSubmitting(true)
    try {
      if (formMode === "create") {
        await vehicleBadgeService.create(formData)
        toast.success("Thêm phù hiệu mới thành công")
      } else {
        if (!selectedBadge) return
        await vehicleBadgeService.update(selectedBadge.id, formData)
        toast.success("Cập nhật phù hiệu thành công")
      }
      setFormDialogOpen(false)
      loadBadges(true)
    } catch (error: any) {
      console.error("Failed to save badge:", error)
      const errorMessage = error.response?.data?.error || "Không thể lưu phù hiệu. Vui lòng thử lại sau."
      toast.error(errorMessage)
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (event) => {
      try {
        const data = event.target?.result
        const workbook = XLSX.read(data, { type: "binary" })
        const sheetName = workbook.SheetNames[0]
        const worksheet = workbook.Sheets[sheetName]
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }) as string[][]

        if (jsonData.length < 2) {
          toast.error("File Excel không có dữ liệu")
          return
        }

        // Get headers from first row
        const headers = jsonData[0].map((h) => h?.toString().toLowerCase().trim() || "")
        
        // Map Vietnamese headers to field names
        const headerMap: Record<string, string> = {
          "số phù hiệu": "badge_number",
          "so phu hieu": "badge_number",
          "biển số xe": "license_plate_sheet",
          "bien so xe": "license_plate_sheet",
          "biển số": "license_plate_sheet",
          "bien so": "license_plate_sheet",
          "loại phù hiệu": "badge_type",
          "loai phu hieu": "badge_type",
          "màu phù hiệu": "badge_color",
          "mau phu hieu": "badge_color",
          "màu": "badge_color",
          "mau": "badge_color",
          "ngày cấp": "issue_date",
          "ngay cap": "issue_date",
          "ngày hết hạn": "expiry_date",
          "ngay het han": "expiry_date",
          "trạng thái": "status",
          "trang thai": "status",
          "mã hồ sơ": "file_code",
          "ma ho so": "file_code",
          "loại cấp": "issue_type",
          "loai cap": "issue_type",
          "tuyến đường": "bus_route_ref",
          "tuyen duong": "bus_route_ref",
          "loại xe": "vehicle_type",
          "loai xe": "vehicle_type",
          "ghi chú": "notes",
          "ghi chu": "notes",
        }

        // Find column indices
        const columnMap: Record<string, number> = {}
        headers.forEach((header, index) => {
          const fieldName = headerMap[header]
          if (fieldName) {
            columnMap[fieldName] = index
          }
        })

        // Check required columns
        if (columnMap["badge_number"] === undefined || columnMap["license_plate_sheet"] === undefined) {
          toast.error("File Excel phải có cột 'Số phù hiệu' và 'Biển số xe'")
          return
        }

        // Parse data rows
        const parsedData: CreateVehicleBadgeInput[] = []
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i]
          if (!row || row.length === 0) continue

          const badgeNumber = row[columnMap["badge_number"]]?.toString().trim()
          const plateNumber = row[columnMap["license_plate_sheet"]]?.toString().trim()

          if (!badgeNumber || !plateNumber) continue

          parsedData.push({
            badge_number: badgeNumber,
            license_plate_sheet: plateNumber,
            badge_type: columnMap["badge_type"] !== undefined ? row[columnMap["badge_type"]]?.toString().trim() || "" : "",
            badge_color: columnMap["badge_color"] !== undefined ? row[columnMap["badge_color"]]?.toString().trim() || "" : "",
            issue_date: columnMap["issue_date"] !== undefined ? row[columnMap["issue_date"]]?.toString().trim() || "" : "",
            expiry_date: columnMap["expiry_date"] !== undefined ? row[columnMap["expiry_date"]]?.toString().trim() || "" : "",
            status: columnMap["status"] !== undefined ? row[columnMap["status"]]?.toString().trim() || "Còn hiệu lực" : "Còn hiệu lực",
            file_code: columnMap["file_code"] !== undefined ? row[columnMap["file_code"]]?.toString().trim() || "" : "",
            issue_type: columnMap["issue_type"] !== undefined ? row[columnMap["issue_type"]]?.toString().trim() || "Cấp mới" : "Cấp mới",
            bus_route_ref: columnMap["bus_route_ref"] !== undefined ? row[columnMap["bus_route_ref"]]?.toString().trim() || "" : "",
            vehicle_type: columnMap["vehicle_type"] !== undefined ? row[columnMap["vehicle_type"]]?.toString().trim() || "" : "",
            notes: columnMap["notes"] !== undefined ? row[columnMap["notes"]]?.toString().trim() || "" : "",
          })
        }

        if (parsedData.length === 0) {
          toast.error("Không tìm thấy dữ liệu hợp lệ trong file")
          return
        }

        setImportData(parsedData)
        setImportDialogOpen(true)
      } catch (error) {
        console.error("Failed to parse Excel file:", error)
        toast.error("Không thể đọc file Excel. Vui lòng kiểm tra định dạng file.")
      }
    }
    reader.readAsBinaryString(file)
    
    // Reset input
    if (fileInputRef.current) {
      fileInputRef.current.value = ""
    }
  }

  const handleImportConfirm = async () => {
    if (importData.length === 0) return

    setIsImporting(true)
    let successCount = 0
    let errorCount = 0
    const errors: string[] = []

    for (const badge of importData) {
      try {
        await vehicleBadgeService.create(badge)
        successCount++
      } catch (error: any) {
        errorCount++
        const errorMsg = error.response?.data?.error || "Lỗi không xác định"
        errors.push(`${badge.badge_number}: ${errorMsg}`)
      }
    }

    setIsImporting(false)
    setImportDialogOpen(false)
    setImportData([])

    if (successCount > 0) {
      toast.success(`Đã import thành công ${successCount} phù hiệu`)
      loadBadges(true)
    }
    if (errorCount > 0) {
      toast.error(`Có ${errorCount} phù hiệu không thể import`)
      console.error("Import errors:", errors)
    }
  }

  const downloadTemplate = () => {
    const templateData = [
      ["Số phù hiệu", "Biển số xe", "Loại phù hiệu", "Màu phù hiệu", "Ngày cấp", "Ngày hết hạn", "Trạng thái", "Mã hồ sơ", "Loại cấp", "Tuyến đường", "Loại xe", "Ghi chú"],
      ["PH001", "51B-12345", "Xe khách cố định", "Xanh", "01/01/2024", "01/01/2029", "Còn hiệu lực", "HS001", "Cấp mới", "Sài Gòn - Nha Trang", "Xe khách 45 chỗ", "Ghi chú mẫu"],
    ]
    
    const ws = XLSX.utils.aoa_to_sheet(templateData)
    const wb = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(wb, ws, "Template")
    
    // Set column widths
    ws["!cols"] = [
      { wch: 15 }, // Số phù hiệu
      { wch: 15 }, // Biển số xe
      { wch: 18 }, // Loại phù hiệu
      { wch: 15 }, // Màu phù hiệu
      { wch: 12 }, // Ngày cấp
      { wch: 15 }, // Ngày hết hạn
      { wch: 15 }, // Trạng thái
      { wch: 12 }, // Mã hồ sơ
      { wch: 12 }, // Loại cấp
      { wch: 25 }, // Tuyến đường
      { wch: 20 }, // Loại xe
      { wch: 20 }, // Ghi chú
    ]
    
    XLSX.writeFile(wb, "template-phu-hieu-xe.xlsx")
    toast.success("Đã tải template Excel")
  }

  const handleExport = () => {
    // Convert data to CSV
    const headers = [
      "Số phù hiệu",
      "Biển số xe",
      "Loại phù hiệu",
      "Màu phù hiệu",
      "Ngày cấp",
      "Ngày hết hạn",
      "Trạng thái",
      "Mã hồ sơ",
      "Loại cấp",
      "Ghi chú",
    ]

    const rows = filteredBadges.map((badge) => [
      badge.badge_number,
      badge.license_plate_sheet,
      badge.badge_type,
      badge.badge_color,
      badge.issue_date,
      badge.expiry_date,
      badge.status || "",
      badge.file_code,
      badge.issue_type,
      badge.notes || "",
    ])

    const csvContent = [
      headers.join(","),
      ...rows.map((row) => row.map((cell) => `"${cell}"`).join(",")),
    ].join("\n")

    // Create blob and download
    const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" })
    const link = document.createElement("a")
    const url = URL.createObjectURL(blob)
    link.setAttribute("href", url)
    link.setAttribute("download", `phu-hieu-xe-${new Date().toISOString().split("T")[0]}.csv`)
    link.style.visibility = "hidden"
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)

    toast.success("Xuất dữ liệu thành công")
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Quản lý phù hiệu xe</h1>
        <div className="flex gap-2">
          <Button onClick={handleCreate}>
            <Plus className="mr-2 h-4 w-4" />
            Thêm phù hiệu
          </Button>
          <Button variant="outline" onClick={() => fileInputRef.current?.click()}>
            <Upload className="mr-2 h-4 w-4" />
            Import Excel
          </Button>
          <Button variant="outline" onClick={downloadTemplate}>
            <FileSpreadsheet className="mr-2 h-4 w-4" />
            Tải Template
          </Button>
          <Button variant="outline" onClick={handleExport}>
            <Download className="mr-2 h-4 w-4" />
            Xuất Excel
          </Button>
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileSelect}
            accept=".xlsx,.xls"
            className="hidden"
          />
        </div>
      </div>

      {/* Search and Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
              <Input
                placeholder="Tìm kiếm theo số phù hiệu, biển số, mã hồ sơ..."
                className="pl-10"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="space-y-2">
                <Label htmlFor="filterStatus" className="text-sm font-medium">
                  Lọc theo trạng thái
                </Label>
                <Select
                  id="filterStatus"
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                >
                  <option value="">Tất cả trạng thái</option>
                  {badgeStatuses.map((status) => (
                    <option key={status} value={status}>
                      {status}
                    </option>
                  ))}
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="filterBadgeType" className="text-sm font-medium">
                  Lọc theo loại phù hiệu
                </Label>
                <Select
                  id="filterBadgeType"
                  value={filterBadgeType}
                  onChange={(e) => setFilterBadgeType(e.target.value)}
                >
                  <option value="">Tất cả loại</option>
                  {badgeTypes.map((type) => (
                    <option key={type} value={type}>
                      {type}
                    </option>
                  ))}
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="filterBadgeColor" className="text-sm font-medium">
                  Lọc theo màu phù hiệu
                </Label>
                <Select
                  id="filterBadgeColor"
                  value={filterBadgeColor}
                  onChange={(e) => setFilterBadgeColor(e.target.value)}
                >
                  <option value="">Tất cả màu</option>
                  {badgeColors.map((color) => (
                    <option key={color} value={color}>
                      {color}
                    </option>
                  ))}
                </Select>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="text-center">Số phù hiệu</TableHead>
              <TableHead className="text-center">Biển số xe</TableHead>
              <TableHead className="text-center">Loại phù hiệu</TableHead>
              <TableHead className="text-center">Màu phù hiệu</TableHead>
              <TableHead className="text-center">Ngày cấp</TableHead>
              <TableHead className="text-center">Ngày hết hạn</TableHead>
              <TableHead className="text-center">Trạng thái</TableHead>
              <TableHead className="text-center">Mã hồ sơ</TableHead>
              <TableHead className="text-center">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={9} className="text-center py-8">
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : filteredBadges.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9} className="text-center py-8 text-gray-500">
                  Không có dữ liệu
                </TableCell>
              </TableRow>
            ) : (
              paginatedBadges.map((badge) => (
                <TableRow key={badge.id}>
                  <TableCell className="font-medium text-center">
                    {badge.badge_number}
                  </TableCell>
                  <TableCell className="text-center">
                    {badge.license_plate_sheet || "N/A"}
                  </TableCell>
                  <TableCell className="text-center">
                    {badge.badge_type || "N/A"}
                  </TableCell>
                  <TableCell className="text-center">
                    {badge.badge_color || "N/A"}
                  </TableCell>
                  <TableCell className="text-center">
                    {formatDate(badge.issue_date)}
                  </TableCell>
                  <TableCell className="text-center">
                    {formatDate(badge.expiry_date)}
                  </TableCell>
                  <TableCell className="text-center">
                    <StatusBadge
                      status={getStatusVariant(badge.status)}
                      label={badge.status || "N/A"}
                    />
                  </TableCell>
                  <TableCell className="text-center">
                    {badge.file_code || "N/A"}
                  </TableCell>
                  <TableCell className="text-center">
                    <div className="flex items-center justify-center gap-1">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleView(badge)}
                        aria-label="Xem chi tiết"
                      >
                        <Eye className="h-4 w-4" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleEdit(badge)}
                        aria-label="Sửa"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleDelete(badge)}
                        aria-label="Xóa"
                        className="text-red-600 hover:text-red-700"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </Card>

      {/* Pagination */}
      {filteredBadges.length > 0 && (
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div className="text-sm text-gray-600">
                Hiển thị {startIndex + 1} - {Math.min(endIndex, filteredBadges.length)} của {filteredBadges.length} phù hiệu
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
                  disabled={currentPage === 1}
                >
                  Trang trước
                </Button>
                <div className="flex items-center gap-1">
                  {Array.from({ length: totalPages }, (_, i) => i + 1)
                    .filter((page) => {
                      // Show first page, last page, current page, and pages around current
                      return (
                        page === 1 ||
                        page === totalPages ||
                        (page >= currentPage - 1 && page <= currentPage + 1)
                      )
                    })
                    .map((page, index, array) => (
                      <div key={page} className="flex items-center">
                        {index > 0 && array[index - 1] !== page - 1 && (
                          <span className="px-2 text-gray-400">...</span>
                        )}
                        <Button
                          variant={currentPage === page ? "default" : "outline"}
                          size="sm"
                          onClick={() => setCurrentPage(page)}
                          className="min-w-[40px]"
                        >
                          {page}
                        </Button>
                      </div>
                    ))}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setCurrentPage((prev) => Math.min(totalPages, prev + 1))}
                  disabled={currentPage === totalPages}
                >
                  Trang sau
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* View Detail Dialog */}
      <Dialog open={viewDialogOpen} onOpenChange={setViewDialogOpen}>
        <DialogContent className="max-w-4xl w-full max-h-[95vh] overflow-y-auto p-6">
          <DialogClose onClose={() => setViewDialogOpen(false)} />
          <DialogHeader>
            <DialogTitle className="text-2xl">Chi tiết phù hiệu xe</DialogTitle>
          </DialogHeader>
          {selectedBadge && (
            <div className="mt-4 space-y-6">
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Số phù hiệu</Label>
                  <p className="text-sm">{selectedBadge.badge_number || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Biển số xe</Label>
                  <p className="text-sm">{selectedBadge.license_plate_sheet || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Loại phù hiệu</Label>
                  <p className="text-sm">{selectedBadge.badge_type || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Màu phù hiệu</Label>
                  <p className="text-sm">{selectedBadge.badge_color || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Ngày cấp</Label>
                  <p className="text-sm">{formatDate(selectedBadge.issue_date)}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Ngày hết hạn</Label>
                  <p className="text-sm">{formatDate(selectedBadge.expiry_date)}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Trạng thái</Label>
                  <StatusBadge
                    status={getStatusVariant(selectedBadge.status)}
                    label={selectedBadge.status || "N/A"}
                  />
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Loại cấp</Label>
                  <p className="text-sm">{selectedBadge.issue_type || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">Mã hồ sơ</Label>
                  <p className="text-sm">{selectedBadge.file_code || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">ID Xe</Label>
                  <p className="text-sm">{selectedBadge.vehicle_id || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">ID Giấy phép kinh doanh</Label>
                  <p className="text-sm">{selectedBadge.business_license_ref || "N/A"}</p>
                </div>
                <div className="space-y-2">
                  <Label className="text-sm font-semibold">ID Tuyến</Label>
                  <p className="text-sm">{selectedBadge.route_id || "N/A"}</p>
                </div>
                {selectedBadge.previous_badge_number && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Số phù hiệu cũ</Label>
                    <p className="text-sm">{selectedBadge.previous_badge_number}</p>
                  </div>
                )}
                {selectedBadge.renewal_due_date && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Ngày đến hạn gia hạn</Label>
                    <p className="text-sm">{formatDate(selectedBadge.renewal_due_date)}</p>
                  </div>
                )}
                {selectedBadge.renewal_reason && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Lý do gia hạn</Label>
                    <p className="text-sm">{selectedBadge.renewal_reason}</p>
                  </div>
                )}
                {selectedBadge.revocation_date && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Ngày thu hồi</Label>
                    <p className="text-sm">{formatDate(selectedBadge.revocation_date)}</p>
                  </div>
                )}
                {selectedBadge.revocation_decision && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Quyết định thu hồi</Label>
                    <p className="text-sm">{selectedBadge.revocation_decision}</p>
                  </div>
                )}
                {selectedBadge.revocation_reason && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">Lý do thu hồi</Label>
                    <p className="text-sm">{selectedBadge.revocation_reason}</p>
                  </div>
                )}
                {selectedBadge.replacement_vehicle_id && (
                  <div className="space-y-2">
                    <Label className="text-sm font-semibold">ID Xe thay thế</Label>
                    <p className="text-sm">{selectedBadge.replacement_vehicle_id}</p>
                  </div>
                )}
                {selectedBadge.notes && (
                  <div className="space-y-2 col-span-2">
                    <Label className="text-sm font-semibold">Ghi chú</Label>
                    <p className="text-sm">{selectedBadge.notes}</p>
                  </div>
                )}
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Form Dialog (Create/Edit) */}
      <Dialog open={formDialogOpen} onOpenChange={setFormDialogOpen}>
        <DialogContent className="max-w-2xl w-full max-h-[95vh] overflow-y-auto p-6">
          <DialogClose onClose={() => setFormDialogOpen(false)} />
          <DialogHeader>
            <DialogTitle className="text-2xl">
              {formMode === "create" ? "Thêm phù hiệu mới" : "Chỉnh sửa phù hiệu"}
            </DialogTitle>
          </DialogHeader>
          <form onSubmit={handleFormSubmit} className="mt-4 space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="badge_number">Số phù hiệu *</Label>
                <Input
                  id="badge_number"
                  value={formData.badge_number}
                  onChange={(e) => setFormData({ ...formData, badge_number: e.target.value })}
                  placeholder="Nhập số phù hiệu"
                  required
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="license_plate_sheet">Biển số xe *</Label>
                <Input
                  id="license_plate_sheet"
                  value={formData.license_plate_sheet}
                  onChange={(e) => setFormData({ ...formData, license_plate_sheet: e.target.value })}
                  placeholder="VD: 51B-12345"
                  required
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="badge_type">Loại phù hiệu</Label>
                <Select
                  id="badge_type"
                  value={formData.badge_type}
                  onChange={(e) => setFormData({ ...formData, badge_type: e.target.value })}
                >
                  <option value="">Chọn loại phù hiệu</option>
                  {badgeTypes.map((type) => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                  <option value="Xe khách cố định">Xe khách cố định</option>
                  <option value="Xe hợp đồng">Xe hợp đồng</option>
                  <option value="Xe du lịch">Xe du lịch</option>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="badge_color">Màu phù hiệu</Label>
                <Select
                  id="badge_color"
                  value={formData.badge_color}
                  onChange={(e) => setFormData({ ...formData, badge_color: e.target.value })}
                >
                  <option value="">Chọn màu phù hiệu</option>
                  {badgeColors.map((color) => (
                    <option key={color} value={color}>{color}</option>
                  ))}
                  <option value="Xanh">Xanh</option>
                  <option value="Vàng">Vàng</option>
                  <option value="Đỏ">Đỏ</option>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="issue_date">Ngày cấp</Label>
                <Input
                  id="issue_date"
                  value={formData.issue_date}
                  onChange={(e) => setFormData({ ...formData, issue_date: e.target.value })}
                  placeholder="DD/MM/YYYY"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="expiry_date">Ngày hết hạn</Label>
                <Input
                  id="expiry_date"
                  value={formData.expiry_date}
                  onChange={(e) => setFormData({ ...formData, expiry_date: e.target.value })}
                  placeholder="DD/MM/YYYY"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="status">Trạng thái</Label>
                <Select
                  id="status"
                  value={formData.status}
                  onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                >
                  <option value="Còn hiệu lực">Còn hiệu lực</option>
                  <option value="Hết hạn">Hết hạn</option>
                  <option value="Thu hồi">Thu hồi</option>
                  <option value="Cấp mới">Cấp mới</option>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="issue_type">Loại cấp</Label>
                <Select
                  id="issue_type"
                  value={formData.issue_type}
                  onChange={(e) => setFormData({ ...formData, issue_type: e.target.value })}
                >
                  <option value="Cấp mới">Cấp mới</option>
                  <option value="Cấp đổi">Cấp đổi</option>
                  <option value="Cấp lại">Cấp lại</option>
                  <option value="Gia hạn">Gia hạn</option>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="file_code">Mã hồ sơ</Label>
                <Input
                  id="file_code"
                  value={formData.file_code}
                  onChange={(e) => setFormData({ ...formData, file_code: e.target.value })}
                  placeholder="Nhập mã hồ sơ"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="vehicle_type">Loại xe</Label>
                <Input
                  id="vehicle_type"
                  value={formData.vehicle_type}
                  onChange={(e) => setFormData({ ...formData, vehicle_type: e.target.value })}
                  placeholder="VD: Xe khách 45 chỗ"
                />
              </div>
              <div className="space-y-2 col-span-2">
                <Label htmlFor="bus_route_ref">Tuyến đường</Label>
                <Input
                  id="bus_route_ref"
                  value={formData.bus_route_ref}
                  onChange={(e) => setFormData({ ...formData, bus_route_ref: e.target.value })}
                  placeholder="VD: Sài Gòn - Nha Trang"
                />
              </div>
              <div className="space-y-2 col-span-2">
                <Label htmlFor="notes">Ghi chú</Label>
                <Input
                  id="notes"
                  value={formData.notes}
                  onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
                  placeholder="Nhập ghi chú (nếu có)"
                />
              </div>
            </div>
            <div className="flex justify-end gap-2 pt-4">
              <Button type="button" variant="outline" onClick={() => setFormDialogOpen(false)}>
                Hủy
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Đang lưu..." : formMode === "create" ? "Thêm mới" : "Cập nhật"}
              </Button>
            </div>
          </form>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <DialogContent className="max-w-md">
          <DialogClose onClose={() => setDeleteDialogOpen(false)} />
          <DialogHeader>
            <DialogTitle>Xác nhận xóa</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <p>Bạn có chắc chắn muốn xóa phù hiệu <strong>{badgeToDelete?.badge_number}</strong>?</p>
            <p className="text-sm text-gray-500 mt-2">Biển số xe: {badgeToDelete?.license_plate_sheet}</p>
          </div>
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={() => setDeleteDialogOpen(false)}>
              Hủy
            </Button>
            <Button variant="destructive" onClick={confirmDelete}>
              Xóa
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Import Preview Dialog */}
      <Dialog open={importDialogOpen} onOpenChange={setImportDialogOpen}>
        <DialogContent className="max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
          <DialogClose onClose={() => setImportDialogOpen(false)} />
          <DialogHeader>
            <DialogTitle className="text-xl">Xem trước dữ liệu import</DialogTitle>
          </DialogHeader>
          <div className="flex-1 overflow-auto">
            <p className="text-sm text-gray-600 mb-4">
              Tìm thấy <strong>{importData.length}</strong> phù hiệu sẽ được import. Vui lòng kiểm tra trước khi xác nhận.
            </p>
            <div className="border rounded-lg overflow-hidden">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="text-center w-12">STT</TableHead>
                    <TableHead className="text-center">Số phù hiệu</TableHead>
                    <TableHead className="text-center">Biển số xe</TableHead>
                    <TableHead className="text-center">Loại PH</TableHead>
                    <TableHead className="text-center">Màu PH</TableHead>
                    <TableHead className="text-center">Ngày cấp</TableHead>
                    <TableHead className="text-center">Ngày hết hạn</TableHead>
                    <TableHead className="text-center">Trạng thái</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {importData.slice(0, 100).map((badge, index) => (
                    <TableRow key={index}>
                      <TableCell className="text-center">{index + 1}</TableCell>
                      <TableCell className="text-center font-medium">{badge.badge_number}</TableCell>
                      <TableCell className="text-center">{badge.license_plate_sheet}</TableCell>
                      <TableCell className="text-center">{badge.badge_type || "-"}</TableCell>
                      <TableCell className="text-center">{badge.badge_color || "-"}</TableCell>
                      <TableCell className="text-center">{badge.issue_date || "-"}</TableCell>
                      <TableCell className="text-center">{badge.expiry_date || "-"}</TableCell>
                      <TableCell className="text-center">{badge.status || "-"}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
            {importData.length > 100 && (
              <p className="text-sm text-gray-500 mt-2 text-center">
                ...và {importData.length - 100} phù hiệu khác
              </p>
            )}
          </div>
          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button 
              variant="outline" 
              onClick={() => {
                setImportDialogOpen(false)
                setImportData([])
              }}
              disabled={isImporting}
            >
              Hủy
            </Button>
            <Button onClick={handleImportConfirm} disabled={isImporting}>
              {isImporting ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                  Đang import...
                </>
              ) : (
                <>
                  <Upload className="mr-2 h-4 w-4" />
                  Import {importData.length} phù hiệu
                </>
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="client/src/services/dispatch.service.ts">
import api from '@/lib/api'
import type { DispatchRecord, DispatchInput, DispatchStatus } from '@/types'

export const dispatchService = {
  getAll: async (
    status?: DispatchStatus,
    vehicleId?: string,
    driverId?: string,
    routeId?: string
  ): Promise<DispatchRecord[]> => {
    try {
      const params = new URLSearchParams()
      if (status) params.append('status', status)
      if (vehicleId) params.append('vehicleId', vehicleId)
      if (driverId) params.append('driverId', driverId)
      if (routeId) params.append('routeId', routeId)

      const queryString = params.toString()
      const url = queryString ? `/dispatch?${queryString}` : '/dispatch'
      const response = await api.get<DispatchRecord[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching dispatch records:', error)
      return []
    }
  },

  getById: async (id: string): Promise<DispatchRecord> => {
    const response = await api.get<DispatchRecord>(`/dispatch/${id}`)
    return response.data
  },

  create: async (input: DispatchInput): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>('/dispatch', input)
    return response.data
  },

  recordPassengerDrop: async (
    id: string,
    passengersArrived: number,
    routeId?: string
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/passenger-drop`, {
      passengersArrived,
      routeId,
    })
    return response.data
  },

  issuePermit: async (
    id: string,
    data: {
      transportOrderCode?: string
      plannedDepartureTime: string
      seatCount: number
      permitStatus?: 'approved' | 'rejected'
      rejectionReason?: string
      routeId?: string
      scheduleId?: string
      replacementVehicleId?: string
      permitShiftId?: string
    }
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/permit`, data)
    return response.data
  },

  processPayment: async (
    id: string,
    data: {
      paymentAmount: number
      paymentMethod?: 'cash' | 'bank_transfer' | 'card'
      invoiceNumber?: string
      paymentShiftId?: string
    }
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/payment`, data)
    return response.data
  },

  issueDepartureOrder: async (
    id: string,
    passengersDeparting: number,
    departureOrderShiftId?: string
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/departure-order`, {
      passengersDeparting,
      departureOrderShiftId,
    })
    return response.data
  },

  recordExit: async (
    id: string,
    exitTime?: string,
    passengersDeparting?: number,
    exitShiftId?: string
  ): Promise<DispatchRecord> => {
    const response = await api.post<DispatchRecord>(`/dispatch/${id}/exit`, {
      exitTime,
      passengersDeparting,
      exitShiftId,
    })
    return response.data
  },

  updateEntryImage: async (id: string, entryImageUrl: string): Promise<DispatchRecord> => {
    const response = await api.patch<{ dispatch: DispatchRecord }>(`/dispatch/${id}/entry-image`, {
      entryImageUrl,
    })
    return response.data.dispatch
  },

  // Legacy methods for backward compatibility
  updateStatus: async (
    id: string,
    status: DispatchStatus,
    data?: Partial<DispatchRecord>
  ): Promise<DispatchRecord> => {
    if (status === 'permit_issued') {
      return dispatchService.issuePermit(id, {
        transportOrderCode: data?.transportOrderCode || '',
        plannedDepartureTime: data?.plannedDepartureTime || new Date().toISOString(),
        seatCount: data?.seatCount || 0,
      })
    }
    if (status === 'paid') {
      return dispatchService.processPayment(id, {
        paymentAmount: data?.paymentAmount || 0,
      })
    }
    if (status === 'departed') {
      return dispatchService.recordExit(id)
    }
    throw new Error('Legacy updateStatus is deprecated. Use specific workflow methods.')
  },

  depart: async (
    id: string,
    _exitTime: string,
    passengerCount: number
  ): Promise<DispatchRecord> => {
    await dispatchService.issueDepartureOrder(id, passengerCount)
    return dispatchService.recordExit(id)
  },

  update: async (
    id: string,
    data: {
      vehicleId?: string
      driverId?: string
      routeId?: string
      entryTime?: string
      notes?: string
    }
  ): Promise<DispatchRecord> => {
    const response = await api.put<DispatchRecord>(`/dispatch/${id}`, data)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/dispatch/${id}`)
  },

  cancel: async (id: string, reason?: string): Promise<DispatchRecord> => {
    const response = await api.post<{ dispatch: DispatchRecord }>(`/dispatch/${id}/cancel`, { reason })
    return response.data.dispatch
  },
}
</file>

<file path="client/src/services/vehicle.service.ts">
import api from '@/lib/api'
import type { Vehicle, VehicleInput } from '@/types'

export const vehicleService = {
  getAll: async (operatorId?: string, isActive?: boolean, includeLegacy?: boolean): Promise<Vehicle[]> => {
    try {
      const params = new URLSearchParams()
      if (operatorId) params.append('operatorId', operatorId)
      if (isActive !== undefined) params.append('isActive', String(isActive))
      if (includeLegacy !== undefined) params.append('includeLegacy', String(includeLegacy))

      const queryString = params.toString()
      const url = queryString ? `/vehicles?${queryString}` : '/vehicles'

      const response = await api.get<Vehicle[]>(url)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicles:', error)
      return []
    }
  },

  getById: async (id: string): Promise<Vehicle> => {
    const response = await api.get<Vehicle>(`/vehicles/${id}`)
    return response.data
  },

  create: async (input: VehicleInput): Promise<Vehicle> => {
    const response = await api.post<Vehicle>('/vehicles', input)
    return response.data
  },

  update: async (id: string, input: Partial<VehicleInput>): Promise<Vehicle> => {
    const response = await api.put<Vehicle>(`/vehicles/${id}`, input)
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/vehicles/${id}`)
  },

  getDocumentAuditLogs: async (vehicleId: string): Promise<any[]> => {
    try {
      const response = await api.get<any[]>(`/vehicles/${vehicleId}/document-audit-logs`)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle document audit logs:', error)
      return []
    }
  },

  // Get all document audit logs for all vehicles (optimized)
  getAllDocumentAuditLogs: async (): Promise<any[]> => {
    try {
      const response = await api.get<any[]>('/vehicles/document-audit-logs/all')
      return response.data
    } catch (error) {
      console.error('Error fetching all document audit logs:', error)
      return []
    }
  },

  /**
   * Lookup vehicle by plate from RTDB datasheet/Xe
   * Returns seat capacity for ANY vehicle (not filtered by badge)
   */
  lookupByPlate: async (plate: string): Promise<{
    id: string
    plateNumber: string
    seatCapacity: number
    operatorName: string
    vehicleType: string
    source: string
  } | null> => {
    try {
      const response = await api.get(`/vehicles/lookup/${encodeURIComponent(plate)}`)
      return response.data
    } catch (error) {
      console.error('Error looking up vehicle by plate:', error)
      return null
    }
  },
}
</file>

<file path="client/src/components/dispatch/ChoXeVaoBenDialog.tsx">
import { createPortal } from "react-dom";
import { CapPhepDialog } from "./CapPhepDialog";
import { FormHeader, VehicleEntryForm, TransportOrderPreview } from "./entry";
import { useChoXeVaoBenForm } from "@/hooks/useChoXeVaoBenForm";
import type { DispatchRecord } from "@/types";

interface ChoXeVaoBenDialogProps {
  vehicleOptions: Array<{ id: string; plateNumber: string }>;
  onClose: () => void;
  onSuccess?: () => void;
  open?: boolean;
  editRecord?: DispatchRecord | null;
}

export function ChoXeVaoBenDialog({
  vehicleOptions,
  onClose,
  onSuccess,
  open = true,
  editRecord = null,
}: ChoXeVaoBenDialogProps) {
  const {
    isEditMode,
    vehicleId,
    entryDateTime,
    setEntryDateTime,
    performPermitAfterEntry,
    setPerformPermitAfterEntry,
    confirmPassengerDrop,
    scheduleId,
    setScheduleId,
    passengersArrived,
    setPassengersArrived,
    routeId,
    setRouteId,
    transportOrderCode,
    setTransportOrderCode,
    signAndTransmit,
    setSignAndTransmit,
    printDisplay,
    setPrintDisplay,
    routes,
    schedules,
    transportOrderDisplay,
    isLoading,
    isAnimating,
    showPermitDialog,
    permitDispatchRecord,
    handleVehicleSelect,
    handleRefreshTransportOrder,
    handleConfirmPassengerDropChange,
    handleSubmit,
    handleClose,
    handlePermitDialogClose,
  } = useChoXeVaoBenForm({ open, editRecord, onSuccess, onClose });

  if (!open) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center"
      onClick={handleClose}
    >
      <div
        className={`bg-white w-full h-full overflow-y-auto overflow-x-hidden transition-all duration-300 ${
          isAnimating ? "scale-100 opacity-100" : "scale-95 opacity-0"
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="max-w-[1920px] mx-auto p-8">
          <form onSubmit={handleSubmit} className="space-y-6">
            <FormHeader
              isEditMode={isEditMode}
              isLoading={isLoading}
              performPermitAfterEntry={performPermitAfterEntry}
              onPerformPermitChange={setPerformPermitAfterEntry}
              onClose={handleClose}
            />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <VehicleEntryForm
                vehicleOptions={vehicleOptions}
                vehicleId={vehicleId}
                entryDateTime={entryDateTime}
                confirmPassengerDrop={confirmPassengerDrop}
                routeId={routeId}
                scheduleId={scheduleId}
                passengersArrived={passengersArrived}
                transportOrderCode={transportOrderCode}
                routes={routes}
                schedules={schedules}
                onVehicleSelect={handleVehicleSelect}
                onEntryDateTimeChange={setEntryDateTime}
                onConfirmPassengerDropChange={handleConfirmPassengerDropChange}
                onRouteChange={setRouteId}
                onScheduleChange={setScheduleId}
                onPassengersArrivedChange={setPassengersArrived}
                onTransportOrderCodeChange={setTransportOrderCode}
                onRefreshTransportOrder={handleRefreshTransportOrder}
              />

              <TransportOrderPreview
                signAndTransmit={signAndTransmit}
                printDisplay={printDisplay}
                transportOrderDisplay={transportOrderDisplay}
                onSignAndTransmitChange={setSignAndTransmit}
                onPrintDisplayChange={setPrintDisplay}
              />
            </div>
          </form>
        </div>
      </div>

      {showPermitDialog && permitDispatchRecord && (
        <CapPhepDialog
          record={permitDispatchRecord}
          open={showPermitDialog}
          onClose={handlePermitDialogClose}
          onSuccess={handlePermitDialogClose}
        />
      )}
    </div>,
    document.body
  );
}
</file>

<file path="client/src/pages/QuanLyDonViVanTai.tsx">
import {
  Plus,
  Search,
  Building2,
  ChevronLeft,
  ChevronRight,
  LayoutGrid,
  List,
  RefreshCw,
  SlidersHorizontal,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { OperatorDialog } from "@/components/operator/OperatorDialog";
import { OperatorDetailDialog } from "@/components/operator/OperatorDetailDialog";
import {
  SkeletonRow,
  QuickFilter,
  OperatorStatsCards,
  OperatorTableRow,
  OperatorGridCard,
  DeleteConfirmDialog,
} from "@/components/operator/common";
import { useOperatorManagement } from "@/hooks/useOperatorManagement";

export default function QuanLyDonViVanTai() {
  const {
    paginatedOperators,
    filteredOperators,
    stats,
    searchQuery,
    setSearchQuery,
    filterStatus,
    setFilterStatus,
    filterTicketDelegated,
    setFilterTicketDelegated,
    filterProvince,
    setFilterProvince,
    quickFilter,
    setQuickFilter,
    hasActiveFilters,
    clearFilters,
    showAdvancedFilters,
    setShowAdvancedFilters,
    isLoading,
    loadOperators,
    currentPage,
    setCurrentPage,
    totalPages,
    ITEMS_PER_PAGE,
    displayMode,
    setDisplayMode,
    dialogOpen,
    setDialogOpen,
    viewMode,
    selectedOperator,
    detailDialogOpen,
    setDetailDialogOpen,
    selectedOperatorForDetail,
    setSelectedOperatorForDetail,
    deleteDialogOpen,
    setDeleteDialogOpen,
    operatorToDelete,
    setOperatorToDelete,
    handleCreate,
    handleView,
    handleEdit,
    handleDelete,
    confirmDelete,
    handleRowClick,
  } = useOperatorManagement();

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-slate-100 to-orange-50">
      <div className="max-w-[1600px] mx-auto p-6 space-y-6">
        {/* Header */}
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div className="flex items-center gap-4">
            <div className="p-4 rounded-2xl bg-gradient-to-br from-orange-500 to-amber-500 shadow-xl shadow-orange-500/30">
              <Building2 className="h-7 w-7 text-white" />
            </div>
            <div>
              <h1 className="text-3xl font-bold text-slate-800 tracking-tight">
                Quản lý Đơn vị vận tải
              </h1>
              <p className="text-slate-500 text-sm mt-1">
                Đơn vị có phù hiệu Buýt hoặc Tuyến cố định
              </p>
            </div>
          </div>

          <div className="flex items-center gap-3">
            <Button
              onClick={() => loadOperators(true)}
              disabled={isLoading}
              className="px-4 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 hover:border-slate-300 transition-all shadow-sm"
            >
              <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? "animate-spin" : ""}`} />
              Làm mới
            </Button>
            <Button
              onClick={handleCreate}
              className="px-6 py-2.5 rounded-xl bg-gradient-to-r from-orange-500 to-amber-500 text-white font-semibold hover:from-orange-600 hover:to-amber-600 shadow-lg shadow-orange-500/30 transition-all hover:shadow-xl hover:shadow-orange-500/40 hover:-translate-y-0.5"
            >
              <Plus className="h-4 w-4 mr-2" />
              Thêm đơn vị
            </Button>
          </div>
        </div>

        {/* Stats Cards */}
        <OperatorStatsCards stats={stats} />

        {/* Search Bar */}
        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-2 flex flex-col lg:flex-row lg:items-center gap-2">
          <div className="flex-1 flex items-center gap-3 px-4 py-2 bg-slate-50 rounded-xl">
            <Search className="w-5 h-5 text-slate-400" />
            <input
              type="text"
              placeholder="Tìm kiếm tên, mã đơn vị, số điện thoại..."
              className="flex-1 bg-transparent border-none outline-none text-sm text-slate-700 placeholder-slate-400"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>

          <div className="hidden lg:block w-px h-10 bg-slate-200" />

          <div className="flex items-center gap-2 px-2">
            <QuickFilter
              label="Tất cả"
              count={stats.total}
              active={quickFilter === "all"}
              onClick={() => setQuickFilter("all")}
            />
            <QuickFilter
              label="Hoạt động"
              count={stats.active}
              active={quickFilter === "active"}
              onClick={() => setQuickFilter("active")}
            />
            <QuickFilter
              label="Ngừng"
              count={stats.inactive}
              active={quickFilter === "inactive"}
              onClick={() => setQuickFilter("inactive")}
            />
          </div>

          <div className="hidden lg:block w-px h-10 bg-slate-200" />

          <div className="flex items-center gap-2 px-2">
            <div className="flex items-center bg-slate-100 rounded-xl p-1">
              <button
                onClick={() => setDisplayMode("table")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "table"
                    ? "bg-white text-orange-600 shadow-sm"
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <List className="h-4 w-4" />
              </button>
              <button
                onClick={() => setDisplayMode("grid")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "grid"
                    ? "bg-white text-orange-600 shadow-sm"
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <LayoutGrid className="h-4 w-4" />
              </button>
            </div>

            <Button
              onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
              className={`px-4 py-2.5 rounded-xl border transition-all ${
                showAdvancedFilters || hasActiveFilters
                  ? "bg-orange-50 border-orange-200 text-orange-600"
                  : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50"
              }`}
            >
              <SlidersHorizontal className="h-4 w-4 mr-2" />
              Nâng cao
            </Button>
          </div>
        </div>

        {/* Advanced Filters */}
        {showAdvancedFilters && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6 animate-in slide-in-from-top-2 duration-200">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">
                  Trạng thái
                </Label>
                <select
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-orange-500/30 focus:border-orange-400 transition-all"
                >
                  <option value="">Tất cả trạng thái</option>
                  <option value="active">Đang hoạt động</option>
                  <option value="inactive">Ngừng hoạt động</option>
                </select>
              </div>
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">
                  Ủy thác vé
                </Label>
                <select
                  value={filterTicketDelegated}
                  onChange={(e) => setFilterTicketDelegated(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-orange-500/30 focus:border-orange-400 transition-all"
                >
                  <option value="">Tất cả</option>
                  <option value="yes">Có ủy thác</option>
                  <option value="no">Không ủy thác</option>
                </select>
              </div>
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">
                  Tỉnh/Thành phố
                </Label>
                <select
                  value={filterProvince}
                  onChange={(e) => setFilterProvince(e.target.value as "all" | "bac_ninh" | "ngoai_bac_ninh")}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-orange-500/30 focus:border-orange-400 transition-all"
                >
                  <option value="all">Tất cả tỉnh/thành</option>
                  <option value="bac_ninh">Trong Bắc Ninh ({stats.bacNinh})</option>
                  <option value="ngoai_bac_ninh">Ngoài Bắc Ninh ({stats.ngoaiBacNinh})</option>
                </select>
              </div>
            </div>
            {hasActiveFilters && (
              <div className="mt-4 flex justify-end">
                <Button
                  onClick={clearFilters}
                  className="px-4 py-2 rounded-lg text-sm text-slate-500 hover:text-slate-700 hover:bg-slate-100 transition-all"
                >
                  Xóa bộ lọc
                </Button>
              </div>
            )}
          </div>
        )}

        {/* Results info */}
        <div className="flex items-center justify-between text-sm text-slate-500">
          <span>
            Hiển thị{" "}
            <strong className="text-slate-700">{paginatedOperators.length}</strong>{" "}
            trong tổng số{" "}
            <strong className="text-slate-700">
              {filteredOperators.length.toLocaleString()}
            </strong>{" "}
            đơn vị
          </span>
          {totalPages > 1 && (
            <span>
              Trang {currentPage} / {totalPages}
            </span>
          )}
        </div>

        {/* Table View */}
        {displayMode === "table" && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="bg-gradient-to-r from-slate-800 to-slate-900">
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Mã ĐV
                    </th>
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Tên đơn vị
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Số điện thoại
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Người đại diện
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Ủy thác vé
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Trạng thái
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Thao tác
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-100">
                  {isLoading ? (
                    Array.from({ length: 8 }).map((_, i) => <SkeletonRow key={i} />)
                  ) : paginatedOperators.length === 0 ? (
                    <tr>
                      <td colSpan={7} className="px-6 py-16 text-center">
                        <div className="flex flex-col items-center">
                          <div className="relative mb-4">
                            <div className="w-24 h-24 rounded-full bg-gradient-to-br from-orange-100 to-amber-100 flex items-center justify-center">
                              <Building2 className="h-12 w-12 text-orange-500" />
                            </div>
                            <div className="absolute -bottom-1 -right-1 w-8 h-8 rounded-full bg-white border-2 border-orange-500 flex items-center justify-center">
                              <Plus className="w-4 h-4 text-orange-500" />
                            </div>
                          </div>
                          <h3 className="text-lg font-semibold text-slate-800 mb-1">
                            Chưa có đơn vị nào
                          </h3>
                          <p className="text-slate-500 mb-4">
                            Bắt đầu bằng cách thêm đơn vị đầu tiên
                          </p>
                          {hasActiveFilters ? (
                            <Button
                              onClick={clearFilters}
                              className="text-orange-600 hover:text-orange-700"
                            >
                              Xóa bộ lọc
                            </Button>
                          ) : (
                            <Button
                              onClick={handleCreate}
                              className="bg-orange-500 hover:bg-orange-600 text-white rounded-xl px-6 py-2.5"
                            >
                              <Plus className="w-4 h-4 mr-2" />
                              Thêm đơn vị
                            </Button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ) : (
                    paginatedOperators.map((operator, index) => (
                      <OperatorTableRow
                        key={operator.id}
                        operator={operator}
                        index={index}
                        onRowClick={handleRowClick}
                        onView={handleView}
                        onEdit={handleEdit}
                        onDelete={handleDelete}
                      />
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>
        )}

        {/* Grid View */}
        {displayMode === "grid" && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {isLoading ? (
              Array.from({ length: 8 }).map((_, i) => (
                <div
                  key={i}
                  className="bg-white rounded-2xl border border-slate-200 p-5 animate-pulse"
                >
                  <div className="flex items-center gap-3 mb-4">
                    <div className="w-12 h-12 rounded-xl bg-slate-200" />
                    <div className="flex-1">
                      <div className="h-5 bg-slate-200 rounded w-3/4 mb-2" />
                      <div className="h-3 bg-slate-100 rounded w-1/2" />
                    </div>
                  </div>
                  <div className="space-y-2">
                    <div className="h-3 bg-slate-100 rounded" />
                    <div className="h-3 bg-slate-100 rounded w-2/3" />
                  </div>
                </div>
              ))
            ) : paginatedOperators.length === 0 ? (
              <div className="col-span-full py-16 text-center">
                <Building2 className="h-16 w-16 text-slate-300 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-slate-800">
                  Không tìm thấy đơn vị nào
                </h3>
              </div>
            ) : (
              paginatedOperators.map((operator, index) => (
                <OperatorGridCard
                  key={operator.id}
                  operator={operator}
                  index={index}
                  onRowClick={handleRowClick}
                  onView={handleView}
                  onEdit={handleEdit}
                  onDelete={handleDelete}
                />
              ))
            )}
          </div>
        )}

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm px-6 py-4">
            <div className="flex items-center justify-between">
              <p className="text-sm text-slate-600">
                Hiển thị {(currentPage - 1) * ITEMS_PER_PAGE + 1}-
                {Math.min(currentPage * ITEMS_PER_PAGE, filteredOperators.length)} trong
                tổng số {filteredOperators.length.toLocaleString()} đơn vị
              </p>
              <div className="flex items-center gap-2">
                <Button
                  onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
                  disabled={currentPage === 1}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronLeft className="h-4 w-4" />
                </Button>

                <div className="flex items-center gap-1">
                  {Array.from({ length: totalPages }, (_, i) => i + 1)
                    .filter(
                      (page) =>
                        page === 1 ||
                        page === totalPages ||
                        (page >= currentPage - 1 && page <= currentPage + 1)
                    )
                    .map((page, index, array) => (
                      <span key={page} className="flex items-center">
                        {index > 0 && array[index - 1] !== page - 1 && (
                          <span className="px-2 text-slate-400">...</span>
                        )}
                        <button
                          onClick={() => setCurrentPage(page)}
                          className={`min-w-[40px] h-10 rounded-xl text-sm font-medium transition-all ${
                            currentPage === page
                              ? "bg-orange-500 text-white shadow-md shadow-orange-500/25"
                              : "bg-white border border-slate-200 text-slate-600 hover:bg-slate-50"
                          }`}
                        >
                          {page}
                        </button>
                      </span>
                    ))}
                </div>

                <Button
                  onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))}
                  disabled={currentPage === totalPages}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        )}

        {/* Dialogs */}
        <OperatorDialog
          open={dialogOpen}
          onOpenChange={setDialogOpen}
          mode={viewMode}
          operator={selectedOperator}
          onSuccess={loadOperators}
        />

        <OperatorDetailDialog
          open={detailDialogOpen}
          onClose={() => {
            setDetailDialogOpen(false);
            setSelectedOperatorForDetail(null);
          }}
          operator={selectedOperatorForDetail}
        />

        <DeleteConfirmDialog
          open={deleteDialogOpen}
          operatorName={operatorToDelete?.name}
          onConfirm={confirmDelete}
          onCancel={() => {
            setDeleteDialogOpen(false);
            setOperatorToDelete(null);
          }}
        />
      </div>

      {/* CSS Animation */}
      <style>{`
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(8px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      `}</style>
    </div>
  );
}
</file>

<file path="client/src/pages/ThanhToan.tsx">
import { useState, useEffect } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { toast } from "react-toastify";
import {
  ChevronDown,
  RefreshCw,
  FileSpreadsheet,
  Clock,
  Receipt,
  Banknote,
  CheckCircle2,
  AlertCircle,
  Search,
  Wallet,
  FileText,
  X,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select } from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { dispatchService } from "@/services/dispatch.service";
import { serviceChargeService } from "@/services/service-charge.service";
import type { DispatchRecord, ServiceCharge, ServiceType } from "@/types";
import { format } from "date-fns";
import { useUIStore } from "@/store/ui.store";
import * as XLSX from "xlsx";
import { DatePickerRange } from "@/components/DatePickerRange";
import { type DateRange } from "react-day-picker";
import {
  PaymentStatsCard,
  OrderCard,
  VehicleInfoCard,
  ServicesCard,
  PaymentSidebar,
  ZeroAmountWarningDialog,
} from "@/components/payment";

export default function ThanhToan() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const setTitle = useUIStore((state) => state.setTitle);

  // Detail view state
  const [record, setRecord] = useState<DispatchRecord | null>(null);
  const [serviceCharges, setServiceCharges] = useState<ServiceCharge[]>([]);
  const [serviceTypes, setServiceTypes] = useState<ServiceType[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [symbol, setSymbol] = useState("QLBX");
  const [note, setNote] = useState("");
  const [printOneCopy, setPrintOneCopy] = useState(true);
  const [printTwoCopies, setPrintTwoCopies] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [showZeroAmountWarning, setShowZeroAmountWarning] = useState(false);

  // List view state
  const [allData, setAllData] = useState<DispatchRecord[]>([]);
  const [listData, setListData] = useState<DispatchRecord[]>([]);
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [orderType, setOrderType] = useState<string>("all");
  const [searchQuery, setSearchQuery] = useState("");
  const [dateRange, setDateRange] = useState<DateRange | undefined>(undefined);

  // Calculate stats
  const stats = {
    total: listData.length,
    pending: listData.filter(i => i.currentStatus !== 'paid' && i.currentStatus !== 'departed').length,
    paid: listData.filter(i => i.currentStatus === 'paid' || i.currentStatus === 'departed').length,
    totalAmount: listData
      .filter(i => i.currentStatus === 'paid' || i.currentStatus === 'departed')
      .reduce((sum, i) => sum + (i.paymentAmount || 0), 0)
  };

  useEffect(() => {
    if (id) {
      setTitle("Xác nhận thanh toán");
      loadData();
    } else {
      setTitle("Quản lý đơn hàng");
      loadListData();
    }
  }, [id, setTitle]);

  useEffect(() => {
    if (!id && allData.length > 0) {
      applyFilters();
    }
  }, [dateRange, orderType, searchQuery, allData.length, id]);

  const applyFilters = () => {
    let filtered = [...allData];

    if (dateRange?.from && dateRange?.to) {
      const fromDate = new Date(dateRange.from);
      fromDate.setHours(0, 0, 0, 0);
      const toDate = new Date(dateRange.to);
      toDate.setHours(23, 59, 59, 999);
      filtered = filtered.filter(record => {
        const entryTime = new Date(record.entryTime);
        return entryTime >= fromDate && entryTime <= toDate;
      });
    } else if (dateRange?.from) {
      const fromDate = new Date(dateRange.from);
      fromDate.setHours(0, 0, 0, 0);
      filtered = filtered.filter(record => new Date(record.entryTime) >= fromDate);
    }

    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(record =>
        record.vehiclePlateNumber?.toLowerCase().includes(query) ||
        record.transportOrderCode?.toLowerCase().includes(query) ||
        record.vehicle?.operator?.name?.toLowerCase().includes(query) ||
        record.routeName?.toLowerCase().includes(query)
      );
    }

    filtered.sort((a, b) => new Date(b.entryTime).getTime() - new Date(a.entryTime).getTime());
    setListData(filtered);

    setSelectedItems(prev => {
      const newSet = new Set<string>();
      prev.forEach(itemId => {
        const item = filtered.find(i => i.id === itemId);
        if (item && item.currentStatus !== 'paid' && item.currentStatus !== 'departed') {
          newSet.add(itemId);
        }
      });
      return newSet;
    });
  };

  const loadListData = async () => {
    setIsLoading(true);
    try {
      const data = await dispatchService.getAll();
      
      // Filter to only show TODAY's records
      // This allows multiple trips per vehicle in a single day
      // Old records from previous days won't pollute operational views
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const todayRecords = data.filter(record => {
        const entryTime = new Date(record.entryTime);
        return entryTime >= today && entryTime < tomorrow;
      });
      
      setAllData(todayRecords);
    } catch (error) {
      console.error("Failed to load list data:", error);
      toast.error("Không thể tải danh sách đơn hàng");
    } finally {
      setIsLoading(false);
    }
  };

  const handleExportExcel = () => {
    if (listData.length === 0) {
      toast.warning("Không có dữ liệu để xuất Excel");
      return;
    }

    try {
      const excelData = listData.map((item, index) => ({
        "STT": index + 1,
        "Mã đơn hàng": item.transportOrderCode || item.id.substring(0, 8),
        "Biển kiểm soát": item.vehiclePlateNumber,
        "Đơn vị vận tải": item.vehicle?.operator?.name || "-",
        "Tuyến vận chuyển": item.routeName || "-",
        "Giờ xuất bến KH": item.plannedDepartureTime
          ? format(new Date(item.plannedDepartureTime), "HH:mm")
          : "-",
        "Ngày tạo": format(new Date(item.entryTime), "dd/MM/yyyy HH:mm"),
        "Người tạo": item.entryBy || "-",
        "Tổng tiền (đồng)": item.paymentAmount || 0,
        "Trạng thái": item.currentStatus === 'paid' ? 'Đã thanh toán' :
          item.currentStatus === 'departed' ? 'Đã xuất bến' : 'Chưa thanh toán'
      }));

      const ws = XLSX.utils.json_to_sheet(excelData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Danh sách đơn hàng");

      const fromDateStr = dateRange?.from ? format(dateRange.from, "dd-MM-yyyy") : format(new Date(), "dd-MM-yyyy");
      const toDateStr = dateRange?.to ? format(dateRange.to, "dd-MM-yyyy") : format(new Date(), "dd-MM-yyyy");
      XLSX.writeFile(wb, `Danh-sach-don-hang_${fromDateStr}_${toDateStr}.xlsx`);
      toast.success("Đã xuất Excel thành công");
    } catch (error) {
      console.error("Failed to export Excel:", error);
      toast.error("Không thể xuất Excel");
    }
  };

  const loadData = async () => {
    if (!id) return;
    setIsLoading(true);
    try {
      const [recordData, chargesData, typesData] = await Promise.all([
        dispatchService.getById(id),
        serviceChargeService.getAll(id),
        serviceChargeService.getServiceTypes(true)
      ]);
      setRecord(recordData);
      setServiceCharges(chargesData);
      setServiceTypes(typesData);

      if (recordData) {
        setNote(`Đơn hàng điều độ (${format(new Date(recordData.entryTime), "dd/MM/yyyy HH:mm")})`);
      }
    } catch (error) {
      console.error("Failed to load payment data:", error);
      toast.error("Không thể tải dữ liệu thanh toán");
      navigate("/dieu-do");
    } finally {
      setIsLoading(false);
    }
  };

  const calculateTotals = () => {
    const subtotal = serviceCharges.reduce((sum, charge) => sum + charge.totalAmount, 0);
    const discount = 0;
    const tax = 0;
    return { subtotal, discount, tax, total: subtotal - discount + tax };
  };

  const processPayment = async () => {
    if (!record) return;
    const { total } = calculateTotals();

    setIsProcessing(true);
    try {
      await dispatchService.processPayment(record.id, { paymentAmount: total, paymentMethod: 'cash' });
      toast.success("Thanh toán thành công!");
      navigate("/thanh-toan");
    } catch (error) {
      console.error("Failed to process payment:", error);
      toast.error("Không thể xử lý thanh toán");
    } finally {
      setIsProcessing(false);
    }
  };

  const handlePayment = async () => {
    if (!record) return;
    const { total } = calculateTotals();
    if (total === 0) {
      setShowZeroAmountWarning(true);
      return;
    }
    await processPayment();
  };

  const handleCancel = async () => {
    if (!record) return;
    
    const reason = window.prompt(
      "Bạn có chắc chắn muốn hủy bỏ record này?\n\nNhập lý do hủy (bắt buộc):",
      ""
    );
    
    if (reason === null) return; // User clicked Cancel
    if (!reason.trim()) {
      toast.warning("Vui lòng nhập lý do hủy");
      return;
    }

    try {
      await dispatchService.cancel(record.id, reason.trim());
      toast.success("Đã hủy bỏ record thành công");
      navigate("/thanh-toan");
    } catch (error: unknown) {
      const err = error as { response?: { data?: { error?: string } } };
      toast.error(err.response?.data?.error || "Không thể hủy bỏ record");
    }
  };

  const toggleItemSelection = (itemId: string) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(itemId)) newSet.delete(itemId);
      else newSet.add(itemId);
      return newSet;
    });
  };

  const handleBatchPayment = () => {
    if (selectedItems.size === 0) {
      toast.warning("Vui lòng chọn ít nhất một đơn hàng");
      return;
    }
    const selectedRecord = listData.find(item => selectedItems.has(item.id));
    if (selectedRecord) navigate(`/thanh-toan/${selectedRecord.id}`);
  };

  // ========== LIST VIEW ==========
  if (!id) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 via-gray-50 to-slate-100">
        <div className="p-4 lg:p-6 space-y-6">
          {/* Header */}
          <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
                <div className="p-2 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl text-white">
                  <Receipt className="w-6 h-6" />
                </div>
                Quản lý đơn hàng
              </h1>
              <p className="text-gray-500 mt-1">Theo dõi và xử lý thanh toán</p>
            </div>
            <div className="flex items-center gap-2">
              <Button variant="outline" size="sm" onClick={loadListData} className="gap-2">
                <RefreshCw className="w-4 h-4" /> Làm mới
              </Button>
              <Button variant="outline" size="sm" onClick={handleExportExcel} className="gap-2">
                <FileSpreadsheet className="w-4 h-4" /> Xuất Excel
              </Button>
              {selectedItems.size > 0 && (
                <Button size="sm" onClick={handleBatchPayment} className="gap-2 bg-gradient-to-r from-emerald-500 to-teal-500">
                  <Banknote className="w-4 h-4" /> Thanh toán ({selectedItems.size})
                </Button>
              )}
            </div>
          </div>

          {/* Stats Cards */}
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
            <PaymentStatsCard title="Tổng đơn hàng" value={stats.total} subtitle="Trong khoảng thời gian" icon={Receipt} gradient="from-blue-500 to-indigo-600" />
            <PaymentStatsCard title="Chờ thanh toán" value={stats.pending} subtitle="Cần xử lý" icon={Clock} gradient="from-amber-500 to-orange-500" />
            <PaymentStatsCard title="Đã thanh toán" value={stats.paid} subtitle="Hoàn thành" icon={CheckCircle2} gradient="from-emerald-500 to-teal-500" />
            <PaymentStatsCard title="Tổng doanh thu" value={`${(stats.totalAmount / 1000000).toFixed(1)}M`} subtitle={`${stats.totalAmount.toLocaleString('vi-VN')}đ`} icon={Wallet} gradient="from-violet-500 to-purple-600" />
          </div>

          {/* Filters */}
          <Card className="border-0 shadow-sm">
            <CardContent className="p-4">
              <div className="flex flex-col lg:flex-row gap-4">
                <div className="flex-1 relative">
                  <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" />
                  <Input placeholder="Tìm theo biển số, mã đơn, đơn vị, tuyến..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="pl-10" />
                </div>
                <div className="w-full lg:w-80">
                  <DatePickerRange range={dateRange} onRangeChange={setDateRange} placeholder="Chọn khoảng thời gian" label="" className="w-full" />
                </div>
                <div className="w-full lg:w-48">
                  <Select value={orderType} onChange={(e) => setOrderType(e.target.value)} className="w-full">
                    <option value="all">Tất cả loại</option>
                    <option value="thanh-toan-chuyen">Thanh toán chuyến</option>
                    <option value="thanh-toan-dinh-ky">Thanh toán định kỳ</option>
                    <option value="thanh-toan-vang-lai">Vãng lai</option>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Orders Grid */}
          {isLoading ? (
            <div className="flex items-center justify-center py-20">
              <div className="text-center">
                <div className="w-10 h-10 border-3 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" />
                <p className="text-gray-500 mt-4">Đang tải dữ liệu...</p>
              </div>
            </div>
          ) : listData.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-20">
              <div className="w-20 h-20 bg-gray-100 rounded-full flex items-center justify-center mb-4">
                <Receipt className="w-10 h-10 text-gray-400" />
              </div>
              <p className="text-gray-500 text-lg font-medium">Không có đơn hàng nào</p>
              <p className="text-gray-400 text-sm mt-1">Thay đổi bộ lọc để xem thêm</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-4">
              {listData.map(item => (
                <OrderCard key={item.id} item={item} isSelected={selectedItems.has(item.id)} onSelect={() => toggleItemSelection(item.id)} onNavigate={() => navigate(`/thanh-toan/${item.id}`)} />
              ))}
            </div>
          )}

          {/* Footer Summary */}
          {listData.length > 0 && (
            <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-4">
              <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
                <div className="flex items-center gap-4 text-sm text-gray-600">
                  <span>Hiển thị <strong>{listData.length}</strong> đơn hàng</span>
                  {selectedItems.size > 0 && <span className="text-blue-600">| Đã chọn <strong>{selectedItems.size}</strong></span>}
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-gray-500">Tổng:</span>
                  <span className="text-2xl font-bold text-emerald-600">{stats.totalAmount.toLocaleString('vi-VN')}đ</span>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ========== DETAIL VIEW ==========
  const { subtotal, discount, tax, total } = calculateTotals();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen bg-gradient-to-br from-slate-50 via-gray-50 to-slate-100">
        <div className="text-center">
          <div className="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" />
          <p className="text-gray-600 mt-4">Đang tải...</p>
        </div>
      </div>
    );
  }

  if (!record) {
    return (
      <div className="flex items-center justify-center h-screen bg-gradient-to-br from-slate-50 via-gray-50 to-slate-100">
        <div className="text-center">
          <div className="w-20 h-20 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <AlertCircle className="w-10 h-10 text-gray-400" />
          </div>
          <p className="text-gray-600 text-lg">Không tìm thấy thông tin thanh toán</p>
          <Button onClick={() => navigate("/dieu-do")} className="mt-4">Quay lại</Button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-gray-50 to-slate-100">
      <div className="p-4 lg:p-6 space-y-6">
        {/* Header */}
        <div className="flex items-center gap-3 text-sm text-gray-500">
          <button onClick={() => navigate("/thanh-toan")} className="hover:text-blue-600 transition-colors">Quản lý đơn hàng</button>
          <ChevronDown className="w-4 h-4 rotate-[-90deg]" />
          <span className="text-gray-900 font-medium">Thanh toán</span>
        </div>

        <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
          {/* Left Column */}
          <div className="xl:col-span-2 space-y-6">
            <VehicleInfoCard record={record} />
            <ServicesCard record={record} serviceCharges={serviceCharges} serviceTypes={serviceTypes} onChargesUpdate={setServiceCharges} />

            {/* Quick Actions */}
            <div className="flex flex-wrap gap-3">
              <Button variant="outline" onClick={handleCancel} className="gap-2 text-red-600 border-red-200 hover:bg-red-50">
                <X className="w-4 h-4" /> Hủy bỏ record
              </Button>
              <Button variant="outline" onClick={() => navigate(`/bao-cao/xe-tra-khach?vehiclePlateNumber=${encodeURIComponent(record.vehiclePlateNumber)}&returnTo=/thanh-toan/${id}`)} className="gap-2">
                <FileText className="w-4 h-4" /> Lịch sử trả khách
              </Button>
              <Button variant="outline" onClick={() => navigate(`/bao-cao/xe-ra-vao-ben?vehiclePlateNumber=${encodeURIComponent(record.vehiclePlateNumber)}&returnTo=/thanh-toan/${id}`)} className="gap-2">
                <FileText className="w-4 h-4" /> Lịch sử ra vào
              </Button>
            </div>
          </div>

          {/* Right Column - Payment Sidebar */}
          <div className="space-y-6">
            <PaymentSidebar
              record={record}
              total={total}
              subtotal={subtotal}
              discount={discount}
              tax={tax}
              symbol={symbol}
              setSymbol={setSymbol}
              note={note}
              setNote={setNote}
              printOneCopy={printOneCopy}
              setPrintOneCopy={setPrintOneCopy}
              printTwoCopies={printTwoCopies}
              setPrintTwoCopies={setPrintTwoCopies}
              isProcessing={isProcessing}
              onPayment={handlePayment}
            />
          </div>
        </div>
      </div>

      <ZeroAmountWarningDialog
        open={showZeroAmountWarning}
        onOpenChange={setShowZeroAmountWarning}
        onConfirm={async () => {
          setShowZeroAmountWarning(false);
          await processPayment();
        }}
        isProcessing={isProcessing}
      />
    </div>
  );
}
</file>

<file path="client/src/services/vehicle-badge.service.ts">
import api from '@/lib/api'

export type OperationalStatus = 'trong_ben' | 'dang_chay'

export interface VehicleBadge {
  id: string
  badge_color: string
  badge_number: string
  badge_type: string
  bus_route_ref: string
  business_license_ref: string
  created_at: string
  created_by: string
  email_notification_sent: boolean
  expiry_date: string
  file_code: string
  issue_date: string
  issue_type: string
  issuing_authority_ref: string
  license_plate_sheet: string
  notes: string
  notification_ref: string
  previous_badge_number: string
  renewal_due_date: string
  renewal_reason: string
  renewal_reminder_shown: boolean
  replacement_vehicle_id: string
  revocation_date: string
  revocation_decision: string
  revocation_reason: string
  route_id: string
  status: string
  vehicle_id: string
  vehicle_type: string
  warn_duplicate_plate: boolean
  operational_status: OperationalStatus  // 'trong_ben' (in station) or 'dang_chay' (running)
}

export interface CreateVehicleBadgeInput {
  badge_number: string
  license_plate_sheet: string
  badge_type?: string
  badge_color?: string
  issue_date?: string
  expiry_date?: string
  status?: string
  file_code?: string
  issue_type?: string
  bus_route_ref?: string
  vehicle_type?: string
  notes?: string
}

export interface UpdateVehicleBadgeInput extends Partial<CreateVehicleBadgeInput> {}

// Frontend cache for badges
let badgesCache: VehicleBadge[] | null = null
let badgesCacheTime = 0
const FE_CACHE_TTL = 5 * 60 * 1000 // 5 minutes frontend cache

export const vehicleBadgeService = {
  getAll: async (forceRefresh = false): Promise<VehicleBadge[]> => {
    try {
      const now = Date.now()
      
      // Return cached data if valid and not forcing refresh
      if (!forceRefresh && badgesCache && (now - badgesCacheTime) < FE_CACHE_TTL) {
        return badgesCache
      }
      
      const response = await api.get<VehicleBadge[]>('/vehicle-badges')
      badgesCache = response.data
      badgesCacheTime = now
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badges:', error)
      return badgesCache || [] // Return stale cache on error
    }
  },
  
  clearCache: () => {
    badgesCache = null
    badgesCacheTime = 0
  },

  getById: async (id: string): Promise<VehicleBadge | null> => {
    try {
      const response = await api.get<VehicleBadge>(`/vehicle-badges/${id}`)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badge by id:', error)
      return null
    }
  },

  getByPlateNumber: async (plateNumber: string): Promise<VehicleBadge | null> => {
    try {
      const response = await api.get<VehicleBadge>(`/vehicle-badges/by-plate/${encodeURIComponent(plateNumber)}`)
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badge by plate number:', error)
      return null
    }
  },

  getStats: async (): Promise<{
    total: number
    active: number
    expired: number
    expiringSoon: number
  }> => {
    try {
      const response = await api.get<{
        total: number
        active: number
        expired: number
        expiringSoon: number
      }>('/vehicle-badges/stats')
      return response.data
    } catch (error) {
      console.error('Error fetching vehicle badge stats:', error)
      return {
        total: 0,
        active: 0,
        expired: 0,
        expiringSoon: 0,
      }
    }
  },

  create: async (data: CreateVehicleBadgeInput): Promise<VehicleBadge> => {
    const response = await api.post<VehicleBadge>('/vehicle-badges', data)
    vehicleBadgeService.clearCache()
    return response.data
  },

  update: async (id: string, data: UpdateVehicleBadgeInput): Promise<VehicleBadge> => {
    const response = await api.put<VehicleBadge>(`/vehicle-badges/${id}`, data)
    vehicleBadgeService.clearCache()
    return response.data
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/vehicle-badges/${id}`)
    vehicleBadgeService.clearCache()
  },
}
</file>

<file path="server/src/controllers/dispatch.controller.ts">
import { Request, Response } from 'express'
import { firebase } from '../config/database.js'
import { z } from 'zod'
import { AuthRequest } from '../middleware/auth.js'
import { getCurrentVietnamTime, convertVietnamISOToUTCForStorage } from '../utils/timezone.js'
import {
  fetchDenormalizedData,
  buildDenormalizedFields,
  fetchUserName,
  fetchRouteData,
  buildRouteDenormalizedFields
} from '../utils/denormalization.js'

const dispatchSchema = z.object({
  vehicleId: z.string().min(1, 'Invalid vehicle ID'),
  driverId: z.string().min(1).optional(),  // Optional - bypass driver requirement
  scheduleId: z.string().min(1).optional(),
  routeId: z.string().min(1, 'Invalid route ID').optional(),
  entryTime: z.string().refine(
    (val) => {
      // Accept ISO 8601 format with or without timezone
      // Examples: "2024-12-25T14:30:00+07:00" or "2024-12-25T14:30:00Z" or "2024-12-25T14:30:00"
      const date = new Date(val)
      return !isNaN(date.getTime())
    },
    { message: 'Invalid entry time format' }
  ),
  notes: z.string().optional(),
  entryShiftId: z.string().min(1).optional(),
})

export const getAllDispatchRecords = async (req: Request, res: Response) => {
  try {
    const { status, vehicleId, driverId, routeId } = req.query

    let query = firebase
      .from('dispatch_records')
      .select('*')
      .order('entry_time', { ascending: false })

    if (status) {
      query = query.eq('current_status', status as string)
    }
    if (vehicleId) {
      query = query.eq('vehicle_id', vehicleId as string)
    }
    if (driverId) {
      query = query.eq('driver_id', driverId as string)
    }
    if (routeId) {
      query = query.eq('route_id', routeId as string)
    }

    const { data: records, error } = await query

    if (error) throw error

    // OPTIMIZED: Use denormalized data - no additional queries needed!
    // All related entity names are embedded in the dispatch_records
    const result = records.map((record: any) => ({
      id: record.id,
      vehicleId: record.vehicle_id,
      vehicle: {
        id: record.vehicle_id,
        plateNumber: record.vehicle_plate_number || '',
        operatorId: record.vehicle_operator_id || null,
        operator: record.vehicle_operator_name ? {
          id: record.vehicle_operator_id,
          name: record.vehicle_operator_name,
          code: record.vehicle_operator_code,
        } : undefined,
      },
      vehiclePlateNumber: record.vehicle_plate_number || '',
      driverId: record.driver_id,
      driverName: record.driver_full_name || '',
      scheduleId: record.schedule_id,
      routeId: record.route_id,
      route: record.route_name ? {
        id: record.route_id,
        routeName: record.route_name,
        routeType: record.route_type,
        destination: record.route_destination_name ? {
          id: record.route_destination_id,
          name: record.route_destination_name,
          code: record.route_destination_code,
        } : undefined,
      } : undefined,
      routeName: record.route_name || '',
      entryTime: record.entry_time,
      entryBy: record.entry_by_name || record.entry_by,
      passengerDropTime: record.passenger_drop_time,
      passengersArrived: record.passengers_arrived,
      passengerDropBy: record.passenger_drop_by_name || record.passenger_drop_by,
      boardingPermitTime: record.boarding_permit_time,
      plannedDepartureTime: record.planned_departure_time,
      transportOrderCode: record.transport_order_code,
      seatCount: record.seat_count,
      permitStatus: record.permit_status,
      rejectionReason: record.rejection_reason,
      boardingPermitBy: record.boarding_permit_by_name || record.boarding_permit_by,
      paymentTime: record.payment_time,
      paymentAmount: record.payment_amount ? parseFloat(record.payment_amount) : null,
      paymentMethod: record.payment_method,
      invoiceNumber: record.invoice_number,
      paymentBy: record.payment_by_name || record.payment_by,
      departureOrderTime: record.departure_order_time,
      passengersDeparting: record.passengers_departing,
      departureOrderBy: record.departure_order_by_name || record.departure_order_by,
      exitTime: record.exit_time,
      exitBy: record.exit_by_name || record.exit_by,
      currentStatus: record.current_status,
      notes: record.notes,
      metadata: record.metadata,
      createdAt: record.created_at,
      updatedAt: record.updated_at,
    }))

    return res.json(result)
  } catch (error) {
    console.error('Error fetching dispatch records:', error)
    return res.status(500).json({ error: 'Failed to fetch dispatch records' })
  }
}

export const getDispatchRecordById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data: record, error } = await firebase
      .from('dispatch_records')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    if (!record) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    // OPTIMIZED: Use denormalized data - no additional queries needed!
    return res.json({
      id: record.id,
      vehicleId: record.vehicle_id,
      vehicle: {
        id: record.vehicle_id,
        plateNumber: record.vehicle_plate_number || '',
        operatorId: record.vehicle_operator_id || null,
        operator: record.vehicle_operator_name ? {
          id: record.vehicle_operator_id,
          name: record.vehicle_operator_name,
          code: record.vehicle_operator_code,
        } : undefined,
      },
      vehiclePlateNumber: record.vehicle_plate_number || '',
      driverId: record.driver_id,
      driverName: record.driver_full_name || '',
      scheduleId: record.schedule_id,
      routeId: record.route_id,
      route: record.route_name ? {
        id: record.route_id,
        routeName: record.route_name,
        routeType: record.route_type,
        destination: record.route_destination_name ? {
          id: record.route_destination_id,
          name: record.route_destination_name,
          code: record.route_destination_code,
        } : undefined,
      } : undefined,
      routeName: record.route_name || '',
      entryTime: record.entry_time,
      entryBy: record.entry_by_name || record.entry_by,
      passengerDropTime: record.passenger_drop_time,
      passengersArrived: record.passengers_arrived,
      passengerDropBy: record.passenger_drop_by_name || record.passenger_drop_by,
      boardingPermitTime: record.boarding_permit_time,
      plannedDepartureTime: record.planned_departure_time,
      transportOrderCode: record.transport_order_code,
      seatCount: record.seat_count,
      permitStatus: record.permit_status,
      rejectionReason: record.rejection_reason,
      boardingPermitBy: record.boarding_permit_by_name || record.boarding_permit_by,
      paymentTime: record.payment_time,
      paymentAmount: record.payment_amount ? parseFloat(record.payment_amount) : null,
      paymentMethod: record.payment_method,
      invoiceNumber: record.invoice_number,
      paymentBy: record.payment_by_name || record.payment_by,
      departureOrderTime: record.departure_order_time,
      passengersDeparting: record.passengers_departing,
      departureOrderBy: record.departure_order_by_name || record.departure_order_by,
      exitTime: record.exit_time,
      exitBy: record.exit_by_name || record.exit_by,
      currentStatus: record.current_status,
      notes: record.notes,
      metadata: record.metadata,
      createdAt: record.created_at,
      updatedAt: record.updated_at,
    })
  } catch (error) {
    console.error('Error fetching dispatch record:', error)
    return res.status(500).json({ error: 'Failed to fetch dispatch record' })
  }
}

export const createDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const { vehicleId, driverId, scheduleId, routeId, entryTime, notes, entryShiftId } = dispatchSchema.parse(req.body)
    const userId = req.user?.id

    // Frontend sends ISO string with +07:00 (Vietnam time)
    // Convert to UTC ISO string for database storage, but preserve Vietnam time value
    // by storing UTC time that represents Vietnam time (UTC+7)
    const entryTimeForDB = convertVietnamISOToUTCForStorage(entryTime)

    // OPTIMIZED: Fetch denormalized data in parallel before insert
    const denormData = await fetchDenormalizedData({
      vehicleId,
      driverId,
      routeId,
      userId,
    })

    const denormFields = buildDenormalizedFields(denormData)

    const insertData: any = {
      vehicle_id: vehicleId,
      driver_id: driverId || null,  // Firebase RTDB doesn't accept undefined
      schedule_id: scheduleId || null,
      route_id: routeId || null,
      entry_time: entryTimeForDB,
      entry_by: userId || null,
      current_status: 'entered',
      notes: notes || null,
      // Denormalized fields
      ...denormFields,
      entry_by_name: denormData.user?.fullName || null,
    }

    // Set entry_shift_id if provided
    if (entryShiftId) {
      insertData.entry_shift_id = entryShiftId
    }

    const { data, error } = await firebase
      .from('dispatch_records')
      .insert(insertData)
      .select('*')
      .single()

    if (error) throw error

    // Response uses denormalized data - no additional queries needed!
    return res.status(201).json({
      id: data.id,
      vehicleId: data.vehicle_id,
      vehicle: {
        id: data.vehicle_id,
        plateNumber: data.vehicle_plate_number || '',
        operatorId: data.vehicle_operator_id || null,
        operator: data.vehicle_operator_name ? {
          id: data.vehicle_operator_id,
          name: data.vehicle_operator_name,
          code: data.vehicle_operator_code,
        } : undefined,
      },
      vehiclePlateNumber: data.vehicle_plate_number || '',
      driverId: data.driver_id,
      driverName: data.driver_full_name || '',
      scheduleId: data.schedule_id,
      routeId: data.route_id,
      route: data.route_name ? {
        id: data.route_id,
        routeName: data.route_name,
        routeType: data.route_type,
        destination: data.route_destination_name ? {
          id: data.route_destination_id,
          name: data.route_destination_name,
          code: data.route_destination_code,
        } : undefined,
      } : undefined,
      routeName: data.route_name || '',
      entryTime: data.entry_time,
      entryBy: data.entry_by_name || data.entry_by,
      currentStatus: data.current_status,
      notes: data.notes,
      metadata: data.metadata,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    })
  } catch (error: any) {
    console.error('Error creating dispatch record:', error)
    console.error('Error stack:', error.stack)
    console.error('Request body:', JSON.stringify(req.body, null, 2))
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create dispatch record' })
  }
}

// Update dispatch status - passengers dropped
export const recordPassengerDrop = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { passengersArrived, routeId } = req.body
    const userId = req.user?.id

    // Fetch user name for denormalization
    const userName = await fetchUserName(userId)

    // Build update object with denormalized user name
    const updateData: any = {
      passenger_drop_time: getCurrentVietnamTime(),
      passengers_arrived: passengersArrived || null,
      passenger_drop_by: userId || null,
      passenger_drop_by_name: userName,
      current_status: 'passengers_dropped',
    }

    // Set routeId and fetch route denormalized data if provided
    if (routeId) {
      updateData.route_id = routeId
      const routeData = await fetchRouteData(routeId)
      if (routeData) {
        Object.assign(updateData, buildRouteDenormalizedFields(routeData))
      }
    }

    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json({ message: 'Passenger drop recorded', dispatch: data })
  } catch (error: any) {
    console.error('Error recording passenger drop:', error)
    return res.status(500).json({ error: error.message || 'Failed to record passenger drop' })
  }
}

// Issue boarding permit
export const issuePermit = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { transportOrderCode, plannedDepartureTime, seatCount, permitStatus, rejectionReason, routeId, scheduleId, replacementVehicleId, permitShiftId } = req.body
    const userId = req.user?.id

    console.log('[issuePermit] Record ID:', id)
    console.log('[issuePermit] Request body:', { transportOrderCode, plannedDepartureTime, seatCount, permitStatus, routeId, scheduleId })

    if (!transportOrderCode && permitStatus !== 'rejected') {
      return res.status(400).json({ error: 'Transport order code is required for approval' })
    }

    // Fetch user name for denormalization
    const userName = await fetchUserName(userId)

    // Get current metadata to preserve existing data
    const { data: currentRecord } = await firebase
      .from('dispatch_records')
      .select('metadata')
      .eq('id', id)
      .single()

    const currentMetadata = currentRecord?.metadata || {}
    const newMetadata = { ...currentMetadata }

    // Update replacement vehicle ID in metadata if provided
    if (replacementVehicleId) {
      newMetadata.replacementVehicleId = replacementVehicleId
    } else if (replacementVehicleId === null || replacementVehicleId === '') {
      // Remove replacement vehicle ID if explicitly set to empty
      delete newMetadata.replacementVehicleId
    }

    const updateData: any = {
      boarding_permit_time: getCurrentVietnamTime(),
      boarding_permit_by: userId || null,
      boarding_permit_by_name: userName,
      permit_status: permitStatus || 'approved',
      metadata: newMetadata,
    }

    // Set permit_shift_id if provided
    if (permitShiftId) {
      updateData.permit_shift_id = permitShiftId
    }

    // Set routeId and fetch route denormalized data if provided
    if (routeId) {
      updateData.route_id = routeId
      const routeData = await fetchRouteData(routeId)
      if (routeData) {
        Object.assign(updateData, buildRouteDenormalizedFields(routeData))
      }
    }

    // Set scheduleId if provided
    if (scheduleId) {
      updateData.schedule_id = scheduleId
    }

    if (permitStatus === 'approved') {
      updateData.transport_order_code = transportOrderCode
      updateData.planned_departure_time = plannedDepartureTime
      updateData.seat_count = seatCount
      updateData.current_status = 'permit_issued'
      updateData.rejection_reason = rejectionReason || null
    } else if (permitStatus === 'rejected') {
      updateData.transport_order_code = transportOrderCode || null
      updateData.planned_departure_time = plannedDepartureTime || null
      updateData.seat_count = seatCount || null
      updateData.current_status = 'permit_rejected'
      updateData.rejection_reason = rejectionReason || null
    }

    console.log('[issuePermit] Updating record with data:', JSON.stringify(updateData, null, 2))

    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    console.log('[issuePermit] Update result - data:', data ? 'found' : 'null', 'error:', error)

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json({ message: 'Permit processed', dispatch: data })
  } catch (error: any) {
    console.error('[issuePermit] Error:', error)
    // Check for duplicate key error (unique constraint violation)
    if (error.code === '23505' || error.message?.includes('duplicate key')) {
      return res.status(400).json({
        error: 'Mã lệnh vận chuyển đã tồn tại. Vui lòng chọn mã khác.',
        code: '23505'
      })
    }
    return res.status(500).json({ error: error.message || 'Failed to issue permit' })
  }
}

// Process payment
export const processPayment = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { paymentAmount, paymentMethod, invoiceNumber, paymentShiftId } = req.body
    const userId = req.user?.id

    // Allow payment amount >= 0 (including 0 for cases with no services)
    if (paymentAmount === undefined || paymentAmount === null || paymentAmount < 0) {
      return res.status(400).json({ error: 'Valid payment amount is required (must be >= 0)' })
    }

    // Fetch user name for denormalization
    const userName = await fetchUserName(userId)

    const updateData: any = {
      payment_time: getCurrentVietnamTime(),
      payment_amount: paymentAmount,
      payment_method: paymentMethod || 'cash',
      invoice_number: invoiceNumber || null,
      payment_by: userId || null,
      payment_by_name: userName,
      current_status: 'paid',
    }

    // Set payment_shift_id if provided
    if (paymentShiftId) {
      updateData.payment_shift_id = paymentShiftId
    }

    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json({ message: 'Payment processed', dispatch: data })
  } catch (error: any) {
    console.error('Error processing payment:', error)
    return res.status(500).json({ error: error.message || 'Failed to process payment' })
  }
}

// Issue departure order
export const issueDepartureOrder = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { passengersDeparting, departureOrderShiftId } = req.body
    const userId = req.user?.id

    // Fetch user name for denormalization
    const userName = await fetchUserName(userId)

    const updateData: any = {
      departure_order_time: getCurrentVietnamTime(),
      passengers_departing: passengersDeparting || null,
      departure_order_by: userId || null,
      departure_order_by_name: userName,
      current_status: 'departure_ordered',
    }

    // Set departure_order_shift_id if provided
    if (departureOrderShiftId) {
      updateData.departure_order_shift_id = departureOrderShiftId
    }

    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json({ message: 'Departure order issued', dispatch: data })
  } catch (error: any) {
    console.error('Error issuing departure order:', error)
    return res.status(500).json({ error: error.message || 'Failed to issue departure order' })
  }
}

// Record exit
export const recordExit = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { exitTime, passengersDeparting, exitShiftId } = req.body
    const userId = req.user?.id

    // Fetch user name for denormalization
    const userName = await fetchUserName(userId)

    const updateData: any = {
      exit_time: exitTime ? convertVietnamISOToUTCForStorage(exitTime) : getCurrentVietnamTime(),
      exit_by: userId || null,
      exit_by_name: userName,
      current_status: 'departed',
    }

    if (passengersDeparting !== undefined) {
      updateData.passengers_departing = passengersDeparting
    }

    // Set exit_shift_id if provided
    if (exitShiftId) {
      updateData.exit_shift_id = exitShiftId
    }

    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    return res.json({ message: 'Exit recorded', dispatch: data })
  } catch (error: any) {
    console.error('Error recording exit:', error)
    return res.status(500).json({ error: error.message || 'Failed to record exit' })
  }
}

// Delete dispatch record
export const deleteDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    console.log('[deleteDispatchRecord] Attempting to delete record:', id)

    // Check if record exists
    const { data: existingRecord, error: fetchError } = await firebase
      .from('dispatch_records')
      .select('*')
      .eq('id', id)
      .single()

    console.log('[deleteDispatchRecord] Fetch result:', { found: !!existingRecord, error: fetchError?.message })

    if (fetchError || !existingRecord) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    // Only allow deletion of records that haven't departed yet
    if (existingRecord.current_status === 'departed') {
      return res.status(400).json({ error: 'Cannot delete a record that has already departed' })
    }

    // Delete the record
    const { error: deleteError } = await firebase
      .from('dispatch_records')
      .delete()
      .eq('id', id)

    if (deleteError) throw deleteError

    return res.json({ message: 'Dispatch record deleted successfully' })
  } catch (error: any) {
    console.error('Error deleting dispatch record:', error)
    return res.status(500).json({ error: error.message || 'Failed to delete dispatch record' })
  }
}

// Update dispatch record (for editing basic info)
export const updateDispatchRecord = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const { vehicleId, driverId, routeId, entryTime, notes } = req.body

    // Check if record exists
    const { data: existingRecord, error: fetchError } = await firebase
      .from('dispatch_records')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingRecord) {
      return res.status(404).json({ error: 'Dispatch record not found' })
    }

    // Only allow editing of records in early stages
    const editableStatuses = ['entered', 'passengers_dropped']
    if (!editableStatuses.includes(existingRecord.current_status)) {
      return res.status(400).json({
        error: 'Cannot edit a record that has already been permitted or paid'
      })
    }

    // Build update data
    const updateData: Record<string, any> = {
      updated_at: new Date().toISOString(),
    }

    // Update vehicle if changed
    if (vehicleId && vehicleId !== existingRecord.vehicle_id) {
      const denormalized = await fetchDenormalizedData(vehicleId)
      updateData.vehicle_id = vehicleId
      Object.assign(updateData, buildDenormalizedFields(denormalized))
    }

    // Update driver if changed
    if (driverId && driverId !== existingRecord.driver_id) {
      const driverName = await fetchUserName(driverId)
      updateData.driver_id = driverId
      updateData.driver_full_name = driverName
    }

    // Update route if changed
    if (routeId !== undefined) {
      if (routeId && routeId !== existingRecord.route_id) {
        const routeData = await fetchRouteData(routeId)
        updateData.route_id = routeId
        Object.assign(updateData, buildRouteDenormalizedFields(routeData))
      } else if (!routeId) {
        updateData.route_id = null
        updateData.route_name = null
        updateData.route_type = null
        updateData.route_destination_id = null
        updateData.route_destination_name = null
        updateData.route_destination_code = null
      }
    }

    // Update entry time if changed
    if (entryTime) {
      updateData.entry_time = convertVietnamISOToUTCForStorage(entryTime)
    }

    // Update notes if provided
    if (notes !== undefined) {
      updateData.notes = notes
    }

    // Perform update
    const { data, error } = await firebase
      .from('dispatch_records')
      .update(updateData)
      .eq('id', id)
      .single()

    if (error) throw error

    return res.json({ message: 'Dispatch record updated successfully', dispatch: data })
  } catch (error: any) {
    console.error('Error updating dispatch record:', error)
    return res.status(500).json({ error: error.message || 'Failed to update dispatch record' })
  }
}

// Legacy endpoints for backward compatibility
export const updateDispatchStatus = async (_req: Request, res: Response) => {
  return res.status(400).json({
    error: 'This endpoint is deprecated. Use specific workflow endpoints instead.'
  })
}

export const depart = async (_req: Request, res: Response) => {
  return res.status(400).json({
    error: 'This endpoint is deprecated. Use /depart endpoint instead.'
  })
}
</file>

<file path="server/src/controllers/vehicle-badge.controller.ts">
import { Request, Response } from 'express'
import { db, firebase } from '../config/database.js'

// In-memory cache for vehicle badges (refresh every 30 minutes for production)
let badgesCache: any[] | null = null
let badgesCacheTime: number = 0
const CACHE_TTL = 30 * 60 * 1000 // 30 minutes - badges don't change often
let cacheLoading: Promise<any[]> | null = null // Prevent multiple simultaneous loads

// Helper function to get active dispatch vehicle plates (vehicles currently in operation)
const getActiveDispatchPlates = async (): Promise<Set<string>> => {
  try {
    // Get all dispatch records that are NOT departed (still in process)
    const { data: activeRecords } = await firebase
      .from('dispatch_records')
      .select('vehicle_plate_number, current_status')
      .neq('current_status', 'departed')

    const activePlates = new Set<string>()
    if (activeRecords) {
      for (const record of activeRecords) {
        if (record.vehicle_plate_number) {
          // Normalize plate number for comparison
          activePlates.add(record.vehicle_plate_number.replace(/[.\-\s]/g, '').toUpperCase())
        }
      }
    }
    return activePlates
  } catch (error) {
    console.error('Error fetching active dispatch plates:', error)
    return new Set()
  }
}

// Helper function to normalize plate number for comparison
const normalizePlate = (plate: string): string => {
  return plate.replace(/[.\-\s]/g, '').toUpperCase()
}

// Helper function to map Firebase data to VehicleBadge format
// Supports both old format (Vietnamese field names) and new format (from Google Sheets sync)
const mapFirebaseDataToBadge = (firebaseData: any, activePlates?: Set<string>) => {
  // Support both old (TrangThai) and new (status) field names
  const status = firebaseData.TrangThai || firebaseData.status || ''
  const vehicleRef = firebaseData.BienSoXe || firebaseData.vehicle_id || ''

  return {
    id: firebaseData.ID_PhuHieu || firebaseData.id || '',
    badge_number: firebaseData.SoPhuHieu || firebaseData.badge_number || '',
    license_plate_sheet: vehicleRef,
    badge_type: firebaseData.LoaiPH || firebaseData.badge_type || '',
    badge_color: firebaseData.MauPhuHieu || firebaseData.badge_color || '',
    issue_date: firebaseData.NgayCap || firebaseData.issue_date || '',
    expiry_date: firebaseData.NgayHetHan || firebaseData.expiry_date || '',
    status: status,
    file_code: firebaseData.MaHoSo || firebaseData.file_number || '',
    issue_type: firebaseData.LoaiCap || firebaseData.issue_type || '',
    business_license_ref: firebaseData.Ref_GPKD || firebaseData.business_license_ref || '',
    issuing_authority_ref: firebaseData.Ref_DonViCapPhuHieu || firebaseData.issuing_authority_ref || '',
    vehicle_id: vehicleRef,
    route_id: firebaseData.Ref_Tuyen || firebaseData.route_ref || '',
    bus_route_ref: firebaseData.TuyenDuong || firebaseData.Ref_TuyenBuyt || firebaseData.bus_route_ref || '',
    vehicle_type: firebaseData.LoaiXe || firebaseData.vehicle_type || '',
    notes: firebaseData.GhiChu || firebaseData.notes || '',
    created_at: firebaseData.created_at || firebaseData.synced_at || new Date().toISOString(),
    created_by: firebaseData.User || firebaseData.user || '',
    email_notification_sent: firebaseData.GuiEmailbao || firebaseData.email_sent || false,
    notification_ref: firebaseData.Ref_ThongBao || firebaseData.notification_ref || '',
    previous_badge_number: firebaseData.SoPhuHieuCu || firebaseData.old_badge_number || '',
    renewal_due_date: firebaseData.Hancap || firebaseData.issue_deadline || '',
    renewal_reason: firebaseData.LyDoCapLai || firebaseData.reissue_reason || '',
    renewal_reminder_shown: firebaseData.CanCapLaiPopup || firebaseData.need_reissue_popup || false,
    replacement_vehicle_id: firebaseData.XeThayThe || firebaseData.replacement_vehicle || '',
    revocation_date: firebaseData.NgayThuHoi || firebaseData.revoke_date || '',
    revocation_decision: firebaseData.QDThuHoi || firebaseData.revoke_decision || '',
    revocation_reason: firebaseData.LyDoThuHoi || firebaseData.revoke_reason || '',
    warn_duplicate_plate: firebaseData.CanhBaoTrungBienSoKhiCapPH || firebaseData.warning_duplicate_plate || false,
    // Compute operational_status based on active dispatch records
    operational_status: activePlates && vehicleRef
      ? (activePlates.has(normalizePlate(vehicleRef)) ? 'dang_chay' : 'trong_ben')
      : 'trong_ben',
  }
}

// Cache for vehicle ID to plate number mapping
let vehiclePlateCache: Map<string, string> | null = null
let vehiclePlateCacheTime: number = 0

// Helper to load vehicle plate numbers for resolving badge vehicle_id
const loadVehiclePlates = async (): Promise<Map<string, string>> => {
  const now = Date.now()
  if (vehiclePlateCache && (now - vehiclePlateCacheTime) < CACHE_TTL) {
    return vehiclePlateCache
  }
  
  const snapshot = await db!.ref('datasheet/Xe').once('value')
  const data = snapshot.val()
  vehiclePlateCache = new Map()
  
  if (data) {
    for (const [key, vehicle] of Object.entries(data)) {
      const v = vehicle as any
      const plate = v.plate_number || v.BienSo || ''
      if (plate) {
        vehiclePlateCache.set(key, plate)
      }
    }
  }
  
  vehiclePlateCacheTime = Date.now()
  return vehiclePlateCache
}

// Helper to load and cache badges with deduplication
const loadBadgesFromDB = async (): Promise<any[]> => {
  const now = Date.now()
  
  // Return cached data if valid
  if (badgesCache && (now - badgesCacheTime) < CACHE_TTL) {
    return badgesCache
  }
  
  // If already loading, wait for that instead of starting another load
  if (cacheLoading) {
    return cacheLoading
  }
  
  // Start loading
  cacheLoading = (async () => {
    try {
      // Load from Firebase
      const [badgeSnapshot, vehiclePlates] = await Promise.all([
        db!.ref('datasheet/PHUHIEUXE').once('value'),
        loadVehiclePlates()
      ])
      const firebaseData = badgeSnapshot.val()
      
      if (!firebaseData) {
        badgesCache = []
        badgesCacheTime = Date.now()
        return []
      }
      
      // Convert and cache - use Object.values for faster iteration
      const keys = Object.keys(firebaseData)
      badgesCache = new Array(keys.length)
      
      for (let i = 0; i < keys.length; i++) {
        const badge = mapFirebaseDataToBadge(firebaseData[keys[i]])
        // Resolve vehicle_id to actual plate number
        if (badge.vehicle_id && vehiclePlates.has(badge.vehicle_id)) {
          badge.license_plate_sheet = vehiclePlates.get(badge.vehicle_id)!
        }
        badgesCache[i] = badge
      }
      
      // Sort once during caching
      badgesCache.sort((a, b) => b.badge_number.localeCompare(a.badge_number))
      badgesCacheTime = Date.now()
      
      return badgesCache
    } finally {
      cacheLoading = null
    }
  })()
  
  return cacheLoading
}

// Invalidate cache (call after create/update/delete)
export const invalidateBadgesCache = () => {
  badgesCache = null
  badgesCacheTime = 0
  cacheLoading = null
  vehiclePlateCache = null
  vehiclePlateCacheTime = 0
}

export const getAllVehicleBadges = async (req: Request, res: Response): Promise<void> => {
  try {
    const { status, badgeType, badgeColor, vehicleId, routeId, page, limit } = req.query

    // Load from cache
    let badges = await loadBadgesFromDB()

    // Apply filters
    if (status) {
      badges = badges.filter(badge => badge.status === status)
    }
    if (badgeType) {
      badges = badges.filter(badge => badge.badge_type === badgeType)
    }
    if (badgeColor) {
      badges = badges.filter(badge => badge.badge_color === badgeColor)
    }
    if (vehicleId) {
      badges = badges.filter(badge => badge.vehicle_id === vehicleId)
    }
    if (routeId) {
      badges = badges.filter(badge => badge.route_id === routeId)
    }

    // Server-side pagination
    const pageNum = parseInt(page as string) || 1
    const limitNum = parseInt(limit as string) || 0 // 0 = no limit
    
    if (limitNum > 0) {
      const startIndex = (pageNum - 1) * limitNum
      badges = badges.slice(startIndex, startIndex + limitNum)
    }

    res.json(badges)
  } catch (error) {
    console.error('Error fetching vehicle badges:', error)
    res.status(500).json({ 
      error: 'Failed to fetch vehicle badges',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

export const getVehicleBadgeById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params

    // Get active dispatch plates to compute operational_status
    const activePlates = await getActiveDispatchPlates()

    // Get data from Firebase datasheet/PHUHIEUXE path (migrated from old Firebase)
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const firebaseData = snapshot.val()

    if (!firebaseData) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    // Find badge by ID
    const badgeKey = Object.keys(firebaseData).find(key => {
      const item = firebaseData[key]
      return item.ID_PhuHieu === id
    })

    if (!badgeKey) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    const badge = mapFirebaseDataToBadge(firebaseData[badgeKey], activePlates)
    res.json(badge)
  } catch (error) {
    console.error('Error fetching vehicle badge:', error)
    res.status(500).json({ 
      error: 'Failed to fetch vehicle badge',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

export const getVehicleBadgeByPlateNumber = async (req: Request, res: Response): Promise<void> => {
  try {
    const { plateNumber } = req.params

    if (!plateNumber) {
      res.status(400).json({ error: 'Plate number is required' })
      return
    }

    // Normalize input plate number
    const normalizedInput = normalizePlate(plateNumber)

    // Get active dispatch plates to compute operational_status
    const activePlates = await getActiveDispatchPlates()

    // Get data from Firebase datasheet/PHUHIEUXE path
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const firebaseData = snapshot.val()

    if (!firebaseData) {
      res.status(404).json({ error: 'No vehicle badges found' })
      return
    }

    // Find badge by plate number (BienSoXe field)
    const badgeKey = Object.keys(firebaseData).find(key => {
      const item = firebaseData[key]
      if (!item.BienSoXe) return false
      return normalizePlate(item.BienSoXe) === normalizedInput
    })

    if (!badgeKey) {
      res.status(404).json({ error: 'Vehicle badge not found for this plate number' })
      return
    }

    const badge = mapFirebaseDataToBadge(firebaseData[badgeKey], activePlates)
    res.json(badge)
  } catch (error) {
    console.error('Error fetching vehicle badge by plate number:', error)
    res.status(500).json({
      error: 'Failed to fetch vehicle badge',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// Create a new vehicle badge
export const createVehicleBadge = async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      badge_number,
      license_plate_sheet,
      badge_type,
      badge_color,
      issue_date,
      expiry_date,
      status,
      file_code,
      issue_type,
      bus_route_ref,
      vehicle_type,
      notes,
    } = req.body

    // Validate required fields
    if (!badge_number || !license_plate_sheet) {
      res.status(400).json({ error: 'Số phù hiệu và biển số xe là bắt buộc' })
      return
    }

    // Check for duplicate badge number
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const existingData = snapshot.val() || {}
    
    const duplicateBadge = Object.values(existingData).find(
      (item: any) => item.SoPhuHieu === badge_number
    )
    if (duplicateBadge) {
      res.status(400).json({ error: 'Số phù hiệu đã tồn tại' })
      return
    }

    // Generate new ID
    const newId = `PH_${Date.now()}`
    
    // Create new badge data in Firebase format
    const newBadgeData = {
      ID_PhuHieu: newId,
      SoPhuHieu: badge_number,
      BienSoXe: license_plate_sheet,
      LoaiPH: badge_type || '',
      MauPhuHieu: badge_color || '',
      NgayCap: issue_date || '',
      NgayHetHan: expiry_date || '',
      TrangThai: status || 'Còn hiệu lực',
      MaHoSo: file_code || '',
      LoaiCap: issue_type || 'Cấp mới',
      TuyenDuong: bus_route_ref || '',
      LoaiXe: vehicle_type || '',
      GhiChu: notes || '',
      created_at: new Date().toISOString(),
    }

    // Save to Firebase
    await db!.ref(`datasheet/PHUHIEUXE/${newId}`).set(newBadgeData)

    // Invalidate cache
    invalidateBadgesCache()

    // Return mapped badge
    const createdBadge = mapFirebaseDataToBadge(newBadgeData)
    
    res.status(201).json(createdBadge)
  } catch (error) {
    console.error('Error creating vehicle badge:', error)
    res.status(500).json({
      error: 'Failed to create vehicle badge',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// Update an existing vehicle badge
export const updateVehicleBadge = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params
    const {
      badge_number,
      license_plate_sheet,
      badge_type,
      badge_color,
      issue_date,
      expiry_date,
      status,
      file_code,
      issue_type,
      bus_route_ref,
      vehicle_type,
      notes,
    } = req.body

    // Find the badge by ID
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const firebaseData = snapshot.val()

    if (!firebaseData) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    // Find badge key by ID
    const badgeKey = Object.keys(firebaseData).find(key => {
      const item = firebaseData[key]
      return item.ID_PhuHieu === id
    })

    if (!badgeKey) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    // Check for duplicate badge number (excluding current badge)
    if (badge_number) {
      const duplicateBadge = Object.entries(firebaseData).find(
        ([key, item]: [string, any]) => item.SoPhuHieu === badge_number && key !== badgeKey
      )
      if (duplicateBadge) {
        res.status(400).json({ error: 'Số phù hiệu đã tồn tại' })
        return
      }
    }

    // Update badge data
    const existingData = firebaseData[badgeKey]
    const updatedData = {
      ...existingData,
      SoPhuHieu: badge_number ?? existingData.SoPhuHieu,
      BienSoXe: license_plate_sheet ?? existingData.BienSoXe,
      LoaiPH: badge_type ?? existingData.LoaiPH,
      MauPhuHieu: badge_color ?? existingData.MauPhuHieu,
      NgayCap: issue_date ?? existingData.NgayCap,
      NgayHetHan: expiry_date ?? existingData.NgayHetHan,
      TrangThai: status ?? existingData.TrangThai,
      MaHoSo: file_code ?? existingData.MaHoSo,
      LoaiCap: issue_type ?? existingData.LoaiCap,
      TuyenDuong: bus_route_ref ?? existingData.TuyenDuong,
      LoaiXe: vehicle_type ?? existingData.LoaiXe,
      GhiChu: notes ?? existingData.GhiChu,
      updated_at: new Date().toISOString(),
    }

    // Save to Firebase
    await db!.ref(`datasheet/PHUHIEUXE/${badgeKey}`).set(updatedData)

    // Invalidate cache
    invalidateBadgesCache()

    // Return mapped badge
    const updatedBadge = mapFirebaseDataToBadge(updatedData)
    
    res.json(updatedBadge)
  } catch (error) {
    console.error('Error updating vehicle badge:', error)
    res.status(500).json({
      error: 'Failed to update vehicle badge',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

// Delete a vehicle badge
export const deleteVehicleBadge = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params

    // Find the badge by ID
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const firebaseData = snapshot.val()

    if (!firebaseData) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    // Find badge key by ID
    const badgeKey = Object.keys(firebaseData).find(key => {
      const item = firebaseData[key]
      return item.ID_PhuHieu === id
    })

    if (!badgeKey) {
      res.status(404).json({ error: 'Vehicle badge not found' })
      return
    }

    // Delete from Firebase
    await db!.ref(`datasheet/PHUHIEUXE/${badgeKey}`).remove()

    // Invalidate cache
    invalidateBadgesCache()

    res.status(204).send()
  } catch (error) {
    console.error('Error deleting vehicle badge:', error)
    res.status(500).json({
      error: 'Failed to delete vehicle badge',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}

export const getVehicleBadgeStats = async (_req: Request, res: Response): Promise<void> => {
  try {
    // Get data from Firebase datasheet/PHUHIEUXE path (migrated from old Firebase)
    const snapshot = await db!.ref('datasheet/PHUHIEUXE').once('value')
    const firebaseData = snapshot.val()

    if (!firebaseData) {
      res.json({
        total: 0,
        active: 0,
        expired: 0,
        expiringSoon: 0,
      })
      return
    }

    // Convert to array and map
    const badges = Object.keys(firebaseData).map(key => mapFirebaseDataToBadge(firebaseData[key]))

    // Calculate stats
    const totalCount = badges.length
    const activeCount = badges.filter(b => b.status === 'active').length
    const expiredCount = badges.filter(b => b.status === 'expired').length

    // Get badges expiring soon (within 30 days)
    const thirtyDaysFromNow = new Date()
    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30)

    const expiringSoonCount = badges.filter(b => {
      if (b.status !== 'active' || !b.expiry_date) return false
      // Handle both DD/MM/YYYY and YYYY-MM-DD formats
      let expiryDate: Date
      if (b.expiry_date.includes('/')) {
        const [day, month, year] = b.expiry_date.split('/')
        expiryDate = new Date(`${year}-${month}-${day}`)
      } else {
        expiryDate = new Date(b.expiry_date)
      }
      return expiryDate <= thirtyDaysFromNow && expiryDate >= new Date()
    }).length

    res.json({
      total: totalCount,
      active: activeCount,
      expired: expiredCount,
      expiringSoon: expiringSoonCount,
    })
  } catch (error) {
    console.error('Error fetching vehicle badge stats:', error)
    res.status(500).json({ 
      error: 'Failed to fetch vehicle badge statistics',
      details: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}
</file>

<file path="server/src/modules/fleet/controllers/vehicle.controller.ts">
/**
 * Vehicle Controller
 * Handles HTTP requests for vehicle operations
 */

import { Request, Response } from 'express';
import { AuthRequest } from '../../../middleware/auth.js';
import { firebase } from '../../../config/database.js';
import { syncVehicleChanges } from '../../../utils/denormalization-sync.js';
import { validateCreateVehicle, validateUpdateVehicle } from '../fleet-validation.js';
import { mapVehicleToAPI, mapAuditLogToAPI } from '../fleet-mappers.js';
import { vehicleService } from '../services/vehicle.service.js';
import type { VehicleDocumentDB, DocumentType } from '../fleet-types.js';

const DOCUMENT_TYPES: DocumentType[] = ['registration', 'inspection', 'insurance', 'operation_permit', 'emblem'];

// ========== Document Helpers ==========

async function fetchVehicleDocuments(vehicleId: string): Promise<VehicleDocumentDB[]> {
  const { data } = await firebase.from('vehicle_documents').select('*').eq('vehicle_id', vehicleId);
  return data || [];
}

async function upsertDocuments(
  vehicleId: string,
  documents: Record<string, { number: string; issueDate: string; expiryDate: string; issuingAuthority?: string; documentUrl?: string; notes?: string }>,
  userId?: string
): Promise<void> {
  for (const type of DOCUMENT_TYPES) {
    const doc = documents[type];
    if (!doc) continue;

    const { data: existingDoc } = await firebase
      .from('vehicle_documents')
      .select('id')
      .eq('vehicle_id', vehicleId)
      .eq('document_type', type)
      .single();

    const docData = {
      document_number: doc.number,
      issue_date: doc.issueDate,
      expiry_date: doc.expiryDate,
      issuing_authority: doc.issuingAuthority || null,
      document_url: doc.documentUrl || null,
      notes: doc.notes || null,
    };

    if (existingDoc) {
      await firebase
        .from('vehicle_documents')
        .update({ ...docData, updated_by: userId || null, updated_at: new Date().toISOString() })
        .eq('id', existingDoc.id);
    } else {
      await firebase
        .from('vehicle_documents')
        .insert({ vehicle_id: vehicleId, document_type: type, ...docData, updated_by: userId || null });
    }
  }
}

// ========== Controller Handlers ==========

export const getAllVehicles = async (req: Request, res: Response) => {
  try {
    const { operatorId, isActive, includeLegacy } = req.query;
    const vehicles = await vehicleService.getAll({
      operatorId: operatorId as string | undefined,
      isActive: isActive === 'all' ? 'all' : isActive === 'false' ? false : undefined,
      includeLegacy: includeLegacy !== 'false',
    });
    return res.json(vehicles);
  } catch (error: unknown) {
    const err = error as { message?: string };
    return res.status(500).json({ error: err.message || 'Failed to fetch vehicles' });
  }
};

export const getVehicleById = async (req: Request, res: Response) => {
  try {
    const vehicle = await vehicleService.getById(req.params.id);
    return res.json(vehicle);
  } catch (error: unknown) {
    const err = error as { name?: string; message?: string };
    if (err.message?.includes('not found')) {
      return res.status(404).json({ error: err.message });
    }
    return res.status(500).json({ error: err.message || 'Failed to fetch vehicle' });
  }
};

export const createVehicle = async (req: Request, res: Response) => {
  try {
    const validated = validateCreateVehicle(req.body);
    const { data: vehicle, error } = await firebase
      .from('vehicles')
      .insert({
        plate_number: validated.plateNumber,
        vehicle_type_id: validated.vehicleTypeId || null,
        operator_id: validated.operatorId || null,
        seat_capacity: validated.seatCapacity,
        bed_capacity: validated.bedCapacity || 0,
        chassis_number: validated.chassisNumber || null,
        engine_number: validated.engineNumber || null,
        image_url: validated.imageUrl || null,
        insurance_expiry_date: validated.insuranceExpiryDate || null,
        inspection_expiry_date: validated.inspectionExpiryDate || null,
        cargo_length: validated.cargoLength || null,
        cargo_width: validated.cargoWidth || null,
        cargo_height: validated.cargoHeight || null,
        gps_provider: validated.gpsProvider || null,
        gps_username: validated.gpsUsername || null,
        gps_password: validated.gpsPassword || null,
        province: validated.province || null,
        notes: validated.notes || null,
        is_active: true,
      })
      .select('*')
      .single();

    if (error) throw error;

    // Fetch relations
    let operator = null, vehicleType = null;
    if (vehicle.operator_id) {
      const { data: op } = await firebase.from('operators').select('id, name, code').eq('id', vehicle.operator_id).single();
      operator = op;
    }
    if (vehicle.vehicle_type_id) {
      const { data: vt } = await firebase.from('vehicle_types').select('id, name').eq('id', vehicle.vehicle_type_id).single();
      vehicleType = vt;
    }

    if (validated.documents) {
      await upsertDocuments(vehicle.id, validated.documents as Record<string, { number: string; issueDate: string; expiryDate: string; issuingAuthority?: string; documentUrl?: string; notes?: string }>);
    }

    const documents = await fetchVehicleDocuments(vehicle.id);
    return res.status(201).json(mapVehicleToAPI(vehicle, documents, operator, vehicleType));
  } catch (error: unknown) {
    const err = error as { code?: string; name?: string; errors?: Array<{ message: string }>; message?: string };
    if (err.code === '23505') return res.status(409).json({ error: 'Vehicle with this plate number already exists' });
    if (err.name === 'ZodError') return res.status(400).json({ error: err.errors?.[0]?.message });
    return res.status(500).json({ error: err.message || 'Failed to create vehicle' });
  }
};

export const updateVehicle = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;
    const validated = validateUpdateVehicle(req.body);

    const updateData: Record<string, unknown> = {};
    if (validated.plateNumber) updateData.plate_number = validated.plateNumber;
    if (validated.vehicleTypeId !== undefined) updateData.vehicle_type_id = validated.vehicleTypeId || null;
    if ('operatorId' in req.body) {
      updateData.operator_id = req.body.operatorId?.trim() || null;
    } else if (validated.operatorId !== undefined) {
      updateData.operator_id = validated.operatorId || null;
    }
    if (validated.seatCapacity) updateData.seat_capacity = validated.seatCapacity;
    if (validated.bedCapacity !== undefined) updateData.bed_capacity = validated.bedCapacity || 0;
    if (validated.chassisNumber !== undefined) updateData.chassis_number = validated.chassisNumber || null;
    if (validated.engineNumber !== undefined) updateData.engine_number = validated.engineNumber || null;
    if (validated.imageUrl !== undefined) updateData.image_url = validated.imageUrl || null;
    if (validated.insuranceExpiryDate !== undefined) updateData.insurance_expiry_date = validated.insuranceExpiryDate || null;
    if (validated.inspectionExpiryDate !== undefined) updateData.inspection_expiry_date = validated.inspectionExpiryDate || null;
    if (validated.cargoLength !== undefined) updateData.cargo_length = validated.cargoLength || null;
    if (validated.cargoWidth !== undefined) updateData.cargo_width = validated.cargoWidth || null;
    if (validated.cargoHeight !== undefined) updateData.cargo_height = validated.cargoHeight || null;
    if (validated.gpsProvider !== undefined) updateData.gps_provider = validated.gpsProvider || null;
    if (validated.gpsUsername !== undefined) updateData.gps_username = validated.gpsUsername || null;
    if (validated.gpsPassword !== undefined) updateData.gps_password = validated.gpsPassword || null;
    if (validated.province !== undefined) updateData.province = validated.province || null;
    if (validated.notes !== undefined) updateData.notes = validated.notes || null;

    if (Object.keys(updateData).length > 0) {
      const { error } = await firebase.from('vehicles').update(updateData).eq('id', id);
      if (error) throw error;
    }

    if (validated.documents) {
      await upsertDocuments(id, validated.documents as Record<string, { number: string; issueDate: string; expiryDate: string; issuingAuthority?: string; documentUrl?: string; notes?: string }>, userId);
    }

    const { data: vehicle } = await firebase.from('vehicles').select('*').eq('id', id).single();
    if (!vehicle) return res.status(404).json({ error: 'Vehicle not found after update' });

    let operator = null, vehicleType = null;
    if (vehicle.operator_id) {
      const { data: op } = await firebase.from('operators').select('id, name, code').eq('id', vehicle.operator_id).single();
      operator = op;
    }
    if (vehicle.vehicle_type_id) {
      const { data: vt } = await firebase.from('vehicle_types').select('id, name').eq('id', vehicle.vehicle_type_id).single();
      vehicleType = vt;
    }

    if (updateData.plate_number || updateData.operator_id !== undefined) {
      syncVehicleChanges(id, {
        plateNumber: vehicle.plate_number,
        operatorId: vehicle.operator_id,
        operatorName: operator?.name || null,
        operatorCode: operator?.code || null,
      }).catch((err) => console.error('[Vehicle Update] Sync failed:', err));
    }

    const documents = await fetchVehicleDocuments(id);
    return res.json(mapVehicleToAPI(vehicle, documents, operator, vehicleType));
  } catch (error: unknown) {
    const err = error as { name?: string; errors?: Array<{ message: string }>; message?: string };
    if (err.name === 'ZodError') return res.status(400).json({ error: err.errors?.[0]?.message });
    return res.status(500).json({ error: err.message || 'Failed to update vehicle' });
  }
};

export const deleteVehicle = async (req: Request, res: Response) => {
  try {
    const { data, error } = await firebase
      .from('vehicles')
      .update({ is_active: false })
      .eq('id', req.params.id)
      .select()
      .single();

    if (error) throw error;
    if (!data) return res.status(404).json({ error: 'Vehicle not found' });
    return res.json({ id: data.id, isActive: data.is_active, message: 'Vehicle deleted successfully' });
  } catch (error: unknown) {
    const err = error as { message?: string };
    return res.status(500).json({ error: err.message || 'Failed to delete vehicle' });
  }
};

export const getVehicleDocumentAuditLogs = async (req: Request, res: Response) => {
  try {
    const { id: vehicleId } = req.params;
    if (!vehicleId) return res.status(400).json({ error: 'Vehicle ID is required' });

    const { data: vehicleDocs, error: docsError } = await firebase
      .from('vehicle_documents')
      .select('id')
      .eq('vehicle_id', vehicleId);

    if (docsError) throw docsError;
    const docIds = vehicleDocs?.map((doc: { id: string }) => doc.id) || [];
    if (docIds.length === 0) return res.json([]);

    const { data: auditLogs, error: auditError } = await firebase
      .from('audit_logs')
      .select('*, users:user_id(id, full_name, username)')
      .eq('table_name', 'vehicle_documents')
      .in('record_id', docIds)
      .order('created_at', { ascending: false });

    if (auditError) throw auditError;
    return res.json(auditLogs?.map(mapAuditLogToAPI) || []);
  } catch (error: unknown) {
    const err = error as { message?: string };
    return res.status(500).json({ error: err.message || 'Failed to fetch audit logs' });
  }
};

/**
 * Get all document audit logs for all vehicles (optimized single query)
 */
export const getAllDocumentAuditLogs = async (_req: Request, res: Response) => {
  try {
    // Get all audit logs for vehicle_documents in one query
    const { data: auditLogs, error: auditError } = await firebase
      .from('audit_logs')
      .select('*')
      .eq('table_name', 'vehicle_documents')
      .order('created_at', { ascending: false })
      .limit(500);

    if (auditError) throw auditError;
    if (!auditLogs || auditLogs.length === 0) return res.json([]);

    // Get unique vehicle_document IDs
    const docIds = [...new Set(auditLogs.map((log: any) => log.record_id))];

    // Fetch vehicle_documents to get vehicle_id
    const { data: vehicleDocs } = await firebase
      .from('vehicle_documents')
      .select('id, vehicle_id')
      .in('id', docIds);

    const docToVehicleMap = new Map(
      (vehicleDocs || []).map((doc: any) => [doc.id, doc.vehicle_id])
    );

    // Get unique vehicle IDs
    const vehicleIds = [...new Set(
      (vehicleDocs || []).map((doc: any) => doc.vehicle_id).filter(Boolean)
    )];

    // Fetch vehicles to get plate numbers
    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id, plate_number')
      .in('id', vehicleIds);

    const vehicleMap = new Map(
      (vehicles || []).map((v: any) => [v.id, v.plate_number])
    );

    // Fetch users for names
    const userIds = [...new Set(auditLogs.map((log: any) => log.user_id).filter(Boolean))];
    const { data: users } = await firebase
      .from('users')
      .select('id, full_name, username')
      .in('id', userIds);

    const userMap = new Map(
      (users || []).map((u: any) => [u.id, u.full_name || u.username || 'Không xác định'])
    );

    // Format response
    const formattedLogs = auditLogs.map((log: any) => {
      const vehicleId = docToVehicleMap.get(log.record_id);
      const plateNumber = vehicleId ? vehicleMap.get(vehicleId) : null;

      return {
        id: log.id,
        userId: log.user_id,
        userName: userMap.get(log.user_id) || 'Không xác định',
        action: log.action,
        recordId: log.record_id,
        oldValues: log.old_values,
        newValues: log.new_values,
        createdAt: log.created_at,
        vehiclePlateNumber: plateNumber || '-',
      };
    });

    return res.json(formattedLogs);
  } catch (error: unknown) {
    const err = error as { message?: string };
    console.error('Error fetching all document audit logs:', err);
    return res.status(500).json({ error: err.message || 'Failed to fetch audit logs' });
  }
};
</file>

<file path="server/src/utils/denormalization.ts">
/**
 * Denormalization utilities for Firebase RTDB optimization
 *
 * These utilities help fetch and build denormalized data for dispatch_records
 * to reduce the number of queries needed when reading dispatch data.
 */

import { firebase, firebaseDb } from '../config/database.js'

export interface DenormalizedVehicleData {
  plateNumber: string
  operatorId: string | null
  operatorName: string | null
  operatorCode: string | null
}

export interface DenormalizedDriverData {
  fullName: string
}

export interface DenormalizedRouteData {
  name: string | null
  type: string | null
  destinationId: string | null
  destinationName: string | null
  destinationCode: string | null
}

export interface DenormalizedUserData {
  fullName: string | null
}

export interface DenormalizedData {
  vehicle: DenormalizedVehicleData
  driver: DenormalizedDriverData
  route: DenormalizedRouteData | null
  user: DenormalizedUserData | null
}

/**
 * Fetches vehicle data from legacy datasheet/Xe
 */
async function fetchLegacyVehicle(legacyKey: string): Promise<DenormalizedVehicleData> {
  try {
    const snapshot = await firebaseDb.ref(`datasheet/Xe/${legacyKey}`).once('value')
    const data = snapshot.val()
    if (!data) {
      return { plateNumber: '', operatorId: null, operatorName: null, operatorCode: null }
    }
    return {
      plateNumber: data.plate_number || data.BienSo || '',
      operatorId: null,
      operatorName: data.owner_name || data.TenDangKyXe || null,
      operatorCode: null,
    }
  } catch (error) {
    console.error('Failed to fetch legacy vehicle:', error)
    return { plateNumber: '', operatorId: null, operatorName: null, operatorCode: null }
  }
}

/**
 * Fetches vehicle data from badge datasheet/PHUHIEUXE
 */
async function fetchBadgeVehicle(badgeKey: string): Promise<DenormalizedVehicleData> {
  try {
    const snapshot = await firebaseDb.ref(`datasheet/PHUHIEUXE/${badgeKey}`).once('value')
    const data = snapshot.val()
    if (!data) {
      return { plateNumber: '', operatorId: null, operatorName: null, operatorCode: null }
    }
    return {
      plateNumber: data.BienSoXe || '',
      operatorId: null,
      operatorName: null,
      operatorCode: null,
    }
  } catch (error) {
    console.error('Failed to fetch badge vehicle:', error)
    return { plateNumber: '', operatorId: null, operatorName: null, operatorCode: null }
  }
}

/**
 * Fetches denormalized data for a dispatch record in parallel
 * to minimize database round trips while capturing all related entity names
 * Supports legacy vehicles (legacy_xxx) and badge vehicles (badge_xxx)
 */
export async function fetchDenormalizedData(params: {
  vehicleId: string
  driverId?: string | null  // Optional - bypass driver requirement
  routeId?: string | null
  userId?: string | null
}): Promise<DenormalizedData> {
  console.log('[fetchDenormalizedData] params:', JSON.stringify(params))
  
  // Check if vehicleId is legacy or badge
  const isLegacyVehicle = params.vehicleId.startsWith('legacy_')
  const isBadgeVehicle = params.vehicleId.startsWith('badge_')
  console.log('[fetchDenormalizedData] isLegacy:', isLegacyVehicle, 'isBadge:', isBadgeVehicle)

  let vehicleData: DenormalizedVehicleData

  if (isLegacyVehicle) {
    // Extract key from legacy_xxx format
    const legacyKey = params.vehicleId.replace('legacy_', '')
    console.log('[fetchDenormalizedData] Fetching legacy vehicle with key:', legacyKey)
    vehicleData = await fetchLegacyVehicle(legacyKey)
    console.log('[fetchDenormalizedData] Legacy vehicle data:', JSON.stringify(vehicleData))
  } else if (isBadgeVehicle) {
    // Extract key from badge_xxx format
    const badgeKey = params.vehicleId.replace('badge_', '')
    vehicleData = await fetchBadgeVehicle(badgeKey)
  } else {
    // Normal vehicle from vehicles table
    const { data: vehicle } = await firebase.from('vehicles')
      .select('id, plate_number, operator_id')
      .eq('id', params.vehicleId)
      .single()

    let operatorData = null
    if (vehicle?.operator_id) {
      const { data: op } = await firebase.from('operators').select('id, name, code').eq('id', vehicle.operator_id).single()
      operatorData = op
    }

    vehicleData = {
      plateNumber: vehicle?.plate_number || '',
      operatorId: vehicle?.operator_id || null,
      operatorName: operatorData?.name || null,
      operatorCode: operatorData?.code || null,
    }
  }

  // Fetch other entities in parallel
  const [driverResult, routeResult, userResult] = await Promise.all([
    params.driverId ? firebase.from('drivers')
      .select('id, full_name')
      .eq('id', params.driverId)
      .single() : Promise.resolve({ data: null }),
    params.routeId ? firebase.from('routes')
      .select('id, route_name, route_type, destination_id')
      .eq('id', params.routeId)
      .single() : Promise.resolve({ data: null }),
    params.userId ? firebase.from('users')
      .select('id, full_name')
      .eq('id', params.userId)
      .single() : Promise.resolve({ data: null })
  ])

  const driver = driverResult.data
  const route = routeResult.data
  const user = userResult.data

  // Fetch destination if route has one
  let destinationData = null
  if (route?.destination_id) {
    const { data: dest } = await firebase.from('destinations').select('id, name, code').eq('id', route.destination_id).single()
    destinationData = dest
  }

  return {
    vehicle: vehicleData,
    driver: {
      fullName: driver?.full_name || '',
    },
    route: route ? {
      name: route.route_name || null,
      type: route.route_type || null,
      destinationId: destinationData?.id || null,
      destinationName: destinationData?.name || null,
      destinationCode: destinationData?.code || null,
    } : null,
    user: user ? {
      fullName: user.full_name || null,
    } : null,
  }
}

/**
 * Builds the denormalized fields object for database insert/update
 */
export function buildDenormalizedFields(data: DenormalizedData) {
  return {
    // Vehicle denormalized data
    vehicle_plate_number: data.vehicle.plateNumber,
    vehicle_operator_id: data.vehicle.operatorId,
    vehicle_operator_name: data.vehicle.operatorName,
    vehicle_operator_code: data.vehicle.operatorCode,

    // Driver denormalized data
    driver_full_name: data.driver.fullName,

    // Route denormalized data
    route_name: data.route?.name || null,
    route_type: data.route?.type || null,
    route_destination_id: data.route?.destinationId || null,
    route_destination_name: data.route?.destinationName || null,
    route_destination_code: data.route?.destinationCode || null,
  }
}

/**
 * Fetches user name by ID for workflow functions
 * Returns null if userId is not provided or user not found
 */
export async function fetchUserName(userId: string | null | undefined): Promise<string | null> {
  if (!userId) return null

  const { data } = await firebase
    .from('users')
    .select('id, full_name')
    .eq('id', userId)
    .single()

  return data?.full_name || null
}

/**
 * Fetches route denormalized data by ID
 * Used when route is updated during workflow
 */
export async function fetchRouteData(routeId: string | null | undefined): Promise<DenormalizedRouteData | null> {
  if (!routeId) return null

  const { data: route } = await firebase
    .from('routes')
    .select('id, route_name, route_type, destination:destination_id(id, name, code)')
    .eq('id', routeId)
    .single()

  if (!route) return null

  const destinationData = route.destination
    ? (Array.isArray(route.destination) ? route.destination[0] : route.destination)
    : null

  return {
    name: route.route_name || null,
    type: route.route_type || null,
    destinationId: destinationData?.id || null,
    destinationName: destinationData?.name || null,
    destinationCode: destinationData?.code || null,
  }
}

/**
 * Builds route denormalized fields for database update
 */
export function buildRouteDenormalizedFields(routeData: DenormalizedRouteData | null) {
  if (!routeData) {
    return {
      route_name: null,
      route_type: null,
      route_destination_id: null,
      route_destination_name: null,
      route_destination_code: null,
    }
  }

  return {
    route_name: routeData.name,
    route_type: routeData.type,
    route_destination_id: routeData.destinationId,
    route_destination_name: routeData.destinationName,
    route_destination_code: routeData.destinationCode,
  }
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.pnpm-store/

# Build outputs
dist/
dist-ssr/
build/
.next/

# Environment variables
.env
.env.*
*.env

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# IDE & Editor
.idea/
.vscode/*
!.vscode/extensions.json
*.swp
*.swo
*.sw?
*.suo
*.ntvs*
*.njsproj
*.sln
*~

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Testing
coverage/
.nyc_output/

# Temporary files
tmp/
temp/
*.tmp
*.local

# Uploads (keep folder but ignore contents)
server/uploads/*
!server/uploads/.gitkeep

# Firebase
.firebase/
firebase-debug.log
firestore-debug.log
ui-debug.log
firebase-debug.*.log
*-debug.log
firebase-service-account.json

# TypeScript
*.tsbuildinfo

# Misc
.cache/
*.pid
*.seed
*.pid.lock

# Windows artifacts
nul
NUL

# Plans folder (internal planning docs)
plans/
docs/
.claude/
.factory/
client/docs/archived/
server/docs/archived/
</file>

<file path="client/src/pages/Dashboard.tsx">
import { useState, useEffect } from "react";
import {
  RefreshCw,
  Clock,
} from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { DocumentWarningsTable } from "@/components/dashboard/DocumentWarningsTable";
import { EditDocumentDialog } from "@/components/dashboard/EditDocumentDialog";
import { VehicleHistoryTable } from "@/components/dashboard/VehicleHistoryTable";
import {
  TrendStatCard,
} from "@/components/dashboard/stats";
import { format } from "date-fns";
import { dashboardService } from "@/services/dashboard.service";
import type { DashboardStats, ChartDataPoint, RecentActivity, Warning, WeeklyStat, MonthlyStat, RouteBreakdown } from "@/services/dashboard.service";
import { useUIStore } from "@/store/ui.store";
import { cn } from "@/lib/utils";

// Chart components (to be implemented in Phase 2-4)
import { VehicleTrendChart } from "@/components/dashboard/charts/VehicleTrendChart";
import { WeeklyProgressChart } from "@/components/dashboard/charts/WeeklyProgressChart";
import { VehiclesByStatusChart } from "@/components/dashboard/charts/VehiclesByStatusChart";
import { VehiclesByRouteChart } from "@/components/dashboard/charts/VehiclesByRouteChart";
import { MonthlyBreakdownChart } from "@/components/dashboard/charts/MonthlyBreakdownChart";

export default function Dashboard() {
  const [stats, setStats] = useState<DashboardStats>({
    totalVehiclesToday: 0,
    vehiclesInStation: 0,
    vehiclesDepartedToday: 0,
    revenueToday: 0,
    invalidVehicles: 0,
  });
  const [chartData, setChartData] = useState<ChartDataPoint[]>([]);
  const [recentActivity, setRecentActivity] = useState<RecentActivity[]>([]);
  const [warnings, setWarnings] = useState<Warning[]>([]);
  const [weeklyStats, setWeeklyStats] = useState<WeeklyStat[]>([]);
  const [monthlyStats, setMonthlyStats] = useState<MonthlyStat[]>([]);
  const [routeBreakdown, setRouteBreakdown] = useState<RouteBreakdown[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [editDocumentOpen, setEditDocumentOpen] = useState(false);
  const [selectedWarning, setSelectedWarning] = useState<Warning | null>(null);
  const [vehicleHistoryOpen, setVehicleHistoryOpen] = useState(false);
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const setTitle = useUIStore((state) => state.setTitle);

  useEffect(() => {
    setTitle("Tổng quan");
    loadDashboardData();
    const interval = setInterval(loadDashboardData, 30000);
    return () => clearInterval(interval);
  }, [setTitle]);

  const loadDashboardData = async () => {
    setIsLoading(true);
    try {
      const data = await dashboardService.getDashboardData();
      setStats(data.stats);
      setChartData(data.chartData);
      setRecentActivity(data.recentActivity);
      setWarnings(data.warnings);
      setWeeklyStats(data.weeklyStats || []);
      setMonthlyStats(data.monthlyStats || []);
      setRouteBreakdown(data.routeBreakdown || []);
      setLastUpdated(new Date());
    } catch (error) {
      console.error("Failed to load dashboard data:", error);
      try {
        const [statsData, chartDataData, activityData, warningsData] = await Promise.all([
          dashboardService.getStats().catch(() => null),
          dashboardService.getChartData().catch(() => []),
          dashboardService.getRecentActivity().catch(() => []),
          dashboardService.getWarnings().catch(() => []),
        ]);
        if (statsData) setStats(statsData);
        if (chartDataData.length > 0) setChartData(chartDataData);
        if (activityData.length > 0) setRecentActivity(activityData);
        if (warningsData.length > 0) setWarnings(warningsData);
        setLastUpdated(new Date());
      } catch {
        // Silent fail
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleEditDocument = (warning: Warning) => {
    setSelectedWarning(warning);
    setEditDocumentOpen(true);
  };

  const handleViewHistory = (warning: Warning) => {
    setSelectedWarning(warning);
    setVehicleHistoryOpen(true);
  };

  const handleSaveDocument = async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    loadDashboardData();
  };

  return (
    <div className="min-h-screen bg-[#FAFAFA]">
      <div className="p-4 lg:p-6 space-y-6">
        {/* Header */}
        <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
          <div>
            <p className="text-sm text-stone-500 mb-1">Tổng quan</p>
            <h1 className="text-3xl lg:text-4xl font-semibold text-stone-900 tracking-tight">
              Dữ liệu
            </h1>
          </div>

          <div className="flex items-center gap-3">
            <div className="hidden sm:flex items-center gap-2 px-4 py-2.5 rounded-xl bg-white border border-stone-200">
              <Clock className="w-4 h-4 text-stone-400" />
              <span className="text-sm text-stone-500">Cập nhật:</span>
              <span className="text-sm font-mono font-semibold text-stone-800">
                {format(lastUpdated, "HH:mm:ss")}
              </span>
            </div>
            <Button
              variant="outline"
              size="sm"
              className="gap-2 h-10 px-4 rounded-xl border-stone-200 bg-white hover:bg-stone-50"
              onClick={loadDashboardData}
              disabled={isLoading}
            >
              <RefreshCw className={cn("w-4 h-4", isLoading && "animate-spin")} />
              <span className="hidden sm:inline">Làm mới</span>
            </Button>
          </div>
        </div>

        {/* Overview Tab */}
        <div className="flex items-center gap-1 border-b border-stone-200 pb-2">
          <button className="px-4 py-2 text-sm font-medium text-stone-900 border-b-2 border-stone-900">
            Tổng quan
          </button>
        </div>

        {/* 6 Stat Cards Row */}
        <div className="grid grid-cols-2 md:grid-cols-3 xl:grid-cols-6 gap-4">
          <TrendStatCard
            category="Tổng xe"
            categoryColor="orange"
            value={stats.totalVehiclesToday}
            subtitle="Toàn bộ hoạt động"
            trend={{
              direction: "up",
              value: "+8%",
              description: "tuần này",
            }}
            isLoading={isLoading}
          />
          <TrendStatCard
            category="Đã xuất bến"
            categoryColor="green"
            value={stats.vehiclesDepartedToday}
            subtitle="So với hôm qua"
            trend={{
              direction: "up",
              value: "+23%",
              description: "hiệu quả",
            }}
            isLoading={isLoading}
          />
          <TrendStatCard
            category="Trong bến"
            categoryColor="blue"
            value={stats.vehiclesInStation}
            subtitle="Đang chờ xuất bến"
            trend={{
              direction: "attention",
              value: "",
              description: "Cần theo dõi",
            }}
            isLoading={isLoading}
          />
          <TrendStatCard
            category="Doanh thu"
            categoryColor="amber"
            value={stats.revenueToday}
            subtitle="VNĐ trong ngày"
            trend={{
              direction: "up",
              value: "+12%",
              description: "so với hôm qua",
            }}
            isLoading={isLoading}
            isCurrency
          />
          <TrendStatCard
            category="Hoạt động"
            categoryColor="purple"
            value={recentActivity.length}
            subtitle="Cập nhật mới"
            trend={{
              direction: "up",
              value: "",
              description: "Đang hoạt động",
            }}
            isLoading={isLoading}
          />
          <TrendStatCard
            category="Cảnh báo"
            categoryColor="rose"
            value={warnings.length}
            subtitle="Giấy tờ hết hạn"
            trend={{
              direction: warnings.length > 0 ? "attention" : "up",
              value: warnings.length > 0 ? `${warnings.length}` : "",
              description: warnings.length > 0 ? "cần xử lý" : "Ổn định",
            }}
            isLoading={isLoading}
          />
        </div>

        {/* Charts Row 1: Trend + Weekly Progress */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Vehicle Trend Chart - 2/3 width */}
          <Card className="lg:col-span-2 border border-stone-200 bg-white rounded-xl">
            <CardHeader className="pb-2">
              <CardTitle className="text-base font-semibold text-stone-900">
                Xu hướng hoạt động xe
              </CardTitle>
            </CardHeader>
            <CardContent>
              <VehicleTrendChart data={chartData} isLoading={isLoading} />
            </CardContent>
          </Card>

          {/* Weekly Progress Chart - 1/3 width */}
          <Card className="border border-stone-200 bg-white rounded-xl">
            <CardHeader className="pb-2">
              <CardTitle className="text-base font-semibold text-stone-900">
                Tiến độ tuần
              </CardTitle>
            </CardHeader>
            <CardContent>
              <WeeklyProgressChart data={weeklyStats} isLoading={isLoading} />
            </CardContent>
          </Card>
        </div>

        {/* Charts Row 2: Status + Route + Monthly Breakdown */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {/* Vehicles by Status - Donut */}
          <Card className="border border-stone-200 bg-white rounded-xl">
            <CardHeader className="pb-2">
              <CardTitle className="text-base font-semibold text-stone-900">
                Xe theo trạng thái
              </CardTitle>
            </CardHeader>
            <CardContent>
              <VehiclesByStatusChart
                inStation={stats.vehiclesInStation}
                departed={stats.vehiclesDepartedToday}
                total={stats.totalVehiclesToday}
                isLoading={isLoading}
              />
            </CardContent>
          </Card>

          {/* Vehicles by Route - Donut */}
          <Card className="border border-stone-200 bg-white rounded-xl">
            <CardHeader className="pb-2">
              <CardTitle className="text-base font-semibold text-stone-900">
                Xe theo tuyến
              </CardTitle>
            </CardHeader>
            <CardContent>
              <VehiclesByRouteChart
                data={routeBreakdown}
                isLoading={isLoading}
              />
            </CardContent>
          </Card>

          {/* Monthly Breakdown - Stacked Bar */}
          <Card className="border border-stone-200 bg-white rounded-xl">
            <CardHeader className="pb-2">
              <div className="flex items-center justify-between">
                <CardTitle className="text-base font-semibold text-stone-900">
                  Thống kê theo tháng
                </CardTitle>
                <div className="flex items-center gap-3 text-xs">
                  <div className="flex items-center gap-1">
                    <span className="w-2 h-2 rounded-full bg-emerald-500" />
                    <span className="text-stone-500">Xuất bến</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <span className="w-2 h-2 rounded-full bg-amber-500" />
                    <span className="text-stone-500">Chờ</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <span className="w-2 h-2 rounded-full bg-stone-300" />
                    <span className="text-stone-500">Khác</span>
                  </div>
                </div>
              </div>
            </CardHeader>
            <CardContent>
              <MonthlyBreakdownChart data={monthlyStats} isLoading={isLoading} />
            </CardContent>
          </Card>
        </div>

        {/* Warnings Table */}
        <DocumentWarningsTable
          warnings={warnings}
          isLoading={isLoading}
          onEditDocument={handleEditDocument}
          onViewHistory={handleViewHistory}
        />
      </div>

      {/* Dialogs */}
      <EditDocumentDialog
        open={editDocumentOpen}
        onOpenChange={setEditDocumentOpen}
        warning={selectedWarning}
        onSave={handleSaveDocument}
      />

      <VehicleHistoryTable
        open={vehicleHistoryOpen}
        onOpenChange={setVehicleHistoryOpen}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/QuanLyXe.tsx">
import { useState, useEffect, useMemo } from "react"
import { toast } from "react-toastify"
import { 
  Plus, 
  Search, 
  Edit, 
  Eye, 
  Trash2, 
  Car,
  ChevronLeft,
  ChevronRight,
  LayoutGrid,
  List,
  Calendar,
  Building2,
  Users,
  AlertCircle,
  TrendingUp,
  RefreshCw,
  SlidersHorizontal,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog"
import { vehicleService, VehicleForm, VehicleView } from "@/features/fleet/vehicles"
import { type VehicleBadge } from "@/services/vehicle-badge.service"
import { quanlyDataService } from "@/services/quanly-data.service"
import type { Vehicle } from "@/types"
import { useUIStore } from "@/store/ui.store"
import { format, isValid, parseISO } from "date-fns"

// Allowed badge types for filtering (same as QuanLyPhuHieuXe)
const ALLOWED_BADGE_TYPES = ["Buýt", "Tuyến cố định"]

// Helper functions
const getVehicleTypeName = (vehicle: Vehicle): string => {
  const v = vehicle as any
  return vehicle.vehicleType?.name || v.vehicleTypeName || v.vehicleType || ""
}

const getOperatorName = (vehicle: Vehicle): string => {
  const v = vehicle as any
  return vehicle.operator?.name || v.operatorName || ""
}

const formatDate = (dateString: string | undefined | null): string => {
  if (!dateString) return "N/A"
  if (dateString.includes('/')) return dateString
  const date = typeof dateString === 'string' ? parseISO(dateString) : new Date(dateString)
  return isValid(date) ? format(date, "dd/MM/yyyy") : "N/A"
}

// Skeleton Row Component
const SkeletonRow = () => (
  <tr className="animate-pulse">
    <td className="px-6 py-4"><div className="h-10 w-32 bg-slate-200 rounded-xl" /></td>
    <td className="px-6 py-4"><div className="h-4 w-24 bg-slate-200 rounded" /></td>
    <td className="px-6 py-4 text-center"><div className="h-8 w-8 bg-slate-200 rounded-lg mx-auto" /></td>
    <td className="px-6 py-4"><div className="h-4 w-40 bg-slate-200 rounded" /></td>
    <td className="px-6 py-4 text-center"><div className="h-4 w-24 bg-slate-200 rounded mx-auto" /></td>
    <td className="px-6 py-4 text-center"><div className="h-6 w-20 bg-slate-200 rounded-full mx-auto" /></td>
    <td className="px-6 py-4"><div className="h-8 w-24 bg-slate-200 rounded mx-auto" /></td>
  </tr>
)

// Quick Filter Chip
const QuickFilter = ({ label, count, active, onClick }: { 
  label: string; count?: number; active?: boolean; onClick: () => void 
}) => (
  <button
    onClick={onClick}
    className={`px-4 py-2 rounded-xl text-sm font-medium transition-all ${
      active 
        ? "bg-sky-500 text-white shadow-md shadow-sky-500/25" 
        : "bg-slate-100 text-slate-600 hover:bg-slate-200"
    }`}
  >
    {label}
    {count !== undefined && (
      <span className={`ml-2 px-2 py-0.5 rounded-full text-xs ${
        active ? "bg-white/20 text-white" : "bg-slate-200 text-slate-500"
      }`}>
        {count.toLocaleString()}
      </span>
    )}
  </button>
)

const ITEMS_PER_PAGE = 20

export default function QuanLyXe() {
  const [vehicles, setVehicles] = useState<Vehicle[]>([])
  const [badges, setBadges] = useState<VehicleBadge[]>([])
  const [operatorCount, setOperatorCount] = useState(0)
  const [searchQuery, setSearchQuery] = useState("")
  const [filterVehicleType, setFilterVehicleType] = useState("")
  const [filterOperator, setFilterOperator] = useState("")
  const [filterStatus, setFilterStatus] = useState("")
  const [quickFilter, setQuickFilter] = useState<"all" | "active" | "inactive">("all")
  const [isLoading, setIsLoading] = useState(false)
  const [selectedVehicle, setSelectedVehicle] = useState<Vehicle | null>(null)
  const [dialogOpen, setDialogOpen] = useState(false)
  const [viewMode, setViewMode] = useState<"create" | "edit" | "view">("create")
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const [vehicleToDelete, setVehicleToDelete] = useState<Vehicle | null>(null)
  const [currentPage, setCurrentPage] = useState(1)
  const [displayMode, setDisplayMode] = useState<"table" | "grid">("table")
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false)
  const setTitle = useUIStore((state) => state.setTitle)

  useEffect(() => {
    setTitle("Quản lý xe")
    loadData()
  }, [setTitle])

  const loadData = async (forceRefresh = false) => {
    setIsLoading(true)
    try {
      // Use optimized unified endpoint - single request for all data (include operators for stats)
      const data = await quanlyDataService.getAll(['badges', 'vehicles', 'operators'], forceRefresh)
      
      // Debug: log sample vehicle from API response
      if (data.vehicles && data.vehicles.length > 0) {
        console.log('[QuanLyXe] Sample vehicle from API:', data.vehicles[0])
      }
      
      // Convert to expected formats
      const vehicleData: Vehicle[] = (data.vehicles || []).map(v => ({
        id: v.id,
        plateNumber: v.plateNumber,
        seatCapacity: v.seatCapacity,
        operatorName: v.operatorName || '',
        vehicleTypeName: v.vehicleType || '',  // Use vehicleTypeName for helper compatibility
        inspectionExpiryDate: v.inspectionExpiryDate,
        isActive: v.isActive,
        source: 'badge',  // Mark as badge so frontend filter passes them through
      } as any))
      
      const badgeData: VehicleBadge[] = (data.badges || []).map(b => ({
        ...b,
        vehicle_id: b.license_plate_sheet,
        operational_status: 'trong_ben' as const,
      } as any))
      
      setVehicles(vehicleData)
      setBadges(badgeData)
      setOperatorCount((data.operators || []).length)  // Use operators count from same data source
    } catch (error) {
      console.error("Failed to load data:", error)
      toast.error("Không thể tải danh sách xe. Vui lòng thử lại sau.")
    } finally {
      setIsLoading(false)
    }
  }

  // Get plate numbers from badges with allowed types (Buýt, Tuyến cố định)
  const allowedPlateNumbers = useMemo(() => {
    const plates = new Set<string>()
    badges.forEach(badge => {
      if (ALLOWED_BADGE_TYPES.includes(badge.badge_type || "")) {
        plates.add(badge.license_plate_sheet.toUpperCase().replace(/\s+/g, ""))
      }
    })
    return plates
  }, [badges])

  // Filter vehicles by: badge source OR plate matches Buýt/Tuyến cố định badges
  const vehiclesWithAllowedTypes = useMemo(() => {
    return vehicles.filter((vehicle: Vehicle & { source?: string }) => {
      // Badge vehicles are already filtered by backend (Buýt/Tuyến cố định only)
      if (vehicle.source === "badge") {
        return true
      }
      
      // For legacy/db vehicles, check if plate matches allowed badges
      const plateNormalized = (vehicle.plateNumber || "").toUpperCase().replace(/\s+/g, "")
      return allowedPlateNumbers.has(plateNormalized)
    })
  }, [vehicles, allowedPlateNumbers])

  // Get unique vehicle types and operators for filter options (from filtered vehicles only)
  const vehicleTypes = useMemo(() => 
    Array.from(new Set(vehiclesWithAllowedTypes.map(getVehicleTypeName).filter(Boolean))).sort(),
    [vehiclesWithAllowedTypes]
  )
  const operatorNames = useMemo(() => 
    Array.from(new Set(vehiclesWithAllowedTypes.map(getOperatorName).filter(Boolean))).sort(),
    [vehiclesWithAllowedTypes]
  )

  // Stats calculations (from filtered vehicles only)
  const stats = useMemo(() => {
    const active = vehiclesWithAllowedTypes.filter(v => v.isActive).length
    const inactive = vehiclesWithAllowedTypes.length - active
    // Use operatorCount from same data source as Đơn vị vận tải page for consistency
    return { total: vehiclesWithAllowedTypes.length, active, inactive, uniqueOperators: operatorCount }
  }, [vehiclesWithAllowedTypes, operatorCount])

  const filteredVehicles = useMemo(() => {
    return vehiclesWithAllowedTypes.filter((vehicle: Vehicle) => {
      const vehicleTypeName = getVehicleTypeName(vehicle)
      const operatorName = getOperatorName(vehicle)

      // Quick filter
      if (quickFilter === "active" && !vehicle.isActive) return false
      if (quickFilter === "inactive" && vehicle.isActive) return false

      if (searchQuery) {
        const query = searchQuery.toLowerCase()
        const matchesSearch =
          (vehicle.plateNumber?.toLowerCase() || "").includes(query) ||
          (vehicle.chassisNumber?.toLowerCase() || "").includes(query) ||
          operatorName.toLowerCase().includes(query) ||
          vehicleTypeName.toLowerCase().includes(query)
        if (!matchesSearch) return false
      }

      if (filterVehicleType && vehicleTypeName !== filterVehicleType) return false
      if (filterOperator && operatorName !== filterOperator) return false
      if (filterStatus) {
        const isActive = filterStatus === "active"
        if (vehicle.isActive !== isActive) return false
      }

      return true
    })
  }, [vehiclesWithAllowedTypes, searchQuery, filterVehicleType, filterOperator, filterStatus, quickFilter])

  // Pagination
  const totalPages = Math.ceil(filteredVehicles.length / ITEMS_PER_PAGE)
  const paginatedVehicles = useMemo(() => {
    const start = (currentPage - 1) * ITEMS_PER_PAGE
    return filteredVehicles.slice(start, start + ITEMS_PER_PAGE)
  }, [filteredVehicles, currentPage])

  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, filterVehicleType, filterOperator, filterStatus, quickFilter])

  const handleCreate = () => {
    setSelectedVehicle(null)
    setViewMode("create")
    setDialogOpen(true)
  }

  const handleEdit = (vehicle: Vehicle) => {
    setSelectedVehicle(vehicle)
    setViewMode("edit")
    setDialogOpen(true)
  }

  const handleView = (vehicle: Vehicle) => {
    setSelectedVehicle(vehicle)
    setViewMode("view")
    setDialogOpen(true)
  }

  const handleDelete = (vehicle: Vehicle) => {
    setVehicleToDelete(vehicle)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = async () => {
    if (!vehicleToDelete) return
    
    try {
      await vehicleService.delete(vehicleToDelete.id)
      toast.success("Xóa xe thành công")
      setDeleteDialogOpen(false)
      setVehicleToDelete(null)
      loadData()
    } catch (error: any) {
      console.error("Failed to delete vehicle:", error)
      toast.error(error.response?.data?.error || "Không thể xóa xe. Vui lòng thử lại.")
    }
  }

  const clearFilters = () => {
    setSearchQuery("")
    setFilterVehicleType("")
    setFilterOperator("")
    setFilterStatus("")
    setQuickFilter("all")
  }

  const hasActiveFilters = searchQuery || filterVehicleType || filterOperator || filterStatus

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-slate-100 to-sky-50">
      <div className="max-w-[1600px] mx-auto p-6 space-y-6">
        {/* Header */}
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div className="flex items-center gap-4">
            <div className="p-4 rounded-2xl bg-gradient-to-br from-sky-500 to-cyan-500 shadow-xl shadow-sky-500/30">
              <Car className="h-7 w-7 text-white" />
            </div>
            <div>
              <h1 className="text-3xl font-bold text-slate-800 tracking-tight">
                Quản lý xe
              </h1>
              <p className="text-slate-500 text-sm mt-1">
                Quản lý thông tin phương tiện vận tải
              </p>
            </div>
          </div>
          
          <div className="flex items-center gap-3">
            <Button
              onClick={() => loadData(true)}
              disabled={isLoading}
              className="px-4 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 hover:border-slate-300 transition-all shadow-sm"
            >
              <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
              Làm mới
            </Button>
            <Button
              onClick={handleCreate}
              className="px-6 py-2.5 rounded-xl bg-gradient-to-r from-sky-500 to-cyan-500 text-white font-semibold hover:from-sky-600 hover:to-cyan-600 shadow-lg shadow-sky-500/30 transition-all hover:shadow-xl hover:shadow-sky-500/40 hover:-translate-y-0.5"
            >
              <Plus className="h-4 w-4 mr-2" />
              Thêm xe
            </Button>
          </div>
        </div>

        {/* Hero Stats - Asymmetric Layout */}
        <div className="grid grid-cols-12 gap-4">
          {/* Primary Stat - Hero Card */}
          <div className="col-span-12 lg:col-span-5 bg-gradient-to-br from-sky-500 via-sky-600 to-cyan-600 rounded-3xl p-8 text-white relative overflow-hidden">
            <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full -translate-y-1/2 translate-x-1/2" />
            <div className="absolute bottom-0 left-0 w-32 h-32 bg-white/5 rounded-full translate-y-1/2 -translate-x-1/2" />
            <div className="relative">
              <div className="flex items-center gap-2 text-sky-100 mb-2">
                <Car className="h-5 w-5" />
                <span className="text-sm font-medium uppercase tracking-wider">Tổng số xe</span>
              </div>
              <p className="text-6xl font-bold tracking-tight">{stats.total.toLocaleString()}</p>
              <div className="flex items-center gap-2 mt-4 text-sky-100">
                <TrendingUp className="w-4 h-4" />
                <span className="text-sm">Đang quản lý trong hệ thống</span>
              </div>
            </div>
          </div>

          {/* Secondary Stats */}
          <div className="col-span-12 lg:col-span-7 grid grid-cols-3 gap-4">
            {/* Active */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-emerald-100 group-hover:bg-emerald-500 transition-colors">
                  <div className="w-2 h-2 rounded-full bg-emerald-500 group-hover:bg-white animate-pulse" />
                </div>
                <span className="text-xs font-medium text-emerald-600 bg-emerald-50 px-2 py-1 rounded-full">
                  {stats.total > 0 ? Math.round((stats.active / stats.total) * 100) : 0}%
                </span>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.active.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Đang hoạt động</p>
              <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-emerald-400 to-emerald-500 rounded-full transition-all duration-500"
                  style={{ width: `${stats.total > 0 ? (stats.active / stats.total) * 100 : 0}%` }}
                />
              </div>
            </div>

            {/* Inactive */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-rose-100 group-hover:bg-rose-500 transition-colors">
                  <div className="w-2 h-2 rounded-full bg-rose-500 group-hover:bg-white" />
                </div>
                <span className="text-xs font-medium text-rose-600 bg-rose-50 px-2 py-1 rounded-full">
                  {stats.total > 0 ? Math.round((stats.inactive / stats.total) * 100) : 0}%
                </span>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.inactive.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Ngừng hoạt động</p>
              <div className="mt-3 h-1.5 bg-slate-100 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-rose-400 to-rose-500 rounded-full transition-all duration-500"
                  style={{ width: `${stats.total > 0 ? (stats.inactive / stats.total) * 100 : 0}%` }}
                />
              </div>
            </div>

            {/* Operators */}
            <div className="bg-white rounded-2xl p-6 border border-slate-100 shadow-sm hover:shadow-md transition-all group">
              <div className="flex items-center justify-between mb-4">
                <div className="p-3 rounded-xl bg-amber-100 group-hover:bg-amber-500 transition-colors">
                  <Building2 className="w-4 h-4 text-amber-600 group-hover:text-white transition-colors" />
                </div>
              </div>
              <p className="text-3xl font-bold text-slate-800">{stats.uniqueOperators.toLocaleString()}</p>
              <p className="text-sm text-slate-500 mt-1">Đơn vị vận tải</p>
              <div className="mt-3 flex items-center gap-1">
                {Array.from({ length: Math.min(5, stats.uniqueOperators) }).map((_, i) => (
                  <div key={i} className="w-6 h-6 rounded-full bg-gradient-to-br from-amber-400 to-orange-500 border-2 border-white -ml-2 first:ml-0" />
                ))}
                {stats.uniqueOperators > 5 && (
                  <span className="text-xs text-slate-500 ml-1">+{stats.uniqueOperators - 5}</span>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Unified Search Bar */}
        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-2 flex flex-col lg:flex-row lg:items-center gap-2">
          {/* Search Input */}
          <div className="flex-1 flex items-center gap-3 px-4 py-2 bg-slate-50 rounded-xl">
            <Search className="w-5 h-5 text-slate-400" />
            <input 
              type="text"
              placeholder="Tìm kiếm biển số, đơn vị vận tải..."
              className="flex-1 bg-transparent border-none outline-none text-sm text-slate-700 placeholder-slate-400"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
          
          {/* Divider */}
          <div className="hidden lg:block w-px h-10 bg-slate-200" />
          
          {/* Quick Filters */}
          <div className="flex items-center gap-2 px-2">
            <QuickFilter 
              label="Tất cả" 
              count={stats.total} 
              active={quickFilter === "all"} 
              onClick={() => setQuickFilter("all")} 
            />
            <QuickFilter 
              label="Hoạt động" 
              count={stats.active} 
              active={quickFilter === "active"} 
              onClick={() => setQuickFilter("active")} 
            />
            <QuickFilter 
              label="Ngừng" 
              count={stats.inactive} 
              active={quickFilter === "inactive"} 
              onClick={() => setQuickFilter("inactive")} 
            />
          </div>

          {/* Divider */}
          <div className="hidden lg:block w-px h-10 bg-slate-200" />

          {/* View Toggle */}
          <div className="flex items-center gap-2 px-2">
            <div className="flex items-center bg-slate-100 rounded-xl p-1">
              <button
                onClick={() => setDisplayMode("table")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "table" 
                    ? "bg-white text-sky-600 shadow-sm" 
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <List className="h-4 w-4" />
              </button>
              <button
                onClick={() => setDisplayMode("grid")}
                className={`p-2.5 rounded-lg transition-all ${
                  displayMode === "grid" 
                    ? "bg-white text-sky-600 shadow-sm" 
                    : "text-slate-500 hover:text-slate-700"
                }`}
              >
                <LayoutGrid className="h-4 w-4" />
              </button>
            </div>

            <Button
              onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
              className={`px-4 py-2.5 rounded-xl border transition-all ${
                showAdvancedFilters || hasActiveFilters
                  ? "bg-sky-50 border-sky-200 text-sky-600"
                  : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50"
              }`}
            >
              <SlidersHorizontal className="h-4 w-4 mr-2" />
              Nâng cao
            </Button>
          </div>
        </div>

        {/* Advanced Filter Panel */}
        {showAdvancedFilters && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6 animate-in slide-in-from-top-2 duration-200">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">Loại xe</Label>
                <select
                  value={filterVehicleType}
                  onChange={(e) => setFilterVehicleType(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-sky-500/30 focus:border-sky-400 transition-all"
                >
                  <option value="">Tất cả loại xe</option>
                  {vehicleTypes.map((type) => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                </select>
              </div>
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">Đơn vị vận tải</Label>
                <select
                  value={filterOperator}
                  onChange={(e) => setFilterOperator(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-sky-500/30 focus:border-sky-400 transition-all"
                >
                  <option value="">Tất cả đơn vị</option>
                  {operatorNames.map((op) => (
                    <option key={op} value={op}>{op}</option>
                  ))}
                </select>
              </div>
              <div>
                <Label className="text-sm font-medium text-slate-600 mb-2 block">Trạng thái</Label>
                <select
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 focus:outline-none focus:ring-2 focus:ring-sky-500/30 focus:border-sky-400 transition-all"
                >
                  <option value="">Tất cả trạng thái</option>
                  <option value="active">Đang hoạt động</option>
                  <option value="inactive">Ngừng hoạt động</option>
                </select>
              </div>
            </div>
            {hasActiveFilters && (
              <div className="mt-4 flex justify-end">
                <Button
                  onClick={clearFilters}
                  className="px-4 py-2 rounded-lg text-sm text-slate-500 hover:text-slate-700 hover:bg-slate-100 transition-all"
                >
                  Xóa bộ lọc
                </Button>
              </div>
            )}
          </div>
        )}

        {/* Results info */}
        <div className="flex items-center justify-between text-sm text-slate-500">
          <span>
            Hiển thị <strong className="text-slate-700">{paginatedVehicles.length}</strong> trong tổng số <strong className="text-slate-700">{filteredVehicles.length.toLocaleString()}</strong> xe
          </span>
          {totalPages > 1 && (
            <span>Trang {currentPage} / {totalPages}</span>
          )}
        </div>

        {/* Content - Table View */}
        {displayMode === "table" && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="bg-gradient-to-r from-slate-800 to-slate-900">
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Biển kiểm soát
                    </th>
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Loại xe
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Số chỗ
                    </th>
                    <th className="px-6 py-4 text-left text-xs font-semibold text-white uppercase tracking-wider">
                      Đơn vị vận tải
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Hạn đăng kiểm
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Trạng thái
                    </th>
                    <th className="px-6 py-4 text-center text-xs font-semibold text-white uppercase tracking-wider">
                      Thao tác
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-100">
                  {isLoading ? (
                    Array.from({ length: 8 }).map((_, i) => <SkeletonRow key={i} />)
                  ) : paginatedVehicles.length === 0 ? (
                    <tr>
                      <td colSpan={7} className="px-6 py-16 text-center">
                        <div className="flex flex-col items-center">
                          <div className="relative mb-4">
                            <div className="w-24 h-24 rounded-full bg-gradient-to-br from-sky-100 to-cyan-100 flex items-center justify-center">
                              <Car className="h-12 w-12 text-sky-500" />
                            </div>
                            <div className="absolute -bottom-1 -right-1 w-8 h-8 rounded-full bg-white border-2 border-sky-500 flex items-center justify-center">
                              <Plus className="w-4 h-4 text-sky-500" />
                            </div>
                          </div>
                          <h3 className="text-lg font-semibold text-slate-800 mb-1">Chưa có xe nào</h3>
                          <p className="text-slate-500 mb-4">Bắt đầu bằng cách thêm xe đầu tiên vào hệ thống</p>
                          {hasActiveFilters ? (
                            <Button onClick={clearFilters} className="text-sky-600 hover:text-sky-700">
                              Xóa bộ lọc
                            </Button>
                          ) : (
                            <Button onClick={handleCreate} className="bg-sky-500 hover:bg-sky-600 text-white rounded-xl px-6 py-2.5">
                              <Plus className="w-4 h-4 mr-2" />
                              Thêm xe mới
                            </Button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ) : (
                    paginatedVehicles.map((vehicle: any, index) => (
                      <tr 
                        key={vehicle.id} 
                        className="group hover:bg-sky-50/50 transition-colors"
                        style={{ 
                          animation: 'fadeInUp 0.3s ease forwards',
                          animationDelay: `${index * 30}ms`,
                          opacity: 0
                        }}
                      >
                        <td className="px-6 py-4">
                          <span className="font-mono text-sm font-bold bg-slate-100 text-slate-800 px-3 py-1.5 rounded-lg">
                            {vehicle.plateNumber}
                          </span>
                        </td>
                        <td className="px-6 py-4">
                          <span className="text-slate-600">{getVehicleTypeName(vehicle) || "N/A"}</span>
                        </td>
                        <td className="px-6 py-4 text-center">
                          <span className="inline-flex items-center justify-center w-10 h-10 rounded-xl bg-slate-100 text-slate-700 font-semibold text-sm">
                            {vehicle.seatCapacity || "-"}
                          </span>
                        </td>
                        <td className="px-6 py-4">
                          <div className="flex items-center gap-2 max-w-[250px]">
                            <Building2 className="h-4 w-4 text-slate-400 shrink-0" />
                            <span className="text-slate-600 truncate">
                              {getOperatorName(vehicle) || "N/A"}
                            </span>
                          </div>
                        </td>
                        <td className="px-6 py-4 text-center">
                          <div className="flex items-center justify-center gap-2 text-slate-600">
                            <Calendar className="h-4 w-4 text-slate-400" />
                            <span className="text-sm">{formatDate(vehicle.inspectionExpiryDate)}</span>
                          </div>
                        </td>
                        <td className="px-6 py-4 text-center">
                          <span className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold ${
                            vehicle.isActive 
                              ? "bg-emerald-100 text-emerald-700" 
                              : "bg-slate-100 text-slate-600"
                          }`}>
                            <span className={`w-2 h-2 rounded-full ${
                              vehicle.isActive ? "bg-emerald-500 animate-pulse" : "bg-slate-400"
                            }`} />
                            {vehicle.isActive ? "Hoạt động" : "Ngừng"}
                          </span>
                        </td>
                        <td className="px-6 py-4">
                          <div className="flex items-center justify-center gap-1 opacity-60 group-hover:opacity-100 transition-opacity">
                            <button
                              onClick={() => handleView(vehicle)}
                              className="p-2 rounded-lg text-slate-500 hover:text-sky-600 hover:bg-sky-50 transition-all"
                              title="Xem chi tiết"
                            >
                              <Eye className="h-4 w-4" />
                            </button>
                            <button
                              onClick={() => handleEdit(vehicle)}
                              className="p-2 rounded-lg text-slate-500 hover:text-amber-600 hover:bg-amber-50 transition-all"
                              title="Chỉnh sửa"
                            >
                              <Edit className="h-4 w-4" />
                            </button>
                            <button
                              onClick={() => handleDelete(vehicle)}
                              className="p-2 rounded-lg text-slate-500 hover:text-rose-600 hover:bg-rose-50 transition-all"
                              title="Xóa"
                            >
                              <Trash2 className="h-4 w-4" />
                            </button>
                          </div>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>
        )}

        {/* Content - Grid View */}
        {displayMode === "grid" && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {isLoading ? (
              Array.from({ length: 8 }).map((_, i) => (
                <div key={i} className="bg-white rounded-2xl border border-slate-200 p-5 animate-pulse">
                  <div className="flex items-center gap-3 mb-4">
                    <div className="w-12 h-12 rounded-xl bg-slate-200" />
                    <div className="flex-1">
                      <div className="h-5 bg-slate-200 rounded w-3/4 mb-2" />
                      <div className="h-3 bg-slate-100 rounded w-1/2" />
                    </div>
                  </div>
                  <div className="space-y-2">
                    <div className="h-3 bg-slate-100 rounded" />
                    <div className="h-3 bg-slate-100 rounded w-2/3" />
                  </div>
                </div>
              ))
            ) : paginatedVehicles.length === 0 ? (
              <div className="col-span-full py-16 text-center">
                <Car className="h-16 w-16 text-slate-300 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-slate-800">Không tìm thấy xe nào</h3>
              </div>
            ) : (
              paginatedVehicles.map((vehicle: any, index) => (
                <div 
                  key={vehicle.id} 
                  className="bg-white rounded-2xl border border-slate-200 p-5 hover:shadow-lg hover:border-sky-200 transition-all group hover:-translate-y-1"
                  style={{ 
                    animation: 'fadeInUp 0.3s ease forwards',
                    animationDelay: `${index * 50}ms`,
                    opacity: 0
                  }}
                >
                  <div className="flex items-start justify-between mb-4">
                    <div className="flex items-center gap-3">
                      <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-sky-100 to-cyan-100 flex items-center justify-center group-hover:from-sky-500 group-hover:to-cyan-500 transition-colors">
                        <Car className="h-6 w-6 text-sky-600 group-hover:text-white transition-colors" />
                      </div>
                      <div>
                        <h3 className="font-mono font-bold text-slate-800">{vehicle.plateNumber}</h3>
                        <p className="text-sm text-slate-500">{getVehicleTypeName(vehicle) || "N/A"}</p>
                      </div>
                    </div>
                    <span className={`inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-semibold ${
                      vehicle.isActive 
                        ? "bg-emerald-100 text-emerald-700" 
                        : "bg-slate-100 text-slate-600"
                    }`}>
                      <span className={`w-1.5 h-1.5 rounded-full ${
                        vehicle.isActive ? "bg-emerald-500" : "bg-slate-400"
                      }`} />
                      {vehicle.isActive ? "Hoạt động" : "Ngừng"}
                    </span>
                  </div>

                  <div className="space-y-2 mb-4">
                    <div className="flex items-center gap-2 text-sm">
                      <Building2 className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600 truncate">{getOperatorName(vehicle) || "N/A"}</span>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                      <Users className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600">{vehicle.seatCapacity || "N/A"} chỗ</span>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                      <Calendar className="h-4 w-4 text-slate-400" />
                      <span className="text-slate-600">Đăng kiểm: {formatDate(vehicle.inspectionExpiryDate)}</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-end gap-1 pt-4 border-t border-slate-100">
                    <button
                      onClick={() => handleView(vehicle)}
                      className="p-2 rounded-lg text-slate-400 hover:text-sky-600 hover:bg-sky-50 transition-all"
                    >
                      <Eye className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleEdit(vehicle)}
                      className="p-2 rounded-lg text-slate-400 hover:text-amber-600 hover:bg-amber-50 transition-all"
                    >
                      <Edit className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleDelete(vehicle)}
                      className="p-2 rounded-lg text-slate-400 hover:text-rose-600 hover:bg-rose-50 transition-all"
                    >
                      <Trash2 className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              ))
            )}
          </div>
        )}

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="bg-white rounded-2xl border border-slate-200 shadow-sm px-6 py-4">
            <div className="flex items-center justify-between">
              <p className="text-sm text-slate-600">
                Hiển thị {((currentPage - 1) * ITEMS_PER_PAGE) + 1}-{Math.min(currentPage * ITEMS_PER_PAGE, filteredVehicles.length)} trong tổng số {filteredVehicles.length.toLocaleString()} xe
              </p>
              <div className="flex items-center gap-2">
                <Button
                  onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                  disabled={currentPage === 1}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronLeft className="h-4 w-4" />
                </Button>
                
                <div className="flex items-center gap-1">
                  {Array.from({ length: totalPages }, (_, i) => i + 1)
                    .filter((page) => 
                      page === 1 || 
                      page === totalPages || 
                      (page >= currentPage - 1 && page <= currentPage + 1)
                    )
                    .map((page, index, array) => (
                      <span key={page} className="flex items-center">
                        {index > 0 && array[index - 1] !== page - 1 && (
                          <span className="px-2 text-slate-400">...</span>
                        )}
                        <button
                          onClick={() => setCurrentPage(page)}
                          className={`min-w-[40px] h-10 rounded-xl text-sm font-medium transition-all ${
                            currentPage === page
                              ? "bg-sky-500 text-white shadow-md shadow-sky-500/25"
                              : "bg-white border border-slate-200 text-slate-600 hover:bg-slate-50"
                          }`}
                        >
                          {page}
                        </button>
                      </span>
                    ))}
                </div>

                <Button
                  onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                  disabled={currentPage === totalPages}
                  className="p-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        )}

        {/* Vehicle Dialog */}
        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
          <DialogContent className="max-w-5xl w-full max-h-[95vh] overflow-y-auto p-6">
            <DialogClose onClose={() => setDialogOpen(false)} />
            <DialogHeader>
              <DialogTitle className="text-2xl flex items-center gap-3">
                <div className="p-2.5 rounded-xl bg-gradient-to-br from-sky-500 to-cyan-500 shadow-lg shadow-sky-500/25">
                  <Car className="h-5 w-5 text-white" />
                </div>
                {viewMode === "create" && "Thêm xe mới"}
                {viewMode === "edit" && "Sửa thông tin xe"}
                {viewMode === "view" && "Chi tiết xe"}
              </DialogTitle>
            </DialogHeader>
            <div className="mt-4">
              {viewMode === "view" && selectedVehicle ? (
                <VehicleView vehicle={selectedVehicle} />
              ) : (
                <VehicleForm
                  vehicle={selectedVehicle}
                  mode={viewMode === "view" ? "create" : viewMode}
                  onClose={() => {
                    setDialogOpen(false)
                    loadData()
                  }}
                />
              )}
            </div>
          </DialogContent>
        </Dialog>

        {/* Delete Confirmation Dialog */}
        {deleteDialogOpen && (
          <div className="fixed inset-0 z-50 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 animate-in zoom-in-95 duration-200">
              <div className="flex items-center gap-4 mb-4">
                <div className="p-3 rounded-2xl bg-rose-100">
                  <AlertCircle className="h-6 w-6 text-rose-600" />
                </div>
                <div>
                  <h3 className="text-lg font-bold text-slate-800">Xác nhận xóa xe</h3>
                  <p className="text-sm text-slate-500">Thao tác này không thể hoàn tác</p>
                </div>
              </div>
              <p className="text-slate-600 mb-6">
                Bạn có chắc chắn muốn xóa xe <strong className="font-mono text-slate-800">{vehicleToDelete?.plateNumber}</strong>?
              </p>
              <div className="flex justify-end gap-3">
                <Button
                  onClick={() => {
                    setDeleteDialogOpen(false)
                    setVehicleToDelete(null)
                  }}
                  className="px-5 py-2.5 rounded-xl bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 transition-all"
                >
                  Hủy
                </Button>
                <Button
                  onClick={confirmDelete}
                  className="px-5 py-2.5 rounded-xl bg-gradient-to-r from-rose-500 to-red-500 text-white hover:from-rose-600 hover:to-red-600 shadow-lg shadow-rose-500/25 transition-all"
                >
                  Xóa xe
                </Button>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* CSS Animation */}
      <style>{`
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(8px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      `}</style>
    </div>
  )
}
</file>

<file path="server/src/config/database.ts">
import { initializeApp, getApps, cert, App } from 'firebase-admin/app'
import { getDatabase, Database } from 'firebase-admin/database'
// Note: Storage is imported in upload.controller.ts, bucket config is set in initializeApp
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import dotenv from 'dotenv'

dotenv.config()

// Use RTDB_URL instead of FIREBASE_DATABASE_URL (reserved prefix in Firebase Functions)
const firebaseDatabaseURL = process.env.RTDB_URL || 'https://benxe-management-20251218-default-rtdb.asia-southeast1.firebasedatabase.app/'

let app: App | null = null
let db: Database | null = null
let initialized = false

// Lazy initialization function - only called when database is actually needed
function initializeFirebase(): Database {
  if (initialized && db) {
    return db
  }

  if (!getApps().length) {
    // Use SERVICE_ACCOUNT_PATH instead of FIREBASE_SERVICE_ACCOUNT_PATH (reserved prefix in Firebase Functions)
    const serviceAccountPath = process.env.SERVICE_ACCOUNT_PATH
    const googleApplicationCredentials = process.env.GOOGLE_APPLICATION_CREDENTIALS

    try {
      if (serviceAccountPath) {
        const absolutePath = resolve(process.cwd(), serviceAccountPath)
        
        // Validate service account file exists
        if (!existsSync(absolutePath)) {
          throw new Error(`Service account file not found at: ${absolutePath}`)
        }
        
        const serviceAccount = JSON.parse(readFileSync(absolutePath, 'utf-8'))
        const projectId = serviceAccount.project_id || 'benxe-management-20251218'
        app = initializeApp({
          credential: cert(serviceAccount),
          databaseURL: firebaseDatabaseURL,
          storageBucket: `${projectId}.firebasestorage.app`
        })
        console.log('[Firebase] Initialized with service account:', serviceAccount.client_email)
        console.log('[Firebase] Storage bucket:', `${projectId}.firebasestorage.app`)
      } else if (googleApplicationCredentials) {
        app = initializeApp({
          databaseURL: firebaseDatabaseURL
        })
        console.log('[Firebase] Initialized with GOOGLE_APPLICATION_CREDENTIALS')
      } else {
        app = initializeApp({
          databaseURL: firebaseDatabaseURL
        })
        console.warn('[Firebase] WARNING: Initialized without explicit credentials!')
        console.warn('   Database access may fail if Firebase rules require authentication.')
        console.warn('   To fix, set one of these environment variables:')
        console.warn('   - SERVICE_ACCOUNT_PATH=./firebase-service-account.json')
        console.warn('   - GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json')
      }
      
      console.log('[Firebase] Database URL:', firebaseDatabaseURL)
    } catch (error: any) {
      console.error('[Firebase] Initialization error:', error.message)
      throw new Error(`Failed to initialize Firebase: ${error.message}`)
    }
  } else {
    app = getApps()[0]
    console.log('[Firebase] Using existing app instance')
  }

  if (!app) {
    throw new Error('Failed to initialize Firebase app')
  }

  db = getDatabase(app)
  initialized = true
  return db
}

/**
 * Test Firebase connection by attempting a simple read
 * Call this on server startup to verify configuration
 */
export async function testFirebaseConnection(): Promise<boolean> {
  try {
    const database = initializeFirebase()
    await database.ref('.info/connected').once('value')
    console.log('[Firebase] Connection test: SUCCESS')
    return true
  } catch (error: any) {
    console.error('[Firebase] Connection test: FAILED -', error.message)
    return false
  }
}

// Getter for database instance (triggers lazy init)
function getDb(): Database {
  return initializeFirebase()
}

// Export database reference (lazy)
export { db }

// Helper functions to work with Firebase Realtime Database
export const firebaseDb = {
  ref: (path: string) => getDb().ref(path),

  get: async (path: string) => {
    const snapshot = await getDb().ref(path).once('value')
    return snapshot.val()
  },

  set: async (path: string, data: any) => {
    await getDb().ref(path).set(data)
    return data
  },

  update: async (path: string, data: any) => {
    await getDb().ref(path).update(data)
    return data
  },

  push: async (path: string, data: any) => {
    const ref = getDb().ref(path).push()
    await ref.set(data)
    return { key: ref.key, ...data }
  },

  remove: async (path: string) => {
    await getDb().ref(path).remove()
  },

  exists: async (path: string) => {
    const snapshot = await getDb().ref(path).once('value')
    return snapshot.exists()
  },

  query: (collection: string) => {
    return new FirebaseQuery(getDb().ref(collection), collection)
  }
}

// Firebase Query Builder - chainable API for Firebase Realtime Database
class FirebaseQuery {
  private ref: any
  private collection: string
  private filters: Array<{ field: string; operator: string; value: any }> = []
  private orderByField?: string
  private orderByDirection: 'asc' | 'desc' = 'asc'
  private limitCount?: number
  private selectFields?: string[]
  private isSingle: boolean = false
  private updateData?: any
  private insertData?: any | any[]
  private isDelete: boolean = false

  constructor(ref: any, collection: string) {
    this.ref = ref
    this.collection = collection
  }

  select(fields?: string) {
    if (!fields || fields === '*') {
      this.selectFields = ['*']
    } else {
      this.selectFields = fields.split(',').map(f => f.trim())
    }
    return this
  }

  eq(field: string, value: any) {
    this.filters.push({ field, operator: '==', value })
    return this
  }

  neq(field: string, value: any) {
    this.filters.push({ field, operator: '!=', value })
    return this
  }

  gt(field: string, value: any) {
    this.filters.push({ field, operator: '>', value })
    return this
  }

  gte(field: string, value: any) {
    this.filters.push({ field, operator: '>=', value })
    return this
  }

  lt(field: string, value: any) {
    this.filters.push({ field, operator: '<', value })
    return this
  }

  lte(field: string, value: any) {
    this.filters.push({ field, operator: '<=', value })
    return this
  }

  in(field: string, values: any[]) {
    this.filters.push({ field, operator: 'in', value: values })
    return this
  }

  order(field: string, options?: { ascending?: boolean }) {
    this.orderByField = field
    this.orderByDirection = options?.ascending === false ? 'desc' : 'asc'
    return this
  }

  limit(count: number) {
    this.limitCount = count
    return this
  }

  single() {
    this.limitCount = 1
    this.isSingle = true
    return this
  }

  insert(data: any | any[]) {
    this.insertData = data
    return this
  }

  update(data: any) {
    this.updateData = data
    return this
  }

  delete() {
    this.isDelete = true
    return this
  }

  // Remove undefined values from object (Firebase RTDB doesn't accept undefined)
  private removeUndefined(obj: any): any {
    return JSON.parse(JSON.stringify(obj))
  }

  async execute() {
    const database = getDb()

    return new Promise(async (resolve, reject) => {
      try {
        // Handle INSERT
        if (this.insertData) {
          const dataArray = Array.isArray(this.insertData) ? this.insertData : [this.insertData]
          const results: any[] = []

          for (const item of dataArray) {
            const id = item.id || this.generateId()
            const dataWithId = { ...item, id }

            if (!dataWithId.created_at) {
              dataWithId.created_at = new Date().toISOString()
            }
            if (!dataWithId.updated_at) {
              dataWithId.updated_at = new Date().toISOString()
            }

            // Sanitize to remove undefined values before Firebase set
            const sanitizedData = this.removeUndefined(dataWithId)
            await database.ref(`${this.collection}/${id}`).set(sanitizedData)
            results.push(sanitizedData)
          }

          resolve({
            data: Array.isArray(this.insertData) ? results : results[0],
            error: null
          })
          return
        }

        // Handle UPDATE
        if (this.updateData) {
          const updateData = {
            ...this.updateData,
            updated_at: new Date().toISOString()
          }

          const snapshot = await this.ref.once('value')
          let allData = snapshot.val()

          if (!allData) {
            resolve({ data: null, error: { message: 'No records found' } })
            return
          }

          const records = Object.keys(allData).map(key => ({
            ...allData[key],
            id: key
          }))

          const filteredRecords = this.applyFilters(records)

          if (filteredRecords.length === 0) {
            resolve({ data: null, error: { message: 'No records found' } })
            return
          }

          const updatedRecords: any[] = []
          for (const record of filteredRecords) {
            // Sanitize to remove undefined values before Firebase update
            const sanitizedUpdateData = this.removeUndefined(updateData)
            const updated = { ...record, ...sanitizedUpdateData }
            await database.ref(`${this.collection}/${record.id}`).update(sanitizedUpdateData)
            updatedRecords.push(updated)
          }

          resolve({
            data: this.isSingle ? updatedRecords[0] : updatedRecords,
            error: null
          })
          return
        }

        // Handle DELETE
        if (this.isDelete) {
          console.log('[FirebaseQuery DELETE] Collection:', this.collection, 'Filters:', JSON.stringify(this.filters))
          const snapshot = await this.ref.once('value')
          let allData = snapshot.val()

          if (!allData) {
            console.log('[FirebaseQuery DELETE] No data found in collection')
            resolve({ data: null, error: null })
            return
          }

          const records = Object.keys(allData).map(key => ({
            ...allData[key],
            id: key
          }))
          console.log('[FirebaseQuery DELETE] Total records:', records.length)

          const filteredRecords = this.applyFilters(records)
          console.log('[FirebaseQuery DELETE] Filtered records:', filteredRecords.length)

          for (const record of filteredRecords) {
            await database.ref(`${this.collection}/${record.id}`).remove()
          }

          resolve({ data: null, error: null })
          return
        }

        // Handle SELECT (read)
        let queryRef: any = this.ref

        // IMPORTANT: Only apply Firebase-level limit if there are NO filters
        // When filters exist, we need ALL data first, then filter in JS, then apply limit
        const hasFilters = this.filters.length > 0
        
        if (this.orderByField) {
          queryRef = queryRef.orderByChild(this.orderByField)
          // Only apply limit at Firebase level if no filters
          if (!hasFilters) {
            if (this.orderByDirection === 'desc') {
              queryRef = queryRef.limitToLast(this.limitCount || 1000)
            } else {
              queryRef = queryRef.limitToFirst(this.limitCount || 1000)
            }
          }
        } else if (this.limitCount && !hasFilters) {
          // Only apply limit at Firebase level if no filters
          queryRef = queryRef.limitToFirst(this.limitCount)
        }

        const snapshot = await queryRef.once('value')
        let data = snapshot.val()

        if (data && typeof data === 'object' && !Array.isArray(data)) {
          data = Object.keys(data).map(key => ({
            ...data[key],
            id: key
          }))
        } else if (!data) {
          data = []
        }

        // Apply filters in JavaScript (after fetching all data)
        if (hasFilters && Array.isArray(data)) {
          console.log('[FirebaseQuery SELECT] Before filter:', data.length, 'Filters:', JSON.stringify(this.filters))
          data = this.applyFilters(data)
          console.log('[FirebaseQuery SELECT] After filter:', data.length)
        }
        
        // Apply limit AFTER filtering (when filters were used)
        if (hasFilters && this.limitCount && Array.isArray(data)) {
          data = data.slice(0, this.limitCount)
        }

        if (this.selectFields && Array.isArray(data)) {
          data = data.map((item: any) => {
            if (this.selectFields!.some(f => f.includes(':'))) {
              return item
            }

            if (this.selectFields!.includes('*')) {
              return item
            }

            const selected: any = { id: item.id }
            this.selectFields!.forEach(field => {
              if (item.hasOwnProperty(field)) {
                selected[field] = item[field]
              }
            })
            return selected
          })
        }

        if (this.isSingle && Array.isArray(data)) {
          resolve({ data: data[0] || null, error: data[0] ? null : { message: 'Not found' } })
        } else {
          resolve({ data, error: null })
        }
      } catch (error: any) {
        reject({ data: null, error })
      }
    })
  }

  private applyFilters(data: any[]) {
    if (this.filters.length === 0) return data

    return data.filter((item: any) => {
      return this.filters.every(filter => {
        const fieldValue = item[filter.field]
        switch (filter.operator) {
          case '==':
            return fieldValue === filter.value
          case '!=':
            return fieldValue !== filter.value
          case '>':
            return fieldValue > filter.value
          case '>=':
            return fieldValue >= filter.value
          case '<':
            return fieldValue < filter.value
          case '<=':
            return fieldValue <= filter.value
          case 'in':
            return Array.isArray(filter.value) && filter.value.includes(fieldValue)
          default:
            return true
        }
      })
    })
  }

  private generateId(): string {
    const timestamp = Date.now().toString(36)
    const randomPart = Math.random().toString(36).substring(2, 15)
    return `${timestamp}-${randomPart}`
  }
}

// Create a thenable query builder that proxies all methods
function createThenableQuery(query: FirebaseQuery): any {
  const proxy = new Proxy(query, {
    get(target: FirebaseQuery, prop: string) {
      if (prop === 'then' || prop === 'catch' || prop === 'finally') {
        return (onResolve: any, onReject?: any) => {
          return target.execute().then(onResolve, onReject)
        }
      }
      const value = (target as any)[prop]
      if (typeof value === 'function') {
        return function(...args: any[]) {
          const result = value.apply(target, args)
          return result === target ? proxy : result
        }
      }
      return value
    }
  })
  return proxy
}

// Firebase query interface with chainable API
export const firebase = {
  from: (table: string) => {
    const query = firebaseDb.query(table)
    return createThenableQuery(query)
  },
  rpc: async (_functionName: string, _params?: any) => {
    return { data: null, error: { message: 'RPC not supported in Firebase Realtime Database' } }
  }
}
</file>

<file path="server/src/index.ts">
import express, { Request, Response } from 'express'
import cors from 'cors'
import dotenv from 'dotenv'
import { errorHandler } from './middleware/errorHandler.js'

// Routes
import authRoutes from './routes/auth.routes.js'
import driverRoutes from './modules/fleet/driver.routes.js'
import vehicleRoutes from './modules/fleet/vehicle.routes.js'
import operatorRoutes from './routes/operator.routes.js'
import locationRoutes from './routes/location.routes.js'
import routeRoutes from './routes/route.routes.js'
import scheduleRoutes from './routes/schedule.routes.js'
import vehicleTypeRoutes from './routes/vehicle-type.routes.js'
import shiftRoutes from './routes/shift.routes.js'
import dispatchRoutes from './modules/dispatch/dispatch.routes.js'
import violationRoutes from './routes/violation.routes.js'
import invoiceRoutes from './routes/invoice.routes.js'
import serviceChargeRoutes from './routes/service-charge.routes.js'
import serviceRoutes from './routes/service.routes.js'
import serviceFormulaRoutes from './routes/service-formula.routes.js'
import reportRoutes from './routes/report.routes.js'
import dashboardRoutes from './routes/dashboard.routes.js'
import uploadRoutes from './routes/upload.routes.js'
import vehicleBadgeRoutes from './routes/vehicle-badge.routes.js'
import provinceRoutes from './routes/province.routes.js'
import chatRoutes from './modules/chat/chat.routes.js'
import quanlyDataRoutes from './routes/quanly-data.routes.js'

dotenv.config()

const app = express()
// Use APP_PORT instead of PORT (reserved in Firebase Functions)
const PORT = Number(process.env.APP_PORT) || 3000

// CORS Configuration - Allow Firebase Hosting and common domains
const ALLOWED_ORIGINS = [
  'http://localhost:5173',
  'http://localhost:3000',
  'http://127.0.0.1:5173',
  'https://benxe-management-20251218.web.app',
  'https://benxe-management-20251218.firebaseapp.com',
]

// Middleware
app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps, curl, or server-to-server)
    if (!origin) {
      return callback(null, true)
    }

    // Normalize request origin (remove trailing slash)
    const normalizedOrigin = origin.replace(/\/$/, '')

    // Allow localhost in any environment
    if (normalizedOrigin.includes('localhost') || normalizedOrigin.includes('127.0.0.1')) {
      return callback(null, true)
    }

    // Allow Firebase Hosting domains
    if (normalizedOrigin.includes('.web.app') || normalizedOrigin.includes('.firebaseapp.com')) {
      return callback(null, true)
    }

    // Check explicit allowed origins
    if (ALLOWED_ORIGINS.includes(normalizedOrigin)) {
      return callback(null, true)
    }

    // Allow any origin from env CORS_ORIGIN
    const envOrigins = (process.env.CORS_ORIGIN || '').split(',').map(o => o.trim())
    if (envOrigins.includes(normalizedOrigin)) {
      return callback(null, true)
    }

    callback(new Error('Not allowed by CORS'))
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// Health check
app.get('/health', (_req: Request, res: Response) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() })
})

// API Routes
app.use('/api/auth', authRoutes)
app.use('/api/drivers', driverRoutes)
app.use('/api/vehicles', vehicleRoutes)
app.use('/api/operators', operatorRoutes)
app.use('/api/locations', locationRoutes)
app.use('/api/routes', routeRoutes)
app.use('/api/schedules', scheduleRoutes)
app.use('/api/vehicle-types', vehicleTypeRoutes)
app.use('/api/shifts', shiftRoutes)
app.use('/api/dispatch', dispatchRoutes)
app.use('/api/violations', violationRoutes)
app.use('/api/invoices', invoiceRoutes)
app.use('/api/service-charges', serviceChargeRoutes)
app.use('/api/services', serviceRoutes)
app.use('/api/service-formulas', serviceFormulaRoutes)
app.use('/api/reports', reportRoutes)
app.use('/api/dashboard', dashboardRoutes)
app.use('/api/upload', uploadRoutes)
app.use('/api/vehicle-badges', vehicleBadgeRoutes)
app.use('/api/provinces', provinceRoutes)
app.use('/api/chat', chatRoutes)
app.use('/api/quanly-data', quanlyDataRoutes)

// Error handling
app.use(errorHandler)

// 404 handler
app.use((_req: Request, res: Response) => {
  res.status(404).json({ error: 'Route not found' })
})

// Export app for Firebase Functions
export { app }

// Start server only when running directly (not as Cloud Function or being analyzed)
// Check multiple environment variables that indicate we're in a Cloud Function context
const isCloudFunction = process.env.FUNCTION_TARGET ||
                        process.env.K_SERVICE ||
                        process.env.FUNCTIONS_EMULATOR ||
                        process.env.GCLOUD_PROJECT ||
                        process.env.FIREBASE_CONFIG

// Also check if this module is being required/imported (not run directly)
const isMainModule = process.argv[1]?.includes('index.js') || process.argv[1]?.includes('index.ts')

if (!isCloudFunction && isMainModule) {
  // Import and test Firebase connection on startup
  import('./config/database.js').then(async ({ testFirebaseConnection }) => {
    const isConnected = await testFirebaseConnection()
    if (!isConnected) {
      console.error('========================================')
      console.error('WARNING: Firebase connection failed!')
      console.error('API calls to database will fail.')
      console.error('Please check:')
      console.error('  1. SERVICE_ACCOUNT_PATH points to valid JSON file')
      console.error('  2. RTDB_URL is correct')
      console.error('  3. Service account has database access')
      console.error('========================================')
    }

    // Start server first, then preload cache in background
    app.listen(PORT, () => {
      console.log(`Server is running on http://localhost:${PORT}`)
      console.log(`API available at http://localhost:${PORT}/api`)
      console.log(`Health check: http://localhost:${PORT}/health`)
      
      // Preload cache in background (non-blocking)
      Promise.resolve().then(async () => {
        try {
          // Pre-warm vehicle cache FIRST (used by /api/vehicles - DieuDo page)
          const { vehicleCacheService } = await import('./modules/fleet/services/vehicle-cache.service.js')
          await vehicleCacheService.preWarm()
          
          const { cachedData } = await import('./services/cached-data.service.js')
          await cachedData.preloadCommonData()
          
          // Pre-warm quanly-data cache (runs in background)
          const { preWarmQuanLyCache } = await import('./controllers/quanly-data.controller.js')
          await preWarmQuanLyCache()
          
          // Pre-warm chat cache for AI chatbot (all collections)
          const { chatCacheService } = await import('./modules/chat/services/chat-cache.service.js')
          await chatCacheService.preWarm()
        } catch (error) {
          console.warn('[Cache] Failed to preload:', error)
        }
      })
    })
    
    // Start sync cron jobs in background
    setTimeout(async () => {
      try {
        // Operator sync (every 30 minutes)
        const { startOperatorSyncCron } = await import('./services/operator-sync.service.js')
        startOperatorSyncCron()
        
        // Vehicle sync (every 15 minutes)
        const { startVehicleSyncCron } = await import('./services/vehicle-sync.service.js')
        startVehicleSyncCron()
        
        // Badge sync (every 15 minutes, runs after vehicle sync)
        const { startBadgeSyncCron } = await import('./services/badge-sync.service.js')
        // Delay badge sync by 30 seconds to ensure vehicles are synced first
        setTimeout(() => startBadgeSyncCron(), 30 * 1000)
        
        // Route sync (every 30 minutes)
        const { startRouteSyncCron } = await import('./services/route-sync.service.js')
        startRouteSyncCron()
      } catch (error) {
        console.warn('[SyncCron] Failed to start cron jobs:', error)
      }
    }, 1000)
  }).catch((error) => {
    console.error('Failed to import database config:', error)
    process.exit(1)
  })
}
</file>

<file path="client/src/pages/DieuDo.tsx">
import { useNavigate } from "react-router-dom";
import {
  Search,
  FileCheck,
  Plus,
  Bus,
  FileText,
  RefreshCw,
  ShieldCheck,
  Banknote,
  ArrowRightLeft,
  ArrowRight,
  Pencil,
  Trash2,
  Activity,
  Radar,
  Sparkles,
  User,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog";
import { ChoXeVaoBenDialog } from "@/components/dispatch/ChoXeVaoBenDialog";
import { XeTraKhachDialog } from "@/components/dispatch/XeTraKhachDialog";
import { CapPhepDialog } from "@/components/dispatch/CapPhepDialog";
import { ThanhToanTheoThangDialog } from "@/components/dispatch/ThanhToanTheoThangDialog";
import { ChoXeRaBenDialog } from "@/components/dispatch/ChoXeRaBenDialog";
import { CapLenhXuatBenDialog } from "@/components/dispatch/CapLenhXuatBenDialog";
import { ChoNhieuXeRaBenDialog } from "@/components/dispatch/ChoNhieuXeRaBenDialog";
import { BusPlusIcon, BusEnterIcon } from "@/components/dispatch/icons";
import {
  columnConfig,
  type DisplayStatus,
  RadarPulse,
  ActionButton,
  FloatingDotsEmpty,
  VehicleCard,
} from "@/components/dispatch/common";
import { useDieuDo } from "@/hooks/useDieuDo";
import { cn } from "@/lib/utils";
import type { DispatchRecord } from "@/types";

export default function DieuDo() {
  const navigate = useNavigate();
  const {
    records,
    searchQuery,
    setSearchQuery,
    isLoading,
    selectedRecord,
    dialogOpen,
    setDialogOpen,
    closeDialog,
    dialogType,
    setDialogType,
    isReadOnly,
    vehicleOptions,
    stats,
    totalActive,
    loadRecords,
    handleDelete,
    handleEdit,
    handleAction,
    handleOpenPermitReadOnly,
    handleRecordExit,
    getRecordsByStatus,
    isMonthlyPaymentVehicle,
    getVehicleStatus,
  } = useDieuDo();

  const getActionButtons = (record: DispatchRecord, status: DisplayStatus) => {
    const buttons: React.ReactNode[] = [];

    if (status === "in-station") {
      if (isMonthlyPaymentVehicle(record)) {
        buttons.push(
          <ActionButton key="monthly-payment" icon={FileCheck} onClick={(e) => { e.stopPropagation(); handleAction(record, "monthly-payment"); }} title="Thanh toán theo tháng" variant="info" />
        );
      }
      buttons.push(
        <ActionButton key="return" icon={User} onClick={(e) => { e.stopPropagation(); handleAction(record, "return"); }} title="Xác nhận trả khách" variant="info" />,
        <ActionButton key="permit" icon={FileCheck} onClick={(e) => { e.stopPropagation(); handleAction(record, "permit"); }} title="Cấp phép" variant="success" />,
        <ActionButton key="edit" icon={Pencil} onClick={(e) => { e.stopPropagation(); handleEdit(record); }} title="Sửa thông tin" variant="warning" />,
        <ActionButton key="delete" icon={Trash2} onClick={(e) => { e.stopPropagation(); handleDelete(record); }} title="Xóa" variant="danger" />
      );
    } else if (status === "permit-issued") {
      buttons.push(
        <ActionButton key="payment" icon={Banknote} onClick={(e) => { e.stopPropagation(); navigate(`/thanh-toan/${record.id}`); }} title="Thanh toán" variant="warning" />,
        <ActionButton key="document" icon={FileText} onClick={(e) => { e.stopPropagation(); handleOpenPermitReadOnly(record); }} title="Xem tài liệu" variant="info" />
      );
    } else if (status === "paid") {
      if (record.permitStatus === "approved") {
        buttons.push(<ActionButton key="departure-order" icon={ShieldCheck} onClick={(e) => { e.stopPropagation(); handleAction(record, "departure-order"); }} title="Cấp lệnh xuất bến" variant="success" />);
      }
      if (record.permitStatus === "rejected" || !record.permitStatus) {
        buttons.push(<ActionButton key="exit" icon={BusEnterIcon} onClick={async (e) => { e.stopPropagation(); await handleRecordExit(record); }} title="Cho xe ra bến" variant="danger" />);
      }
    } else if (status === "departed" && record.currentStatus === "departure_ordered") {
      buttons.push(<ActionButton key="depart" icon={BusEnterIcon} onClick={(e) => { e.stopPropagation(); handleAction(record, "depart"); }} title="Cho xe ra bến" variant="success" />);
    }

    return buttons;
  };

  const renderColumn = (status: DisplayStatus) => {
    const config = columnConfig[status];
    const columnRecords = getRecordsByStatus(status);
    const Icon = config.icon;
    const colorMap: Record<DisplayStatus, string> = { "in-station": "sky", "permit-issued": "amber", paid: "emerald", departed: "violet" };

    return (
      <div className="flex flex-col h-full min-h-0 rounded-3xl overflow-hidden shadow-xl border border-white/50 bg-white/60 backdrop-blur-xl">
        {/* Glass Header */}
        <div className={cn("relative px-5 py-5 bg-gradient-to-r overflow-hidden", config.headerGradient)}>
          <div className="absolute inset-0 bg-white/10 backdrop-blur-sm" />
          <div className="absolute inset-0 opacity-10">
            <div className="absolute inset-0" style={{ backgroundImage: `radial-gradient(circle at 2px 2px, white 1px, transparent 0)`, backgroundSize: '20px 20px' }} />
          </div>
          <div className="relative flex items-center justify-between">
            <div className="flex items-center gap-4">
              <div className="p-3 rounded-2xl bg-white/20 backdrop-blur-sm shadow-inner">
                <Icon className="h-6 w-6 text-white drop-shadow" />
              </div>
              <div>
                <h2 className="font-black text-white text-lg drop-shadow-sm tracking-wide">
                  <span className="hidden lg:inline">{config.title}</span>
                  <span className="lg:hidden">{config.shortTitle}</span>
                </h2>
              </div>
            </div>
            <RadarPulse count={columnRecords.length} color={colorMap[status]} />
          </div>
        </div>

        {/* Content */}
        <div className={cn("flex-1 overflow-y-auto p-4 space-y-4 min-h-0", `bg-gradient-to-b ${config.gradient}`)}>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center py-16">
              <div className="relative">
                <div className="w-16 h-16 rounded-full border-4 border-slate-200 border-t-blue-500 animate-spin" />
                <Radar className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 text-slate-400" />
              </div>
              <p className="text-slate-400 font-medium mt-4">Đang quét...</p>
            </div>
          ) : columnRecords.length === 0 ? (
            <FloatingDotsEmpty message="Không có xe" />
          ) : (
            columnRecords.map((record, index) => (
              <VehicleCard
                key={record.id}
                record={record}
                status={status}
                index={index}
                vehicleStatus={getVehicleStatus(record, status)}
                onClick={() => {
                  if (status === "in-station") handleAction(record, "permit");
                  else if (status === "permit-issued") navigate(`/thanh-toan/${record.id}`);
                  else if (status === "paid") handleAction(record, "depart");
                }}
                actionButtons={getActionButtons(record, status)}
              />
            ))
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="h-full flex flex-col bg-gradient-to-br from-slate-100 via-slate-50 to-white">
      <style>{`@keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }`}</style>

      {/* Header */}
      <div className="flex-shrink-0 px-4 lg:px-6 py-4 border-b border-slate-200/50 bg-white/80 backdrop-blur-xl shadow-sm">
        <div className="flex flex-col lg:flex-row lg:items-center gap-4">
          <div className="flex items-center gap-4 flex-1">
            <div className="flex items-center gap-4">
              <div className="relative p-3 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 shadow-xl">
                <Activity className="h-7 w-7 text-white" />
                <span className="absolute -top-1 -right-1 flex h-4 w-4">
                  <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75" />
                  <span className="relative inline-flex rounded-full h-4 w-4 bg-emerald-500" />
                </span>
              </div>
              <div>
                <h1 className="text-xl lg:text-2xl font-black text-slate-900 tracking-tight">Dispatch Control</h1>
                <div className="flex items-center gap-2 text-sm text-slate-500">
                  <Sparkles className="h-4 w-4 text-amber-500" />
                  <span className="font-semibold">{totalActive} xe hoạt động</span>
                </div>
              </div>
            </div>

            <div className="hidden lg:flex items-center gap-3 ml-6 pl-6 border-l border-slate-200">
              {(Object.keys(columnConfig) as DisplayStatus[]).map((key) => (
                <div key={key} className="flex items-center gap-2 px-4 py-2 rounded-xl bg-white shadow-sm border border-slate-100 hover:shadow-md transition-shadow">
                  <div className={cn("h-3 w-3 rounded-full", columnConfig[key].dotColor)} />
                  <span className="text-sm font-black text-slate-700 tabular-nums">{stats[key]}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="flex items-center gap-3">
            <div className="relative flex-1 lg:w-80">
              <Search className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
              <Input placeholder="Tìm biển số, tuyến, tài xế..." className="pl-12 h-12 bg-white/80 backdrop-blur border-slate-200 text-slate-900 placeholder:text-slate-400 rounded-xl" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />
            </div>
            <Button variant="outline" size="icon" onClick={loadRecords} className="h-12 w-12 rounded-xl border-slate-200 bg-white/80 hover:bg-slate-100">
              <RefreshCw className={cn("h-5 w-5", isLoading && "animate-spin")} />
            </Button>
            <Button variant="outline" onClick={() => { setDialogType("depart-multiple"); setDialogOpen(true); }} className="h-12 gap-2 rounded-xl border-slate-200 bg-white/80 hover:bg-slate-100 hidden sm:flex px-4">
              <ArrowRight className="h-5 w-5" />
              <span className="hidden xl:inline font-semibold">Nhiều xe ra bến</span>
            </Button>
            <Button onClick={() => { setDialogType("entry"); handleAction(null as unknown as DispatchRecord, "entry"); }} className="h-12 gap-2 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white shadow-lg shadow-blue-500/30 px-5">
              <Plus className="h-5 w-5" />
              <span className="hidden sm:inline font-semibold">Vào bến</span>
            </Button>
          </div>
        </div>
      </div>

      {/* Kanban Board */}
      <div className="flex-1 overflow-hidden p-4 lg:p-6">
        <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-4 lg:gap-6 h-full">
          {renderColumn("in-station")}
          {renderColumn("permit-issued")}
          {renderColumn("paid")}
          {renderColumn("departed")}
        </div>
      </div>

      {/* Footer Legend */}
      <div className="flex-shrink-0 px-4 lg:px-6 py-4 border-t border-slate-200/50 bg-white/80 backdrop-blur-xl">
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="flex flex-wrap items-center gap-4 lg:gap-6">
            <div className="flex items-center gap-2 text-sm text-slate-600"><div className="p-1.5 rounded-lg bg-slate-100"><Bus className="h-4 w-4" /></div><span className="font-semibold">Tuyến cố định</span></div>
            <div className="flex items-center gap-2 text-sm text-slate-600"><div className="p-1.5 rounded-lg bg-blue-100"><BusPlusIcon className="h-4 w-4 text-blue-600" /></div><span className="font-semibold">Tăng cường</span></div>
            <div className="flex items-center gap-2 text-sm text-slate-600"><div className="p-1.5 rounded-lg bg-violet-100"><ArrowRightLeft className="h-4 w-4 text-violet-600" /></div><span className="font-semibold">Đi thay</span></div>
          </div>
          <div className="flex flex-wrap items-center gap-4 lg:gap-6">
            <div className="flex items-center gap-2"><span className="h-3 w-3 rounded-full bg-emerald-500 shadow-sm" /><span className="text-sm text-slate-600 font-semibold">Đủ ĐK</span></div>
            <div className="flex items-center gap-2"><span className="h-3 w-3 rounded-full bg-rose-500 shadow-sm" /><span className="text-sm text-slate-600 font-semibold">Thiếu ĐK</span></div>
            <div className="flex items-center gap-2"><span className="h-3 w-3 rounded-full bg-sky-500 shadow-sm" /><span className="text-sm text-slate-600 font-semibold">Trả khách</span></div>
            <div className="flex items-center gap-2"><span className="h-3 w-3 rounded-full bg-amber-500 shadow-sm" /><span className="text-sm text-slate-600 font-semibold">Vãng lai</span></div>
          </div>
        </div>
      </div>

      {/* Dialogs */}
      {dialogType === "permit" && selectedRecord && (
        <CapPhepDialog key={selectedRecord.id} record={selectedRecord} open={dialogOpen} readOnly={isReadOnly} onClose={closeDialog} onSuccess={loadRecords} />
      )}

      {(dialogType === "entry" || dialogType === "edit") && (
        <ChoXeVaoBenDialog open={dialogOpen} vehicleOptions={vehicleOptions} onClose={closeDialog} onSuccess={loadRecords} editRecord={dialogType === "edit" ? selectedRecord : null} />
      )}

      {dialogType === "depart-multiple" && (
        <Dialog open={dialogOpen} onOpenChange={(open) => !open && closeDialog()}>
          <DialogContent className="max-h-[95vh] overflow-y-auto w-[95vw] max-w-[1800px]">
            <DialogClose onClose={closeDialog} />
            <DialogHeader><DialogTitle>Cho nhiều xe ra bến</DialogTitle></DialogHeader>
            <ChoNhieuXeRaBenDialog records={records.filter((r) => r.currentStatus === "departure_ordered")} onClose={closeDialog} onSuccess={loadRecords} open={dialogOpen} />
          </DialogContent>
        </Dialog>
      )}

      <Dialog open={dialogOpen && !["permit", "entry", "edit", "depart-multiple"].includes(dialogType)} onOpenChange={(open) => !open && closeDialog()}>
        <DialogContent className={cn("max-h-[95vh] overflow-y-auto w-[95vw]", dialogType === "depart" ? "max-w-xl" : "max-w-5xl")}>
          <DialogClose onClose={closeDialog} />
          <DialogHeader>
            <DialogTitle>
              {dialogType === "return" && "Xác nhận trả khách"}
              {dialogType === "depart" && "Cho xe ra bến"}
              {dialogType === "departure-order" && "Cấp lệnh xuất bến"}
              {dialogType === "monthly-payment" && "Thanh toán theo tháng"}
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            {dialogType === "return" && selectedRecord && <XeTraKhachDialog record={selectedRecord} onClose={closeDialog} onSuccess={loadRecords} />}
            {dialogType === "depart" && selectedRecord && <ChoXeRaBenDialog record={selectedRecord} onClose={closeDialog} onSuccess={loadRecords} />}
            {dialogType === "departure-order" && selectedRecord && <CapLenhXuatBenDialog record={selectedRecord} onClose={closeDialog} onSuccess={loadRecords} />}
            {dialogType === "monthly-payment" && selectedRecord && <ThanhToanTheoThangDialog record={selectedRecord} onClose={closeDialog} onSuccess={loadRecords} />}
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="client/src/components/dispatch/CapPhepDialog.tsx">
import { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { FileText, X, XCircle, CheckCircle, Calendar } from "lucide-react";
import { format } from "date-fns";
import { useCapPhepDialog } from "@/hooks/useCapPhepDialog";
import {
  VehicleInfoSection,
  DriverSection,
  MonthlyCalendarHeatmap,
  TransportOrderSection,
  ServiceChargesSection,
  DocumentCheckCards,
  VehicleImageSection,
  GsgtCheckSection,
  NotesSection,
  ZeroAmountWarningDialog,
} from "./sections";
import { KiemTraGiayToDialog } from "./KiemTraGiayToDialog";
import { LyDoKhongDuDieuKienDialog } from "./LyDoKhongDuDieuKienDialog";
import { ThemDichVuDialog } from "./ThemDichVuDialog";
import { ThemTaiXeDialog } from "./ThemTaiXeDialog";
import type { DispatchRecord } from "@/types";

interface CapPhepDialogProps {
  record: DispatchRecord;
  onClose: () => void;
  onSuccess?: () => void;
  open?: boolean;
  readOnly?: boolean;
}

export function CapPhepDialog({
  record,
  onClose,
  onSuccess,
  open = true,
  readOnly = false,
}: CapPhepDialogProps) {
  const [isAnimating, setIsAnimating] = useState(false);
  const [documentDialogOpen, setDocumentDialogOpen] = useState(false);
  const [notEligibleDialogOpen, setNotEligibleDialogOpen] = useState(false);
  const [addServiceDialogOpen, setAddServiceDialogOpen] = useState(false);
  const [addDriverDialogOpen, setAddDriverDialogOpen] = useState(false);
  const [showCalendar, setShowCalendar] = useState(false);

  const hook = useCapPhepDialog(record, onClose, onSuccess);

  useEffect(() => {
    if (open) {
      setIsAnimating(true);
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }
    return () => { document.body.style.overflow = "unset"; };
  }, [open]);

  const handleClose = () => {
    setIsAnimating(false);
    setTimeout(onClose, 300);
  };

  const handleNotEligibleConfirm = async (
    selectedReasons: string[],
    options: { createOrder: boolean; signAndTransmit: boolean; printDisplay: boolean }
  ) => {
    await hook.handleNotEligibleConfirm(selectedReasons, options);
    setNotEligibleDialogOpen(false);
  };

  if (!open) return null;

  const overallStatus = hook.getOverallStatus();

  return createPortal(
    <div className="fixed inset-0 z-50 flex flex-col" onClick={handleClose}>
      {/* Clean background */}
      <div className="absolute inset-0 bg-gray-50" />

      {/* STICKY HEADER */}
      <div 
        className="sticky top-0 z-10 bg-white border-b border-gray-200 shadow-sm"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="max-w-[1800px] mx-auto px-4 lg:px-6 py-3">
          <div className="flex items-center justify-between">
            {/* Left: Title & Info */}
            <div className="flex items-center gap-4">
              <div className="p-2 rounded-xl bg-blue-600">
                <FileText className="h-5 w-5 text-white" />
              </div>
              <div>
                <h1 className="text-xl font-bold text-gray-900">
                  {readOnly ? "Xem Cấp phép" : "Cấp phép lên nốt"}
                </h1>
                <div className="flex items-center gap-3 text-sm">
                  <span className="font-semibold text-blue-600">{record.vehiclePlateNumber || "---"}</span>
                  {record.entryTime && (
                    <span className="text-gray-500">
                      Vào bến: {format(new Date(record.entryTime), "HH:mm dd/MM")}
                    </span>
                  )}
                  {/* Pre-flight status inline */}
                  <span className={`inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-bold ${
                    overallStatus.isValid 
                      ? 'bg-emerald-100 text-emerald-700' 
                      : 'bg-rose-100 text-rose-700'
                  }`}>
                    {overallStatus.isValid ? <CheckCircle className="h-3 w-3" /> : <XCircle className="h-3 w-3" />}
                    {overallStatus.validCount}/{overallStatus.totalCount} ĐK
                  </span>
                </div>
              </div>
            </div>

            {/* Right: Action Buttons */}
            <div className="flex items-center gap-2">
              <button
                onClick={handleClose}
                disabled={hook.isLoading}
                className="h-9 px-4 rounded-lg border border-gray-300 text-gray-600 font-medium text-sm hover:bg-gray-50 transition-colors"
              >
                <X className="h-4 w-4 inline mr-1" />
                {readOnly ? "Đóng" : "Hủy"}
              </button>
              {!readOnly && (
                <>
                  <button
                    onClick={() => setNotEligibleDialogOpen(true)}
                    disabled={hook.isLoading}
                    className="h-9 px-4 rounded-lg bg-rose-500 text-white font-medium text-sm hover:bg-rose-600 transition-colors"
                  >
                    <XCircle className="h-4 w-4 inline mr-1" />
                    Không đủ ĐK
                  </button>
                  <button
                    onClick={hook.handleEligible}
                    disabled={hook.isLoading}
                    className="h-10 px-6 rounded-lg bg-emerald-500 text-white font-bold text-sm hover:bg-emerald-600 transition-colors shadow-lg shadow-emerald-500/30"
                  >
                    <CheckCircle className="h-4 w-4 inline mr-1" />
                    Đủ điều kiện
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* MAIN CONTENT - Scrollable */}
      <div
        className={`flex-1 overflow-y-auto transition-all duration-300 ${
          isAnimating ? "opacity-100" : "opacity-0"
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="max-w-[1800px] mx-auto px-4 lg:px-6 py-4">
          {/* Loading state */}
          {hook.isInitialLoading && (
            <div className="flex items-center justify-center h-[60vh]">
              <div className="text-center">
                <div className="relative w-12 h-12 mx-auto mb-3">
                  <div className="absolute inset-0 rounded-full border-3 border-gray-200" />
                  <div className="absolute inset-0 rounded-full border-3 border-transparent border-t-blue-500 animate-spin" />
                </div>
                <p className="text-gray-500 text-sm">Đang tải...</p>
              </div>
            </div>
          )}

          {!hook.isInitialLoading && (
            <div className="grid grid-cols-12 gap-4">
              {/* COLUMN 1: Vehicle, Driver, Documents (4 cols) */}
              <div className="col-span-12 lg:col-span-4 space-y-4">
                <VehicleInfoSection
                  record={record}
                  readOnly={readOnly}
                  permitType={hook.permitType}
                  setPermitType={hook.setPermitType}
                  registeredPlateNumber={hook.registeredPlateNumber}
                  setRegisteredPlateNumber={hook.setRegisteredPlateNumber}
                  selectedVehicle={hook.selectedVehicle}
                  vehicleBadges={hook.vehicleBadges}
                  vehicles={hook.vehicles}
                  vehiclesWithStatus={hook.vehiclesWithStatus}
                  replacementVehicleId={hook.replacementVehicleId}
                  setReplacementVehicleId={hook.setReplacementVehicleId}
                  entryPlateNumber={hook.entryPlateNumber}
                  setEntryPlateNumber={hook.setEntryPlateNumber}
                  operatorNameFromVehicle={hook.operatorNameFromVehicle}
                  selectedOperatorId={hook.selectedOperatorId}
                  setSelectedOperatorId={hook.setSelectedOperatorId}
                  operators={hook.operators}
                  scheduleId={hook.scheduleId}
                  setScheduleId={hook.setScheduleId}
                  routeId={hook.routeId}
                  schedules={hook.schedules}
                  departureTime={hook.departureTime}
                />
                <DriverSection
                  drivers={hook.drivers}
                  readOnly={readOnly}
                  onAddDriver={() => setAddDriverDialogOpen(true)}
                />
                <DocumentCheckCards
                  documents={hook.getDocumentsCheckResults()}
                  isValid={overallStatus.isValid}
                  validCount={overallStatus.validCount}
                  totalCount={overallStatus.totalCount}
                  onEdit={() => setDocumentDialogOpen(true)}
                />
              </div>

              {/* COLUMN 2: Transport Order & Services (4 cols) */}
              <div className="col-span-12 lg:col-span-4 space-y-4">
                <TransportOrderSection
                  readOnly={readOnly}
                  transportOrderCode={hook.transportOrderCode}
                  setTransportOrderCode={hook.setTransportOrderCode}
                  seatCount={hook.seatCount}
                  setSeatCount={hook.setSeatCount}
                  bedCount={hook.bedCount}
                  setBedCount={hook.setBedCount}
                  hhTicketCount={hook.hhTicketCount}
                  setHhTicketCount={hook.setHhTicketCount}
                  hhPercentage={hook.hhPercentage}
                  setHhPercentage={hook.setHhPercentage}
                  routeId={hook.routeId}
                  setRouteId={hook.setRouteId}
                  routes={hook.routes}
                  departureTime={hook.departureTime}
                  setDepartureTime={hook.setDepartureTime}
                  departureDate={hook.departureDate}
                  setDepartureDate={hook.setDepartureDate}
                  scheduleId={hook.scheduleId}
                  validationErrors={hook.validationErrors}
                />
                <ServiceChargesSection
                  readOnly={readOnly}
                  serviceCharges={hook.serviceCharges}
                  totalAmount={hook.totalAmount}
                  serviceDetailsExpanded={hook.serviceDetailsExpanded}
                  setServiceDetailsExpanded={hook.setServiceDetailsExpanded}
                  onAddService={() => setAddServiceDialogOpen(true)}
                  recordId={record.id}
                />
                <GsgtCheckSection />
              </div>

              {/* COLUMN 3: Images, Notes, Calendar (4 cols) */}
              <div className="col-span-12 lg:col-span-4 space-y-4">
                <VehicleImageSection
                  vehicleImageUrl={hook.selectedVehicle?.imageUrl}
                  entryImageUrl={record.entryImageUrl}
                  dispatchId={record.id}
                />
                <NotesSection />
                {/* Calendar Toggle */}
                <button
                  onClick={() => setShowCalendar(!showCalendar)}
                  className="w-full flex items-center justify-between p-3 rounded-xl bg-white border border-gray-200 text-sm font-medium text-gray-600 hover:bg-gray-50 transition-colors"
                >
                  <span className="flex items-center gap-2">
                    <Calendar className="h-4 w-4" />
                    Lịch hoạt động tháng
                  </span>
                  <span className="text-xs text-gray-400">{showCalendar ? "Ẩn" : "Hiện"}</span>
                </button>
                {showCalendar && (
                  <MonthlyCalendarHeatmap
                    departureDate={hook.departureDate}
                    dailyTripCounts={hook.dailyTripCounts}
                  />
                )}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Dialogs */}
      {record.vehicleId && (
        <KiemTraGiayToDialog
          vehicleId={record.vehicleId}
          open={documentDialogOpen}
          onClose={() => setDocumentDialogOpen(false)}
          onSuccess={hook.handleDocumentDialogSuccess}
        />
      )}
      <LyDoKhongDuDieuKienDialog
        open={notEligibleDialogOpen}
        onClose={() => setNotEligibleDialogOpen(false)}
        onConfirm={handleNotEligibleConfirm}
      />
      {record.id && (
        <ThemDichVuDialog
          dispatchRecordId={record.id}
          open={addServiceDialogOpen}
          onClose={() => setAddServiceDialogOpen(false)}
          onSuccess={hook.handleAddServiceSuccess}
        />
      )}
      <ThemTaiXeDialog
        operatorId={hook.selectedOperatorId || undefined}
        open={addDriverDialogOpen}
        onClose={() => setAddDriverDialogOpen(false)}
        onSuccess={hook.handleAddDriverSuccess}
      />
      <ZeroAmountWarningDialog
        open={hook.showZeroAmountConfirm}
        onClose={() => hook.setShowZeroAmountConfirm(false)}
        onConfirm={() => {
          hook.setShowZeroAmountConfirm(false);
          hook.submitPermit();
        }}
      />
    </div>,
    document.body
  );
}
</file>

<file path="server/src/controllers/vehicle.controller.ts">
import { Request, Response } from 'express'
import { AuthRequest } from '../middleware/auth.js'
import { firebase } from '../config/database.js'
import { z } from 'zod'
import { syncVehicleChanges } from '../utils/denormalization-sync.js'
import { cachedData } from '../services/cached-data.service.js'
import { vehicleCacheService } from '../modules/fleet/services/vehicle-cache.service.js'

const vehicleSchema = z.object({
  plateNumber: z.string().min(1, 'Plate number is required'),
  vehicleTypeId: z.string().min(1).optional(),
  operatorId: z.string().min(1, 'Invalid operator ID').optional(),
  seatCapacity: z.number().int().positive('Seat capacity must be positive'),
  bedCapacity: z.number().int().optional(),
  chassisNumber: z.string().optional(),
  engineNumber: z.string().optional(),
  imageUrl: z.string().url().optional().or(z.literal('')),
  
  insuranceExpiryDate: z.string().optional(),
  inspectionExpiryDate: z.string().optional(),
  
  cargoLength: z.number().optional(),
  cargoWidth: z.number().optional(),
  cargoHeight: z.number().optional(),
  
  gpsProvider: z.string().optional(),
  gpsUsername: z.string().optional(),
  gpsPassword: z.string().optional(),
  
  province: z.string().optional(),

  notes: z.string().optional(),
  documents: z.object({
    registration: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      issuingAuthority: z.string().optional(),
      documentUrl: z.string().optional(),
      notes: z.string().optional(),
    }).optional(),
    inspection: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      issuingAuthority: z.string().optional(),
      documentUrl: z.string().optional(),
      notes: z.string().optional(),
    }).optional(),
    insurance: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      issuingAuthority: z.string().optional(),
      documentUrl: z.string().optional(),
      notes: z.string().optional(),
    }).optional(),
    operation_permit: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      issuingAuthority: z.string().optional(),
      documentUrl: z.string().optional(),
      notes: z.string().optional(),
    }).optional(),
    emblem: z.object({
      number: z.string(),
      issueDate: z.string(),
      expiryDate: z.string(),
      issuingAuthority: z.string().optional(),
      documentUrl: z.string().optional(),
      notes: z.string().optional(),
    }).optional(),
  }).optional(),
})

export const getAllVehicles = async (req: Request, res: Response) => {
  try {
    const { operatorId, isActive } = req.query
    const activeOnly = isActive !== 'all' && isActive !== 'false'

    // Use cached data for vehicles, operators, and vehicle types
    let vehicles = await cachedData.getAllVehicles(activeOnly)
    
    // Filter by operatorId if provided
    if (operatorId) {
      vehicles = vehicles.filter((v: any) => v.operator_id === operatorId)
    }
    
    // Filter inactive if specifically requested
    if (isActive === 'false') {
      vehicles = vehicles.filter((v: any) => v.is_active === false)
    }

    // Use cached operators and vehicle types (parallel fetch)
    const [operatorMap, vehicleTypeMap] = await Promise.all([
      cachedData.getOperatorsMap(),
      cachedData.getVehicleTypesMap(),
    ])

    // Fetch documents
    const vehicleIds = vehicles.map((v: any) => v.id)
    const { data: documents } = await firebase
      .from('vehicle_documents')
      .select('*')
      .in('vehicle_id', vehicleIds)

    const vehiclesWithDocs = vehicles.map((vehicle: any) => {
      const vehicleDocs = documents?.filter((doc: any) => doc.vehicle_id === vehicle.id) || []
      const docsMap: any = {}
      const today = new Date().toISOString().split('T')[0]
      vehicleDocs.forEach((doc: any) => {
        docsMap[doc.document_type] = {
          number: doc.document_number,
          issueDate: doc.issue_date,
          expiryDate: doc.expiry_date,
          issuingAuthority: doc.issuing_authority,
          documentUrl: doc.document_url,
          notes: doc.notes,
          isValid: doc.expiry_date >= today,
        }
      })

      // Manual join with operators and vehicle_types
      const operator = vehicle.operator_id ? operatorMap.get(vehicle.operator_id) as any : null
      const vehicleType = vehicle.vehicle_type_id ? vehicleTypeMap.get(vehicle.vehicle_type_id) as any : null

      return {
        id: vehicle.id,
        plateNumber: vehicle.plate_number,
        vehicleTypeId: vehicle.vehicle_type_id,
        vehicleType: vehicleType ? {
          id: vehicleType.id,
          name: vehicleType.name,
        } : undefined,
        operatorId: vehicle.operator_id,
        operator: operator ? {
          id: operator.id,
          name: operator.name,
          code: operator.code,
        } : undefined,
        seatCapacity: vehicle.seat_capacity,
        bedCapacity: vehicle.bed_capacity,
        manufactureYear: vehicle.manufacture_year,
        chassisNumber: vehicle.chassis_number,
        engineNumber: vehicle.engine_number,
        color: vehicle.color,
        imageUrl: vehicle.image_url,
        insuranceExpiryDate: vehicle.insurance_expiry_date,
        inspectionExpiryDate: vehicle.inspection_expiry_date,
        cargoLength: vehicle.cargo_length,
        cargoWidth: vehicle.cargo_width,
        cargoHeight: vehicle.cargo_height,
        gpsProvider: vehicle.gps_provider,
        gpsUsername: vehicle.gps_username,
        gpsPassword: vehicle.gps_password,
        province: vehicle.province,
        isActive: vehicle.is_active,
        notes: vehicle.notes,
        documents: {
          registration: docsMap.registration || undefined,
          inspection: docsMap.inspection || undefined,
          insurance: docsMap.insurance || undefined,
          operation_permit: docsMap.operation_permit || undefined,
          emblem: docsMap.emblem || undefined,
        },
        createdAt: vehicle.created_at,
        updatedAt: vehicle.updated_at,
      }
    })

    return res.json(vehiclesWithDocs)
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch vehicles' })
  }
}

export const getVehicleById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    const { data: vehicle, error: vehicleError } = await firebase
      .from('vehicles')
      .select('*')
      .eq('id', id)
      .single()

    if (vehicleError) throw vehicleError
    if (!vehicle) {
      return res.status(404).json({ error: 'Vehicle not found' })
    }

    // Fetch operator and vehicle_type for manual join
    let operator = null
    let vehicleType = null
    
    if (vehicle.operator_id) {
      const { data: op } = await firebase.from('operators').select('*').eq('id', vehicle.operator_id).single()
      operator = op
    }
    if (vehicle.vehicle_type_id) {
      const { data: vt } = await firebase.from('vehicle_types').select('*').eq('id', vehicle.vehicle_type_id).single()
      vehicleType = vt
    }

    const { data: documents } = await firebase
      .from('vehicle_documents')
      .select('*')
      .eq('vehicle_id', id)

    const docsMap: any = {}
    const today = new Date().toISOString().split('T')[0]
    documents?.forEach((doc: any) => {
      docsMap[doc.document_type] = {
        number: doc.document_number,
        issueDate: doc.issue_date,
        expiryDate: doc.expiry_date,
        issuingAuthority: doc.issuing_authority,
        documentUrl: doc.document_url,
        notes: doc.notes,
        isValid: doc.expiry_date >= today,
      }
    })

    return res.json({
      id: vehicle.id,
      plateNumber: vehicle.plate_number,
      vehicleTypeId: vehicle.vehicle_type_id,
      vehicleType: vehicleType ? {
        id: vehicleType.id,
        name: vehicleType.name,
      } : undefined,
      operatorId: vehicle.operator_id,
      operator: operator ? {
        id: operator.id,
        name: operator.name,
        code: operator.code,
      } : undefined,
      seatCapacity: vehicle.seat_capacity,
      bedCapacity: vehicle.bed_capacity,
      manufactureYear: vehicle.manufacture_year,
      chassisNumber: vehicle.chassis_number,
      engineNumber: vehicle.engine_number,
      color: vehicle.color,
      imageUrl: vehicle.image_url,

      insuranceExpiryDate: vehicle.insurance_expiry_date,
      inspectionExpiryDate: vehicle.inspection_expiry_date,

      cargoLength: vehicle.cargo_length,
      cargoWidth: vehicle.cargo_width,
      cargoHeight: vehicle.cargo_height,

      gpsProvider: vehicle.gps_provider,
      gpsUsername: vehicle.gps_username,
      gpsPassword: vehicle.gps_password,

      province: vehicle.province,

      isActive: vehicle.is_active,
      notes: vehicle.notes,
      documents: {
        registration: docsMap.registration || undefined,
        inspection: docsMap.inspection || undefined,
        insurance: docsMap.insurance || undefined,
        operation_permit: docsMap.operation_permit || undefined,
        emblem: docsMap.emblem || undefined,
      },
      createdAt: vehicle.created_at,
      updatedAt: vehicle.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to fetch vehicle' })
  }
}

export const createVehicle = async (req: Request, res: Response) => {
  try {
    const validated = vehicleSchema.parse(req.body)
    const { 
      plateNumber, vehicleTypeId, operatorId, seatCapacity, bedCapacity,
      chassisNumber, engineNumber, imageUrl,
      insuranceExpiryDate, inspectionExpiryDate,
      cargoLength, cargoWidth, cargoHeight,
      gpsProvider, gpsUsername, gpsPassword,
      province,
      notes, documents 
    } = validated

    // Insert vehicle
    const { data: vehicle, error: vehicleError } = await firebase
      .from('vehicles')
      .insert({
        plate_number: plateNumber,
        vehicle_type_id: vehicleTypeId || null,
        operator_id: operatorId || null,
        seat_capacity: seatCapacity,
        bed_capacity: bedCapacity || 0,
        chassis_number: chassisNumber || null,
        engine_number: engineNumber || null,
        image_url: imageUrl || null,
        
        insurance_expiry_date: insuranceExpiryDate || null,
        inspection_expiry_date: inspectionExpiryDate || null,
        
        cargo_length: cargoLength || null,
        cargo_width: cargoWidth || null,
        cargo_height: cargoHeight || null,
        
        gps_provider: gpsProvider || null,
        gps_username: gpsUsername || null,
        gps_password: gpsPassword || null,
        
        province: province || null,

        notes: notes || null,
        is_active: true,
      })
      .select('*')
      .single()

    if (vehicleError) throw vehicleError

    // Fetch operator and vehicle_type for manual join
    let operator = null
    let vehicleType = null
    
    if (vehicle.operator_id) {
      const { data: op } = await firebase.from('operators').select('*').eq('id', vehicle.operator_id).single()
      operator = op
    }
    if (vehicle.vehicle_type_id) {
      const { data: vt } = await firebase.from('vehicle_types').select('*').eq('id', vehicle.vehicle_type_id).single()
      vehicleType = vt
    }

    // Insert documents
    if (documents) {
      const documentTypes = ['registration', 'inspection', 'insurance', 'operation_permit', 'emblem'] as const
      const documentsToInsert = documentTypes
        .filter((type) => documents[type])
        .map((type) => ({
          vehicle_id: vehicle.id,
          document_type: type,
          document_number: documents[type]!.number,
          issue_date: documents[type]!.issueDate,
          expiry_date: documents[type]!.expiryDate,
          issuing_authority: documents[type]!.issuingAuthority || null,
          document_url: documents[type]!.documentUrl || null,
          notes: documents[type]!.notes || null,
        }))

      if (documentsToInsert.length > 0) {
        const { error: docsError } = await firebase
          .from('vehicle_documents')
          .insert(documentsToInsert)

        if (docsError) throw docsError
      }
    }

    // Fetch the complete vehicle with documents
    const { data: allDocs } = await firebase
      .from('vehicle_documents')
      .select('*')
      .eq('vehicle_id', vehicle.id)

    const docsMap: any = {}
    const today = new Date().toISOString().split('T')[0]
    allDocs?.forEach((doc: any) => {
      docsMap[doc.document_type] = {
        number: doc.document_number,
        issueDate: doc.issue_date,
        expiryDate: doc.expiry_date,
        issuingAuthority: doc.issuing_authority,
        documentUrl: doc.document_url,
        notes: doc.notes,
        isValid: doc.expiry_date >= today,
      }
    })

    // Invalidate vehicle cache after create
    cachedData.invalidateVehicles()

    return res.status(201).json({
      id: vehicle.id,
      plateNumber: vehicle.plate_number,
      vehicleTypeId: vehicle.vehicle_type_id,
      vehicleType: vehicleType ? {
        id: vehicleType.id,
        name: vehicleType.name,
      } : undefined,
      operatorId: vehicle.operator_id,
      operator: operator ? {
        id: operator.id,
        name: operator.name,
        code: operator.code,
      } : undefined,
      seatCapacity: vehicle.seat_capacity,
      bedCapacity: vehicle.bed_capacity,
      chassisNumber: vehicle.chassis_number,
      engineNumber: vehicle.engine_number,
      
      insuranceExpiryDate: vehicle.insurance_expiry_date,
      inspectionExpiryDate: vehicle.inspection_expiry_date,
      
      cargoLength: vehicle.cargo_length,
      cargoWidth: vehicle.cargo_width,
      cargoHeight: vehicle.cargo_height,
      
      gpsProvider: vehicle.gps_provider,
      gpsUsername: vehicle.gps_username,
      gpsPassword: vehicle.gps_password,
      
      province: vehicle.province,

      isActive: vehicle.is_active,
      notes: vehicle.notes,
      documents: {
        registration: docsMap.registration || undefined,
        inspection: docsMap.inspection || undefined,
        insurance: docsMap.insurance || undefined,
        operation_permit: docsMap.operation_permit || undefined,
        emblem: docsMap.emblem || undefined,
      },
      createdAt: vehicle.created_at,
      updatedAt: vehicle.updated_at,
    })
  } catch (error: any) {
    if (error.code === '23505') {
      return res.status(409).json({ error: 'Vehicle with this plate number already exists' })
    }
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to create vehicle' })
  }
}

export const updateVehicle = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params
    const userId = req.user?.id
    const validated = vehicleSchema.partial().parse(req.body)

    // Update vehicle
    const updateData: any = {}
    if (validated.plateNumber) updateData.plate_number = validated.plateNumber
    // Allow updating vehicleTypeId even if it's empty to clear the value
    if (validated.vehicleTypeId !== undefined) {
      updateData.vehicle_type_id = validated.vehicleTypeId || null
    }
    // Allow updating operatorId - handle both empty string and undefined
    // Empty string from frontend means clear the operator
    if ('operatorId' in req.body) {
      // Field was explicitly sent (even if empty), so update it
      const operatorId = req.body.operatorId
      updateData.operator_id = (operatorId && operatorId.trim() !== '') ? operatorId : null
    } else if (validated.operatorId !== undefined) {
      // Validated and present in request
      updateData.operator_id = validated.operatorId || null
    }
    if (validated.seatCapacity) updateData.seat_capacity = validated.seatCapacity
    if (validated.bedCapacity !== undefined) updateData.bed_capacity = validated.bedCapacity || 0
    if (validated.chassisNumber !== undefined) updateData.chassis_number = validated.chassisNumber || null
    if (validated.engineNumber !== undefined) updateData.engine_number = validated.engineNumber || null
    if (validated.imageUrl !== undefined) updateData.image_url = validated.imageUrl || null
    
    if (validated.insuranceExpiryDate !== undefined) updateData.insurance_expiry_date = validated.insuranceExpiryDate || null
    if (validated.inspectionExpiryDate !== undefined) updateData.inspection_expiry_date = validated.inspectionExpiryDate || null
    
    if (validated.cargoLength !== undefined) updateData.cargo_length = validated.cargoLength || null
    if (validated.cargoWidth !== undefined) updateData.cargo_width = validated.cargoWidth || null
    if (validated.cargoHeight !== undefined) updateData.cargo_height = validated.cargoHeight || null
    
    if (validated.gpsProvider !== undefined) updateData.gps_provider = validated.gpsProvider || null
    if (validated.gpsUsername !== undefined) updateData.gps_username = validated.gpsUsername || null
    if (validated.gpsPassword !== undefined) updateData.gps_password = validated.gpsPassword || null
    
    if (validated.province !== undefined) updateData.province = validated.province || null

    if (validated.notes !== undefined) updateData.notes = validated.notes || null

    if (Object.keys(updateData).length > 0) {
      const { error: vehicleError } = await firebase
        .from('vehicles')
        .update(updateData)
        .eq('id', id)

      if (vehicleError) throw vehicleError
    }

    // Update documents if provided
    if (validated.documents) {
      const documentTypes = ['registration', 'inspection', 'insurance', 'operation_permit', 'emblem'] as const
      
      for (const type of documentTypes) {
        if (validated.documents[type]) {
          const doc = validated.documents[type]!
          
          // Check if document already exists
          const { data: existingDoc } = await firebase
            .from('vehicle_documents')
            .select('id')
            .eq('vehicle_id', id)
            .eq('document_type', type)
            .single()

          if (existingDoc) {
            // Update existing document
            const { error: updateError } = await firebase
              .from('vehicle_documents')
              .update({
                document_number: doc.number,
                issue_date: doc.issueDate,
                expiry_date: doc.expiryDate,
                issuing_authority: doc.issuingAuthority || null,
                document_url: doc.documentUrl || null,
                notes: doc.notes || null,
                updated_by: userId || null,
                updated_at: new Date().toISOString()
              })
              .eq('id', existingDoc.id)

            if (updateError) throw updateError
          } else {
            // Insert new document
            const { error: insertError } = await firebase
              .from('vehicle_documents')
              .insert({
                vehicle_id: id,
                document_type: type,
                document_number: doc.number,
                issue_date: doc.issueDate,
                expiry_date: doc.expiryDate,
                issuing_authority: doc.issuingAuthority || null,
                document_url: doc.documentUrl || null,
                notes: doc.notes || null,
                updated_by: userId || null,
              })

            if (insertError) throw insertError
          }
        }
      }
    }

    // Fetch updated vehicle
    const { data: vehicle } = await firebase
      .from('vehicles')
      .select('*')
      .eq('id', id)
      .single()

    if (!vehicle) {
      return res.status(404).json({ error: 'Vehicle not found after update' })
    }

    // Fetch operator and vehicle_type for manual join
    let operator = null
    let vehicleType = null
    
    if (vehicle.operator_id) {
      const { data: op } = await firebase.from('operators').select('*').eq('id', vehicle.operator_id).single()
      operator = op
    }
    if (vehicle.vehicle_type_id) {
      const { data: vt } = await firebase.from('vehicle_types').select('*').eq('id', vehicle.vehicle_type_id).single()
      vehicleType = vt
    }

    // Sync denormalized data to dispatch_records if plate_number or operator changed
    if (updateData.plate_number || updateData.operator_id !== undefined) {
      // Run sync in background (non-blocking)
      syncVehicleChanges(id, {
        plateNumber: vehicle.plate_number,
        operatorId: vehicle.operator_id,
        operatorName: operator?.name || null,
        operatorCode: operator?.code || null,
      }).catch((err) => {
        console.error('[Vehicle Update] Failed to sync denormalized data:', err)
      })
    }

    // Invalidate vehicle cache after update
    cachedData.invalidateVehicles()

    const { data: documents } = await firebase
      .from('vehicle_documents')
      .select('*')
      .eq('vehicle_id', id)

    const docsMap: any = {}
    const today = new Date().toISOString().split('T')[0]
    documents?.forEach((doc: any) => {
      docsMap[doc.document_type] = {
        number: doc.document_number,
        issueDate: doc.issue_date,
        expiryDate: doc.expiry_date,
        issuingAuthority: doc.issuing_authority,
        documentUrl: doc.document_url,
        notes: doc.notes,
        isValid: doc.expiry_date >= today,
      }
    })

    return res.json({
      id: vehicle.id,
      plateNumber: vehicle.plate_number,
      vehicleTypeId: vehicle.vehicle_type_id,
      vehicleType: vehicleType ? {
        id: vehicleType.id,
        name: vehicleType.name,
      } : undefined,
      operatorId: vehicle.operator_id,
      operator: operator ? {
        id: operator.id,
        name: operator.name,
        code: operator.code,
      } : undefined,
      seatCapacity: vehicle.seat_capacity,
      bedCapacity: vehicle.bed_capacity,
      manufactureYear: vehicle.manufacture_year,
      chassisNumber: vehicle.chassis_number,
      engineNumber: vehicle.engine_number,
      color: vehicle.color,
      imageUrl: vehicle.image_url,
      
      insuranceExpiryDate: vehicle.insurance_expiry_date,
      inspectionExpiryDate: vehicle.inspection_expiry_date,
      
      cargoLength: vehicle.cargo_length,
      cargoWidth: vehicle.cargo_width,
      cargoHeight: vehicle.cargo_height,
      
      gpsProvider: vehicle.gps_provider,
      gpsUsername: vehicle.gps_username,
      gpsPassword: vehicle.gps_password,
      
      province: vehicle.province,

      isActive: vehicle.is_active,
      notes: vehicle.notes,
      documents: {
        registration: docsMap.registration || undefined,
        inspection: docsMap.inspection || undefined,
        insurance: docsMap.insurance || undefined,
        operation_permit: docsMap.operation_permit || undefined,
        emblem: docsMap.emblem || undefined,
      },
      createdAt: vehicle.created_at,
      updatedAt: vehicle.updated_at,
    })
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: error.errors[0].message })
    }
    return res.status(500).json({ error: error.message || 'Failed to update vehicle' })
  }
}

export const getVehicleDocumentAuditLogs = async (req: Request, res: Response) => {
  try {
    const { id: vehicleId } = req.params

    if (!vehicleId) {
      return res.status(400).json({ error: 'Vehicle ID is required' })
    }

    // Lấy tất cả vehicle_documents của xe này
    const { data: vehicleDocs, error: docsError } = await firebase
      .from('vehicle_documents')
      .select('id')
      .eq('vehicle_id', vehicleId)

    if (docsError) throw docsError

    const docIds = vehicleDocs?.map((doc: any) => doc.id) || []

    if (docIds.length === 0) {
      return res.json([])
    }

    // Lấy audit logs cho các documents này
    const { data: auditLogs, error: auditError } = await firebase
      .from('audit_logs')
      .select(`
        *,
        users:user_id(id, full_name, username)
      `)
      .eq('table_name', 'vehicle_documents')
      .in('record_id', docIds)
      .order('created_at', { ascending: false })

    if (auditError) throw auditError

    // Format response
    // Convert timestamp to Vietnam timezone (UTC+7) for display
    const formattedLogs = auditLogs?.map((log: any) => {
      let createdAt = log.created_at
      
      // If timestamp is UTC (ends with Z), convert to Vietnam time (add +07:00)
      if (createdAt && typeof createdAt === 'string') {
        if (createdAt.endsWith('Z')) {
          // UTC timestamp, add 7 hours and format as +07:00
          const utcDate = new Date(createdAt)
          const vietnamDate = new Date(utcDate.getTime() + 7 * 60 * 60 * 1000)
          const year = vietnamDate.getUTCFullYear()
          const month = String(vietnamDate.getUTCMonth() + 1).padStart(2, '0')
          const day = String(vietnamDate.getUTCDate()).padStart(2, '0')
          const hours = String(vietnamDate.getUTCHours()).padStart(2, '0')
          const minutes = String(vietnamDate.getUTCMinutes()).padStart(2, '0')
          const seconds = String(vietnamDate.getUTCSeconds()).padStart(2, '0')
          createdAt = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+07:00`
        } else if (!createdAt.includes('+') && !createdAt.includes('Z')) {
          // No timezone info, assume it's already Vietnam time, add +07:00
          createdAt = createdAt.endsWith('+07:00') ? createdAt : `${createdAt}+07:00`
        }
      }
      
      return {
        id: log.id,
        userId: log.user_id,
        userName: log.users?.full_name || log.users?.username || 'Không xác định',
        action: log.action,
        recordId: log.record_id,
        oldValues: log.old_values,
        newValues: log.new_values,
        createdAt,
      }
    }) || []

    return res.json(formattedLogs)
  } catch (error: any) {
    console.error('Error fetching vehicle document audit logs:', error)
    return res.status(500).json({ error: error.message || 'Failed to fetch audit logs' })
  }
}

/**
 * Get all document audit logs for all vehicles (optimized single query)
 */
export const getAllDocumentAuditLogs = async (_req: Request, res: Response) => {
  try {
    // Get all audit logs for vehicle_documents in one query
    const { data: auditLogs, error: auditError } = await firebase
      .from('audit_logs')
      .select('*')
      .eq('table_name', 'vehicle_documents')
      .order('created_at', { ascending: false })
      .limit(500)

    if (auditError) throw auditError

    if (!auditLogs || auditLogs.length === 0) {
      return res.json([])
    }

    // Get unique vehicle_document IDs
    const docIds = [...new Set(auditLogs.map((log: any) => log.record_id))]

    // Fetch vehicle_documents to get vehicle_id
    const { data: vehicleDocs } = await firebase
      .from('vehicle_documents')
      .select('id, vehicle_id')
      .in('id', docIds)

    const docToVehicleMap = new Map(
      (vehicleDocs || []).map((doc: any) => [doc.id, doc.vehicle_id])
    )

    // Get unique vehicle IDs
    const vehicleIds = [...new Set(
      (vehicleDocs || []).map((doc: any) => doc.vehicle_id).filter(Boolean)
    )]

    // Fetch vehicles to get plate numbers
    const { data: vehicles } = await firebase
      .from('vehicles')
      .select('id, plate_number')
      .in('id', vehicleIds)

    const vehicleMap = new Map(
      (vehicles || []).map((v: any) => [v.id, v.plate_number])
    )

    // Fetch users for names
    const userIds = [...new Set(auditLogs.map((log: any) => log.user_id).filter(Boolean))]
    const { data: users } = await firebase
      .from('users')
      .select('id, full_name, username')
      .in('id', userIds)

    const userMap = new Map(
      (users || []).map((u: any) => [u.id, u.full_name || u.username || 'Không xác định'])
    )

    // Format response
    const formattedLogs = auditLogs.map((log: any) => {
      const vehicleId = docToVehicleMap.get(log.record_id)
      const plateNumber = vehicleId ? vehicleMap.get(vehicleId) : null

      let createdAt = log.created_at
      if (createdAt && typeof createdAt === 'string' && createdAt.endsWith('Z')) {
        const utcDate = new Date(createdAt)
        const vietnamDate = new Date(utcDate.getTime() + 7 * 60 * 60 * 1000)
        createdAt = vietnamDate.toISOString().replace('Z', '+07:00')
      }

      return {
        id: log.id,
        userId: log.user_id,
        userName: userMap.get(log.user_id) || 'Không xác định',
        action: log.action,
        recordId: log.record_id,
        oldValues: log.old_values,
        newValues: log.new_values,
        createdAt,
        vehiclePlateNumber: plateNumber || '-',
      }
    })

    return res.json(formattedLogs)
  } catch (error: any) {
    console.error('Error fetching all document audit logs:', error)
    return res.status(500).json({ error: error.message || 'Failed to fetch audit logs' })
  }
}

export const deleteVehicle = async (req: Request, res: Response) => {
  try {
    const { id } = req.params

    // Soft delete: set is_active to false instead of deleting
    const { data, error } = await firebase
      .from('vehicles')
      .update({ is_active: false })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    if (!data) {
      return res.status(404).json({ error: 'Vehicle not found' })
    }

    // Invalidate vehicle cache after delete
    cachedData.invalidateVehicles()

    return res.json({
      id: data.id,
      isActive: data.is_active,
      message: 'Vehicle deleted successfully'
    })
  } catch (error: any) {
    console.error('Error deleting vehicle:', error)
    return res.status(500).json({ error: error.message || 'Failed to delete vehicle' })
  }
}

/**
 * Lookup vehicle by plate number using cached data
 * Uses VehicleCacheService for fast lookup (30min cache TTL)
 * Returns seat capacity and other info for ANY vehicle
 */
export const lookupVehicleByPlate = async (req: Request, res: Response) => {
  try {
    const { plate } = req.params
    if (!plate) {
      return res.status(400).json({ error: 'Plate number is required' })
    }

    // Use cached lookup - much faster than RTDB query
    const vehicle = await vehicleCacheService.lookupByPlate(plate)

    if (!vehicle) {
      return res.status(404).json({ error: 'Vehicle not found' })
    }

    return res.json({
      id: vehicle.id,
      plateNumber: vehicle.plateNumber,
      seatCapacity: vehicle.seatCapacity || vehicle.bedCapacity || 0,
      operatorName: vehicle.operatorName,
      vehicleType: vehicle.vehicleType,
      source: vehicle.source,
    })
  } catch (error: any) {
    console.error('Error looking up vehicle:', error)
    return res.status(500).json({ error: error.message || 'Failed to lookup vehicle' })
  }
}
</file>

</files>
